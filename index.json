[{"content":"개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\n쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\n이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\n1. 핵심 용어 정리 오프체인 서명 (Off-chain Signature) 블록체인 외부(주로 백엔드 서버)에서 생성된 디지털 서명을 의미함 이 방식은 서명을 생성하는 과정에서 가스비가 들지 않고, 서버의 다양한 로직과 결합할 수 있는 장점이 있음\n메타 트랜잭션 (Meta-transaction) 사용자가 가스비를 직접 내지 않고, 트랜잭션에 대한 의도만 \u0026lsquo;서명\u0026rsquo;으로 표현하면, 제3의 대리인(Relayer)이 이를 대신 실행하고 수수료를 지불하는 패턴임 오프체인 서명은 이 메타 트랜잭션을 구현하는 핵심 기술임\n가스리스 트랜잭션 (Gasless Transaction) 메타 트랜잭션을 통해 사용자가 느끼기에 가스비 없이 트랜잭션을 처리하는 경험을 의미함 서비스 제공자가 페이마스터 등을 통해 가스비를 대납함으로써 구현됨\nEIP-712 단순 문자열이 아닌, 구조화된 데이터에 대한 서명 표준임 이 표준을 사용하면 사용자가 자신이 무엇에 서명하는지 명확히 알 수 있으며, 다른 체인이나 다른 컨트랙트에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지할 수 있어 보안성이 매우 높음\n2. 오프체인 서명 검증의 전체 흐름 서버, 사용자, 그리고 컨트랙트 간의 상호작용은 다음과 같은 단계로 이루어짐\n사용자 요청 사용자의 클라이언트(웹/앱)는 트랜잭션을 바로 블록체인에 보내는 대신, 트랜잭션에 필요한 정보들을 백엔드 서버에 API 요청으로 보냄\n서버 검증 및 서명 서버는 요청이 유효한지 검증함 (예: 우리 서비스의 정식 사용자인가? 요청 내용이 합당한가?) 검증이 완료되면, 서버는 EIP-712 표준에 따라 트랜잭션 파라미터가 담긴 메시지를 만들고, 서버의 개인키로 이 메시지에 서명함\n사용자 트랜잭션 제출 서버는 생성된 서명(signature)과 관련 데이터들을 사용자에게 다시 응답으로 보내줌 사용자의 클라이언트는 이 서명 데이터를 포함하여 트랜잭션를 구성하고, 최종적으로 블록체인(스마트 컨트랙트)에 제출함\n컨트랙트 검증 스마트 컨트랙트는 제출된 트랜잭션을 받아 서명이 유효한지 검증함 검증에 성공하면, 컨트랙트는 약속된 작업을 수행함 (예: 가스비 대납, 아이템 지급 등)\n3. 핵심 원리: 컨트랙트의 서명 검증 과정 컨트랙트는 서버의 개인키를 모르는데, 어떻게 서버가 서명했다는 것을 신뢰할 수 있을까? 이 과정은 암호학적 원리를 이용해 세 단계로 진행됨\n1단계: 데이터 해시(Hash) 재구성 컨트랙트는 사용자가 제출한 파라미터들(userAddress, expiryTimestamp 등)을 받아, 서버가 서명을 생성했을 때와 완벽히 동일한 구조와 순서로 이 데이터들을 조합하여 해시(hash) 값을 다시 계산함\n이때 EIP-712 표준에 따라 컨트랙트의 이름, 버전, 체인 ID 등이 포함된 도메인 분리자(Domain Separator)가 해시와 함께 사용되어 다른 컨트랙트에서 서명이 재사용되는 것을 막음\n// 1. 전달받은 파라미터로 해시 재계산 bytes32 hash = keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice )); bytes32 digest = hashTypedDataV4(hash); // 도메인 분리자와 결합 2단계: 서명자 주소 복원 ecrecover라는 암호학적 함수는 메시지 해시(digest)와 서명값(signature), 이 두 가지를 입력받아 해당 서명을 만들 수 있는 유일한 공개키, 즉 서명자의 주소를 역으로 계산해냄 이 과정에서 서버의 개인키는 절대 노출되지 않음\n// 2. 서명에서 주소 복원 address recoveredAddress = digest.recover(signature); 3단계: 서명자 주소 비교 마지막으로, 2단계에서 복원된 주소가 스마트 컨트랙트에 미리 저장된 신뢰할 수 있는 서버의 주소(signer)와 일치하는지 비교함 두 주소가 일치한다면, 이 서명은 우리가 신뢰하는 서버가 생성한 유효한 서명임이 증명된 것임\n// 3. 복원된 주소가 signer와 일치하는지 확인 require(signer == recoveredAddress, \u0026#34;Paymaster: Invalid signer\u0026#34;); 4. 데이터 무결성: 서명된 데이터는 어떻게 신뢰하는가? \u0026ldquo;만약 사용자가 유효한 서명을 받은 뒤, 파라미터 값만 몰래 바꿔서 제출하면 어떡하지?\u0026rdquo; 결론부터 말하면, 불가능함\n서명 검증 과정 자체가 데이터의 무결성을 보장하기 때문임 만약 사용자가 파라미터를 1비트라도 변경하면, 1단계에서 재구성되는 해시값이 원래의 해시값과 완전히 달라짐 결과적으로 2단계에서 주소 복원에 실패하거나 엉뚱한 주소를 반환하게 되어, 3단계의 주소 비교에서 반드시 실패하게 됨\n이처럼, 서명은 데이터의 해시와 한 쌍으로 묶여있기 때문에 데이터가 조금이라도 변조되면 서명은 즉시 무효가 됨 이 원리 덕분에 우리는 데이터가 서버가 승인한 원본 그대로임을 신뢰할 수 있음\n마무리 오프체인 서명 검증은 온체인의 신뢰성과 오프체인의 유연성을 결합한 강력한 패턴임 이를 통해 가스비 소모 없이 복잡한 비즈니스 로직을 온체인 시스템에 안전하게 적용할 수 있음 서명 검증 과정 자체가 데이터의 무결성과 서명자의 신뢰성을 동시에 보장하므로, 다양한 분야에서 보안성과 효율성을 높이는 데 활용될 수 있음\n","permalink":"https://blog.jsontapose.com/posts/off-chain-signature-verification-542a33/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음\n이때 \u003cstrong\u003e오프체인 서명 검증\u003c/strong\u003e(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\u003c/p\u003e\n\u003cp\u003e쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음\n가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\u003c/p\u003e\n\u003cp\u003e이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\u003c/p\u003e","title":"오프체인 서명 검증(Off-chain Signature Verification)이란?"},{"content":"개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\nzkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\n문제 정의: 단순 설계 페이마스터의 명확한 한계 가장 먼저 검토한 toAddressPaymaster는 특정 컨트랙트로 향하는 트랜잭션의 가스비만 대납해주는 단순한 모델임. 하지만 이 방식은 두 가지 치명적인 허점을 가짐\n의도치 않은 트랜잭션 허용: 신규 사용자에게 지갑을 만들어주는 AccountFactory 컨트랙트 주소를 페이마스터에 등록할 경우, 우리 서비스와 무관한 모든 사용자가 이 팩토리를 사용할 때 발생하는 가스비를 우리가 전부 대납하게 됨. 페이마스터가 의도치 않게 공공재가 되어버리는 상황\n가스비 소모 공격에 취약: gasLimit을 검증하는 로직이 없어, 악의적 사용자가 가스비를 비정상적으로 높게 책정해 트랜잭션 한 번으로 페이마스터의 모든 자금을 고갈시킬 수 있는 위험이 존재함\n결론적으로 우리가 허용한 사용자가 우리가 의도한 작업을 할 때 발생하는 합리적인 수준의 가스비만을 선별적으로 대납할 똑똑한 방법이 필요했음\n해결의 실마리: Off-chain Signature Verification 이 문제의 해결책으로 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 도입하기로 결정함\n이 패턴은 블록체인 외부(서버)에서 생성된 디지털 서명을 블록체인 위(스마트 컨트랙트)에서 검증하는 방식임. 즉, 가스비 대납 여부를 컨트랙트가 단독으로 결정하는 게 아니라, 우리가 통제하는 서버의 \u0026lsquo;허가\u0026rsquo;를 받아 결정하게 만드는 것\n이 과정에서 다음과 같은 주요 개념들이 활용됨\n메타 트랜잭션(Meta-transaction): 사용자가 직접 트랜잭션을 생성하고 가스비를 지불하는 대신, 트랜잭션의 내용이 될 데이터에 서명만 함. 그러면 이 서명을 받은 대리인(Relayer)이 실제 트랜잭션으로 만들어 수수료를 대신 내고 블록체인에 제출하는 패턴. 우리가 구현할 페이마스터는 zkSync 시스템이 릴레이어 역할을 해주는 메타 트랜잭션의 일종임\nEIP-712: 단순 텍스트가 아닌, json처럼 구조화된 데이터에 대한 서명 표준. 사용자가 무엇에 서명하는지 명확히 인지할 수 있고, 다른 컨트랙트나 체인에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지하는 도메인 분리(Domain Separator) 기능을 포함하고 있어 페이마스터 서명에 필수적임\n구현 과정: 서명 기반 페이마스터 설계 및 개발 전체 흐름은 서버의 서명 생성(Off-chain)과 컨트랙트의 서명 검증(On-chain) 두 단계로 나뉨\n1. 서버 (Off-chain): 서명 생성 단계 사용자가 트랜잭션을 실행하기 직전, 클라이언트는 트랜잭션 데이터를 백엔드 서버로 전송함. 서버는 다음 절차를 수행\n요청 검증: 요청을 보낸 사용자가 우리 서비스의 유효한 사용자인지, 트랜잭션 내용이 비즈니스 로직에 부합하는지 등을 검증\n가스비 추정 및 파라미터 설정: 트랜잭션에 필요한 가스비를 추정하고, 여기에 약간의 버퍼를 더해 recommendedGasLimit과 recommendedGasPrice를 결정. 서명이 유효할 시간(expiryTimestamp)도 설정함\nEIP-712 서명 생성: 검증된 파라미터들을 바탕으로 EIP-712 표준에 따라 구조화된 데이터를 만들고, 서버만 안전하게 보관하고 있는 개인키로 이 데이터에 서명함\n// 서버에서 EIP-712 타입에 맞춰 서명할 데이터를 구성 const domain = { name: \u0026#34;SignatureBasedPaymaster\u0026#34;, version: \u0026#34;1\u0026#34;, chainId: chainId, verifyingContract: PAYMASTER_ADDRESS }; const types = { SignatureBasedPaymaster: [ { name: \u0026#39;userAddress\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;expiryTimestamp\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasLimit\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasPrice\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] }; const value = { /* userAddress, expiryTimestamp 등 실제 값 */ }; // 서버의 개인키로 서명 생성 const signature = await signerWallet.signTypedData(domain, types, value); 이 서명값과 관련 파라미터들을 클라이언트에 반환하면, 클라이언트는 이 데이터를 트랜잭션과 함께 zkSync 네트워크로 전송함\n2. 컨트랙트 (On-chain): 서명 검증 단계 사용자의 트랜잭션은 zkSync 부트로더(Bootloader)를 통해 페이마스터 컨트랙트의 validateAndPayForPaymasterTransaction 함수를 호출함. 이 함수는 서명 검증의 핵심임\n데이터 재구성: 트랜잭션에 포함된 userAddress, expiryTimestamp, recommendedGasLimit 등의 파라미터를 가져와 서버가 서명했던 것과 완벽히 동일한 구조와 순서로 해시(hash)를 다시 만듦\n서명자 복원: 재구성한 해시와 트랜잭션에 포함된 서명(signature)을 이용해 암호학적 함수(ecrecover)를 호출. 이를 통해 이 서명을 생성한 주소를 역으로 계산해냄\n서명자 검증: 복원된 주소가 컨트랙트에 미리 저장해 둔 우리 서버의 주소(signer)와 일치하는지 확인. 일치해야만 서버가 허가한 유효한 요청으로 간주함\n만약 누군가 서버로부터 받은 서명을 그대로 두고 파라미터(ex: 가스비)를 변경하려 시도하면, 1번 단계에서 생성되는 해시값이 달라져 3번 검증 단계에서 실패하게 됨. 이를 통해 데이터의 무결성과 서명자의 신뢰성을 동시에 확보함\n// 1. 서버가 서명했을 데이터의 해시를 컨트랙트에서 동일하게 재구성 bytes32 digest = hashTypedDataV4(keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice ))); // 2. 서명과 재구성된 해시를 사용해 서명자 주소를 복원 address recoveredSigner = digest.recover(signature); // 3. 복원된 주소가 우리가 신뢰하는 서버의 주소(signer)와 일치하는지 확인 require( signer == recoveredSigner, \u0026#34;Paymaster: Invalid signer\u0026#34; ); // ... 검증 통과 후 가스비 대납 로직 실행 결론 및 회고 zkSync의 페이마스터는 사용자의 가스비를 대신 지불하는 기능을 손쉽게 구현할 수 있는 강력한 기반을 제공함 개발자는 이를 통해 사용자의 진입 장벽을 낮추고 UX를 크게 개선할 수 있음\n하지만 여기에 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 결합함으로써, 단순한 가스비 대납을 넘어 정교한 권한 제어가 가능해짐 서버에서 각 요청을 사전에 검증하고 서명을 발급하는 방식은 다음과 같은 명확한 이점을 가져왔음\n운영 안정성: 누가, 언제, 어떤 트랜잭션의 가스비를 지원받을지 서버단에서 유연하게 제어할 수 있어, 무분별한 비용 소모를 막고 예측 가능한 운영이 가능\n보안 강화: 허가된 주체만이 서명을 통해 가스비를 사용할 수 있으므로, 초기 모델의 가장 큰 문제였던 자금 고갈 공격과 의도치 않은 트랜잭션 허용을 원천적으로 차단할 수 있었음\n결론적으로, zkSync의 편리한 온체인 기능과 서버의 오프체인 로직을 결합한 이 접근법은 보안과 운영 안정성을 모두 확보하는 효과적인 해결책이었음 이를 통해 시스템의 자산을 안전하게 보호하며 지속 가능한 서비스를 운영할 수 있는 견고한 토대를 마련하게 되었음\n","permalink":"https://blog.jsontapose.com/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 \u003cstrong\u003e가스비\u003c/strong\u003e(Gas Fee)임\n아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임\n이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 \u003cstrong\u003e가스리스 트랜잭션\u003c/strong\u003e(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\u003c/p\u003e\n\u003cp\u003ezkSync Era는 이를 위해 \u003cstrong\u003e페이마스터\u003c/strong\u003e(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\u003c/p\u003e","title":"안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)"},{"content":"SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\n주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\nSSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\n장점 간단한 구현 EventSource API(이 예제에선 안 썼지만)는 사용이 매우 간편하며 자동 재연결 기능까지 내장함. 서버 측도 기존 HTTP 서버에서 헤더 설정만 추가하면 됨 HTTP 친화적 (HTTP/2의 강력한 이점) HTTP/1.1의 한계: 브라우저는 동일 도메인당 최대 6개 연결 제한이 있어, SSE가 1개를 점유하면 다른 API 요청이 지연(Head-of-Line Blocking)될 수 있음 HTTP/2의 해결책: HTTP/2는 하나의 TCP 연결 내에서 여러 요청/응답을 스트림(Stream)으로 다중화(Multiplexing)함. 즉, SSE 연결(스트림 1)이 열려 있는 상태에서도 다른 API 요청(스트림 2, 3)이 동일한 TCP 연결을 통해 지연 없이 동시에 처리됨 결론: 프로덕션 환경에서는 6개 연결 제한 회피를 위해 HTTP/2 (HTTPS) 환경 구성을 강력히 권장함 유지보수 용이 프로토콜 자체가 단순하여 디버깅이나 유지보수가 웹소켓보다 쉬움 한계 단방향 통신 (One-way) 가장 큰 한계로, 오직 서버에서 클라이언트로만 데이터를 보낼 수 있음. 클라이언트가 서버로 데이터를 보내려면 별도의 fetch나 axios를 사용한 POST 요청이 필요함 연결 수 제한 (HTTP/1.1) 위에서 언급했듯이, HTTP/1.1 환경에서는 브라우저의 도메인당 연결 수 제한(보통 6개)에 영향을 받음 프로토콜: 표준 HTTP SSE는 웹소켓(WebSocket)처럼 ws:// 같은 별도의 프로토콜을 사용하지 않음 우리가 일반적으로 사용하는 표준 HTTP/1.1 (또는 HTTP/2) 프로토콜 위에서 동작함\n핵심 동작 원리는, 클라이언트의 최초 HTTP GET 요청에 대해 서버가 연결을 종료(close)하지 않고, 응답을 스트리밍하는 것임\nSSE 연결 (서버 측 설정) 클라이언트가 SSE 연결을 요청할 때(예: /events), 서버는 일반적인 HTML이나 JSON이 아닌, 이벤트 스트림임을 알리는 특정 HTTP 헤더로 응답해야 함\nContent-Type: text/event-stream (필수) Connection: keep-alive (연결 유지) Cache-Control: no-cache (중간 프록시나 브라우저가 응답을 캐시하지 않도록 방지) // Node.js (Express 예시) // npm install express import express from \u0026#34;express\u0026#34;; const app = express(); // 연결된 모든 클라이언트(res 객체)를 저장 const clients = new Set(); app.get(\u0026#34;/events\u0026#34;, (req, res) =\u0026gt; { // 1. SSE 연결을 위한 필수 헤더 설정 res.writeHead(200, { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/event-stream\u0026#34;, Connection: \u0026#34;keep-alive\u0026#34;, \u0026#34;Cache-Control\u0026#34;: \u0026#34;no-cache\u0026#34;, }); // 2. 연결된 클라이언트를 Set에 추가 clients.add(res); console.log(\u0026#34;Client connected\u0026#34;); // 3. 클라이언트가 연결을 끊었을 때의 처리 req.on(\u0026#34;close\u0026#34;, () =\u0026gt; { clients.delete(res); console.log(\u0026#34;Client disconnected\u0026#34;); }); }); app.listen(3000, () =\u0026gt; console.log(\u0026#34;SSE server listening on port 3000\u0026#34;)); SSE 연결 (클라이언트 측 - EventSource 미사용) 브라우저에는 EventSource라는 SSE 전용 API가 있지만, 여기서는 SSE가 HTTP 위에서 어떻게 동작하는지 명확히 보기 위해 fetch API의 스트리밍 기능을 사용함\nfetch를 사용하면 서버의 응답 바디(body)를 ReadableStream으로 받아 청크(chunk) 단위로 처리할 수 있음\n// Client-side (Browser JS) async function connectSSE() { let response; try { response = await fetch(\u0026#34;http://localhost:3000/events\u0026#34;); } catch (error) { console.error(\u0026#34;Connection failed:\u0026#34;, error); return; } // 1. 응답 바디에서 ReadableStream의 리더(reader)를 가져옴 const reader = response.body.getReader(); // 2. 텍스트 디코더 준비 (바이너리 데이터를 UTF-8 텍스트로 변환) const decoder = new TextDecoder(); // 3. 스트림이 끝날 때(done)까지 무한 루프 while (true) { const { done, value } = await reader.read(); if (done) { console.log(\u0026#34;Stream finished\u0026#34;); break; // 서버가 연결을 종료함 } // 4. 수신된 바이너리 청크(value)를 텍스트로 디코딩 const rawChunk = decoder.decode(value); // (이후 이 청크를 파싱하는 로직이 필요함) parseStreamChunk(rawChunk); } } // (파싱 로직은 아래 \u0026#39;이벤트 파싱\u0026#39; 섹션 참고) connectSSE(); SSE 이벤트 형식과 송신 (서버 측) SSE는 정해진 텍스트 형식을 사용함. 가장 중요한 필드는 data:임 각 메시지는 두 번의 개행(\\n\\n)으로 구분됨\ndata: [보낼 데이터] (필수) event: [이벤트 이름] (옵션, 클라이언트가 이벤트를 구분할 때 사용) id: [메시지 ID] (옵션, 재연결 시 마지막 ID를 서버로 보냄) clients Set에 저장된 res 객체에 res.write()를 사용해 데이터를 전송함\n// Node.js (Express) - 서버 어디에서든 호출 가능 // 모든 연결된 클라이언트에게 브로드캐스트하는 함수 function broadcast(eventName, data) { // 1. (옵션) \u0026#39;update\u0026#39;라는 이름의 이벤트를 지정 const message = `event: ${eventName}\\n` + // 2. (필수) 실제 데이터를 \u0026#39;data:\u0026#39; 필드에 담아 전송 `data: ${data}\\n` + // 3. (필수) 메시지의 끝을 알리는 개행 전송 `\\n`; for (const res of clients) { res.write(message); } } // 2초마다 모든 클라이언트에게 \u0026#39;update\u0026#39; 이벤트 전송 setInterval(() =\u0026gt; { broadcast(\u0026#34;update\u0026#34;, `This is message number ${Date.now()}`); }, 2000); JSON 데이터 전송 시 주의점 data: 필드가 여러 줄일 경우 파서는 이를 \\n으로 이어붙임 이는 JSON을 여러 줄의 data: 필드로 쪼개어 보내면 안 된다는 것을 의미함\n// 서버에서 JSON 전송 시 const payload = { user: \u0026#34;test\u0026#34;, value: 123 }; // [Good ✅] JSON은 반드시 한 줄의 data 필드로 전송 broadcast(\u0026#34;update\u0026#34;, JSON.stringify(payload)); // (전송되는 텍스트: \u0026#39;event: update\\ndata: {\u0026#34;user\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;value\u0026#34;:123}\\n\\n\u0026#39;) // [Bad ❌] 아래와 같이 여러 data 라인에 걸쳐 JSON을 쪼개면 // res.write(`data: {\u0026#34;user\u0026#34;: \u0026#34;test\u0026#34;,\\n`) // res.write(`data: \u0026#34;value\u0026#34;: 123}\\n\\n`) // 클라이언트 파서는 망가진 텍스트(\u0026#39;{\u0026#34;user\u0026#34;: \u0026#34;test\u0026#34;,\\n\u0026#34;value\u0026#34;: 123}\u0026#39;)를 받게 되어 // JSON.parse()에서 오류가 발생함 SSE 이벤트 파싱 (클라이언트 측 - EventSource 미사용) 서버가 보낸 데이터 청크는 메시지 경계(\\n\\n)와 정확히 일치하지 않을 수 있음 따라서 클라이언트는 데이터를 버퍼(buffer)에 쌓아두고, 메시지 구분자(\\n\\n)가 나타날 때마다 파싱해야 함\n// Client-side (Browser JS) let buffer = \u0026#34;\u0026#34;; // 수신된 청크를 임시 저장할 버퍼 // connectSSE()의 read() 루프에서 호출되는 함수 function parseStreamChunk(rawChunk) { // 1. 버퍼에 새로 수신된 청크를 추가 buffer += rawChunk; // 2. 버퍼에서 메시지 구분자(\\n\\n)를 찾음 let boundary = buffer.indexOf(\u0026#34;\\n\\n\u0026#34;); // 3. 구분자가 존재하면 (즉, 메시지가 하나 이상 완성되면) while (boundary !== -1) { // 4. 완성된 메시지 한 개를 추출 (구분자 앞까지) const rawMessage = buffer.substring(0, boundary); // 5. 버퍼에서 처리된 메시지+구분자 제거 buffer = buffer.substring(boundary + 2); // 6. 추출한 메시지 파싱 parseMessage(rawMessage); // 7. 버퍼에 또 다른 메시지가 있는지 확인 boundary = buffer.indexOf(\u0026#34;\\n\\n\u0026#34;); } } // 수신된 raw 메시지를 파싱하는 헬퍼 함수 function parseMessage(rawMessage) { const lines = rawMessage.split(\u0026#34;\\n\u0026#34;); let eventType = \u0026#34;message\u0026#34;; // event: 필드가 없으면 기본값 \u0026#39;message\u0026#39; let eventData = \u0026#34;\u0026#34;; for (const line of lines) { if (line.startsWith(\u0026#34;event:\u0026#34;)) { eventType = line.substring(6).trim(); } else if (line.startsWith(\u0026#34;data:\u0026#34;)) { // data 필드가 여러 줄일 경우를 대비해 (JSON이 아닌 경우) eventData += line.substring(5).trim(); } } if (eventData) { console.log(`[Event Received] Type: ${eventType}, Data: ${eventData}`); // 여기서 DOM을 업데이트하거나 알림을 표시하는 등 실제 작업 수행 } } 하트비트 (Heartbeat) 일부 프록시 서버나 방화벽은 일정 시간 동안 데이터 전송이 없으면 해당 연결을 유휴(idle) 상태로 간주하고 강제로 종료할 수 있음 이를 방지하기 위해 서버는 주기적으로 의미 없는 데이터(주석)를 보내 연결이 살아있음을 알려야 함. 이를 하트비트라고 함\nSSE 스펙에서 콜론(:)으로 시작하는 라인은 주석으로 취급되며 클라이언트에서 무시됨\n// Node.js (Express) - 서버 측 // 15초마다 하트비트 전송 setInterval(() =\u0026gt; { // : 주석은 클라이언트의 message 이벤트로 전달되지 않음 const heartbeatMessage = \u0026#34;: heartbeat\\n\\n\u0026#34;; for (const res of clients) { res.write(heartbeatMessage); } }, 15000); 클라이언트 측에서는 parseMessage 함수가 event:나 data:가 아닌 라인을 무시하므로 별도 코드가 필요 없음\n서버에서 특정 연결 강제 종료 인증 만료, 중복 로그인 등의 이유로 서버가 특정 사용자의 연결을 선별적으로 종료해야 할 수 있음\n// Node.js (Express) - /events 핸들러 app.get(\u0026#34;/events\u0026#34;, (req, res) =\u0026gt; { // ... 헤더 설정 ... // (실제로는 JWT 등에서 파싱한 ID) res.locals.userId = \u0026#34;user-\u0026#34; + Math.floor(Math.random() * 1000); clients.add(res); req.on(\u0026#34;close\u0026#34;, () =\u0026gt; { clients.delete(res); }); }); // (어드민 API 등) 특정 사용자를 종료시켜야 할 때 function kickUser(userIdToKick, reason) { for (const res of clients) { if (res.locals.userId === userIdToKick) { // 1. 클라이언트가 처리할 수 있는 에러 이벤트를 전송 const message = `event: error\\ndata: ${JSON.stringify({ code: \u0026#34;KICKED\u0026#34;, reason: reason, })}\\n\\n`; res.write(message); // 2. 스트림을 정상적으로 종료 (클라이언트의 req.on(\u0026#39;close\u0026#39;)가 호출됨) res.end(); console.log(`Kicked user: ${userIdToKick}`); break; } } } // 예시: 5초 뒤 특정 유저 강제 종료 setTimeout(() =\u0026gt; { // (실제로는 ID를 특정해야 함) if (clients.size \u0026gt; 0) { const userToKick = clients.values().next().value.locals.userId; kickUser(userToKick, \u0026#34;Session expired\u0026#34;); } }, 5000); 마무리 SSE는 단방향 실시간 데이터(알림, 시세, 피드) 전송이 필요할 때 구현이 간단하고 효율적인 훌륭한 선택지임\n반면, 채팅이나 실시간 온라인 게임처럼 클라이언트와 서버가 지속적으로 데이터를 주고받는 양방향 통신이 필수적이라면 웹소켓이 적합함\n프로젝트의 요구사항을 명확히 파악하고, 단방향인지 양방향인지를 기준으로 적절한 기술 스펙을 고르는 것이 중요함\n참고자료 MDN - Server-Sent Events 사용하기 https://developer.mozilla.org/ko/docs/Web/API/Server-Sent_Events/Using_Server-Sent_Events WHATWG - Server-Sent Events 스펙 https://html.spec.whatwg.org/multipage/server-sent-events.html ","permalink":"https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/","summary":"\u003ch1 id=\"sseserver-sent-events란-무엇인가\"\u003eSSE(Server-Sent Events)란 무엇인가\u003c/h1\u003e\n\u003cp\u003eSSE는 \u003cstrong\u003eServer-Sent Events\u003c/strong\u003e의 약자로, 서버가 클라이언트로 \u003cstrong\u003e실시간 데이터를 단방향으로 푸시\u003c/strong\u003e(push)할 수 있게 해주는 웹 기술임\n클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\u003c/p\u003e\n\u003cp\u003e주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"sse-vs-웹소켓-그리고-한계\"\u003eSSE vs 웹소켓, 그리고 한계\u003c/h2\u003e\n\u003cp\u003eSSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\u003c/p\u003e","title":"SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)"},{"content":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026amp; 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u0026gt;\u0026gt;= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","permalink":"https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e머클트리는 블록체인에서 거래 집합을 \u003cstrong\u003e안전하고 효율적으로 요약·검증\u003c/strong\u003e하기 위해 쓰이는 핵심 자료구조임\n블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 \u003cstrong\u003e고정 크기 해시 하나\u003c/strong\u003e로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임\n이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-구조\"\u003e핵심 개념과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e머클트리는 보통 \u003cstrong\u003e이진 트리\u003c/strong\u003e 형태로 구현함\u003c/li\u003e\n\u003cli\u003e거래들을 \u003cstrong\u003e리프(leaf)\u003c/strong\u003e 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 \u003cstrong\u003e루트 해시\u003c/strong\u003e를 얻음\u003c/li\u003e\n\u003cli\u003e해시 함수는 체인별로 다르며 비트코인은 \u003cstrong\u003e더블 SHA‑256\u003c/strong\u003e, 이더리움은 트라이 구조에서 \u003cstrong\u003eKeccak‑256\u003c/strong\u003e 을 사용함\u003c/li\u003e\n\u003cli\u003e최상단 해시를 \u003cstrong\u003e머클루트(Merkle root)\u003c/strong\u003e 라 부르며 크기는 해시 함수에 따라 고정됨\u003c/li\u003e\n\u003cli\u003e리프 수가 홀수일 때는 마지막 리프를 \u003cstrong\u003e복제해 짝을 맞추는 방식\u003c/strong\u003e이 일반적이며 비트코인은 이 규칙을 사용함\u003c/li\u003e\n\u003cli\u003e트리 깊이는 리프 수 N에 대해 \u003cstrong\u003e⌈log₂ N⌉\u003c/strong\u003e 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-장점\"\u003e동작 원리와 장점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인접 노드 해시 \u003cstrong\u003eH_left || H_right\u003c/strong\u003e 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e무결성 검증\u003c/strong\u003e\n단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적 포함 증명\u003c/strong\u003e\n특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 \u003cstrong\u003e형제 해시들만\u003c/strong\u003e 있으면 됨\n필요한 해시 개수는 \u003cstrong\u003eO(log N)\u003c/strong\u003e 으로 작아 대역폭과 검증 비용이 작음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장성 보조\u003c/strong\u003e\n리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"블록-헤더와-경량-노드spv\"\u003e블록 헤더와 경량 노드(SPV)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함\u003c/li\u003e\n\u003cli\u003e경량 노드(SPV)는 \u003cstrong\u003e블록 전체가 아니라 헤더 체인만\u003c/strong\u003e 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 \u003cstrong\u003e머클 증명\u003c/strong\u003e 을 받아 포함 여부를 검증함\u003c/li\u003e\n\u003cli\u003e이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨\u003c/li\u003e\n\u003cli\u003e이더리움은 전통적인 이진 머클트리 대신 \u003cstrong\u003e머클‑패트리샤 트라이(MPT)\u003c/strong\u003e 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"구현-세부와-체인별-차이\"\u003e구현 세부와 체인별 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비트코인\u003c/strong\u003e\u003c/p\u003e","title":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"},{"content":"@prisma/client의 index.d.ts 개요 Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임 여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리 핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨\n핵심 개념 Aggregation 집계 평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산 결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성 Group By 그룹화 특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용 입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재 Count 카운트 조건에 맞는 레코드 개수 반환 _count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능 Find 조회 findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회 반환 타입은 선택한 필드와 관계에 따라 좁혀짐 타입 구조와 동작 집계 결과 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성 각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨 그룹화 인자와 출력 타입 ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택 출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환 조회 인자 타입 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정 메서드 반환 타입 추론 제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐 _count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용 사용 예시 집계 예시 const aggregationResult = await prisma.objektInventory.aggregate({ _avg: { objektId: true }, _sum: { lenticularPairTokenId: true }, where: { owner: \u0026#39;john\u0026#39; }, }) 그룹화 예시 const groupByResult = await prisma.objektInventory.groupBy({ by: [\u0026#39;status\u0026#39;], _count: { _all: true }, _avg: { objektId: true }, }) 카운트 예시 const totalCount = await prisma.objektInventory.count({ where: { owner: \u0026#39;john\u0026#39; }, }) 조건부 조회 예시 const inventories = await prisma.objektInventory.findMany({ where: { owner: \u0026#39;john\u0026#39; }, orderBy: { updatedAt: \u0026#39;desc\u0026#39; }, take: 10, }) 제약과 주의 사항 groupBy 규칙 by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음 take 또는 skip을 사용하는 경우 orderBy 필수 런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보 null 가능성 집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음 연산 전 null 체크 필요 _count 반환 형태 _count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환 사용 목적에 맞는 형태 선택 권장 성능 고려 불필요한 필드 조회 지양, select로 최소화 where 조건에 인덱스 친화적 필드 사용 권장 대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용 타입 안전성 스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행 any 캐스팅으로 타입 보호 우회 금지 맥락과 활용 포인트 데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소 리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용 타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능 반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능 마무리 ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임 입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임 그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능\n참고 타입 이름 모음 집계 출력 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType, ObjektInventoryMinAggregateInputType, ObjektInventoryMaxAggregateInputType, ObjektInventoryCountAggregateInputType 그룹화 관련 ObjektInventoryGroupByArgs, ObjektInventoryGroupByOutputType 조회 관련 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs 참고자료 아래 문서는 aggregate, groupBy, count, find 계열의 인자와 반환 구조를 가장 정확히 다룸\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/aggregation https://www.prisma.io/docs/orm/prisma-client/queries/groupby https://www.prisma.io/docs/orm/reference/prisma-client-reference#count https://www.prisma.io/docs/orm/reference/prisma-client-reference#find ","permalink":"https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/","summary":"\u003ch2 id=\"prismaclient의-indexdts-개요\"\u003e@prisma/client의 index.d.ts 개요\u003c/h2\u003e\n\u003cp\u003ePrisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임\n여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리\n핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAggregation 집계\n평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산\n결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성\u003c/li\u003e\n\u003cli\u003eGroup By 그룹화\n특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용\n입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재\u003c/li\u003e\n\u003cli\u003eCount 카운트\n조건에 맞는 레코드 개수 반환\n_count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능\u003c/li\u003e\n\u003cli\u003eFind 조회\nfindUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회\n반환 타입은 선택한 필드와 관계에 따라 좁혀짐\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"타입-구조와-동작\"\u003e타입 구조와 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e집계 결과 타입\nObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성\n각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음\u003c/li\u003e\n\u003cli\u003e집계 입력 타입\nObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨\u003c/li\u003e\n\u003cli\u003e그룹화 인자와 출력 타입\nObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택\n출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환\u003c/li\u003e\n\u003cli\u003e조회 인자 타입\nObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정\u003c/li\u003e\n\u003cli\u003e메서드 반환 타입 추론\n제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐\n_count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e집계 예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eaggregationResult\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobjektInventory\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaggregate\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e_avg\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eobjektId\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e_sum\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003elenticularPairTokenId\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eowner\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;john\u0026#39;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e그룹화 예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egroupByResult\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobjektInventory\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003egroupBy\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eby\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e [\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;status\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e_count\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003e_all\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003e_avg\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eobjektId\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e카운트 예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etotalCount\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobjektInventory\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecount\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eowner\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;john\u0026#39;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e조건부 조회 예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003einventories\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eobjektInventory\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindMany\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eowner\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;john\u0026#39;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eorderBy\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eupdatedAt\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;desc\u0026#39;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003etake\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e10\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"제약과-주의-사항\"\u003e제약과 주의 사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003egroupBy 규칙\nby에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음\ntake 또는 skip을 사용하는 경우 orderBy 필수\n런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보\u003c/li\u003e\n\u003cli\u003enull 가능성\n집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음\n연산 전 null 체크 필요\u003c/li\u003e\n\u003cli\u003e_count 반환 형태\n_count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환\n사용 목적에 맞는 형태 선택 권장\u003c/li\u003e\n\u003cli\u003e성능 고려\n불필요한 필드 조회 지양, select로 최소화\nwhere 조건에 인덱스 친화적 필드 사용 권장\n대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용\u003c/li\u003e\n\u003cli\u003e타입 안전성\n스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행\nany 캐스팅으로 타입 보호 우회 금지\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"맥락과-활용-포인트\"\u003e맥락과 활용 포인트\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소\u003c/li\u003e\n\u003cli\u003e리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용\u003c/li\u003e\n\u003cli\u003e타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능\u003c/li\u003e\n\u003cli\u003e반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임\n입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임\n그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능\u003c/p\u003e","title":"Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조"},{"content":"개요 여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음 키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함 이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함\nPromise.all 개념과 정의 여러 Promise를 단일 Promise로 집계하는 유틸리티 모든 입력이 이행되면 결과를 같은 순서의 배열로 반환 하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유 입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨\nPromise.all 동작 원리와 특징 집계 대상 생성 시점에 작업이 시작됨 Promise.all 자체가 작업을 시작시키는 것은 아니고, 보통 배열에 담는 과정에서 각 Promise의 executor가 실행됨 모든 입력이 이행되면 동일한 인덱스 순서로 결과 배열 반환 하나라도 거부되면 첫 번째 거부 이유로 즉시 종료 종료 이후에도 이미 시작된 다른 작업의 부수효과는 계속 진행될 수 있음 빈 배열을 넘기면 즉시 이행하며 결과는 빈 배열 이터러블이면 배열이 아니어도 처리 가능\n간단 문법 Promise.all(iterable) iterable에 Promise 또는 값 나열 반환은 단일 Promise 하나 사용 예시 최소 스니펫 const a = Promise.resolve(3) const b = new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; resolve(\u0026#39;foo\u0026#39;), 1000)) Promise.all([a, b]) .then(([x, y]) =\u0026gt; { console.log(x, y) // 3 \u0026#39;foo\u0026#39; }) .catch(err =\u0026gt; { console.error(\u0026#39;error\u0026#39;, err) }) 거부가 포함된 경우의 동작\nconst ok = Promise.resolve(1) const fail = new Promise((_, reject) =\u0026gt; reject(new Error(\u0026#39;boom\u0026#39;))) Promise.all([ok, fail]) .then(() =\u0026gt; {}) .catch(err =\u0026gt; { console.error(err.message) // boom }) 주의와 한계 fail fast 특성으로 하나가 거부되면 즉시 거부하여 나머지 결과는 수집되지 않음 부분 성공과 실패를 모두 보고 싶다면 Promise.allSettled 선택 이미 실행된 비동기 작업의 취소는 기본적으로 지원하지 않음 AbortController 같은 별도 취소 메커니즘 연동 필요 동시성 제어 기능 없음 필요하면 큐나 제한 도구를 별도로 구성하여 배치 크기 제한 네트워크나 스토리지처럼 외부 리소스를 다루는 경우, 실패 시 이미 진행된 요청의 부수효과를 고려한 롤백 전략 필요\nTypeScript에서의 반환 타입 추론 배열 리터럴을 전달하면 튜플 기반으로 각 요소 타입을 추론\nconst p1: Promise\u0026lt;number\u0026gt; = Promise.resolve(5) const p2: Promise\u0026lt;string\u0026gt; = Promise.resolve(\u0026#39;hi\u0026#39;) Promise.all([p1, p2]).then(([n, s]) =\u0026gt; { // n: number, s: string }) infer가 흐려지는 경우는 가변 배열이나 넓은 타입으로 수집할 때 발생 가능 필요 시 as const 또는 명시적 제네릭 타입 힌트로 튜플화\nPromise.all과 Promise.allSettled 비교 Promise.all 하나라도 거부되면 즉시 거부 모든 결과가 필요하고 어느 하나의 실패 시 전체 흐름을 중단해야 할 때 적합 Promise.allSettled 모든 입력의 상태와 값을 끝까지 수집 일부 실패를 허용하고 결과를 종합 평가할 때 적합 Promise.allSettled([a, b]).then(results =\u0026gt; { for (const r of results) { if (r.status === \u0026#39;fulfilled\u0026#39;) console.log(r.value) else console.warn(r.reason) } }) 현실적인 사용 맥락과 팁 여러 독립 API 요청을 동시에 보내고 전부 필요할 때 사용 각 요청은 미리 생성 후 한 번에 Promise.all로 합치기 개별 실패가 전체를 망치면 안 되는 경우에는 allSettled로 전환 후 실패만 필터링해 재시도 빈 입력은 즉시 이행되므로 조건 분기 간소화 가능 입력 순서가 결과 순서를 보장하므로 호출 순서와 매핑 로직을 단순화\nMap 개념과 정의 키-값 쌍을 저장하는 표준 컬렉션 모든 타입을 키로 사용 가능하며 삽입 순서 유지 키 중복 불가이며 동일 키 설정 시 마지막 값이 유지\nMap의 핵심 특징 모든 자료형 키 지원, 객체와 함수 포함 삽입 순서 기반 순회 보장 size 프로퍼티로 요소 개수 조회 직렬화 내장 지원 없음, 직렬화 시 변환 로직 필요 객체 키는 참조 동일성 기준 비교 사용\n기본 사용법 최소 스니펫 생성과 추가\nconst m = new Map() m.set(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;) m.set(\u0026#39;age\u0026#39;, 25) 조회와 존재 확인\nm.get(\u0026#39;name\u0026#39;) // \u0026#39;Alice\u0026#39; m.has(\u0026#39;age\u0026#39;) // true 삭제와 크기\nm.delete(\u0026#39;age\u0026#39;) m.size // 1 순회\nfor (const [k, v] of m) { console.log(k, v) } 객체와 Map 비교 포인트 키 타입 객체는 문자열과 심벌 중심 Map은 모든 데이터 타입을 키로 허용 순서와 순회 객체는 속성 열거 순서가 상황에 따라 달라질 수 있음 Map은 삽입 순서 보장으로 일관 순회 가능 크기 계산 객체는 Object.keys().length 필요 Map은 size 즉시 제공 성능과 용도 다량의 삽입·삭제·순회에서 Map이 일관된 특성을 제공 단순 구조, 직렬화 중심 데이터는 객체가 편의성 높음 실제 사용 예시와 팁 간단 캐시 패턴\nconst cache = new Map() async function getUser(userId) { if (cache.has(userId)) return cache.get(userId) const data = await doFetchUser(userId) // 외부 호출 추상화 cache.set(userId, data) return data } 주의사항\n객체를 키로 쓸 때는 같은 모양의 다른 객체는 다른 키로 취급됨 캐시로 사용할 때는 만료 정책, 약참조 사용 가능성, 메모리 누수 방지 전략 필요 직렬화가 필요하면 배열이나 객체로 변환해 저장 형식에 맞추는 전처리 필요 마무리 여러 비동기 작업을 동시에 묶고 모두의 성공이 필요하면 Promise.all 선택 부분 실패를 용인하고 결과를 종합하려면 Promise.allSettled 고려 키-값 컬렉션이 필요하고 키 타입의 제약 없이 일관 순회가 중요하면 Map 선택 객체는 단순 데이터 구조와 직렬화 중심 시나리오에서 여전히 유효 용도와 제약을 기준으로 도구를 고르는 것이 유지보수와 성능 모두에 이득임\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map ","permalink":"https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음\n키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함\n이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함\u003c/p\u003e\n\u003ch3 id=\"promiseall-개념과-정의\"\u003ePromise.all 개념과 정의\u003c/h3\u003e\n\u003cp\u003e여러 Promise를 단일 Promise로 집계하는 유틸리티\n모든 입력이 이행되면 결과를 같은 순서의 배열로 반환\n하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유\n입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨\u003c/p\u003e","title":"JavaScript Promise.all과 Map 정리 – 동시 비동기 처리와 키-값 컬렉션 기본"},{"content":"개요 MECE는 Mutually Exclusive Collectively Exhaustive의 약자이며 상호배제와 전체포괄을 뜻함 겹치지 않게 나누되 합치면 전체가 되는 분류 원칙을 말함 영어권에서는 미씨로 읽고, 한국어로는 엠이씨이 또는 미시로 불림 컨설팅 실무에서 대중화된 사고 틀로 문제 분해, 요건 정의, 케이스 분류에 자주 사용됨\n개념과 정의 상호배제는 요소들이 서로 겹치지 않는 상태를 의미함 중복 없이 하나의 요소가 정확히 하나의 범주에만 속함 전체포괄은 분류된 요소들을 모두 합치면 전체 모수를 빠짐없이 덮는 상태를 의미함 누락 없이 전체 공간을 커버하는 분할이 목표임\n원칙 나열된 요소는 서로 배타적이어야 함 나열된 요소의 합은 전체와 같아야 함 중복된 특성이나 정의가 존재하지 않아야 함 목적 상호배제로 중복 제거, 혼동과 불필요한 자원 낭비 예방 전체포괄로 누락 방지, 기회 손실과 가능성 축소 예방 결과적으로 의사결정 단순화와 커뮤니케이션 명확화 달성\n동작 방식과 구조 MECE는 본질적으로 집합의 분할 문제에 해당함 하나의 기준 축을 선정한 뒤 서로 겹치지 않는 부분집합으로 전체를 나눔 경계값과 애매한 사례를 먼저 정의해 모호성을 제거함 분할 결과가 전체 공간을 덮는지 샘플과 로그로 검증함 정기적으로 도메인 변경 사항을 반영해 분류 체계를 보정함\n간단 예시 API 응답 상태 분류\n2xx 성공, 4xx 클라이언트 오류, 5xx 서버 오류로 나누면 상호배제 충족 리다이렉션 3xx와 정보 1xx를 누락하면 전체포괄 위배 발생 필요 범위를 명시해 1xx 2xx 3xx 4xx 5xx로 정의하거나 미사용 구간을 의도적으로 배제 처리 필요 로그 레벨 분류\ntrace debug info warn error fatal 같은 단일 축으로 분류 시 상호배제 충족 일부 시스템에서 error와 fatal의 경계가 정의되지 않으면 중복과 모호성 발생 각 레벨의 의미와 사용 기준을 문서화해 경계값 불일치 제거 필요 사용자 세그먼트 분류\n과금 여부로 free paid 분리 시 간결하지만 trial 상태 누락 가능 축을 혼합해 지역과 요금제를 동시에 쓰면 겹침 발생 위험 커짐 단일 기준 축 선택 후 하위 축을 별도 차원으로 관리하는 다차원 모델 권장 주의사항과 한계 완전한 MECE는 비용이 큼, 과도한 분류는 운영 복잡도 증가 위험 존재 도메인이 변하는 환경에서는 분류가 빠르게 낡음, 주기적 검토 필요 서로 다른 기준 축을 섞으면 즉시 상호배제 깨짐, 축 혼합 금지 기본값 기타 등으로 누락을 덮으면 전체포괄 착시 발생, 반드시 명시적 케이스 관리 필요\n실무 베스트프랙티스 분류 기준 축을 한 문장으로 선언하고 금지된 축 혼합을 명시 경계값 표를 먼저 만들고 애매한 사례를 강제 배치 샘플 데이터 커버리지 체크로 전체포괄 검증, 미매핑 데이터 알림 설정 분기문에서 기본값 허용 금지, 새 케이스 추가 시 빌드 타임에 누락 탐지하도록 정책화 용어 사전으로 각 범주의 정의와 사용 예를 관리, 리뷰 체크리스트 운영 마무리 MECE는 분류와 집합의 원리에 기반한 사고 틀임 겹치지 않게 나누고 빠짐없이 덮는다는 두 가지 조건을 동시에 만족시킬 때 분석과 커뮤니케이션이 선명해짐 완벽함을 강박으로 삼기보다 기준 축 명시와 경계값 관리, 검증 자동화를 통해 실무적 균형을 맞추는 것이 핵심임\n참고자료 https://oriyong.tistory.com/109 https://en.wikipedia.org/wiki/MECE_principle ","permalink":"https://blog.jsontapose.com/posts/mece-structured-classification-principle-c7252d/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eMECE는 Mutually Exclusive Collectively Exhaustive의 약자이며 상호배제와 전체포괄을 뜻함\n겹치지 않게 나누되 합치면 전체가 되는 분류 원칙을 말함\n영어권에서는 미씨로 읽고, 한국어로는 엠이씨이 또는 미시로 불림\n컨설팅 실무에서 대중화된 사고 틀로 문제 분해, 요건 정의, 케이스 분류에 자주 사용됨\u003c/p\u003e\n\u003ch3 id=\"개념과-정의\"\u003e개념과 정의\u003c/h3\u003e\n\u003cp\u003e상호배제는 요소들이 서로 겹치지 않는 상태를 의미함\n중복 없이 하나의 요소가 정확히 하나의 범주에만 속함\n전체포괄은 분류된 요소들을 모두 합치면 전체 모수를 빠짐없이 덮는 상태를 의미함\n누락 없이 전체 공간을 커버하는 분할이 목표임\u003c/p\u003e","title":"MECE 개념 정리: 상호배제와 전체포괄로 구조화하는 분류 원칙"},{"content":"개요 MSA의 기술적 어려움은 결국 분산 시스템의 어려움과 동일함 네트워크는 불안정, 데이터는 서비스별로 분산, 한 번의 요청이 여러 프로세스를 통과하는 구조 특성상 실패와 지연이 쉽게 전파됨 리더급 실무 경험을 검증하려면 이 분산 시스템의 고통을 직접 다뤄본 흔적이 있는지 확인해야 함 아래는 실무 난이도가 높은 세 영역과 면접 시 검증 포인트, 실전형 답변 예시 정리\n분산 트랜잭션과 데이터 정합성 핵심 맥락\n모놀리식에서는 단일 DB 트랜잭션으로 주문·결제·재고 감소를 한 번에 처리 가능 MSA에서는 주문 서비스 DB, 결제 서비스 DB, 재고 서비스 DB가 분리되어 원자적 커밋 불가 일부 단계 성공 후 후속 단계 실패 시 이미 성공한 작업을 어떻게 보상할지 정의 필요 면접에서 확인할 질문\nA, B, C 세 서비스가 관여하는 비즈니스 로직에서 A, B 성공 후 C 실패 시 정합성을 어떻게 맞췄는지 이미 반영된 A, B 작업을 어떤 방식으로 되돌렸는지 좋은 답의 핵심\nSaga 패턴 언급 필수 두 가지 접근 중 하나를 명확히 설명 오케스트레이션 방식 사용, 중앙 Saga 매니저가 A→B→C를 실행하고 실패 시 보상 트랜잭션 호출로 A, B 상태 되돌림 코레오그래피 방식 사용, 각 단계가 이벤트 발행, 후속 서비스가 구독하여 처리, 최종 실패 이벤트를 기반으로 이전 단계들이 자체 보상 처리 결과적 일관성 수용, 사용자 UX는 처리 중 상태 표시 후 최종 반영 보상 트랜잭션의 멱등성 확보 언급이 있으면 신뢰도 상승 이벤트 발행의 유실 방지를 위해 트랜잭셔널 아웃박스 같은 패턴을 고려했다는 언급 가능 나쁜 답의 신호\nDB를 하나로 합쳐 해결 주장, 분산 모놀리식으로 회귀 실패 API를 호출하면 끝 주장, 재시도 실패·네트워크 분할 상황 미고려 C의 안정성을 높여서 회피 주장, 장애 대비 전략 부재 주의와 베스트 프랙티스\n보상 트랜잭션은 비즈니스 의미가 있는 반대 작업으로 정의, 단순 롤백 환상이 아님 중복 이벤트 수신 대비 멱등 처리 필수 상태 전이가 많은 도메인은 오케스트레이터로 명시적 흐름 관리가 유리, 결합도를 낮추려면 코레오그래피 채택 서비스 간 통신과 장애 전파 핵심 맥락\n단일 화면 렌더링에 다수 서비스 호출이 연쇄적으로 묶이는 구조 하위 서비스 지연이 상위 서비스로 전파되어 전체 지연·장애로 비화하는 캐스케이딩 실패 위험 상존 면접에서 확인할 질문\nA가 B를 동기 호출할 때 B가 무응답이거나 극도로 느려지면 A는 어떻게 동작해야 하는지 장애가 전체로 확산되지 않도록 어떤 방어선을 두었는지 좋은 답의 핵심\n서킷 브레이커 적용 언급, 실패율이 임계치를 넘으면 회로를 Open하여 즉시 실패 처리로 자원 보호 타임아웃 기본값 설정, 장시간 블로킹 회피 재시도 적용 시 백오프와 지터 사용, 단시간 일시 오류 회복 기대, 과도한 동시 재시도 폭주 방지 폴백 경로 정의, 캐시 데이터 노출 또는 기능 강등으로 사용자 영향 완화 호출 건격리 필요 시 벌크헤드나 연결 풀 격리 선택 언급 시 가산점 나쁜 답의 신호\nB 응답을 무기한 대기 주장 알람 전파만으로 해결 주장, 전파 차단 부재 단순 증설로 해결 주장, 구조적 회복탄력성 미확보 주의와 베스트 프랙티스\n타임아웃은 상·하위 서비스 SLA를 고려해 예산화, 체인 전체 합성 지연 관리 재시도는 멱등 연산에 한해 제한적으로 적용 서킷 상태 전이는 메트릭 기반, Half-Open에서 소량 탐침으로 회복 확인 분산 모니터링과 로깅 핵심 맥락\n하나의 사용자 요청이 A→B→D→E 등 다단계를 통과하는 구조에서 특정 오류의 원인을 끝까지 추적하기 어려움 로그가 서비스·인스턴스별로 분산되어 개별 파일 탐문으로는 재현 불가 면접에서 확인할 질문\n특정 사용자 결제 실패 요청 흐름을 여러 서비스에 걸쳐 어떻게 추적했는지 대규모 로그에서 해당 트랜잭션만 빠르게 필터링하는 기준이 무엇인지 좋은 답의 핵심\n분산 추적 도입 언급, OpenTelemetry 같은 표준 기반 수집과 Jaeger·Zipkin 등의 뷰어 사용 Correlation ID 또는 Trace ID를 최초 진입점에서 생성, HTTP 헤더나 메시지 메타데이터로 전파 모든 서비스 로그에 Trace ID 포함, 중앙 집중 로그 스택에서 단일 키로 검색 가능하게 구성 메트릭과 트레이스 연계, APM으로 외부 의존성 지연과 오류율 시각화 나쁜 답의 신호\n각 서비스 로그를 시간순으로 열람해 육안 탐색 주장 테스트 환경 재현 중심 접근만 언급, 비결정적 장애 대응 한계 노출 담당자별 구두 확인 의존, 근거 추적 불가 주의와 베스트 프랙티스\n로그 스키마 통일, PII 마스킹, 로그 레벨과 샘플링 정책 명확화 게이트웨이·워크커·비동기 큐 모두 동일한 Trace 컨텍스트 전파 지표는 RED 또는 USE 프레임으로 표준화, 알림은 소음 최소화 기준 설정 마무리 MSA의 난제는 분산 트랜잭션, 장애 전파 억제, 관측 가능성으로 수렴함 경험자의 답변에는 패턴의 이름이 아니라 운영 상의 선택과 트레이드오프, 실패 시나리오와 회복 절차가 담겨 있음 결과적 일관성 수용, 회복탄력성 패턴의 기본기 적용, 추적 가능한 운영 체계가 핵심 조직 차원에서는 SLO와 에러 버짓, 표준 라이브러리화된 통신·관측 컴포넌트, 런북과 사후분석의 반복 개선이 필수\n참고자료 https://microservices.io/patterns/data/saga.html https://microservices.io/patterns/data/transactional-outbox.html https://microservices.io/patterns/reliability/circuit-breaker.html https://resilience4j.readme.io/docs/circuitbreaker https://opentelemetry.io/docs/ https://www.jaegertracing.io/docs/ https://zipkin.io/ https://www.elastic.co/what-is/elk-stack ","permalink":"https://blog.jsontapose.com/posts/msa-core-challenges-and-practical-solutions-90cf31/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eMSA의 기술적 어려움은 결국 분산 시스템의 어려움과 동일함\n네트워크는 불안정, 데이터는 서비스별로 분산, 한 번의 요청이 여러 프로세스를 통과하는 구조 특성상 실패와 지연이 쉽게 전파됨\n리더급 실무 경험을 검증하려면 이 분산 시스템의 고통을 직접 다뤄본 흔적이 있는지 확인해야 함\n아래는 실무 난이도가 높은 세 영역과 면접 시 검증 포인트, 실전형 답변 예시 정리\u003c/p\u003e\n\u003ch3 id=\"분산-트랜잭션과-데이터-정합성\"\u003e분산 트랜잭션과 데이터 정합성\u003c/h3\u003e\n\u003cp\u003e핵심 맥락\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모놀리식에서는 단일 DB 트랜잭션으로 주문·결제·재고 감소를 한 번에 처리 가능\u003c/li\u003e\n\u003cli\u003eMSA에서는 주문 서비스 DB, 결제 서비스 DB, 재고 서비스 DB가 분리되어 원자적 커밋 불가\u003c/li\u003e\n\u003cli\u003e일부 단계 성공 후 후속 단계 실패 시 이미 성공한 작업을 어떻게 보상할지 정의 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e면접에서 확인할 질문\u003c/p\u003e","title":"MSA 설계와 운영의 핵심 난제 3가지와 실전 해결 전략"},{"content":"본 글은 정보보호 개론 맥락에서 암호 시스템의 기본 개념과 동작 방식을 정리한 내용임\n개념과 배경 암호학은 정보의 안전한 전달과 저장을 위한 방법론을 다루는 학문임 정보 보안의 목표는 CIA로 요약됨\n무결성 중간 위조·변조 불가 기밀성 허용되지 않은 자는 내용 파악 불가 가용성 적절한 시점에 허가된 사용자만 접근 가능 현대 보안에서는 암호 알고리즘이 공개되어도 안전해야 한다는 전제를 둠 즉 안전성은 비밀 알고리즘이 아니라 키에 의존함 컴퓨터가 다루는 모든 정보는 이진수이므로 보호는 결국 비트열을 다른 형태로 변환하는 문제로 귀결됨\n암호 시스템의 기본 구성 평문을 암호문으로 바꾸는 과정이 암호화, 암호문을 다시 평문으로 복원하는 과정이 복호화 표기 관례 예시 c = E_k(p), p = D_k(c)에서 p는 plaintext, c는 ciphertext, k는 키를 의미함\n양방향 암호화는 복호화가 가능함 단방향 암호화는 복호화 경로가 없거나 실질적으로 불가능한 변환을 의미함 (대표적으로 해시 함수) 본 글은 양방향 암호화를 중심으로 설명함\n키의 도입 고전 암호는 알고리즘이 노출되면 빠르게 깨짐 현대 암호는 임의의 비트열인 키를 도입해 동일 알고리즘이라도 키 없이는 복호화를 계산적으로 불가능에 가깝게 만듦 키 선택과 관리가 안전성의 핵심 축임\n대칭 암호 하나의 비밀키로 암호화와 복호화를 모두 수행하는 방식 송신자와 수신자만 키를 공유하면 기밀성 확보 가능 대표 알고리즘 예시 DES, AES, SEED, ARIA 현실 과제는 안전한 키 분배와 회전 주기 설계, 키 유출 시 즉시 전파 범위가 넓다는 점\n비대칭 암호 공개키와 개인키로 구성되는 공개키 암호 방식 대칭키의 배포 어려움을 완화하기 위해 고안됨 최초로 제안된 공개키 방식은 디피–헬만 키 교환이며, 이후 RSA, ElGamal 등으로 확장됨 (디피–헬만은 키 교환 프로토콜이며 일반적 의미의 암호문 전송 방식과는 구분됨) 동작 개요\n수신자의 공개키로 송신자가 평문을 암호화 암호문을 수신자에게 전달 수신자가 개인키로 복호화하여 평문 획득 공개키는 배포 가능, 개인키는 소유자만 보관 사용함 공개키를 통한 기밀성, 개인키를 통한 서명·인증 등 다양한 조합 가능 트랩도어 일방향 함수 비밀통로 일방향 함수(trapdoor function)는 순방향 계산은 쉽지만 역방향은 매우 어렵게 설계된 함수이며 특정 비밀 정보(트랩도어, 여기서는 개인키)를 알면 역연산이 가능함 정의 스케치 어떤 함수 f에 대해 y = f(x)는 쉽지만 x = f^{-1}(y)는 계산적으로 어렵다고 가정하는 구조를 일방향 함수라 부름 트랩도어 k를 알면 f^{-1}를 효율적으로 계산 가능함 여기서 어렵다는 의미는 알려진 어떤 방법을 사용하더라도 현실적인 시간 내에 풀 수 없거나 성공 확률이 무시 가능한 수준이라는 뜻임 현대 공개키 암호는 이러한 가정을 전제로 함 대표 후보로 RSA의 트랩도어 퍼뮤테이션이 널리 사용됨 다만 수학적으로 완전한 증명은 부재하므로 후보로서 다루며 안전성은 현재 알려진 최선의 공격 대비 계산적 곤란성에 기반함\n정리 암호 알고리즘은 공개를 전제, 안전성은 키에 의존 대칭 암호는 성능 우수, 키 분배가 관건 비대칭 암호는 키 분배 문제를 완화, 트랩도어 일방향 함수 가정을 활용 RSA 등은 현재 실무에서 널리 사용되나 안전성은 계산적 어려움 가정 위에 성립 다음 글에서는 이러한 가정의 근간이 되는 어려운 문제에 대해 다룸 참고자료 https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99 https://ko.wikipedia.org/wiki/%EC%A0%95%EB%B3%B4_%EB%B3%B4%EC%95%88 https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD%ED%82%A4_%EC%95%94%ED%98%B8 https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C%ED%82%A4_%EC%95%94%ED%98%B8 https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A7%8C_%ED%82%A4_%EA%B5%90%ED%99%98 https://ko.wikipedia.org/wiki/RSA_(%EC%95%94%ED%98%B8%ED%99%94) https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80 https://ko.wikipedia.org/wiki/DES https://ko.wikipedia.org/wiki/SEED https://ko.wikipedia.org/wiki/ARIA_(%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8) https://ko.wikipedia.org/wiki/%EC%9D%BC%EB%B0%A9%ED%96%A5_%ED%95%A8%EC%88%98 https://en.wikipedia.org/wiki/Trapdoor_function ","permalink":"https://blog.jsontapose.com/posts/crypto-basics-symmetric-asymmetric-trapdoor-functions-69a493/","summary":"\u003cp\u003e본 글은 정보보호 개론 맥락에서 암호 시스템의 기본 개념과 동작 방식을 정리한 내용임\u003c/p\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003e암호학은 정보의 안전한 전달과 저장을 위한 방법론을 다루는 학문임\n정보 보안의 목표는 CIA로 요약됨\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e무결성 중간 위조·변조 불가\u003c/li\u003e\n\u003cli\u003e기밀성 허용되지 않은 자는 내용 파악 불가\u003c/li\u003e\n\u003cli\u003e가용성 적절한 시점에 허가된 사용자만 접근 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현대 보안에서는 암호 알고리즘이 공개되어도 안전해야 한다는 전제를 둠 즉 안전성은 비밀 알고리즘이 아니라 키에 의존함\n컴퓨터가 다루는 모든 정보는 이진수이므로 보호는 결국 비트열을 다른 형태로 변환하는 문제로 귀결됨\u003c/p\u003e","title":"암호 시스템 기초: 대칭·비대칭 암호, 키와 트랩도어 함수"},{"content":"관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요\n개념 some 관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함 존재성 검사에 해당, 하나라도 매칭되면 true every 모든 관계된 레코드가 조건을 만족해야 부모 포함 단 하나라도 위배되면 제외됨 관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨 동작 원리 some은 존재량화, every는 전칭량화에 해당함 차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음 특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요 간단 예시 model Post { id Int @id @default(autoincrement()) title String comments Comment[] } model Comment { id Int @id @default(autoincrement()) text String postId Int post Post @relation(fields: [postId], references: [id]) } 댓글 text가 \u0026lsquo;interesting\u0026rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정\nsome 사용\nconst posts = await prisma.post.findMany({ where: { comments: { some: { text: \u0026#34;interesting\u0026#34; }, }, }, }); 댓글 중 하나라도 텍스트가 \u0026lsquo;interesting\u0026rsquo;이면 포함됨 every 사용\nconst posts = await prisma.post.findMany({ where: { comments: { every: { text: \u0026#34;interesting\u0026#34; }, }, }, }); 모든 댓글의 텍스트가 \u0026lsquo;interesting\u0026rsquo;이어야 포함됨 댓글이 하나도 없는 게시글도 조건을 만족한 것으로 간주됨 단일 필드 기준 필터링 시 차이 같은 필드 한 개로 필터링해도 결과가 달라질 수 있음 some은 조건을 만족하는 자식이 하나라도 있으면 부모 포함 every는 모든 자식이 조건을 만족해야 부모 포함, 자식이 없으면 포함됨 자식이 정확히 한 개이고 그 필드만 본다면 두 연산자가 같은 결과를 낼 수 있음. 그러나 자식이 여러 개이거나 없는 경우에는 달라짐 빈 관계를 결과에서 제외하고 싶을 때의 안전한 패턴\nconst posts = await prisma.post.findMany({ where: { AND: [ { comments: { every: { text: \u0026#34;interesting\u0026#34; } } }, { comments: { some: {} } }, // 최소 1개 존재 보장 ], }, }); every의 의도를 유지하면서 빈 관계가 포함되는 부작용 제거 가능 베스트 프랙티스 의도가 존재성 검사면 some, 전부 일치 검사면 every 선택 every 사용 시 빈 관계가 포함되는 특성을 인지하고 필요 시 some과 조합하여 최소 존재 보장 테스트 데이터에 빈 관계, 혼합된 관계, 전부 일치 관계를 포함해 결과 검증 권장 마무리 some은 하나라도 매칭되면 포함, every는 모두 매칭되어야 포함이라는 원칙. 차이는 자식이 0개 또는 다수일 때 크게 나타남. 단일 필드 기준이라도 항상 동일하지 않음. 관계 특성과 조건 의미를 명확히 정의하고, 빈 관계 처리 여부를 설계 단계에서 결정할 것\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions ","permalink":"https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/","summary":"\u003cp\u003e관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요\u003c/p\u003e\n\u003ch3 id=\"개념\"\u003e개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003esome\n\u003cul\u003e\n\u003cli\u003e관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함\u003c/li\u003e\n\u003cli\u003e존재성 검사에 해당, 하나라도 매칭되면 true\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eevery\n\u003cul\u003e\n\u003cli\u003e모든 관계된 레코드가 조건을 만족해야 부모 포함\u003c/li\u003e\n\u003cli\u003e단 하나라도 위배되면 제외됨\u003c/li\u003e\n\u003cli\u003e관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003esome은 존재량화, every는 전칭량화에 해당함\u003c/li\u003e\n\u003cli\u003e차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음\u003c/li\u003e\n\u003cli\u003e특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel Post {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  id       Int       @id @default(autoincrement())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  title    String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  comments Comment[]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel Comment {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  id     Int    @id @default(autoincrement())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  text   String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  postId Int\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  post   Post   @relation(fields: [postId], references: [id])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e댓글 text가 \u0026lsquo;interesting\u0026rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정\u003c/p\u003e","title":"Prisma where 관계 필터 some vs every 동작 차이와 주의점"},{"content":"개념/배경 Array.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임 원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임\n기본 문법 const newArray = array.map((element, index, array) =\u0026gt; { return element; }); element 현재 요소 index 현재 인덱스 array 원본 배열 참조 콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨\n사용 예시 숫자 배열 변환\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((n) =\u0026gt; n * 2); // [2, 4, 6, 8, 10] 객체 배열에서 특정 속성 추출\nconst users = [{ name: \u0026#34;Alice\u0026#34; }, { name: \u0026#34;Bob\u0026#34; }]; const names = users.map((u) =\u0026gt; u.name); // [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;] 인덱스 활용\nconst arr = [10, 20, 30]; const result = arr.map((n, i) =\u0026gt; n + i); // [10, 21, 32] 중첩 배열 변환\nconst nested = [ [1, 2], [3, 4], ]; const sums = nested.map((a) =\u0026gt; a.reduce((x, y) =\u0026gt; x + y, 0)); // [3, 7] 원본 배열과 불변성 map은 원본 배열을 수정하지 않음\nconst numbers = [1, 2, 3]; const squared = numbers.map((n) =\u0026gt; n ** 2); // numbers -\u0026gt; [1, 2, 3] // squared -\u0026gt; [1, 4, 9] null/undefined와 빈 슬롯 처리 주의 명시적 undefined 값이나 null 값은 콜백이 호출됨 반면, 배열의 빈 슬롯(hole)은 콜백이 호출되지 않음. 새 배열에도 동일한 위치의 빈 슬롯이 유지됨 // 명시적 undefined는 콜백 호출됨 const a = [1, undefined, 3]; const r1 = a.map((x) =\u0026gt; (x === undefined ? \u0026#34;empty\u0026#34; : x * 2)); // [2, \u0026#39;empty\u0026#39;, 6] // 빈 슬롯은 콜백 미호출, 그대로 빈 슬롯 유지됨 const b = [1, , 3]; // sparse array const r2 = b.map((x) =\u0026gt; \u0026#34;seen\u0026#34;); // r2는 [\u0026#39;seen\u0026#39;, , \u0026#39;seen\u0026#39;] 형태. 가운데는 여전히 빈 슬롯 이 차이를 혼동하면 데이터 품질 이슈 발생 가능. sparse array를 다루는 경우 사전에 채우기 또는 filter와의 조합 고려 권장\nforEach와의 차이 map 새 배열 반환, 변환 목적 forEach 반환값 없음, 부수 효과 목적 const nums = [1, 2, 3]; nums.forEach((n) =\u0026gt; console.log(n * 2)); // 출력만 수행 const doubled = nums.map((n) =\u0026gt; n * 2); // [2, 4, 6] 장점 불변성 유지 선언적 데이터 변환 체이닝에 유리, 가독성 향상 주의와 팁 콜백은 순수 함수 지향. 부수 효과는 forEach 사용 권장 map은 배열 길이를 기준으로 동작. 순회 중 새 요소를 push해도 방문하지 않음, 삭제된 요소는 방문되지 않음 배열 요소가 배열을 반환하는 변환이 많다면 flatMap 고려. map 후 flat보다 간결한 선택지 성능 민감 구간에서는 불필요한 중간 배열 생성을 피하도록 파이프라인 재검토 권장 정리 map은 각 요소를 변환해 동일 길이의 새 배열을 만드는 표준 도구 원본 불변, 명시적 undefined와 빈 슬롯 처리 차이, forEach와의 역할 분리가 핵심 포인트 데이터 변환 중심 로직에서 선언적이고 예측 가능한 코드 작성에 적합함\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map ","permalink":"https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eArray.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임\n원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임\u003c/p\u003e\n\u003ch3 id=\"기본-문법\"\u003e기본 문법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enewArray\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003earray\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003eelement\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eindex\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003earray\u003c/span\u003e) =\u0026gt; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eelement\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eelement 현재 요소\u003c/li\u003e\n\u003cli\u003eindex 현재 인덱스\u003c/li\u003e\n\u003cli\u003earray 원본 배열 참조\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨\u003c/p\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cp\u003e숫자 배열 변환\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enumbers\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edoubled\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003enumbers\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003emap\u003c/span\u003e((\u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003en\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// [2, 4, 6, 8, 10]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e객체 배열에서 특정 속성 추출\u003c/p\u003e","title":"JavaScript Array.prototype.map 개념과 사용법 정리"},{"content":"개요 커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법 n개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해 함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적\n핵심 개념 커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환 부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법 관계: 커링된 함수는 부분 적용을 자연스럽게 지원함 동작 원리와 간단 예시 일반 함수\nfunction add(a: number, b: number): number { return a + b; } add(1, 2); // 3 커링 적용\nfunction curriedAdd(a: number) { return (b: number): number =\u0026gt; a + b; } const addOne = curriedAdd(1); addOne(2); // 3 addOne(5); // 6 첫 번째 인자 고정 후 나머지 인자를 나중에 적용 가능\nRamda로 보는 자동 커링 Ramda의 함수는 기본적으로 자동 커링 동작 부분 적용이 일관되게 가능\nimport * as R from \u0026#34;ramda\u0026#34;; const add = R.add(1); // 첫 번째 인자 1 고정 add(2); // 3 함수 조합 파이프라인과 결합 시 표현 간결\n커링과 부분 적용의 차이 커링: 다인자 함수를 단일 인자 함수들의 연속으로 변환하는 과정 부분 적용: 전체 인자 중 일부만 먼저 채워 새 함수를 만드는 기법 간단 예시\nconst multiply = (a: number, b: number) =\u0026gt; a * b; const double = multiply.bind(null, 2); // 첫 인자 2 고정 double(5); // 10 커링은 구조 변환, 부분 적용은 사용 패턴에 초점\n함수 조합과의 궁합 커링된 함수는 합성 함수와 결합 시 장점 큼\nimport * as R from \u0026#34;ramda\u0026#34;; const increment = (x: number) =\u0026gt; x + 1; const double = (x: number) =\u0026gt; x * 2; const process = R.pipe(increment, double); process(3); // 8 입력에서 출력까지 단계적 변환을 작게 나눠 조합 가능\n장점 요약 재사용성 향상: 자주 쓰는 인자 고정 함수 생성 용이 가독성 개선: 복잡한 변환을 작은 단위로 분해 가능 조합성 증가: 파이프라인과 컴포지션에 자연스럽게 적합 테스트 용이: 부분 적용된 단일 책임 함수 단위 테스트 수월 주의 사항 과도한 중첩 사용 시 가독성 저하 위험 존재 타입스크립트에서 복잡한 커링 시 제네릭과 추론 한계 고려 필요 bind를 이용한 부분 적용은 this 바인딩까지 관여하므로 의도한 this 문맥 확인 필요 정리 커링은 다인자 함수를 단일 인자 함수의 연속으로 바꾸는 변환이며 부분 적용은 일부 인자만 먼저 고정해 새 함수를 만드는 기법 Ramda 같은 라이브러리의 자동 커링을 활용하면 재사용성과 조합성이 높아짐 작게 쪼개고 필요할 때 부분 적용해 파이프라인으로 잇는 패턴이 핵심\n참고자료 https://ramdajs.com/docs/#curry https://ramdajs.com/docs/#add https://en.wikipedia.org/wiki/Currying https://en.wikipedia.org/wiki/Partial_application ","permalink":"https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법\nn개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해\n함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환\u003c/li\u003e\n\u003cli\u003e부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법\u003c/li\u003e\n\u003cli\u003e관계: 커링된 함수는 부분 적용을 자연스럽게 지원함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-간단-예시\"\u003e동작 원리와 간단 예시\u003c/h3\u003e\n\u003cp\u003e일반 함수\u003c/p\u003e","title":"커링과 부분 적용 이해하기: 함수형 자바스크립트 핵심 패턴"},{"content":"개요 findUnique로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 where와 include를 어떻게 조합해야 하는지 정리함 관계 필터링을 where에 넣을 수 있는지, include에서 필터가 가능한지 헷갈리기 쉬운 지점 정리\n핵심 개념 findUnique는 유니크 키로 정확히 하나의 레코드를 찾는 용도 findUnique의 where는 유니크 필드만 허용됨, 관계 필터나 일반 조건 결합 불가 include는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션 to-many 관계에 한해 include 내부에서 where 사용 가능, to-one 관계는 where 불가 where 사용 패턴 잘못된 예시 // findUnique에 관계 필터 결합 시도 → 타입 에러 // (User(1) → Post(N) → Metadata(1) 관계) await db.user.findUnique({ where: { id: userId, // \u0026#39;posts\u0026#39;는 유니크 필드가 아니므로 \u0026#39;where\u0026#39;에서 관계 필터링 불가 posts: { some: { metadata: { editorEmail: email } } }, }, }); 올바른 최소 조건 await db.user.findUnique({ where: { id: userId }, // \u0026#39;id\u0026#39;는 유니크 필드 }); 관계 조건이 필요하면 findFirst 또는 findMany 사용 // \u0026#39;findUnique\u0026#39;가 아닌 \u0026#39;findFirst\u0026#39;를 사용하면 // \u0026#39;where\u0026#39;에 관계 필터를 포함할 수 있음 await db.user.findFirst({ where: { id: userId, posts: { some: { metadata: { editorEmail: email } } }, }, }); 요약하면 findUnique에는 유니크 조건만, 관계 기반 필터는 findFirst 또는 findMany로 처리함\ninclude 사용 패턴 올바른 기본 형태 (User → Posts → Metadata 관계) await db.user.findUnique({ where: { id: userId }, include: { posts: { include: { metadata: true } }, // \u0026#39;posts\u0026#39;와 중첩된 \u0026#39;metadata\u0026#39; 포함 }, }); 잘못된 형태 // include에 관계 필터를 직접 넣는 구문은 불가 include: { posts: { // \u0026#39;include\u0026#39; 내부에서 필터링을 이렇게 할 수 없음 (Prisma 4.x 이하) // \u0026#39;include\u0026#39;는 \u0026#39;true\u0026#39; 또는 다른 include/select 객체만 받음 include: { metadata: { editorEmail: email } }, }, } 의도에 부합하는 형태 (Prisma 5.x+ 권장) await db.user.findUnique({ where: { id: userId }, include: { posts: { // to-many 관계인 \u0026#39;posts\u0026#39;에 \u0026#39;where\u0026#39;를 걸어 필터링 where: { metadata: { editorEmail: email } }, // 필터링된 \u0026#39;posts\u0026#39;에 연결된 \u0026#39;metadata\u0026#39;를 포함 include: { metadata: true }, }, }, }); 설명\nto-many 관계인 posts에 where를 걸어 하위 metadata의 editorEmail로 필터링 가능 조건에 맞지 않는 posts는 제외되어 빈 배열([])로 반환됨 to-one 관계는 include에서 where를 쓸 수 없으며, 관계가 없으면 해당 필드는 null 반환 결론 예시 단일 User를 유니크 키로 찾고, 연관된 Posts는 특정 email을 가진 Metadata가 있는 경우만 포함하고, 사용자의 Profile과 Role도 함께 가져오고 싶다면 아래 형태를 권장\nconst userId = \u0026#34;user-unique-id-123\u0026#34;; const email = \u0026#34;target-editor@example.com\u0026#34;; await db.user.findUnique({ where: { id: userId }, include: { // 1. (to-many) \u0026#39;posts\u0026#39; 관계 posts: { // 2. \u0026#39;posts\u0026#39; 목록을 \u0026#39;metadata.editorEmail\u0026#39; 기준으로 필터링 where: { metadata: { editorEmail: email } }, // 3. 필터링을 통과한 \u0026#39;posts\u0026#39;의 \u0026#39;metadata\u0026#39;도 함께 로드 include: { metadata: true }, }, // 4. (to-one) \u0026#39;profile\u0026#39; 관계 profile: true, // 5. (to-one) \u0026#39;role\u0026#39; 관계 role: true, }, }); 주의 사항 findUnique의 where에는 유니크 필드만 입력 가능, 관계 필터 결합 불가 관계 조건이 결합된 조회가 필요하면 findFirst 또는 findMany로 상위 where에 관계 필터 사용 include의 where는 to-many 관계에만 적용 가능 to-many 관계에서 include의 where 조건 미매칭 시, 해당 관계는 null이 아닌 빈 배열([]) 반환 선택적 필드 제어가 필요하면 select와 include를 목적에 맞게 혼용 권장 참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/retrieving-data#findunique https://www.prisma.io/docs/orm/prisma-client/queries/retrieving-data#including-relations https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filtering-by-a-related-records-fields ","permalink":"https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efindUnique\u003c/code\u003e로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 \u003ccode\u003ewhere\u003c/code\u003e와 \u003ccode\u003einclude\u003c/code\u003e를 어떻게 조합해야 하는지 정리함\n관계 필터링을 \u003ccode\u003ewhere\u003c/code\u003e에 넣을 수 있는지, \u003ccode\u003einclude\u003c/code\u003e에서 필터가 가능한지 헷갈리기 쉬운 지점 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efindUnique\u003c/code\u003e는 유니크 키로 정확히 \u003cstrong\u003e하나\u003c/strong\u003e의 레코드를 찾는 용도\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efindUnique\u003c/code\u003e의 \u003ccode\u003ewhere\u003c/code\u003e는 \u003cstrong\u003e유니크 필드만\u003c/strong\u003e 허용됨, 관계 필터나 일반 조건 결합 불가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einclude\u003c/code\u003e는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eto-many 관계\u003c/strong\u003e에 한해 \u003ccode\u003einclude\u003c/code\u003e 내부에서 \u003ccode\u003ewhere\u003c/code\u003e 사용 가능, to-one 관계는 \u003ccode\u003ewhere\u003c/code\u003e 불가\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"where-사용-패턴\"\u003ewhere 사용 패턴\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e잘못된 예시\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// findUnique에 관계 필터 결합 시도 → 타입 에러\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// (User(1) → Post(N) → Metadata(1) 관계)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edb\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindUnique\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003euserId\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;posts\u0026#39;는 유니크 필드가 아니므로 \u0026#39;where\u0026#39;에서 관계 필터링 불가\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003esome\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003emetadata\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eeditorEmail\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eemail\u003c/span\u003e } } },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e올바른 최소 조건\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edb\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindUnique\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003euserId\u003c/span\u003e }, \u003cspan style=\"color:#75715e\"\u003e// \u0026#39;id\u0026#39;는 유니크 필드\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e관계 조건이 필요하면 findFirst 또는 findMany 사용\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// \u0026#39;findUnique\u0026#39;가 아닌 \u0026#39;findFirst\u0026#39;를 사용하면\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// \u0026#39;where\u0026#39;에 관계 필터를 포함할 수 있음\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edb\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindFirst\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003euserId\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eposts\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003esome\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003emetadata\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eeditorEmail\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003eemail\u003c/span\u003e } } },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e요약하면 \u003ccode\u003efindUnique\u003c/code\u003e에는 유니크 조건만, 관계 기반 필터는 \u003ccode\u003efindFirst\u003c/code\u003e 또는 \u003ccode\u003efindMany\u003c/code\u003e로 처리함\u003c/p\u003e","title":"Prisma findUnique에서 where와 include 제대로 쓰기"},{"content":"개요 Node.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리 바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명\n핵심 개념 V8 엔진, Ignition 바이트코드와 JIT 최적화 libuv, 비동기 I O 백엔드와 이벤트 루프 단계 모듈 시스템, CommonJS와 ES Module의 로딩 차이 전역 실행 컨텍스트와 런타임 내장 객체 마이크로태스크 큐와 process.nextTick의 우선순위 실행 순서 요약 Node 바이너리 시작 런타임 초기화와 내부 바인딩 준비 모듈 로더 기동 및 엔트리 파일 로드 V8 파싱과 바이트코드 컴파일 전역 실행 컨텍스트 구성과 최상위 코드 실행 비동기 작업 등록 이벤트 루프 진입 비동기 콜백 처리 반복 graph TD A[Node 시작] --\u0026gt; B[V8, libuv 초기화] B --\u0026gt; C[모듈 로딩] C --\u0026gt; D[파싱 및 컴파일] D --\u0026gt; E[최상위 코드 실행] E --\u0026gt; F[이벤트 루프] F --\u0026gt; G[비동기 처리 반복] 단계별 동작 1단계 Node 바이너리 시작 node yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨 V8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨\n2단계 런타임 초기화 V8, libuv, 암호화와 압축 등 필수 의존성 초기화 process 객체와 argv, env, versions 설정 표준 입출력 스트림 바인딩 준비\n3단계 모듈 로더 실행 엔트리 파일을 기준으로 모듈 해석과 로딩 수행\nCommonJS require 사용 시 동기 로딩과 함수 래핑 적용 (function exports, require, module, **filename, **dirname { \u0026hellip; }) 형태로 감쌈 **filename, **dirname 은 CommonJS에서만 제공됨 ES Module import 사용 시 비동기 로딩과 링크 단계 수행 mjs 확장자 또는 package 설정의 type module 조건에서 활성화됨 ESM에는 **filename, **dirname 미제공이며 import.meta.url 사용 권장 의존성 그래프를 구축하고 모듈 결과를 캐시에 보관함 4단계 파싱과 바이트코드 컴파일 V8이 소스 코드를 AST로 파싱한 뒤 Ignition 바이트코드로 컴파일함 실행 중 반복 패턴이 관찰되면 JIT 최적화가 적용됨\n5단계 전역 실행 컨텍스트 구성 ExecutionContext를 만들고 전역 객체와 내장 바인딩을 연결함 global, process, require CommonJS 한정, import ESM 문맥 등 환경이 확정됨 엔트리 파일의 최상위 레벨 코드가 동기적으로 실행됨\n6단계 비동기 작업 등록 setTimeout, Promise, 파일 I O, 네트워크 I O 등은 즉시 실행 대신 콜백을 적절한 큐에 등록함\n타이머 큐, I O 큐, 체크 큐 등 이벤트 루프 단계별 큐에 배치됨 마이크로태스크는 별도 큐에 등록됨 이 시점까지는 콜백이 실행되지 않고 등록만 진행됨 7단계 이벤트 루프 진입 초기 스크립트 평가가 끝나면 이벤트 루프로 진입함 대표 단계 순서\ntimers 단계에서 setTimeout, setInterval 콜백 처리 pending callbacks 단계에서 일부 시스템 콜백 처리 idle, prepare 단계 내부 용도 poll 단계에서 I O 처리 및 대기 check 단계에서 setImmediate 처리 close callbacks 단계에서 close 이벤트 처리 각 콜백 실행 직후에 process.nextTick 큐와 마이크로태스크 큐가 소진됨 우선순위는 process.nextTick 먼저, 그 다음 Promise then, queueMicrotask 순으로 처리됨 8단계 비동기 콜백 처리 반복 대기 중인 큐에서 콜백을 꺼내 실행하고 필요 시 새로운 비동기 작업을 다시 등록함 작업이 남아있는 동안 루프가 계속 순환함\nCJS와 ESM 로딩 차이 요약 require 동기 로딩과 캐시 기반 재사용, 파일 해석과 실행이 호출 시점에 일어남 import 비동기 로딩과 링크, 정적 의존성 해석 우선, 토폴로지 정리 후 실행 런타임 전역 제공 요소 차이 존재 CommonJS의 **filename, **dirname은 ESM에 없음 마이크로태스크와 nextTick 주의 process.nextTick은 Node 전용 큐로 매 단계와 콜백 직후 최우선 처리됨 Promise then 등 마이크로태스크는 nextTick 처리 이후 실행됨 과도한 nextTick 사용은 이벤트 루프 굶김을 유발할 수 있음 종료 조건 활성 타이머, 보류된 I O, 등록된 콜백 등 이벤트 루프에서 처리할 작업이 더 이상 없음 명시적 process.exit 호출 간단 예시 아래 코드는 동기 실행과 마이크로태스크, 타이머의 상대적 순서를 보여줌\nconsole.log(\u0026#39;start\u0026#39;) setTimeout(() =\u0026gt; { console.log(\u0026#39;timeout\u0026#39;) }, 0) Promise.resolve().then(() =\u0026gt; { console.log(\u0026#39;promise\u0026#39;) }) console.log(\u0026#39;end\u0026#39;) 실행 순서 1 start 동기 2 end 동기 3 promise 마이크로태스크 4 timeout 타이머\n정리 Node.js는 바이너리 기동 후 V8과 libuv를 초기화하고 모듈을 로딩한 뒤 최상위 코드를 실행함 비동기 작업은 등록만 수행되고 초기 평가가 끝나면 이벤트 루프에 진입하여 단계별로 콜백을 처리함 process.nextTick이 마이크로태스크보다 먼저 실행되는 점, CommonJS와 ESM의 로딩 및 전역 차이를 구분할 것\n참고자료 https://nodejs.org/en/learn/asynchronous/event-loop-timers-and-nexttick https://nodejs.org/api/modules.html https://nodejs.org/api/esm.html https://docs.libuv.org/en/v1.x/design.html https://v8.dev/docs ","permalink":"https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리\n바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eV8 엔진, Ignition 바이트코드와 JIT 최적화\u003c/li\u003e\n\u003cli\u003elibuv, 비동기 I O 백엔드와 이벤트 루프 단계\u003c/li\u003e\n\u003cli\u003e모듈 시스템, CommonJS와 ES Module의 로딩 차이\u003c/li\u003e\n\u003cli\u003e전역 실행 컨텍스트와 런타임 내장 객체\u003c/li\u003e\n\u003cli\u003e마이크로태스크 큐와 process.nextTick의 우선순위\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실행-순서-요약\"\u003e실행 순서 요약\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eNode 바이너리 시작\u003c/li\u003e\n\u003cli\u003e런타임 초기화와 내부 바인딩 준비\u003c/li\u003e\n\u003cli\u003e모듈 로더 기동 및 엔트리 파일 로드\u003c/li\u003e\n\u003cli\u003eV8 파싱과 바이트코드 컴파일\u003c/li\u003e\n\u003cli\u003e전역 실행 컨텍스트 구성과 최상위 코드 실행\u003c/li\u003e\n\u003cli\u003e비동기 작업 등록\u003c/li\u003e\n\u003cli\u003e이벤트 루프 진입\u003c/li\u003e\n\u003cli\u003e비동기 콜백 처리 반복\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003egraph TD\nA[Node 시작] --\u0026gt; B[V8, libuv 초기화]\nB --\u0026gt; C[모듈 로딩]\nC --\u0026gt; D[파싱 및 컴파일]\nD --\u0026gt; E[최상위 코드 실행]\nE --\u0026gt; F[이벤트 루프]\nF --\u0026gt; G[비동기 처리 반복]\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"단계별-동작\"\u003e단계별 동작\u003c/h3\u003e\n\u003ch4 id=\"1단계-node-바이너리-시작\"\u003e1단계 Node 바이너리 시작\u003c/h4\u003e\n\u003cp\u003enode yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨\nV8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨\u003c/p\u003e","title":"Node.js 실행 흐름과 이벤트 루프 단계 정리"},{"content":"개념/배경 DI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함 객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용하는 것임 이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함\n문제 상황: 강한 결합 (Tight Coupling) 전형적인 문제 패턴은 클래스 내부에서 다른 구체적인 클래스(Concrete Class)를 new 키워드로 직접 생성하여 사용하는 것임\n의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 반드시 함께 수정해야 함 단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐 예를 들어 Gamer가 BlueSwitchKeyboard를 직접 생성해 사용한다면, Gamer는 BlueSwitchKeyboard라는 구체적인 구현에 영구적으로 고정됨 만약 키보드 종류를 RedSwitchSilentKeyboard로 바꾸려면 Gamer 클래스의 내부 코드를 직접 수정해야 함 이 상태를 결합도가 높다고 부름\n예제 코드 (강한 결합) class BlueSwitchKeyboard { type() { console.log(\u0026#34;찰칵- 찰칵-\u0026#34;); } } // Gamer가 BlueSwitchKeyboard라는 \u0026#39;구현\u0026#39;에 직접 의존함 class Gamer { constructor() { // 문제 지점: Gamer가 사용할 키보드를 스스로 생성함 this.keyboard = new BlueSwitchKeyboard(); } play() { console.log(\u0026#34;게임 시작!\u0026#34;); this.keyboard.type(); } } const gamer = new Gamer(); gamer.play(); DI 적용: 느슨한 결합 (Loose Coupling) 핵심 변경점은 제어의 역전(Inversion of Control, IoC)을 적용하는 것임\nGamer는 더 이상 키보드를 직접 만들지 않음 (생성 책임 제거) 외부에서 생성자를 통해 keyboard 인스턴스를 주입받음 Gamer는 주입받은 객체가 type 메서드를 가진다는 인터페이스에만 의존함 예제 코드 (느슨한 결합) // 다양한 키보드 구현체들 class BlueSwitchKeyboard { type() { console.log(\u0026#34;찰칵- 찰칵-\u0026#34;); } } class RedSwitchSilentKeyboard { type() { console.log(\u0026#34;서걱... 서걱...\u0026#34;); } } // Gamer는 \u0026#39;type\u0026#39; 메서드를 가진 객체라면 무엇이든 OK class Gamer { constructor(keyboard) { // 👍 개선 지점: 외부에서 \u0026#39;keyboard\u0026#39; 역할을 하는 객체를 주입받음 this.keyboard = keyboard; } play() { console.log(\u0026#34;게임 시작!\u0026#34;); this.keyboard.type(); // 그냥 계약(type)대로 호출할 뿐임 } } // \u0026#39;조립\u0026#39;은 외부에서 수행함 // 1. 파란 축 키보드가 필요한 경우 const blueKeyboard = new BlueSwitchKeyboard(); const gamer1 = new Gamer(blueKeyboard); gamer1.play(); // 2. 빨간 축 저소음 키보드가 필요한 경우 const redKeyboard = new RedSwitchSilentKeyboard(); const gamer2 = new Gamer(redKeyboard); gamer2.play(); // Gamer 코드는 전혀 수정되지 않았음 이제 Gamer 코드를 단 한 줄도 바꾸지 않고도, type 메서드를 가진 어떤 키보드 구현체든 자유롭게 주입하여 교체할 수 있음\n왜 결합도가 낮아지는가 의존 대상이 구체적인 구현에서 추상적인 역할로 전환되기 때문임\nBefore (강한 결합): Gamer 클래스가 BlueSwitchKeyboard라는 특정 구현 클래스를 직접 알아야 했음 After (느슨한 결합): Gamer 클래스는 \u0026lsquo;type 메서드를 제공하는 무언가\u0026rsquo;라는 인터페이스에만 의존함 Gamer는 이제 BlueSwitchKeyboard나 RedSwitchSilentKeyboard의 존재 자체를 알 필요가 없음 결합의 기준점이 \u0026lsquo;특정 제품\u0026rsquo;이 아닌 \u0026lsquo;제품의 기능 명세\u0026rsquo;로 이동하면서, 변경의 파급 효과가 극적으로 줄어듦\n이는 \u0026ldquo;구체적인 구현이 아닌 추상화에 의존하라\u0026rdquo;(Depend on abstractions, not on concretions)는 SOLID 원칙 중 하나인 의존성 역전 원칙의 핵심 실천 방식임\n테스트와 확장성 테스트 용이성 DI를 사용하면 실제 의존 객체 대신 Mock Object을 쉽게 주입할 수 있음 실제 하드웨어에 의존하거나 네트워크 통신을 하는 무거운 객체를 가벼운 가짜 객체로 대체하여, 빠르고 고립된 단위 테스트가 가능해짐\n예제 코드 (테스트) // 테스트를 위한 가짜 키보드 (Mock) const mockKeyboard = { type: () =\u0026gt; { console.log(\u0026#34;가짜 키보드 입력 테스트\u0026#34;); // 테스트 검증 로직 추가 가능 (예: 호출되었는지 확인) }, }; // 실제 키보드 클래스 없이 Gamer의 play 기능만 고립시켜 테스트 가능 const testGamer = new Gamer(mockKeyboard); testGamer.play(); 확장성 새로운 기능의 키보드(MembraneKeyboard, OpticalSwitchKeyboard 등)가 추가되어도 Gamer 코드는 수정할 필요가 전혀 없음 외부에서 객체를 생성하고 주입하는 Composition Root에서 어떤 구현을 사용할지만 결정하면 됨\nDI와 IoC 컨테이너 작은 규모에서는 위 예제처럼 생성자나 메서드를 통한 수동 DI만으로도 충분한 효과를 볼 수 있음\n하지만 프로젝트 규모가 커지면, 수십 개의 객체가 서로 복잡한 의존 관계를 맺고, 이들의 생성 순서와 수명(Lifecycle) 관리가 복잡한 반복 작업이 됨\nIoC 컨테이너는 이 \u0026lsquo;조립\u0026rsquo; 과정을 자동화하고 중앙에서 관리해주는 프레임워크 기능임\nex. NestJS, Spring, Angular의 DI 시스템 개발자가 클래스 생성자에 필요한 의존성을 \u0026lsquo;선언\u0026rsquo;만 해두면 (예: @Injectable()) 컨테이너가 런타임에 필요한 실제 인스턴스를 찾아 \u0026lsquo;주입\u0026rsquo;해 줌 IoC 컨테이너는 단순 주입 외에도 객체의 수명 주기(Lifecycle) 관리 (싱글톤, 요청 스코프 등), 순환 참조 감지 등 고급 기능을 제공함 ⚠️ 주의사항 서비스 로케이터 패턴 남용 주의 서비스 로케이터는 DI와 달리 의존성을 외부에 명시적으로 드러내지 않고 클래스 내부에 숨김/ 이는 테스트를 어렵게 하고 코드의 의존 관계 추론을 방해할 수 있음 과도한 생성자 인자 한 클래스의 생성자에 5개가 넘는 의존성이 주입된다면, 해당 클래스가 단일 책임 원칙(SRP)을 위반하고 있을 가능성이 높음/ 설계를 재검토하고 책임을 분리해야 함 런타임 타입 검증 타입스크립트 같은 정적 타입 시스템이 없다면, 런타임에 주입된 객체가 필요한 메서드(type 등)를 가지고 있는지 보장하기 어려움/ 이 경우, 인터페이스 검증 로직을 추가로 고려할 수 있음 순환 의존성 (Circular Dependency) A가 B를, B가 다시 A를 의존하는 상황은 IoC 컨테이너를 망가뜨리고 설계 문제를 암시하는 강력한 신호임/ 역할 분리나 중간 계층(Port) 도입으로 의존성 방향을 한쪽으로 정리해야 함 🏁 마무리 DI의 본질은 \u0026lsquo;생성\u0026rsquo;의 책임과 \u0026lsquo;사용\u0026rsquo;의 책임을 분리하는 것임\n사용 객체(Gamer)는 자신이 사용할 대상의 역할만 바라보고 동작함 실제 구현 객체를 생성하는 책임은 외부의 Composition Root이나 IoC 컨테이너가 담당함 이 간단한 책임 분리를 통해 구현 교체가 자유로워지고, 테스트가 가벼워지며, 시스템 전체의 결합도가 낮아져 유연하고 확장 가능한 설계가 완성됨\n참고자료 Martin Fowler - Inversion of Control Containers and the Dependency Injection pattern Wikipedia - Dependency injection NestJS - Custom providers ","permalink":"https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/","summary":"\u003ch2 id=\"개념배경\"\u003e개념/배경\u003c/h2\u003e\n\u003cp\u003eDI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함\n\u003cstrong\u003e객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용\u003c/strong\u003e하는 것임\n이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"문제-상황-강한-결합-tight-coupling\"\u003e문제 상황: 강한 결합 (Tight Coupling)\u003c/h2\u003e\n\u003cp\u003e전형적인 문제 패턴은 클래스 내부에서 다른 \u003cstrong\u003e구체적인 클래스\u003c/strong\u003e(Concrete Class)를 \u003ccode\u003enew\u003c/code\u003e 키워드로 직접 생성하여 사용하는 것임\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 \u003cstrong\u003e반드시 함께 수정\u003c/strong\u003e해야 함\u003c/li\u003e\n\u003cli\u003e단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어 \u003ccode\u003eGamer\u003c/code\u003e가 \u003ccode\u003eBlueSwitchKeyboard\u003c/code\u003e를 직접 생성해 사용한다면, \u003ccode\u003eGamer\u003c/code\u003e는 \u003ccode\u003eBlueSwitchKeyboard\u003c/code\u003e라는 구체적인 구현에 영구적으로 고정됨\n만약 키보드 종류를 \u003ccode\u003eRedSwitchSilentKeyboard\u003c/code\u003e로 바꾸려면 \u003ccode\u003eGamer\u003c/code\u003e 클래스의 내부 코드를 직접 수정해야 함\n이 상태를 \u003cstrong\u003e결합도가 높다\u003c/strong\u003e고 부름\u003c/p\u003e","title":"DI가 결합도를 낮추는 원리와 최소 예시"},{"content":"개요 KISS는 Keep It Simple, Stupid 또는 Keep It Simple and Straightforward의 약자이며 1960년대 미 해군에서 출발한 설계 원칙입니다. 소프트웨어에서는 불필요한 복잡성을 제거하고 이해와 변경이 쉬운 구조를 지향합니다. 목표는 적은 개념과 짧은 경로로 같은 가치를 제공하는 시스템을 만드는 것임\n핵심 개념 단순함 추구: 필요 최소의 개념, 규칙, 구성 요소 유지 이해 용이성: 읽고 추론하기 쉬운 흐름과 명명 유지보수 용이성: 응집도 높이고 결합도 낮춰 변경 영향 최소화 적용 방법 처음부터 모든 시나리오를 포괄하려 하지 말고 현재 요구에 맞춘 최소 기능으로 시작 큰 만능 모듈 대신 작고 역할이 분리된 구성으로 나누기 공개 인터페이스를 최소화하고 기본값을 합리적으로 설계 데이터 흐름을 단방향으로 단순화하고 예외 경로는 명시적으로 처리 관련 원칙 DRY: 중복 제거로 변경 비용과 오류 가능성 감소 YAGNI: 지금 필요 없는 기능은 만들지 않음 간단 예시 모든 옵션을 받는 doSomething(config) 하나로 처리하려는 유혹을 경계. 대신 doSimpleA, doSimpleB처럼 명확한 역할의 작은 함수로 분리하고 기본 동작을 안전하게 설계함. 설정이 꼭 필요할 때만 제한된 형태로 노출\n주의와 한계 지나친 단순화는 요구 사항을 놓치거나 성능 병목을 숨길 수 있음. 단순함은 기능 포기나 임시방편이 아니라 핵심을 분리하고 불필요를 걷어내는 구조적 선택이어야 함. 변경 가능성, 운영 환경, 팀 역량 같은 제약을 고려해 균형 잡힌 트레이드오프 설계 필요\n마무리 KISS의 본질은 덜 하는 것이 아니라 더 잘 하는 것에 있음. 작게 시작하고 반복적으로 다듬으면서 복잡성이 자연스럽게 커지지 않도록 경계하는 습관이 유지보수 가능한 코드베이스를 만든다 함\n참고자료 https://en.wikipedia.org/wiki/KISS_principle https://en.wikipedia.org/wiki/Don%27t_repeat_yourself https://martinfowler.com/bliki/Yagni.html ","permalink":"https://blog.jsontapose.com/posts/kiss-principle-software-design-799a74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eKISS는 Keep It Simple, Stupid 또는 Keep It Simple and Straightforward의 약자이며 1960년대 미 해군에서 출발한 설계 원칙입니다. 소프트웨어에서는 불필요한 복잡성을 제거하고 이해와 변경이 쉬운 구조를 지향합니다. 목표는 적은 개념과 짧은 경로로 같은 가치를 제공하는 시스템을 만드는 것임\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단순함 추구: 필요 최소의 개념, 규칙, 구성 요소 유지\u003c/li\u003e\n\u003cli\u003e이해 용이성: 읽고 추론하기 쉬운 흐름과 명명\u003c/li\u003e\n\u003cli\u003e유지보수 용이성: 응집도 높이고 결합도 낮춰 변경 영향 최소화\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"적용-방법\"\u003e적용 방법\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e처음부터 모든 시나리오를 포괄하려 하지 말고 현재 요구에 맞춘 최소 기능으로 시작\u003c/li\u003e\n\u003cli\u003e큰 만능 모듈 대신 작고 역할이 분리된 구성으로 나누기\u003c/li\u003e\n\u003cli\u003e공개 인터페이스를 최소화하고 기본값을 합리적으로 설계\u003c/li\u003e\n\u003cli\u003e데이터 흐름을 단방향으로 단순화하고 예외 경로는 명시적으로 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"관련-원칙\"\u003e관련 원칙\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDRY: 중복 제거로 변경 비용과 오류 가능성 감소\u003c/li\u003e\n\u003cli\u003eYAGNI: 지금 필요 없는 기능은 만들지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e모든 옵션을 받는 doSomething(config) 하나로 처리하려는 유혹을 경계. 대신 doSimpleA, doSimpleB처럼 명확한 역할의 작은 함수로 분리하고 기본 동작을 안전하게 설계함. 설정이 꼭 필요할 때만 제한된 형태로 노출\u003c/p\u003e","title":"KISS 원리: 소프트웨어 설계에서 불필요한 복잡성 줄이기"},{"content":"개념/배경 Parameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨 함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함\n문법 type Parameters\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends ( ...args: infer P ) =\u0026gt; any ? P : never; T가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출 T가 함수 타입이 아니면 never 반환 추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능 사용 예시 기본 추출\nfunction greet(name: string, age: number) { return `Hello, ${name}. You are ${age} years old`; } type GreetParameters = Parameters\u0026lt;typeof greet\u0026gt;; // [name: string, age: number] 매개변수 타입 재사용\ntype GreetParameters = Parameters\u0026lt;typeof greet\u0026gt;; const newGreet = (...args: GreetParameters) =\u0026gt; greet(...args); 위와 같이 스프레드와 결합해 기존 함수의 매개변수 시그니처를 그대로 보존하는 래퍼를 작성 가능함 시그니처 변경 시 컴파일 시점에 파급 오류가 발생하므로 타입 드리프트를 방지하는 효과가 있음\n비동기 함수에도 동일하게 적용 가능함 매개변수 추출은 반환 타입과 무관하며 Promise 여부에 영향 받지 않음\n동작 포인트 infer 키워드를 사용한 조건부 타입으로 매개변수 튜플 P를 도출하는 구조 튜플에 라벨이 표시될 수 있으나 라벨은 가독성 보조 요소이며 타입 호환성에는 영향이 크지 않음 any에 대한 Parameters는 any[]로 간주될 수 있어 타입 안전성이 약해짐 가능한 한 구체적인 함수 타입을 대상으로 사용 권장 주의 사항 함수 타입이 아닌 입력은 항상 never가 됨 type NotAFunction = Parameters\u0026lt;number\u0026gt;; // never 오버로드가 있는 함수 타입을 대상으로 사용할 때 의도한 시그니처와 추출 결과가 어긋날 수 있음 가능한 한 명시적인 함수 타입 별칭을 만들어 두고 해당 타입에 대해 Parameters를 적용하는 방식 권장 매개변수에 this 바인딩 타입이 있는 함수의 경우, 호출 시그니처 정의 방식에 따라 결과가 달라질 수 있음 this 파라미터를 분리한 호출 시그니처를 명시해 예측 가능성 확보 권장 베스트 프랙티스 기존 함수의 매개변수 타입을 재사용하는 래퍼, 프락시, 데코레이터, 로깅 헬퍼 등에 적극 활용 API 경계에서 입력 검증 로직과 타입을 일치시키기 위해 Parameters 결과를 폼 파서나 밸리데이터와 연계 팀 규칙으로 any를 허용하는 Parameters 사용을 제한하고, 구체 타입 기반으로만 사용하도록 가이드 마무리 Parameters는 함수 타입의 매개변수 목록을 튜플로 추출해 재사용성과 타입 안전성을 동시에 확보하는 유틸리티 타입임 조건부 타입과 infer를 기반으로 동작하며, 함수가 아닌 타입에는 never를 반환함 과도한 중복 선언을 줄이고 래퍼 함수의 타입 드리프트를 방지하는 데 실용적임\n참고자료 https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterst https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#labeled-tuple-elements ","permalink":"https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eParameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨\n함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함\u003c/p\u003e\n\u003ch3 id=\"문법\"\u003e문법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eParameters\u003c/span\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003eT\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eextends\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003e...args\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eany\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e=\u003c/span\u003e\u0026gt; \u003cspan style=\"color:#66d9ef\"\u003eany\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eextends\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ...\u003cspan style=\"color:#a6e22e\"\u003eargs\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003einfer\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e) \u003cspan style=\"color:#f92672\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eany\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  : \u003cspan style=\"color:#66d9ef\"\u003enever\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eT가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출\u003c/li\u003e\n\u003cli\u003eT가 함수 타입이 아니면 never 반환\u003c/li\u003e\n\u003cli\u003e추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cp\u003e기본 추출\u003c/p\u003e","title":"TypeScript Parameters 유틸리티 타입 개념과 안전한 활용"},{"content":"개요 InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 메모리에 캐싱하는 영역임 디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임 InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 심장부라 할 수 있음\n쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임\n버퍼 풀 구성 요소 버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴\n데이터 페이지: 실제 테이블 로우(Row)가 저장된 페이지 인덱스 페이지: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함) 기타 관리 페이지: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등 핵심 개념 페이지 캐싱 InnoDB는 디스크 데이터를 페이지 단위로 다룸 클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 페이지 전체를 버퍼 풀로 가져옴 이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함\n더티 페이지와 쓰기 지연 애플리케이션이 데이터를 변경(INSERT, UPDATE)하면,\n버퍼 풀에 적재된 페이지가 메모리상에서 먼저 수정됨 이 페이지는 \u0026lsquo;더티 페이지(Dirty Page)\u0026rsquo;(디스크와 내용이 다른 상태)로 표시됨 변경 내용은 즉시 디스크 데이터 파일에 쓰지 않고, 백그라운드 스레드가 모아서(Batch) 디스크에 반영(Flush)함 이렇게 모아서 쓰면 랜덤 I/O를 줄이고, 디스크 쓰기 효율을 올릴 수 있음\n리두 로그 (Redo Log) InnoDB는 WAL(Write-Ahead Logging) 방식을 사용함 데이터 페이지를 디스크에 쓰기 전에, 먼저 리두 로그에 변경 내용을 기록함\n트랜잭션 커밋 흐름 요약\n버퍼 풀의 페이지 수정 (→ 더티 페이지) 리두 로그 버퍼에 변경 내역 기록 커밋 시점: 리두 로그를 디스크로 동기화 (fsync) 애플리케이션에 커밋 성공 응답 (이후) 더티 페이지는 백그라운드에서 천천히 디스크에 플러시 서버가 크래시 나도, 디스크에 반영 안 된 더티 페이지 내용은 리두 로그를 적용해 복구할 수 있음 (일관성 보장)\nLRU 기반 페이지 교체 버퍼 풀 크기는 한정되어 있어, 새 페이지를 로드할 자리가 없으면 기존 페이지를 교체(Eviction)해야 함 InnoDB는 단순 LRU가 아닌, LRU 리스트를 \u0026ldquo;Young 영역\u0026quot;과 \u0026ldquo;Old 영역\u0026quot;으로 나누는 변형된 알고리즘을 사용함 (이는 Full Table Scan 같은 대용량 순차 스캔이 버퍼 풀의 \u0026lsquo;핫 데이터\u0026rsquo;를 밀어내는 상황을 방지하기 위함)\n핵심은 \u0026ldquo;최근에 자주 쓰인 페이지는 오래 남기고, 오래 안 쓰인 페이지부터 내보낸다\u0026quot;는 것\n읽기/쓰기 동작 흐름 읽기 경로 클라이언트가 특정 데이터 조회 요청 InnoDB가 해당 페이지가 버퍼 풀에 있는지 확인 있으면 (Cache Hit): 메모리에서 즉시 반환 (매우 빠름) 없으면 (Cache Miss): 디스크에서 페이지를 읽어와 버퍼 풀에 적재 후 반환 (느림) → 버퍼 풀 히트율(Hit Rate)이 높을수록 디스크 I/O가 줄어 성능이 좋아짐 쓰기 경로 애플리케이션이 데이터를 변경하면 버퍼 풀의 페이지에 먼저 반영 (→ 더티 페이지가 됨) 변경 내용이 리두 로그에 기록됨 커밋 시점: 리두 로그가 우선 디스크에 안전하게 기록됨 (애플리케이션 응답 완료) 더티 페이지 자체는 백그라운드 스레드(Page Cleaner)가 디스크로 천천히 내려 보냄 (체크포인트 관리) 이 구조 덕분에 쓰기 트랜잭션이 많아도 애플리케이션은 비교적 빠르게 커밋 응답을 받을 수 있음\n버퍼 풀 크기 설정 기본 원칙 innodb_buffer_pool_size 값은 전체 RAM, 워크로드 특성, 같은 서버에서 돌아가는 다른 프로세스를 모두 고려해서 잡아야 함 전형적인 전용 DB 서버 기준, 러프하게 전체 메모리의 50%~75% 정도를 할당함\n스왑(Swap)은 절대 금물 버퍼 풀 크기를 욕심내서 크게 잡았다가 OS 스왑이 발생하면, 메모리가 디스크처럼 동작하게 되어 성능이 급격히 나빠짐 \u0026ldquo;버퍼 풀 히트율 조금 더 높이기\u0026quot;보다 \u0026ldquo;절대 스왑 안 나게 하기\u0026quot;를 우선하는 게 안전함\n버퍼 풀 인스턴스 대용량 버퍼 풀(수십 GB 이상)일 경우, innodb_buffer_pool_instances를 조정하여 버퍼 풀을 여러 인스턴스로 나누면 락 경합을 줄여 동시성 향상에 도움이 될 수 있음\n모니터링 지표와 튜닝 버퍼 풀 히트율 높은 히트율(예: 99% 이상)은 디스크 I/O가 적다는 뜻 SHOW ENGINE INNODB STATUS로 확인 가능함 워크로드 자체가 디스크를 많이 타는지, 읽기 패턴이 어떤지 같이 봐야 함\n더티 페이지 비율 더티 페이지가 너무 많이 쌓이면(예: innodb_max_dirty_pages_pct), 플러시 작업이 몰려서 디스크가 갑자기 바빠지고 응답 지연이 발생할 수 있음 innodb_io_capacity 등을 조절해 더티 페이지가 적정 수준에서 꾸준히 플러시되도록 유도해야 함\n정리 버퍼 풀은 읽기(캐싱)와 쓰기(지연/배치) 성능을 모두 책임지는 InnoDB의 핵심임 운영 시에는 스왑이 나지 않는 보수적인 크기에서 시작하고, 모니터링 지표(히트율, 더티 페이지, 플러시 지연)를 근거로 점진적으로 조정하는 접근이 안전함\nMySQL 5.7, 8.0에서는 innodb_buffer_pool_size를 온라인(동적)으로 조정 가능함 서비스 중단 없이 부하 패턴 변화에 맞춰 버퍼 풀 크기를 늘리거나 줄일 수 있음\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size ","permalink":"https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003eInnoDB 버퍼 풀은 데이터와 인덱스 페이지를 \u003cstrong\u003e메모리에 캐싱\u003c/strong\u003e하는 영역임\n디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임\nInnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 \u003cstrong\u003e심장부\u003c/strong\u003e라 할 수 있음\u003c/p\u003e\n\u003cp\u003e쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"버퍼-풀-구성-요소\"\u003e버퍼 풀 구성 요소\u003c/h2\u003e\n\u003cp\u003e버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 페이지\u003c/strong\u003e: 실제 테이블 로우(Row)가 저장된 페이지\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인덱스 페이지\u003c/strong\u003e: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기타 관리 페이지\u003c/strong\u003e: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-개념\"\u003e핵심 개념\u003c/h2\u003e\n\u003ch3 id=\"페이지-캐싱\"\u003e페이지 캐싱\u003c/h3\u003e\n\u003cp\u003eInnoDB는 디스크 데이터를 페이지 단위로 다룸\n클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 \u003cstrong\u003e페이지 전체\u003c/strong\u003e를 버퍼 풀로 가져옴\n이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함\u003c/p\u003e","title":"MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드"},{"content":"개요 @nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임 DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함 핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임\nApiProperty 개념과 사용 @ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임 타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공 코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함\n간단 사용 예시\nclass CreateUserDto { @ApiProperty({ description: \u0026#34;사용자 이름\u0026#34;, example: \u0026#34;John Doe\u0026#34; }) name: string; } 이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨\n주요 옵션 필요한 만큼만 설정해 최소 문서화로 시작하고 점진적으로 보강하는 방식 권장\ndescription: 속성 의미 설명 example: 대표 예시 값 required: 필수 여부, 기본값 true type: 복잡 타입 또는 명시가 필요한 경우 사용 enum: 허용 값 집합 지정 isArray: 배열 여부 명시 옵션 스니펫\n@ApiProperty({ description: \u0026#39;사용자 나이\u0026#39;, example: 30, type: Number }) age: number @ApiProperty({ enum: [\u0026#39;admin\u0026#39;, \u0026#39;user\u0026#39;] }) role: string @ApiProperty({ type: String, isArray: true }) tags: string[] required는 별도 지정 없으면 true로 처리됨 PartialType을 통해 생성된 DTO에서는 해당 필드들이 선택적이 되어 Swagger에도 반영됨\n배열과 중첩 객체 배열 표시\n@ApiProperty({ type: String, isArray: true, description: \u0026#39;태그 목록\u0026#39; }) tags: string[] 중첩 객체 표시\nclass AddressDto { @ApiProperty() street: string; @ApiProperty() city: string; } class CreateUserDto { @ApiProperty({ type: AddressDto }) address: AddressDto; } Swagger UI에서는 정의한 타입을 따라 객체 구조와 예시가 노출됨\nPickType 개념과 사용 PickType은 기존 DTO에서 특정 속성만 선택해 새로운 DTO 생성하는 유틸리티임 중복 정의 없이 필요한 필드만 가져와 입력이나 응답 모델을 재사용 가능 Swagger 스키마도 선택된 필드만 반영됨\n기본 사용 예시\nclass CreateUserDto { username: string; password: string; email: string; } class LoginDto extends PickType(CreateUserDto, [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]) {} 활용 포인트\n코드 재사용성 향상 및 중복 제거 입력 모델과 응답 모델을 상황에 맞춰 최소 단위로 분리 가능 스키마가 원본 DTO 변경을 자동 추적해 일관성 유지 관련 유틸리티 OmitType: 특정 속성만 제외하고 나머지로 새 DTO 생성 class PublicUserDto extends OmitType(CreateUserDto, [\u0026#34;password\u0026#34;]) {} PartialType: 모든 속성을 선택적으로 변경해 부분 업데이트 시 유용 class UpdateUserDto extends PartialType(CreateUserDto) {} 조합 사용 시 공통 DTO 하나를 기준으로 입력, 응답, 수정 등 다양한 변형 모델을 일관되게 관리 가능\n팁 타입 추론에 의존해 단순 필드는 최소 정의, 설명과 예시가 필요한 필드에만 @ApiProperty 부여 복잡 타입이나 배열, enum은 type, isArray, enum으로 명시적 선언 권장 응답 모델에서 노출되면 안 되는 필드는 OmitType으로 사전에 제거 부분 업데이트 API는 PartialType 기반 DTO로 required 플래그 자동 조정 유도 문서 신뢰성을 위해 예시 값 example은 실제 도메인 형식과 일치하도록 유지 마무리 @ApiProperty로 DTO 속성 단위 문서화를 정교하게 관리하고, PickType OmitType PartialType으로 DTO 재사용성을 극대화하는 전략 권장 코드와 문서의 단일 소스화를 통해 API 스펙의 정확성, 추적 가능성, 유지보수성을 동시에 확보 가능\n참고자료 https://docs.nestjs.com/openapi/introduction https://github.com/nestjs/swagger https://swagger.io/specification/ ","permalink":"https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임\nDTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함\n핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임\u003c/p\u003e\n\u003ch3 id=\"apiproperty-개념과-사용\"\u003eApiProperty 개념과 사용\u003c/h3\u003e\n\u003cp\u003e@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임\n타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공\n코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함\u003c/p\u003e\n\u003cp\u003e간단 사용 예시\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCreateUserDto\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003e@ApiProperty\u003c/span\u003e({ \u003cspan style=\"color:#a6e22e\"\u003edescription\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;사용자 이름\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eexample\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;John Doe\u0026#34;\u003c/span\u003e })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨\u003c/p\u003e","title":"NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법"},{"content":"개요 Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함 skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함\n핵심 동작 cursor는 그 지점부터 시작 await prisma.user.findMany({ cursor: { id: 100 }, take: 5, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: 100부터 시작해 5개 반환 skip: 1은 cursor에 해당하는 레코드를 건너뜀 await prisma.user.findMany({ cursor: { id: 100 }, skip: 1, take: 5, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: 101부터 5개 반환 예시로 보는 차이 데이터가 아래와 같다고 가정\n98, 99, 100, 101, 102, 103, 104, 105, 106, 107\nskip 없이 cursor: { id: 100 }, take: 3, orderBy: { id: \u0026#39;asc\u0026#39; } // 결과: [100, 101, 102] skip: 1과 함께 cursor: { id: 100 }, skip: 1, take: 3, orderBy: { id: \u0026#39;asc\u0026#39; } // 결과: [101, 102, 103] 왜 skip: 1을 쓰는가 페이지 간 중복 방지 목적\n// 첫 페이지 const page1 = await prisma.user.findMany({ take: 3, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: [98, 99, 100] // nextCursor = 100 // 다음 페이지 const page2 = await prisma.user.findMany({ cursor: { id: 100 }, skip: 1, take: 3, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: [101, 102, 103] 중복 없음 코드 패턴 요약 더보기 여부 판단을 위해 take를 limit + 1로 지정하는 패턴 권장 nextCursor는 반환 목록의 마지막 id 사용 const data = await prisma.user.findMany({ take: limit + 1, ...(cursor \u0026amp;\u0026amp; { cursor: { id: cursor }, skip: 1 }), orderBy: { id: \u0026#34;asc\u0026#34; }, }); const hasMore = data.length \u0026gt; limit; const items = hasMore ? data.slice(0, -1) : data; const nextCursor = items.length ? items[items.length - 1].id : null; return { data: items, hasMore, nextCursor }; 내부 처리 관점 사용자 질문 요지: take: 501, skip: 1, cursor: { id: 1 }이라면 실제로 1부터 502까지 502개의 로우를 확인하는가\n인덱스 관점에서 맞음 일반적인 실행 흐름 인덱스 탐색으로 id = 1 위치 도달 그 항목은 skip으로 제외 이후 연속된 501개 항목을 읽어 반환 결과적으로 인덱스 레벨에서 502개 항목을 방문하는 효과가 발생 클라이언트로 반환되는 레코드 수는 501개 SQL 관점 설명 Prisma의 cursor 기반 페이지네이션은 보통 OFFSET을 쓰지 않고 정렬 컬럼 기준 범위 조건으로 변환됨 단일 정렬 키 id 기준 오름차순의 경우 개념적으로 아래와 유사한 형태\nSELECT ... FROM user_nickname_log WHERE id \u0026gt; 1 -- cursor: { id: 1 }, skip: 1일 때의 개념적 조건 ORDER BY id ASC LIMIT 501 -- take만큼 제한 skip: 1 없이 cursor만 쓰면 WHERE id \u0026gt;= 1에 가까운 조건으로 해석됨 skip: 1을 붙이면 WHERE id \u0026gt; 1로 바뀌는 효과가 나서 중복 제거 실제 생성 SQL과 실행 계획은 데이터베이스와 드라이버, 정렬 키 구성에 따라 다를 수 있음 핵심은 OFFSET으로 앞 페이지를 건너뛰지 않고 인덱스 범위 스캔으로 이어가기 때문에 커서 기반 페이지네이션의 성능 특성이 보장된다는 점임\n정리 cursor는 기준 레코드 지점부터 시작 skip: 1은 기준 레코드를 제외해 중복 제거 limit + 1 패턴으로 hasMore를 안정적으로 판정 인덱스 관점에서 cursor 레코드 포함 총 502개 항목을 방문하고 501개만 반환하는 해석 가능 Prisma는 일반적으로 WHERE 범위 조건과 LIMIT을 활용해 cursor 기반 페이지네이션을 수행하며 OFFSET 기반 페이지네이션과 다름 현재와 같은 구현은 동작 의도와 성능 측면 모두에서 타당함\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/pagination https://www.prisma.io/docs/orm/prisma-client/queries/pagination#cursor-based-pagination ","permalink":"https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003ePrisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함\nskip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함\u003c/p\u003e\n\u003ch3 id=\"핵심-동작\"\u003e핵심 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ecursor는 그 지점부터 시작\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindMany\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecursor\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e100\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003etake\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eorderBy\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;asc\u0026#34;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 결과: 100부터 시작해 5개 반환\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eskip: 1은 cursor에 해당하는 레코드를 건너뜀\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindMany\u003c/span\u003e({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003ecursor\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e100\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eskip\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e1\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003etake\u003c/span\u003e: \u003cspan style=\"color:#66d9ef\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eorderBy\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e { \u003cspan style=\"color:#a6e22e\"\u003eid\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;asc\u0026#34;\u003c/span\u003e },\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 결과: 101부터 5개 반환\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"예시로-보는-차이\"\u003e예시로 보는 차이\u003c/h3\u003e\n\u003cp\u003e데이터가 아래와 같다고 가정\u003c/p\u003e","title":"Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미"},{"content":"개요 Prisma의 findMany는 다중 레코드 조회용 메서드 기본값은 대상 모델의 모든 레코드 반환 where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원 옵션 조합으로 조건 기반 조회를 간결하게 구성 가능\n기본 사용법 가장 단순한 호출 형태\nconst users = await prisma.user.findMany(); 주요 옵션 옵션은 필요한 것만 선택적으로 사용\nwhere: 조건 필터링 select: 필드 서브셋 선택 include: 관계 데이터 로드 orderBy: 정렬 기준 지정 skip, take: 오프셋 기반 페이징 distinct: 특정 필드 기준 중복 제거 where로 조건 필터링 단일 조건부터 복합 조건까지 표현 가능\nconst active = await prisma.user.findMany({ where: { isActive: true }, }); in 조건 지정한 값 배열 중 하나와 일치하는 레코드 매칭\nconst some = await prisma.user.findMany({ where: { id: { in: [1, 2, 3] } }, }); 비교 연산자 숫자, 날짜, 문자열 등 비교 지원\nequals, not lt, lte, gt, gte in, notIn const range = await prisma.user.findMany({ where: { age: { gte: 18, lte: 30 } }, }); 복합 논리 연산 AND, OR 조합으로 다중 조건 구성\nconst mixed = await prisma.user.findMany({ where: { OR: [{ age: { lt: 18 } }, { role: \u0026#34;admin\u0026#34; }], }, }); in과 비교 연산자 결합으로 범위와 집합 조건을 동시에 표현 가능\nconst filtered = await prisma.user.findMany({ where: { id: { in: [1, 2, 3, 4, 5] }, age: { gt: 20 }, }, }); select로 필요한 필드만 조회 응답 페이로드 최소화에 유용\nconst names = await prisma.user.findMany({ select: { name: true, email: true }, }); 주의사항: 같은 호출에서 select와 include를 동시에 사용 불가, 하나만 선택\ninclude로 관계 데이터 로드 연관 모델을 함께 가져오기\nconst withPosts = await prisma.user.findMany({ include: { posts: true }, }); 필요한 필드만 부분 선택하려면 include 내부 select 사용\nconst withTitles = await prisma.user.findMany({ include: { posts: { select: { title: true } }, }, }); orderBy로 정렬 단일 또는 다중 필드 정렬 지원\nconst recent = await prisma.user.findMany({ orderBy: { createdAt: \u0026#34;desc\u0026#34; }, }); 여러 필드 정렬은 배열로 순서 지정 가능\nskip, take로 페이징 오프셋 기반 페이지네이션 구성\nconst page = await prisma.user.findMany({ skip: 10, take: 5, }); 대용량 페이지 이동 시 skip 비용 증가 가능성 존재, 일관성 보장을 위해 cursor 기반 페이징 고려 권장\nconst next = await prisma.user.findMany({ cursor: { id: lastId }, skip: 1, take: 10, orderBy: { id: \u0026#34;asc\u0026#34; }, }); distinct로 중복 제거 지정한 스칼라 필드 조합 기준으로 중복 제거\nconst uniqNames = await prisma.user.findMany({ distinct: [\u0026#34;name\u0026#34;], }); 데이터베이스와 드라이버 제약에 따라 지원 범위가 다를 수 있으므로 최신 문서 확인 권장\n예시 조합 조건 필터 + 필드 선택 + 관계 일부 선택 + 정렬 + 제한 개수 조합\nconst result = await prisma.user.findMany({ where: { isActive: true, age: { gte: 18 } }, select: { name: true, email: true, posts: { select: { title: true } }, }, orderBy: { createdAt: \u0026#34;desc\u0026#34; }, take: 10, }); 주의와 베스트 프랙티스 select와 include는 같은 호출에서 동시 사용 불가 정렬 없이 take만 사용 시 결과 순서 비결정적일 수 있음, orderBy 동반 사용 권장 오프셋 페이징(skip)은 페이지 번호가 커질수록 비용 증가 가능, 커서 기반 페이징 고려 where로 불필요한 데이터 전송 최소화, 필요한 필드만 select로 제한 distinct는 스칼라 필드 기준 사용 권장, 모델 및 드라이버 호환성 확인 정리 findMany는 다중 레코드 조회의 기본 도구 where로 정밀 필터링, select/include로 응답 축소 또는 관계 로드, orderBy와 skip·take로 정렬과 페이징 제어, distinct로 중복 제거 가능 in과 비교 연산자, AND·OR 조합으로 실제 요구사항을 간결하게 표현 가능 커서 기반 페이징과 필드 최소화로 성능과 안정성 확보 권장\n참고자료 https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany https://www.prisma.io/docs/orm/prisma-client/queries/filters https://www.prisma.io/docs/orm/prisma-client/queries/pagination ","permalink":"https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003ePrisma의 findMany는 다중 레코드 조회용 메서드\n기본값은 대상 모델의 모든 레코드 반환\nwhere 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원\n옵션 조합으로 조건 기반 조회를 간결하게 구성 가능\u003c/p\u003e\n\u003ch3 id=\"기본-사용법\"\u003e기본 사용법\u003c/h3\u003e\n\u003cp\u003e가장 단순한 호출 형태\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eusers\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprisma\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003euser\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003efindMany\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"주요-옵션\"\u003e주요 옵션\u003c/h3\u003e\n\u003cp\u003e옵션은 필요한 것만 선택적으로 사용\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhere: 조건 필터링\u003c/li\u003e\n\u003cli\u003eselect: 필드 서브셋 선택\u003c/li\u003e\n\u003cli\u003einclude: 관계 데이터 로드\u003c/li\u003e\n\u003cli\u003eorderBy: 정렬 기준 지정\u003c/li\u003e\n\u003cli\u003eskip, take: 오프셋 기반 페이징\u003c/li\u003e\n\u003cli\u003edistinct: 특정 필드 기준 중복 제거\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"where로-조건-필터링\"\u003ewhere로 조건 필터링\u003c/h3\u003e\n\u003cp\u003e단일 조건부터 복합 조건까지 표현 가능\u003c/p\u003e","title":"Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자"},{"content":"개요 JavaScript에서 함수는 일급 객체로 취급됨 이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함 이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨\n핵심 개념 변수에 할당 가능 다른 함수의 인수로 전달 가능 다른 함수의 반환값으로 사용 가능 객체의 프로퍼티로 저장 가능 간단 예시 변수에 할당\nconst greet = (name) =\u0026gt; `Hello, ${name}`; 인수로 전달\nconst run = (fn, v) =\u0026gt; fn(v); run(greet, \u0026#34;Bob\u0026#34;); 반환값으로 사용 및 클로저\nconst mul = (m) =\u0026gt; (v) =\u0026gt; v * m; mul(2)(5); 객체 프로퍼티로 저장해 메서드 구성\nconst obj = { name: \u0026#34;Charlie\u0026#34;, greet() { return `Hi, I\u0026#39;m ${this.name}`; }, }; obj.greet(); 동작 원리 함수는 객체로 구현되어 프로퍼티와 메서드 보유함(Function.prototype의 call, apply, bind 등) 함수 식과 선언 모두 값으로 평가되어 식 컨텍스트에서 자유롭게 이동 가능함 반환 함수가 외부 스코프 변수를 캡처하면 클로저 형성됨 참조가 값으로 전달되므로 동일 함수 객체를 여러 곳에서 공유 가능함\n이점 함수를 값으로 다뤄 조합성과 재사용성 향상\n고차 함수로 로직을 파라미터화하여 정책 주입 용이 콜백으로 비동기 흐름 연결 및 이벤트 처리 단순화 클로저로 상태 은닉 및 부분 적용 구현 용이 합성으로 작은 함수를 결합해 파이프라인 구성 가능 주의 사항 this 바인딩은 호출 방식에 의존함, 메서드를 분리해 호출 시 this가 바뀔 수 있으므로 bind 등으로 명시적 바인딩 권장 클로저가 불필요한 대상을 오래 참조하면 메모리 유지 발생 가능, 긴 생명주기 객체 참조 최소화 필요 콜백 중첩은 가독성 저하 유발, Promise와 async/await로 흐름 평탄화 권장\n마무리 JavaScript 함수의 일급 객체 성질은 함수형 스타일을 실용적으로 적용하게 하는 기반임 값처럼 전달하고 반환하는 패턴을 표준화해두면 모듈 경계가 명확해지고 테스트 용이성이 개선됨 핵심은 함수를 데이터처럼 다루되 컨텍스트(this)와 수명주기 관리에 신경 쓰는 것임\n참고자료 https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind ","permalink":"https://blog.jsontapose.com/posts/javascript-first-class-functions-5dcc7e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eJavaScript에서 함수는 일급 객체로 취급됨\n이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함\n이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e변수에 할당 가능\u003c/li\u003e\n\u003cli\u003e다른 함수의 인수로 전달 가능\u003c/li\u003e\n\u003cli\u003e다른 함수의 반환값으로 사용 가능\u003c/li\u003e\n\u003cli\u003e객체의 프로퍼티로 저장 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e변수에 할당\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egreet\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#e6db74\"\u003e`Hello, \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e${\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e`\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e인수로 전달\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erun\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e) =\u0026gt; \u003cspan style=\"color:#a6e22e\"\u003efn\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003erun\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003egreet\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e반환값으로 사용 및 클로저\u003c/p\u003e","title":"JavaScript 함수는 왜 일급 객체인가 — 의미와 활용"},{"content":"개념과 배경 InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임 대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함 사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함 이때 결정 규칙이 존재함\n먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용 그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용 세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함 따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함\n핵심 개념 정리 클러스터형 인덱스 테이블의 물리적 정렬 기준이 되는 인덱스 PK 또는 그에 준하는 키가 담당 명시적 PK 부재 시 동작 NOT NULL 유니크 인덱스가 있으면 해당 인덱스를 클러스터 키로 채택 없으면 6바이트 숨김 row_id 생성 후 클러스터 키로 사용 세컨더리 인덱스 리프에 클러스터 키 값을 포함하여 최종 레코드에 도달하는 구조 FK 제약 참조 대상은 PK 또는 유니크 키가 필요 숨김 row_id는 외부에서 참조 불가 장점 설계 유연성 확보 로우의 고유 식별을 강제하지 않음 중복 허용 설계 가능 로그나 임시 적재 같은 일회성 데이터에 적합 스키마 선언 단순화 별도 PK 칼럼을 정의 관리하지 않음 내부적으로는 InnoDB가 식별자를 보유하므로 개발자는 이를 의식하지 않아도 됨 내부 식별 자동 관리 내부 row_id로 일관된 클러스터링 확보 별도의 AUTO_INCREMENT 칼럼을 두지 않아도 되는 선택지 존재 단점 클러스터링 효율 저하 가능성 워크로드가 특정 칼럼 기준 범위 조회 중심인 경우 해당 칼럼을 PK로 잡을 때보다 페이지 지역성과 스캔 효율이 떨어질 수 있음 숨김 row_id 기준 정렬은 업무 키와 무관하므로 의도한 액세스 패턴과 불일치 무결성 및 중복 제어 부재 PK나 유니크 키가 없으면 동일 데이터의 다중 삽입을 제약하기 어려움 중복 제거와 정합성 보장이 애플리케이션 책임으로 이동 FK 사용 제약 FK는 참조 대상이 PK 또는 유니크 키여야 함 숨김 row_id는 외부에서 참조할 수 없어 실질적으로 FK 기반 관계형 모델 구성 난이도 상승 운영 관리와 확장성 저하 대용량 환경에서 주 식별자 부재는 트러블슈팅과 튜닝 지점을 모호하게 만듦 인덱스를 다수 추가해도 클러스터 키가 워크로드와 맞지 않으면 성능 이득이 제한적일 수 있음 예측 불가능성 증가 숨김 row_id는 사용자 가시성과 제어가 없어 클러스터링 순서나 재배치 영향 분석이 어려움 언제 PK 생략을 고려할 수 있는가 로그 수집과 임시 적재처럼 개별 로우 식별이 비핵심이고 중복 허용 전제가 있는 경우 FK를 사용하지 않고 일회성 처리 후 주기적 파티션 드롭이나 벌크 삭제로 관리하는 테이블 접근 패턴이 대부분 단순 삽입과 기간 기반 일괄 삭제이며 조회가 제한적인 워크로드 이 경우에도 최소한의 제약을 두는 편이 안전함\n업무적으로 유일해야 하는 칼럼 조합에는 유니크 인덱스 부여 권장 파티션 키 또는 보존 기간 기준의 관리 전략을 명확히 문서화 조회가 늘거나 관계가 필요해질 가능성에 대비해 스키마 변경 경로를 마련 실무 권장 사항과 트레이드오프 OLTP 워크로드 기준 기본값은 명시적 PK 부여 단조 증가 surrogate key를 PK로 채택해 클러스터 페이지 분할 비용을 낮추는 전략 선호 명시적 PK는 다음 이점을 제공 클러스터 인덱스가 워크로드 접근 패턴을 반영하도록 설계 가능 세컨더리 인덱스의 참조 대상이 명확해 룩업 비용 예측 용이 FK 구성과 무결성 보장 단순화 PK 생략은 스키마와 코드가 단순해 보이지만 운영 단계에서 성능 최적화와 무결성 확보 비용이 커질 수 있음 정리 InnoDB는 항상 클러스터형 인덱스를 필요로 함 명시적 PK가 없으면 NOT NULL 유니크 키를 우선 사용하고 그마저 없으면 6바이트 숨김 row_id를 생성해 대체함 PK 없이 인덱스만 두는 설계는 특수 목적에서만 고려 로그와 임시 저장 등 중복 허용과 낮은 정합성 요구의 시나리오에 한정하는 편이 안전 일반적인 OLTP 환경에서는 명시적 PK가 사실상 필수 무결성 보장과 쿼리 최적화, FK 구성, 예측 가능한 성능 튜닝 측면에서 이점이 큼 결론적으로 PK를 두지 않는 선택은 예외적 상황으로 제한하고 대부분의 테이블에는 업무 맥락에 맞는 명시적 PK를 설계하는 것이 바람직함 참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/innodb-primary-key.html https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html ","permalink":"https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/","summary":"\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eInnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임\n대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함\n사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함\n이때 결정 규칙이 존재함\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용\u003c/li\u003e\n\u003cli\u003e그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함\n따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함\u003c/p\u003e","title":"InnoDB에서 PK 없는 테이블의 동작과 트레이드오프"},{"content":"개요 Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함\n문제를 명확히 하기 작성한 코드의 기대 동작 정의 실제 관측된 동작과의 차이 정리 실패 조건과 재현 절차 고정 문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음\n다양한 가정과 빠른 배제 API를 올바른 개체와 메서드로 사용했는지 확인 오타, 잘못된 인수 순서, 잘못된 기본값 사용 여부 점검 코드 변경 이력이 해당 증상과 인과관계 있는지 검증 실제 값과 다른 상수를 가정해 추론하지 않았는지 점검 타인이 작성한 코드라면 의도와 계약을 먼저 파악 작게 만들고 자주 실행하는 전략 권장. 최소 동작 코어를 먼저 통과시키고, 점진적으로 수정·확장하며 각 단계에서 실패를 국소화함\n디버거 기본 개념 Breakpoint 중단점. 실행을 특정 라인에서 멈춤. 코드에 debugger 구문을 넣거나 에디터에서 라인 왼쪽 클릭 등으로 설정\nWatch 특정 변수나 표현식 값을 지속 관찰. 값 변화와 조건 만족 시점을 빠르게 확인하는 용도\n예시\nfunction fibonacci(n) { if (n \u0026lt; 2) return n; const result = fibonacci(n - 1) + fibonacci(n - 2); return result; } watch에 result === 5 추가 시 false에서 true로 전환되는 시점을 즉시 파악 가능\nCall Stack 현재 호출 중인 함수 스택 추적. 어디에서 무엇이 호출되었는지 역추적 가능\nStep controls\nContinue 다음 중단점까지 진행 Step over 현재 라인 실행, 함수 내부는 건너뜀 Step into 함수 내부로 진입, 라인 단위 실행 Step out 현재 함수 나머지를 실행하고 리턴 지점에서 멈춤 Chrome DevTools로 Node.js 디버깅 Node 8부터 V8 Inspector를 정식 지원. 기존 \u0026ndash;debug 플래그는 폐기되고 \u0026ndash;inspect 계열로 통일됨. 가장 간단한 진입 방법은 다음과 같음\n초기 진입\nnode \u0026ndash;inspect app.js 실행 처음 라인부터 멈추려면 node \u0026ndash;inspect-brk app.js 사용 실행 로그 예시\nDebugger listening on ws://127.0.0.1:9229/... For help, see: https://nodejs.org/en/docs/inspector Chrome 접속\n주소창에 chrome://inspect 입력 후 Devices 화면으로 이동 Remote Target에서 실행 중인 Node 프로세스를 선택해 inspect 진입 유의사항\n기본 디버그 포트는 9229. 충돌 시 \u0026ndash;inspect=127.0.0.1:0 같은 동적 포트를 사용해 충돌 회피 외부 접근이 가능한 호스트로 열지 않기. 로컬 호스트 바인딩 유지 권장 node-inspect CLI 사용 터미널 기반 디버깅이 필요하면 내장 CLI 디버거 사용\n진입\nnode inspect 파일명 기본 명령\ncont 또는 c 계속 실행 next 또는 n 다음 라인으로 이동 step 또는 s 함수 내부로 진입 out 또는 o 현재 함수에서 빠져나옴 run 또는 restart 재실행 repl 현 위치 컨텍스트에서 표현식 평가 임시 중단점\n코드에 debugger 구문 삽입 후 cont로 진행하면 해당 지점에서 중단 CLI는 GUI 없이도 재현 자동화 스크립트나 원격 SSH 환경에서 빠르게 상태를 확인하기에 유용함\nVS Code에서 디버깅 VS Code는 Node 디버거를 기본 통합 제공. 대부분은 실행 메뉴에서 F5로 시작 가능\n첫 실행\n실행 \u0026gt; 디버깅 시작 또는 F5 선택 launch.json이 없으면 환경 선택 팝업에서 Node.js 선택 launch.json 역할\n실행 파일, 인자, 환경 변수, 작업 디렉터리, 포트 등 디버깅 구성을 선언적으로 관리 팀 단위로 동일한 재현 절차를 공유하는 데 유용 최소 설정 예시\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Launch Program\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/app.js\u0026#34; } ] } 단축키\n계속 또는 일시중지 F5 단위 실행 F10 단계 진입 F11 단계 빠져나오기 Shift+F11 다시 시작 Ctrl+Shift+F5 중지 Shift+F5 실전 팁과 주의사항 프로덕션에서 \u0026ndash;inspect 노출 금지. 로컬 또는 제한된 네트워크에서만 사용 포트 고정이 필요 없으면 \u0026ndash;inspect=127.0.0.1:0로 충돌 회피 debugger 구문과 남은 중단점은 커밋 전에 제거 또는 비활성화 비동기 흐름 디버깅 시 콜 스택에서 프레임을 좁히고, 필요 시 로그와 디버거를 병행하여 원인 단정 재현이 어려운 케이스는 입력과 환경을 고정하고 최소 재현 코드를 별도 파일로 분리해 분석 마무리 디버깅의 핵심은 문제를 작게 만들고 실행 흐름과 상태를 검증 가능한 근거로 좁혀가는 것임. Node.js에서는 Chrome DevTools, node-inspect, VS Code 세 가지 축만 숙지해도 대부분의 서버 사이드 이슈를 빠르고 안전하게 추적 가능함. 도구는 상황에 맞게 고르되, 재현성 확보와 가설 검증 루프를 짧게 유지하는 것이 성패를 가름함\n참고자료 https://nodejs.org/en/learn/getting-started/debugging https://nodejs.org/api/inspector.html https://developer.chrome.com/docs/devtools/javascript/watch-variables/ https://code.visualstudio.com/docs/nodejs/nodejs-debugging ","permalink":"https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함\u003c/p\u003e\n\u003ch3 id=\"문제를-명확히-하기\"\u003e문제를 명확히 하기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e작성한 코드의 기대 동작 정의\u003c/li\u003e\n\u003cli\u003e실제 관측된 동작과의 차이 정리\u003c/li\u003e\n\u003cli\u003e실패 조건과 재현 절차 고정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음\u003c/p\u003e","title":"Node.js 환경에서 디버깅하기"},{"content":"개요 TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임 각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음\nenum 개념과 동작 열거형 타입을 선언하는 문법 숫자 기반과 문자열 기반 모두 지원 컴파일 결과로 양방향 매핑을 담은 JS 객체 생성 키로 값 조회, 값으로 키 역조회 가능 예시\nenum BooleanType { False = 0, True = 1, } 컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨\nvar BooleanType = { 0: \u0026#34;False\u0026#34;, 1: \u0026#34;True\u0026#34;, False: 0, True: 1 }; 주의점\n멤버 이름에 숫자 이름 사용 불가 예) enum X { 1: \u0026lsquo;A\u0026rsquo; } 에러 발생 멤버 종류 Constant Member: 고정 상수값 보유 Computed Member: 표현식 평가 결과를 값으로 가짐 값 타입별 종류 Numeric enum String enum Heterogeneous enum (숫자와 문자열 혼합 사용, 특별한 이유 없으면 지양) 자동 할당 첫 멤버 미초기화 시 0부터 시작 이전 멤버가 숫자 상수면 다음 미초기화 멤버는 이전값 + 1 할당 enum Direction { Up, // 0 Down, // 1 Left, // 2 Right, // 3 } 장점 의도 표현력 높음, 양방향 매핑으로 상수 집합을 하나의 식별자로 추상화 가능 정의된 값만 사용하도록 강제 가능, 오입력 방지에 유리 단점 컴파일된 JS 코드가 객체와 초기화 로직을 포함하여 번들 크기 증가 IIFE로 생성되는 사이드이펙트 때문에 일반적으로 트리 셰이킹에 취약 const enum enum의 코드 비용과 간접 참조 비용을 줄이는 목적의 변형 문법 핵심 특징\n멤버 접근 지점에 값이 인라인됨 컴파일 시 enum 구현체가 제거됨 Computed Member 금지, 상수 표현식만 허용 예시\nconst enum Direction { Up, Down, } const xs = [Direction.Up, Direction.Down]; 컴파일 결과에서 배열 리터럴에 숫자 값이 직접 인라인됨\n멤버는 문자열 리터럴 접근으로만 사용 가능하지 않은 방식은 에러 발생 장점\n실행 시 오브젝트 생성 비용 제거, 번들 크기 감소 가능 주의 및 함정\n빌드 파이프라인에서 트랜스파일러가 const enum 인라인을 보장하지 않으면 깨짐 예) 일부 Babel, isolatedModules 환경, 타입 정보 손실되는 트랜스파일 경로 등 라이브러리 경계 넘어 사용하는 경우 소비자 빌드 설정에 따라 오류 유발 가능 이유로 프로덕션 코드베이스에서 const enum 사용을 제한하거나 금지하는 팀이 많음 as const TypeScript 3.4의 const assertion 문법 목적\n값의 타입 추론 범위를 리터럴 단위로 좁히기 위한 선언적 방법 객체, 배열, 중첩 구조를 포함해 값 전반을 상수로 취급하게 함 핵심 효과\n문자열/숫자 값이 리터럴 타입으로 고정됨 객체 수준으로 사용 시 프로퍼티에 readonly 적용됨 간단 예시\nconst s = \u0026#34;NLP\u0026#34; as const; // 타입이 \u0026#39;NLP\u0026#39;로 고정 const obj = { a: 1, b: \u0026#34;x\u0026#34; } as const; // obj.a: 1, obj.b: \u0026#39;x\u0026#39;, 모두 readonly let으로 선언한 값에도 as const를 붙이면 리터럴 타입으로 고정됨\n재할당 또는 변경 시 타입 오류 또는 readonly 위반으로 막힘 Discriminated Union과의 결합 조건 분기에서 안전하게 속성을 접근하려면 판별 가능한 유니온이 유용함\n공통 판별 키 kind 등으로 각 분기를 좁혀 타입 안전한 접근 보장 as const로 리터럴 값을 고정하면 판별 키가 확정되어 오류 제거에 도움 예시\ntype Shape = { kind: \u0026#34;circle\u0026#34;; radius: number } | { kind: \u0026#34;square\u0026#34;; x: number }; function area(s: Shape) { if (s.kind === \u0026#34;circle\u0026#34;) return Math.PI * s.radius * s.radius; return s.x * s.x; } 객체 리터럴 작성 시 kind 값을 as const로 고정하면 판별 정확도 향상\nconst enum 대체 패턴(as const 기반) const enum 없이도 값 집합을 타입으로 뽑아 쓰는 패턴\nconst BooleanType = { False: 0, True: 1 } as const; type BooleanTypeValue = (typeof BooleanType)[keyof typeof BooleanType]; // 0 | 1 특징\n런타임 객체는 단방향 매핑만 가짐 타입은 값 집합의 유니온으로 안전하게 반영됨 번들에 불필요한 초기화 함수 없음, 트리 셰이킹 친화적 enum처럼 값→키 역조회가 필요하면 별도 맵 구성 필요 선택 기준 이중 매핑 필요 여부가 1차 기준\n값↔키 양방향 매핑과 역조회가 유용한 도메인이면 enum 고려 매핑 방향이 단방향이고 값 집합을 타입으로만 활용하면 as const + 유니온 추출 권장 빌드 환경과 도구 호환성도 중요\nconst enum은 인라인이 보장되는 단일 tsc 파이프라인에서만 안정적 다양한 트랜스파일 단계나 라이브러리 경계를 넘는 경우 as const 대안이 안전 요약\nenum은 의도 표현과 역조회가 필요한 경우 적합하지만 번들 비용과 트리 셰이킹 한계 존재 const enum은 이론상 가장 가벼우나 빌드 파이프라인 제약과 함정으로 실무에서 채택 신중 필요 as const는 리터럴 타입 고정과 readonly 부여로 타입 안전성을 높이고, const enum의 주요 사용처를 무리 없이 대체함 마무리 양방향 매핑과 역조회가 반드시 필요하면 enum 선택 그 외 대부분의 상수 집합과 타입 추론 고정 요구에는 as const 기반 패턴 권장 const enum은 빌드 구성과 팀 규칙을 충분히 검토한 뒤 제한적으로 사용 권장\n참고자료 https://www.typescriptlang.org/docs/handbook/enums.html https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#const-assertions https://www.kabuku.co.jp/developers/good-bye-typescript-enum ","permalink":"https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임\n각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음\u003c/p\u003e\n\u003ch3 id=\"enum-개념과-동작\"\u003eenum 개념과 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e열거형 타입을 선언하는 문법\u003c/li\u003e\n\u003cli\u003e숫자 기반과 문자열 기반 모두 지원\u003c/li\u003e\n\u003cli\u003e컴파일 결과로 양방향 매핑을 담은 JS 객체 생성\n\u003cul\u003e\n\u003cli\u003e키로 값 조회, 값으로 키 역조회 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBooleanType\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eFalse\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#a6e22e\"\u003eTrue\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨\u003c/p\u003e","title":"TypeScript enum, const enum, as const 차이와 선택 기준"},{"content":"기본 문법 LIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문 WHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치\n두 가지 형태 사용\nSELECT 컬럼명 FROM 테이블명 LIMIT 개수 SELECT 컬럼명 FROM 테이블명 LIMIT 개수 OFFSET 시작_인덱스 일부 dialect에서는 아래 축약형도 존재\n-- MySQL, SQLite SELECT 컬럼명 FROM 테이블명 LIMIT 시작_인덱스, 개수 1. LIMIT 개수 LIMIT 뒤 숫자는 인덱스가 아닌 개수\nSELECT * FROM Book LIMIT 1 현재 정렬 기준에서 맨 위 행 1개만 반환 ORDER BY가 없으면 반환되는 행은 비결정적일 수 있음\n2. LIMIT 개수 OFFSET 시작 OFFSET은 0부터 시작 다음 예시는 4번째 행부터 1개 반환\nSELECT * FROM Book LIMIT 1 OFFSET 3 3. OFFSET 생략 문법 아래 형태는 시작 인덱스와 개수를 쉼표로 전달\n-- MySQL, SQLite 전용 SELECT * FROM Book LIMIT 1, 3 1번 인덱스부터 3개의 행 반환 PostgreSQL 등에서는 이 문법 미지원이므로 LIMIT 개수 OFFSET 시작 형태 사용\n주의 ORDER BY 없이 LIMIT만 사용하면 결과 순서 보장 안 됨 큰 OFFSET은 비용 증가 위험, 대량 페이징에서는 정렬 키 기반 커서 방식 고려 OFFSET은 0부터 시작, 오프바이원 실수 주의 참고자료 https://www.postgresql.org/docs/current/queries-limit.html https://dev.mysql.com/doc/refman/8.0/en/select.html https://www.sqlite.org/lang_select.html ","permalink":"https://blog.jsontapose.com/posts/sql-limit-offset-basics-4a9880/","summary":"\u003ch3 id=\"기본-문법\"\u003e기본 문법\u003c/h3\u003e\n\u003cp\u003eLIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문\nWHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치\u003c/p\u003e\n\u003cp\u003e두 가지 형태 사용\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e개수\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e개수\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eOFFSET\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e시작\u003c/span\u003e_인덱스\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e일부 dialect에서는 아래 축약형도 존재\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e-- MySQL, SQLite\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e시작\u003c/span\u003e_인덱스, \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e개수\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"1-limit-개수\"\u003e1. LIMIT 개수\u003c/h3\u003e\n\u003cp\u003eLIMIT 뒤 숫자는 인덱스가 아닌 개수\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e Book\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e현재 정렬 기준에서 맨 위 행 1개만 반환\nORDER BY가 없으면 반환되는 행은 비결정적일 수 있음\u003c/p\u003e","title":"SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징"},{"content":"개요 Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음 Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 \u0026ndash;debug는 폐기, \u0026ndash;inspect로 통일됨 CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함\n이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함\n핵심 개념 v8-inspector 프로토콜 V8이 노출하는 디버깅 프로토콜 Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조 \u0026ndash;inspect vs \u0026ndash;inspect-brk \u0026ndash;inspect는 바로 실행하면서 디버거 접속 대기 \u0026ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용 포트 기본 포트 9229 사용 \u0026ndash;inspect=PORT, \u0026ndash;inspect-brk=PORT 형태로 변경 가능 프론트엔드 Chromium 기반 개발자도구로 연결 가능 chrome://inspect 에서 Node 대상 탐색 및 연결 node-inspect Node 내장 CLI 디버거 동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행 크롬 개발자도구로 디버깅 Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정\n서버를 인스펙터 모드로 시작 node --inspect bin/www # Debugger listening on ws://127.0.0.1:9229/\u0026lt;uuid\u0026gt; # For help see https://nodejs.org/en/docs/inspector 브라우저에서 chrome://inspect 접속 Remote Target 목록에서 해당 Node 프로세스 확인 inspect 버튼으로 개발자도구 연결 디버깅 방법은 웹 프론트 디버깅과 동일 브레이크포인트 설정, 콜스택 확인, 스텝 인/아웃, 워치, 콘솔 활용 애플리케이션 시작 시점부터 멈추려면 \u0026ndash;inspect-brk 사용 node-inspect로 터미널 디버깅 GUI 없이도 빠르게 문제를 추적할 때 유용\n디버거 시작 node inspect bin/www # Debugger listening on ws://127.0.0.1:9229/\u0026lt;uuid\u0026gt; # Debugger attached # Break on start in bin/www:1 기본 명령 cont, c 계속 실행 next, n 다음 라인으로 이동 step, s 함수 내부로 진입 out, o 호출한 함수로 빠져나오기 run, restart 프로세스 재시작 repl 현재 컨텍스트에서 표현식 실행 브레이크포인트 팁 코드에 debugger 구문을 삽입해 명시적 중단점으로 사용 가능 간단 예시\ndebug\u0026gt; cont # ... debugger 구문에서 일시정지됨 debug\u0026gt; repl Press Ctrl + C to leave debug repl \u0026gt; console.log(app.settings) \u0026lt; { env: \u0026#39;development\u0026#39;, \u0026#39;view engine\u0026#39;: \u0026#39;jade\u0026#39;, ... } \u0026gt; undefined 경로 등 민감한 값은 출력 시 마스킹 권장\n포트와 연결 관리 기본 포트 9229 충돌 시 \u0026ndash;inspect=9230 처럼 변경 동일한 포트에 크롬 개발자도구 또는 node-inspect 중 하나만 독점 연결하지 않도록 유의 원격 서버에서 사용할 경우 네트워크에 디버그 포트를 그대로 노출하지 않음 신뢰 네트워크에서만 접속 허용 또는 포트포워딩, 터널링 사용 권장 운영 시 유의사항 \u0026ndash;inspect는 성능에 약간의 오버헤드가 있을 수 있음 프로덕션 상시 활성화는 지양, 재현 가능한 환경에서 일시적으로 활성화 권장 초기화 코드 이슈 추적은 \u0026ndash;inspect-brk가 더 안정적 디버깅 세션 중 프로세스가 재시작되면 연결이 끊기므로 재연결 필요 정리 Node.js의 디버깅은 v8-inspector를 중심으로 표준화되었음 \u0026ndash;inspect 또는 \u0026ndash;inspect-brk로 프로세스를 띄우고, 크롬 개발자도구나 node-inspect 중 선호 도구로 연결해 브레이크포인트와 스텝 실행, REPL까지 한 흐름으로 해결 가능함 개발 단계에서 빠르게 재현하고 추적하는 기본 루틴으로 정착시키면 콘솔 로그만으로 놓치는 분기와 타이밍 이슈를 줄일 수 있음\n참고자료 Node.js v8.0.0 Release Debugging Node.js Apps with the Inspector Node.js Debugger API node-inspect Repository Express 참고자료 https://nodejs.org/en/blog/release/v8.0.0/ https://nodejs.org/en/docs/inspector/ https://nodejs.org/api/debugger.html https://github.com/nodejs/node-inspect https://expressjs.com/ ","permalink":"https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음\nNode.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 \u0026ndash;debug는 폐기, \u0026ndash;inspect로 통일됨\nCLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함\u003c/p\u003e\n\u003cp\u003e이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ev8-inspector 프로토콜\n\u003cul\u003e\n\u003cli\u003eV8이 노출하는 디버깅 프로토콜\u003c/li\u003e\n\u003cli\u003eNode 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect vs \u0026ndash;inspect-brk\n\u003cul\u003e\n\u003cli\u003e\u0026ndash;inspect는 바로 실행하면서 디버거 접속 대기\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e포트\n\u003cul\u003e\n\u003cli\u003e기본 포트 9229 사용\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect=PORT, \u0026ndash;inspect-brk=PORT 형태로 변경 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e프론트엔드\n\u003cul\u003e\n\u003cli\u003eChromium 기반 개발자도구로 연결 가능\u003c/li\u003e\n\u003cli\u003echrome://inspect 에서 Node 대상 탐색 및 연결\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003enode-inspect\n\u003cul\u003e\n\u003cli\u003eNode 내장 CLI 디버거\u003c/li\u003e\n\u003cli\u003e동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"크롬-개발자도구로-디버깅\"\u003e크롬 개발자도구로 디버깅\u003c/h3\u003e\n\u003cp\u003eExpress 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정\u003c/p\u003e","title":"Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법"},{"content":"컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음 조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함\n개념과 정의 컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층 사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴\n핵심 구성요소 API 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영\nkubectl, 컨트롤러, 스케줄러 등 모든 클라이언트는 API 서버를 통해 상호작용\n예시\nkubectl get pods kubectl apply -f app.yaml etcd — 클러스터 상태를 저장하는 분산 키-값 저장소\n네임스페이스, 파드, 서비스, 컨피그맵 등 모든 리소스 스펙과 상태 저장 강한 일관성 기반으로 컨트롤 루프의 신뢰성에 핵심 역할 스케줄러 kube-scheduler — 새 파드를 어떤 노드에 배치할지 결정\n리소스 여유, 어피니티/안티어피니티, 톨러레이션, 노드 셀렉터 등을 고려해 최적 노드 선택 프리엠션과 스코어링으로 공정성과 효율성 균형 유지 컨트롤러 매니저 kube-controller-manager — 다양한 컨트롤러의 조정 루프 실행\n레플리카셋, 잡, 데몬셋, 노드, 엔드포인트 등 컨트롤러가 선언된 상태에 맞게 생성·삭제·수정 수행 핵심은 지속적 리컨실리에이션으로 상태 수렴 보장 동작 개요 사용자가 Desired State를 API로 제출 etcd에 영속화 스케줄러가 파드 배치 결정 컨트롤러들이 실제 상태를 감시하고 조정 워커 노드의 kubelet이 파드 실행과 헬스 리포팅 수행 이 흐름이 반복되며 장애나 변동에도 선언된 상태로 복귀하는 자기치유 성질을 구현함 EKS와 일반 k8s 차이 관리 관점\n일반 k8s — 컨트롤 플레인 노드 설치, etcd 운영과 백업 전략, 버전 업그레이드 플랜, 보안 패치, 모니터링, 다중 AZ 기반 HA를 직접 설계·운영해야 함 EKS — 컨트롤 플레인은 완전관리형으로 제공, 마스터 노드와 etcd는 사용자가 접근·관리하지 않음, 내부적으로 백업·복구와 패치·HA가 관리됨, 제어플레인 로그를 CloudWatch로 전송 가능 비용 구조\n일반 k8s — 컨트롤 플레인 인프라 비용, 운영 인력 비용, 백업 스토리지와 모니터링 도구 비용을 직접 산정 EKS — 클러스터당 제어플레인 사용료가 시간 단위 과금, 워커 노드는 EC2 등 사용량 기반, EBS·ELB 등 연동 리소스는 각각 과금 통합 기능\n일반 k8s — 로드밸런서 연동, 스토리지 프로비저닝, 인증·인가, 로깅/모니터링을 별도 구성 필요 EKS — AWS Load Balancer Controller로 ALB/NLB 연동, EBS/EFS CSI 드라이버 통합, IAM Roles for Service Accounts IRSA로 퍼미션 연계, Control Plane 로깅과 메트릭의 CloudWatch 통합 용이 네트워킹\n일반 k8s — CNI 선택·설치, 네트워크 정책 구현, 인그레스 컨트롤러 구성 필요 EKS — AWS VPC CNI 기본 제공으로 VPC 네이티브 IP 모델, Security Groups for Pods로 L3/L4 격리 가능, 표준 Kubernetes NetworkPolicy는 별도 구현체 필요 Calico 등, 인그레스는 AWS Load Balancer Controller 사용 권장 실제 사용 예시 클러스터 생성\n일반 k8s — 컨트롤 플레인 노드 준비, kubeadm init, etcd 구성, CNI 설치, 인증서와 RBAC 설정, HA면 컨트롤 플레인 복수 AZ 배치와 프런트 VIP 구성 필요\nEKS — 명령 몇 줄로 제어플레인과 매니지드 노드그룹 생성 가능\neksctl create cluster \\ --name my-cluster \\ --region ap-northeast-2 \\ --nodes 2 업그레이드\n일반 k8s — 사전 etcd 스냅샷, 컨트롤 플레인 컴포넌트 순차 업그레이드, kubelet 및 CNI 애드온 호환성 검증, 워커 노드 롤링 업데이트가 필요\nEKS — 컨트롤 플레인 버전을 먼저 올리고 노드그룹을 순차 업그레이드, 콘솔이나 eksctl로 진행 가능\neksctl upgrade cluster \\ --name my-cluster \\ --version 1.24 주의와 베스트 프랙티스 컨트롤 플레인 가용성 — 일반 k8s는 etcd 쿼럼과 컨트롤 플레인 노드 다중화가 핵심, EKS는 다중 AZ가 기본이지만 리전 장애 시 DR 전략 별도 고려 권장 업그레이드 — 마이너 버전 스큐 정책과 애드온 호환성 체크, 사전 테스트 클러스터에서 리허설 권장 보안 — EKS는 IRSA로 최소권한 부여, 일반 k8s는 OIDC 연계와 RBAC 최소화 적용, API 서버 접근 경계 명확화 네트워크 정책 — EKS에서 SG for Pods와 NetworkPolicy는 모델이 다름, 필요한 레이어에 맞게 병행 설계 권장 관측성 — 컨트롤 플레인 로그와 감사 로그 활성화, 메트릭 기반으로 컨트롤러 지연과 스케줄링 실패 감시 마무리 컨트롤 플레인은 선언된 상태를 기준으로 클러스터를 지속적으로 수렴시키는 조정자 역할을 수행함 일반 k8s는 높은 설계 자유도와 통제가 장점이나 운영 복잡도가 큼, EKS는 운영 부담을 크게 줄이는 대신 서비스 종속성과 과금 구조를 함께 고려해야 함 워크로드 특성과 팀의 운영 성숙도에 맞춰 관리형과 자가 운영형 중 합리적 선택 필요\n참고자료 https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/controller/ https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html https://aws.amazon.com/eks/pricing/ https://docs.aws.amazon.com/eks/latest/userguide/pod-security-groups.html https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.6/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-control-plane-eks-2af164/","summary":"\u003cp\u003e컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음\n조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함\u003c/p\u003e\n\u003ch3 id=\"개념과-정의\"\u003e개념과 정의\u003c/h3\u003e\n\u003cp\u003e컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층\n사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴\u003c/p\u003e\n\u003ch3 id=\"핵심-구성요소\"\u003e핵심 구성요소\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAPI 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영\u003c/p\u003e","title":"쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교"},{"content":"개요 가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리 컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명\n가드란 NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소 미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점 요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨 canActivate가 true 또는 Promise을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생\n프로젝트 준비 Nest CLI로 샘플 프로젝트 생성\n$ nest new our-nestjs 패키지 매니저 선택 후 기본 템플릿 생성됨\n가드로 요청 전달 CanActivate 인터페이스 구현으로 가드 정의\nimport { Injectable, CanActivate } from \u0026#34;@nestjs/common\u0026#34;; @Injectable() export class AuthGuard implements CanActivate { canActivate() { return true; } } canActivate가 true를 반환하므로 요청은 컨트롤러로 전달됨\n컨트롤러에 가드 적용 UseGuards 데코레이터로 클래스 또는 메서드 단위 적용 가능\nimport { Controller, Get, UseGuards } from \u0026#34;@nestjs/common\u0026#34;; @UseGuards(AuthGuard) @Controller() export class AppController { @Get() getHello() { return \u0026#34;Hello World!\u0026#34;; } } curl로 확인\n$ curl http://localhost:3000 Hello World! 가드로 요청 차단 반대로 false를 반환하면 요청은 차단되고 403 Forbidden 응답\n@Injectable() export class AuthGuard implements CanActivate { canActivate() { return false; } } $ curl http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Forbidden resource\u0026#34;,\u0026#34;error\u0026#34;:\u0026#34;Forbidden\u0026#34;,\u0026#34;statusCode\u0026#34;:403} 가드로 인증 구현 ExecutionContext로 HTTP 요청 객체에 접근해 헤더 등 입력값 검사 가능 Bearer 토큰을 단순 검증하는 예시\nimport { CanActivate, ExecutionContext, BadRequestException, Injectable, } from \u0026#34;@nestjs/common\u0026#34;; @Injectable() export class AuthGuard implements CanActivate { canActivate(context: ExecutionContext) { const req = context.switchToHttp().getRequest(); const auth = req.headers[\u0026#34;authorization\u0026#34;] as string | undefined; if (!auth) throw new BadRequestException(); const [scheme, token] = auth.split(\u0026#34; \u0026#34;); return scheme?.toLowerCase() === \u0026#34;bearer\u0026#34; \u0026amp;\u0026amp; token === \u0026#34;1234\u0026#34;; } } 의미\nAuthorization 헤더가 없으면 BadRequestException 발생해 400 응답 Bearer 스킴이며 토큰이 1234일 때만 통과 실서비스에서는 다음 중 하나 이상 필요\n토큰으로 사용자 조회 또는 권한 검증 서드파티 인증 서버 연동 또는 캐시 검증 JWT 디코딩 및 서명 검증 인증 가드 테스트 잘못된 토큰이면 403\n$ curl -H \u0026#34;Authorization: Bearer 1111\u0026#34; http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Forbidden resource\u0026#34;,\u0026#34;error\u0026#34;:\u0026#34;Forbidden\u0026#34;,\u0026#34;statusCode\u0026#34;:403} 올바른 토큰이면 성공\n$ curl -H \u0026#34;Authorization: Bearer 1234\u0026#34; http://localhost:3000 Hello World! 헤더가 없으면 400\n$ curl http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Bad Request\u0026#34;,\u0026#34;statusCode\u0026#34;:400} 주의와 베스트 프랙티스 가드는 인증·인가 같은 접근 제어에 집중, 복잡한 비즈니스 로직은 서비스로 위임 공통 검증은 글로벌 가드로 등록해 중복 제거 반환형은 boolean 또는 Promise 사용, 명시적 예외는 Exception 클래스로 던짐 로깅은 콘솔 대신 프레임워크 로거 사용 권장 세분화된 역할 검증은 메타데이터와 커스텀 데코레이터 조합으로 역할 기반 가드 구성 권장 마무리 Guard는 컨트롤러 앞단에서 요청을 선별하는 확실한 진입점 제공 간단한 구현만으로도 인증과 접근 제어의 기본선을 세울 수 있음 실서비스에서는 토큰 검증, 캐시, 외부 인증 연동을 조합해 성능과 보안의 균형을 맞출 것\n참고자료 https://docs.nestjs.com/guards https://docs.nestjs.com/fundamentals/execution-context https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization https://curl.se/docs/manpage.html ","permalink":"https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리\n컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명\u003c/p\u003e\n\u003ch3 id=\"가드란\"\u003e가드란\u003c/h3\u003e\n\u003cp\u003eNestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소\n미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점\n요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨\ncanActivate가 true 또는 Promise\u003c!-- raw HTML omitted --\u003e을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생\u003c/p\u003e","title":"NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시"},{"content":"개요 쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템 핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프 각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능\n구성요소 관계 한눈에 kubectl / CI │ ▼ kube-apiserver ──\u0026gt; etcd │ ▲ │ └(상태 영속) │ ├─ kube-scheduler(어디 배치할지 결정) └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등) [각 워커 노드] kubelet ──(CRI gRPC)──\u0026gt; container runtime ──(OCI)──\u0026gt; runc/crun ──\u0026gt; cgroup 설정 + 컨테이너 시작 │ │ ├─(CNI 호출) 네트워크/IP 할당 └─ 네임스페이스/마운트 등 격리 └─ kube-proxy(서비스 라우팅: iptables/ipvs) 모든 컴포넌트의 권위자이자 입구는 apiserver etcd와 직접 통신하는 주체는 apiserver만 존재 kubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지 container runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행 Pod 생성에서 Running까지 사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화 controller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등 scheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩 대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지 kubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당 kubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달 runtime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행 kubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고 kube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립 클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료 cgroup과 리소스 제한 연결 PodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정 CPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여 메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제 쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심 장애·스케일·자체 복구 흐름 컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행 노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택 HPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소 용어 핵심 정리 control plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소 worker node 파드를 실제로 실행하는 머신 풀 kubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당 container runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수 cgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정 마무리 apiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당\n참고자료 https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/ https://kubernetes.io/docs/concepts/architecture/cri/ https://kubernetes.io/docs/concepts/workloads/pods/ https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/ https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html https://kubernetes.io/docs/concepts/services-networking/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-core-components-and-flow-915d3a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템\n핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프\n각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능\u003c/p\u003e\n\u003ch3 id=\"구성요소-관계-한눈에\"\u003e구성요소 관계 한눈에\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekubectl / CI\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekube-apiserver ──\u0026gt; etcd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │  ▲\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │  └(상태 영속)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ├─ kube-scheduler(어디 배치할지 결정)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[각 워커 노드]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekubelet ──(CRI gRPC)──\u0026gt; container runtime ──(OCI)──\u0026gt; runc/crun ──\u0026gt; cgroup 설정 + 컨테이너 시작\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │                                        │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ├─(CNI 호출) 네트워크/IP 할당            └─ 네임스페이스/마운트 등 격리\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    └─ kube-proxy(서비스 라우팅: iptables/ipvs)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e모든 컴포넌트의 권위자이자 입구는 apiserver\u003c/li\u003e\n\u003cli\u003eetcd와 직접 통신하는 주체는 apiserver만 존재\u003c/li\u003e\n\u003cli\u003ekubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지\u003c/li\u003e\n\u003cli\u003econtainer runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pod-생성에서-running까지\"\u003ePod 생성에서 Running까지\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화\u003c/li\u003e\n\u003cli\u003econtroller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등\u003c/li\u003e\n\u003cli\u003escheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩\u003c/li\u003e\n\u003cli\u003e대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지\u003c/li\u003e\n\u003cli\u003ekubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당\u003c/li\u003e\n\u003cli\u003ekubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달\u003c/li\u003e\n\u003cli\u003eruntime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행\u003c/li\u003e\n\u003cli\u003ekubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고\u003c/li\u003e\n\u003cli\u003ekube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립\u003c/li\u003e\n\u003cli\u003e클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"cgroup과-리소스-제한-연결\"\u003ecgroup과 리소스 제한 연결\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정\u003c/li\u003e\n\u003cli\u003eCPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여\u003c/li\u003e\n\u003cli\u003e메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제\u003c/li\u003e\n\u003cli\u003e쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"장애스케일자체-복구-흐름\"\u003e장애·스케일·자체 복구 흐름\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행\u003c/li\u003e\n\u003cli\u003e노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택\u003c/li\u003e\n\u003cli\u003eHPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"용어-핵심-정리\"\u003e용어 핵심 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003econtrol plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소\u003c/li\u003e\n\u003cli\u003eworker node 파드를 실제로 실행하는 머신 풀\u003c/li\u003e\n\u003cli\u003ekubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당\u003c/li\u003e\n\u003cli\u003econtainer runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수\u003c/li\u003e\n\u003cli\u003ecgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eapiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당\u003c/p\u003e","title":"Kubernetes 핵심 구성요소와 동작 흐름"},{"content":"개요 EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구 병목 파악과 인덱스 전략 점검에 사용\n핵심 개념 select_type SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음 PRIMARY 가장 바깥쪽 SELECT SUBQUERY 서브쿼리 DERIVED FROM 절의 서브쿼리 UNION UNION의 두 번째 이후 SELECT type 실행 품질 지표, 위에서 아래로 유리 system 테이블에 단 하나의 행 const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회 eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭 ref 인덱스를 사용한 동등 조건 검색 range 인덱스를 사용한 범위 검색 index 인덱스 전체 스캔 ALL 테이블 전체 스캔, 최악 possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음 key 실제 사용된 인덱스, NULL이면 인덱스 미사용 rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리 filtered 조건 후 남는 행 비율 추정치, 높을수록 유리 Extra 추가 단서 Using index 커버링 인덱스 사용, 유리 Using where WHERE 조건으로 필터링 수행 Using filesort 추가 정렬 필요, 비용 큼 Using temporary 임시 테이블 사용, 비용 큼 해석 기준 type이 const, ref, range 범주에 위치 key가 NULL이 아니고 적절한 인덱스 선택 rows 추정치가 작고 filtered 비율이 높음 Extra에 Using filesort, Using temporary 부재 예시와 해석 type: ALL possible_keys: NULL rows: 3527425 Extra: Using where; Using filesort 테이블 전체 스캔으로 많은 행을 읽게 됨 인덱스 후보와 실제 사용 인덱스가 없음 WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승 현재 계획은 인덱스 설계와 조건식 재검토 필요 주의와 팁 rows와 filtered는 통계 기반 추정치라 실제와 오차 가능 filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용 Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음 인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려 커버링 인덱스 구성 시 Extra의 Using index로 확인 가능 마무리 EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기 위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/explain.html https://dev.mysql.com/doc/refman/8.0/en/explain-output.html ","permalink":"https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eEXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구\n병목 파악과 인덱스 전략 점검에 사용\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eselect_type\n\u003cul\u003e\n\u003cli\u003eSIMPLE 단순 SELECT, 서브쿼리나 UNION 없음\u003c/li\u003e\n\u003cli\u003ePRIMARY 가장 바깥쪽 SELECT\u003c/li\u003e\n\u003cli\u003eSUBQUERY 서브쿼리\u003c/li\u003e\n\u003cli\u003eDERIVED FROM 절의 서브쿼리\u003c/li\u003e\n\u003cli\u003eUNION UNION의 두 번째 이후 SELECT\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003etype 실행 품질 지표, 위에서 아래로 유리\n\u003cul\u003e\n\u003cli\u003esystem 테이블에 단 하나의 행\u003c/li\u003e\n\u003cli\u003econst PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회\u003c/li\u003e\n\u003cli\u003eeq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭\u003c/li\u003e\n\u003cli\u003eref 인덱스를 사용한 동등 조건 검색\u003c/li\u003e\n\u003cli\u003erange 인덱스를 사용한 범위 검색\u003c/li\u003e\n\u003cli\u003eindex 인덱스 전체 스캔\u003c/li\u003e\n\u003cli\u003eALL 테이블 전체 스캔, 최악\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003epossible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음\u003c/li\u003e\n\u003cli\u003ekey 실제 사용된 인덱스, NULL이면 인덱스 미사용\u003c/li\u003e\n\u003cli\u003erows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리\u003c/li\u003e\n\u003cli\u003efiltered 조건 후 남는 행 비율 추정치, 높을수록 유리\u003c/li\u003e\n\u003cli\u003eExtra 추가 단서\n\u003cul\u003e\n\u003cli\u003eUsing index 커버링 인덱스 사용, 유리\u003c/li\u003e\n\u003cli\u003eUsing where WHERE 조건으로 필터링 수행\u003c/li\u003e\n\u003cli\u003eUsing filesort 추가 정렬 필요, 비용 큼\u003c/li\u003e\n\u003cli\u003eUsing temporary 임시 테이블 사용, 비용 큼\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"해석-기준\"\u003e해석 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003etype이 const, ref, range 범주에 위치\u003c/li\u003e\n\u003cli\u003ekey가 NULL이 아니고 적절한 인덱스 선택\u003c/li\u003e\n\u003cli\u003erows 추정치가 작고 filtered 비율이 높음\u003c/li\u003e\n\u003cli\u003eExtra에 Using filesort, Using temporary 부재\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"예시와-해석\"\u003e예시와 해석\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etype: ALL\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epossible_keys: NULL\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erows: 3527425\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExtra: Using where; Using filesort\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e테이블 전체 스캔으로 많은 행을 읽게 됨\u003c/li\u003e\n\u003cli\u003e인덱스 후보와 실제 사용 인덱스가 없음\u003c/li\u003e\n\u003cli\u003eWHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승\u003c/li\u003e\n\u003cli\u003e현재 계획은 인덱스 설계와 조건식 재검토 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의와-팁\"\u003e주의와 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003erows와 filtered는 통계 기반 추정치라 실제와 오차 가능\u003c/li\u003e\n\u003cli\u003efiltered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용\u003c/li\u003e\n\u003cli\u003eUsing filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음\u003c/li\u003e\n\u003cli\u003e인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려\u003c/li\u003e\n\u003cli\u003e커버링 인덱스 구성 시 Extra의 Using index로 확인 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eEXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기\n위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장\u003c/p\u003e","title":"MySQL EXPLAIN 실행 계획 해석 가이드"},{"content":"블록체인 인덱서 가이드 인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임 디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\n왜 인덱서가 필요한가 블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼 디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함 전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임 핵심 개념 인덱싱 대상 데이터 유형 블록 헤더와 트랜잭션 메타데이터\n블록번호, 타임스탬프, 가스 사용량, 트랜잭션 해시 등 스마트 컨트랙트 이벤트 로그\n토픽과 데이터 필드, 인덱스드 파라미터, 로그 인덱스 등 컨트랙트 상태 스냅샷 또는 파생 지표\n잔액 스냅샷, 포지션 지표, 시계열 집계 등 용어 정리 서브그래프\n특정 도메인을 위한 스키마형 인덱싱 단위 최종성 Finality\n블록이 되돌려지지 않을 확률이 충분히 낮은 상태를 의미함 재구성 Reorg\n더 긴 체인이 나타나 일부 블록이 교체되는 현상으로 인덱서가 롤백과 재처리를 수행해야 함 백필 Backfill\n과거 블록 범위를 대량으로 인덱싱하는 작업이며 라이브 스트림과 병행 운영 필요함 아키텍처 구성 요소 수집기 Ingestor\n풀노드 또는 게이트웨이에 구독 혹은 폴링으로 연결해 새 블록과 트랜잭션, 로그 수신 블록 범위 큐와 재시도, 속도 제한 제어 포함 권장 파서 Parser\nABI 기반 디코딩으로 이벤트와 함수 호출 입력을 구조화함 주소, 체인ID, 블록번호, 트랜잭션 해시를 기본 정규화 키로 포함 인덱서 Indexer\n예상 질의 패턴에 맞춘 보조 인덱스와 머티리얼라이즈드 뷰 생성 멱등 처리로 중복 입력에 안전해야 함 저장소 Storage\n관계형 SQL, 문서형, 키밸류, 시계열 중 워크로드에 맞게 혼합 선택 쓰기 집중 구간과 읽기 집중 구간을 분리 설계 권장 서비스 API\nGraphQL 또는 REST 제공 캐시, 커서 기반 페이지네이션, 레이트 리밋, 다중 리전 배포 포함 권장 동작 원리 1) 데이터 수집 최신 블록 스트림 수신 토픽 기반 필터로 관심 이벤트만 선별 가능 블록 범위 작업 단위를 설정해 재시도와 병렬 처리 제어 2) 정리와 저장 ABI로 이벤트 파싱 후 표준 스키마로 정규화\n파티셔닝 키 설계 예시\n주소별 파티션, 컨트랙트별 파티션, 체인ID별 샤딩 스토리지 선택 가이드\nSQL은 조인과 강한 정합성 강점 NoSQL은 쓰기 성능과 수평 확장 강점 혼합 접근으로 원본 로그 테이블과 조회 최적화 테이블을 분리 3) 제공과 캐싱 핫 키에 인메모리 캐시와 세그먼트 캐시 적용 커서 기반 페이지네이션으로 대량 스캔 방지 지표성 데이터는 사전 집계 테이블이나 머티리얼라이즈드 뷰 사용 4) 최종성과 재처리 N 컨펌 이후 확정 마킹으로 Reorg 영향 최소화 Reorg 발생 시 영향 범위만 역인덱스 삭제 후 재인덱싱 백필 잡과 라이브 스트림의 경계 관리로 중복 작업 방지 데이터 모델과 스키마 예시 원본 이벤트 로그 테이블 예시 CREATE TABLE ev_raw ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, log_index INT NOT NULL, topic0 VARBINARY(32) NOT NULL, topic1 VARBINARY(32) NULL, topic2 VARBINARY(32) NULL, topic3 VARBINARY(32) NULL, data BLOB NOT NULL, PRIMARY KEY (chain_id, block_number, tx_hash, log_index) ) 조회 최적화 테이블 예시 CREATE TABLE nft_transfers ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, token_id DECIMAL(78,0) NOT NULL, from_address VARBINARY(20) NOT NULL, to_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, PRIMARY KEY (chain_id, contract_address, token_id, block_number, tx_hash), INDEX idx_owner_history (chain_id, to_address, block_number DESC) ) GraphQL 질의 예시 query { transfers(first: 10, where: { from: \u0026#34;0xaaaa...\u0026#34;, to: null }) { id from to value blockNumber txHash } } 핵심은 애플리케이션이 자주 묻는 질문을 스키마와 인덱스로 선제 정의하는 것임 원장 재탐색 없이 즉시 응답 가능한 형태로 데이터를 재구성하는 것이 목표임\n일관성 모델 확정 상태와 미확정 상태를 명시 구분\n응답 필드에 finality_level 또는 confirmations 포함 권장 API 파라미터로 최종성 레벨 허용\n예시로 minConfirmations=12 전달 시 해당 기준 충족 데이터만 반환 읽기 스냅샷 일관성 유지로 동일 요청 내 시간축 안정성 보장\n재처리와 멱등성 블록 범위 단위의 재인덱싱이 가능하도록 범위 메타 유지\n멱등 키 설계\n(chain_id, tx_hash, log_index) 또는 이벤트 고유 해시로 중복 삽입 방지 업서트 기반 로딩으로 재처리 안전성 확보\nINSERT INTO nft_transfers (...) VALUES (...) ON DUPLICATE KEY UPDATE block_time = VALUES(block_time) 성능과 비용 최적화 백필은 대역폭 우선, 라이브는 지연 우선으로 튜닝 파티션 핫스팟 회피를 위해 주소 해싱 또는 범위 셔플링 적용 대규모 이벤트의 경우 배치 크기와 커밋 간격을 체계적으로 설정 스키마 버저닝을 통해 마이그레이션 시 이중 기록 전략 적용 권장 운영과 관측성 필수 지표\n블록 지연, 수집 지연, 처리 라그, 오류율, 재시도율, 큐 적체량 알람 기준\n라그 급증, Reorg 빈도 증가, 특정 컨트랙트 오류 급증 롤백과 재시작\n저장소에 체크포인트와 커밋 오프셋 기록으로 안전 복구 가능하게 설계 보안과 무결성 데이터 출처 이중화와 교차 검증 적용\n서로 다른 노드나 공급자에서 샘플 검증 수행 권장 서명 검증 가능한 데이터는 파이프라인 내 즉시 검증\n민감 메타데이터는 암호화 저장과 접근 통제 적용\n주요 플랫폼 비교 요약 The Graph\nGraphQL 기반 서브그래프 모델과 커스텀 스키마, 매핑 지원 이벤트 중심 도메인 모델링이 단순함 Covalent\n멀티체인 통합 API와 공통 스키마 제공 빠른 프로토타이핑과 대시보드 연동 용이 QuickNode\n노드와 인덱싱 API 조합으로 고성능 엔드포인트 제공 Moralis\n멀티체인 디앱 백엔드 도구로 지갑과 NFT 중심 인덱싱 제공 자체 구축\n유연성과 데이터 소유권 강점 운영 복잡성과 비용 증가 단점 존재 대표 사용 사례 지갑 화면에서 주소 기준 트랜잭션과 토큰 잔액 즉시 조회 디파이 포지션 수익률과 담보 상태를 실시간 계산 NFT 소유 목록, 전송 이력, 메타데이터 동기화 제공 온체인 데이터 기반 분석과 알림 트리거 생성 베스트 프랙티스 체크리스트 스키마 설계 상위 핵심 질의 세 가지를 먼저 정하고 파티셔닝과 보조 인덱스를 결정 원본 로그 테이블과 조회 최적화 테이블을 분리 운영 시간 기반 파티셔닝과 주소 기반 인덱스를 함께 고려 재처리 전략 블록 범위 메타를 보관해 부분 재인덱싱 가능하게 유지 멱등 키와 업서트로 중복 삽입 방지 일관성과 최종성 확정과 미확정 데이터를 응답에서 구분 API에 최종성 파라미터 제공 성능과 비용 백필 파이프라인은 대역폭과 병렬성 극대화 라이브 스트림은 지연과 안정성 최적화 핫 파티션 회피를 위한 해싱 또는 샤딩 적용 운영과 관측성 라그와 오류 지표를 1급 시민으로 모니터링 스키마 버저닝과 롤백 계획을 문서화 보안과 무결성 공급자 이중화와 교차검증 구성 서명 검증 가능한 지표는 수집 단계에서 검증 안티 패턴 WHERE 절에 함수 연산을 남발해 인덱스를 무력화하는 패턴 원본 로그 테이블 하나로만 모든 질의를 처리하려는 단일 스키마 고집 Reorg 가정 부재로 롤백 경로가 없는 파이프라인 커서 대신 페이지 오프셋을 사용해 심각한 스캔을 유발하는 페이지네이션 간단 레퍼런스 이더리움 JSON-RPC eth_getLogs로 토픽 필터링 수집 가능 Solidity 이벤트는 ABI로 디코딩해 구조화 가능 GraphQL은 선택적 필드 조회와 관계 탐색에 유리함 query WalletView($owner: String!, $first: Int!, $cursor: String) { erc20Balances(owner: $owner, first: $first, after: $cursor) { edges { node { contract symbol decimals balance updatedAt } cursor } pageInfo { hasNextPage endCursor } } } 마무리 인덱서는 제품이 자주 묻는 질문을 데이터 구조로 먼저 표현하는 도구임 초기 단계에서 질의 패턴과 최종성 전략을 분명히 하고 재처리, 관측성, 비용의 트레이드오프를 문서화할 것 관리형 서비스와 자체 구축을 혼합해 민첩성과 통제력을 균형 있게 가져갈 것 참고자료 https://thegraph.com/docs/en/ https://www.covalenthq.com/docs/ https://www.quicknode.com/docs https://docs.moralis.io/ https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs https://docs.soliditylang.org/en/latest/contracts.html#events ","permalink":"https://blog.jsontapose.com/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/","summary":"\u003ch1 id=\"블록체인-인덱서-가이드\"\u003e블록체인 인덱서 가이드\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임\n디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"왜-인덱서가-필요한가\"\u003e왜 인덱서가 필요한가\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼\u003c/li\u003e\n\u003cli\u003e디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함\u003c/li\u003e\n\u003cli\u003e전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-개념\"\u003e핵심 개념\u003c/h2\u003e\n\u003ch3 id=\"인덱싱-대상-데이터-유형\"\u003e인덱싱 대상 데이터 유형\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e블록 헤더와 트랜잭션 메타데이터\u003c/p\u003e","title":"블록체인 인덱서 가이드"},{"content":"개요 퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함 이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름 합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함 PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임 실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\n합의가 필요한 이유와 기준 안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음 활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨 최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨 시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요 성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건 탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요 PoW 작업증명 핵심 정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조 구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요 난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행 보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미 장점\n단순한 검증 경량 노드도 헤더 체인과 작업 증명만으로 유효성 확인 가능 시빌 내성 경제적 비용이 명확하며 물리 자원 기반 보안 단점 에너지 비용 과다 전력과 하드웨어 비용이 지속적으로 소모됨 처리 지연 블록 간격 확대와 오프라인 확률로 인해 확률적 최종성에 의존함 여러 컨펌 대기가 필요 중앙화 유인 대규모 채굴 인프라와 풀 집중 경향 존재 운영 팁 블록 간격과 크기 설정은 고아 블록 비율을 고려해 네트워크 전파 지연을 상회하도록 보수적으로 설정 난이도 조정 주기는 급격한 난이도 스윙을 줄이도록 이동 평균이나 클리핑 적용 수수료 시장 안정화를 위해 기본 수수료 규칙과 대역폭 관리 병행 PoS 지분증명 핵심 정의 토큰 지분을 예치한 검증자가 블록 제안 및 투표 권한을 획득하는 방식 에너지 소모를 낮추고 결정적 최종성 또는 짧은 확률적 최종성을 지향 선정 방식 난수 또는 가중 무작위 선택 VRF 위원회 선출 라운드별 리더 로테이션 등 다양함 안전 장치 슬래싱 이중 제안 또는 상충 투표에 대해 지분 일부 소각해 부정 행위 억제 체크포인트와 파이널라이저로 최종성 확보 대표적 이슈\n아무 것도 걸지 않기 문제 포크마다 비용 없이 투표 가능 설계 시 슬래싱과 보상 구조로 해결 롱레인지 공격 오래된 키로 과거부터 새로운 체인을 위조 가능 약한 주관성 체크포인트 동기화와 키 회수 정책으로 대응 지분 집중 대량 보유의 복리 효과로 중앙화 경향 완화 위해 보상 곡선과 위임 구조 설계 필요 장점 저전력 고효율 일반 하드웨어로 검증 가능해 참여 문턱 완화 빠른 확정 위원회 기반 투표와 파이널리티 가젯으로 블록 확정 지연 축소 단점 프로토콜 복잡도 증가 상태 관리 키 보안 슬래싱 운영 리스크 존재 경제 보안은 토큰 가치에 의존 가격 급락 시 보안 예산 저하 가능 운영 팁 검증자 키 관리 분리 서명 키와 위임 키 분리하고 온라인 노출 최소화 모니터링 필수 가용성 저하와 네트워크 분할 시 슬래싱 위험에 대비해 자동 장애 조치와 경보 체계 구축 업그레이드 경로 사전 예고와 버전 롤링 전략으로 네트워크 분리 리스크 완화 영지식증명 기본 개념 요약 목적 특정 명제가 참임을 비밀 자체를 드러내지 않고 증명 핵심 성질 세 가지\n완전성 증명자가 정당하면 검증자는 수용 건전성 증명자가 거짓이면 들킴 확률이 무시 가능 수준으로 낮음 영지식성 검증 과정에서 비밀에 대한 추가 정보 누설 없음 직관적 비유 알리바바 동굴 이야기 증명자는 비밀번호를 알려주지 않지만 검증자가 무작위로 요구한 출구를 반복해서 만족시킴으로써 지식을 입증함 반복 횟수를 늘릴수록 속임수 성공 확률이 기하급수적으로 줄어듦 zk-SNARK와 zk-STARK 한눈에 정리 zk-SNARK 짧은 증명 크기와 빠른 검증 장점 신뢰 설정이 필요한 설계가 일반적이며 곡선 쌍선형 연산 의존 zk-STARK 신뢰 설정 불필요 투명성 확보 해시 중심 구성 대규모 산술화에 강점 단 증명 크기가 다소 큼 검증도 상수항이 큰 편 최근 동향 순환 증명과 집계 증명으로 대량 트랜잭션을 하나의 짧은 증명으로 압축하는 기술 발전 중 블록체인에서 영지식증명이 유용한 지점 프라이버시 보호 거래 금액과 주소를 숨기면서도 보유액과 보존 법칙을 증명 가능 프라이버시 코인과 선택적 공개 기능에 활용 경량 검증과 확장성 체인 외부에서 상태 전이의 올바름을 증명하고 온체인에서는 짧은 증명만 검증 레이어2 유효성 롤업과 브리지에서 핵심 역할 탈중앙 신원 DID 자격증명 내용을 공개하지 않고 특정 속성 보유 여부를 증명 가능 최소 정보 공개 원칙 준수 합의 검증 비용 절감 블록 제안자가 트랜잭션 집합의 유효성에 대한 증명을 첨부하면 검증자의 부하 감소 가능 특히 대규모 검증 집합에서 효과적 PoW와 ZKP의 접점 경량 노드 강화 SPV 유사 모델을 한 단계 더 줄여 거래와 상태 전이를 영지식 증명으로 요약 검증 데이터 요구량 감소 데이터 가용성과의 분리 증명으로 계산의 정당성을 담보하고 실제 데이터는 샘플링 기반 가용성 검증으로 처리 조합 시 대역폭 부담 경감 현실 제약 PoW 체인에 직접 ZKP를 의무화하면 블록 생성 지연과 수수료 급등 가능 선택적 채택 또는 L2에서 사용 후 앵커링 전략이 실용적 PoS와 ZKP의 접점 빠른 최종성 보조 확정 투표와 함께 블록 유효성에 대한 유효성 증명을 첨부하면 재검증 비용 감소와 상태 동기화 속도 향상 기대 경계 조건 롱레인지 공격 방지 로직과 ZKP의 신뢰 설정 문제가 충돌하지 않도록 설계 필요 검증 키 관리와 프로빙 공격 대응 필수 레이어2 조합 PoS L1은 데이터 가용성과 보안에 집중 L2는 ZKP 기반 유효성 증명으로 대량 처리 규모 확장 구조가 주류로 이동 중 간단 예시 시나리오 전송자 A가 금액 x를 보유하고 있고 x의 일부 y를 B에게 보낸다는 명제를 산술 회로로 구성 A는 입력 금액과 잔액을 숨긴 채 보존 법칙과 서명 유효성 이중 지불 방지 조건을 모두 만족한다는 zk 증명을 생성 블록 제안자는 거래 본문이 아니라 증명과 최소한의 커밋먼트만 포함해 블록을 구성 검증자는 모든 트랜잭션을 재연산하지 않고 증명만 검증해 유효성 확인 네트워크 전체의 검증 비용과 데이터 노출이 줄어듦 주의 사항과 한계 PoW\n에너지 비용과 환경 부담 현실적 고려 필요 정책 변화와 전력 시장 리스크 반영 채굴 풀 집중 위험 수수료 변동성과 수익 불안정성으로 해시 파워 급변 가능 PoS 슬래싱 운영 리스크 네트워크 분할 장애나 키 누출 시 손실 발생 가능 기계적 가용성과 이중 서명 방지 자동화 필수 지분 집중 완화 필요 보상 곡선 설계 위임 한도 분산 인센티브 도입 고려 ZKP 구현 난도 높음 회로 설계와 산술화 최적화에 고도의 전문성 요구 사소한 변경으로도 보안 성질이 깨질 수 있음 신뢰 설정 이슈 TTP를 요구하는 시스템은 설정 자료 유출에 대한 위협 모델을 명확화해야 함 멀티 파티 설정과 폐기 의식 같은 절차 필요 성능 비용 증명 생성 시간이 길고 메모리 사용량이 큼 온체인 검증 가스 비용과 트레이드오프 존재 규제와 프라이버시 충돌 익명성 기능은 규제 요구와 충돌 가능 선택적 공개와 감사 권한 설계 필요 설계와 운영 베스트 프랙티스 체크리스트 요구사항 정렬 최종성 목표 지연 허용치 처리량과 비용 한도를 수치로 정의 보안 예산 추적 PoW는 전력 단가와 장비 감가 PoS는 시가총액과 연간 인플레이션을 기반으로 경제 보안 측정 파라미터 거버넌스 난이도 조정 간격 파이널리티 임계치 슬래싱 파라미터를 온체인 거버넌스 또는 보호된 프로세스로 관리 롤백 규칙 사전 명시 경량 클라이언트 우선 누구나 검증 가능한 경량 노드 경로 제공 체크포인트와 ZKP 기반 동기화 옵션 검토 키 보안 모델 검증자 키 다중화 하드웨어 보안 모듈 사용 원격 서명 분리 공용 백업 절차 문서화 ZKP 도입 전략 파일럿을 레이어2나 특정 자산 유형에 적용 증명 생성 파이프라인과 회로 버전 관리 자동 테스트 구축 관측 가능성 메트릭 합의 파라미터 슬래싱 이벤트 고아 블록율 파이널리티 지연을 지속 수집 경보 기준 수립 마무리 합의 알고리즘 선택은 기술 취향이 아니라 시스템 목표와 제약에 대한 정량적 타협의 산물임 PoW는 단순하고 강인하지만 에너지 비용과 지연의 대가가 큼 PoS는 고성능과 유연성을 제공하지만 프로토콜 복잡도와 운영 리스크를 동반함 영지식증명은 프라이버시와 검증 비용을 동시에 다루는 실용 도구로 자리잡는 중이며 신뢰 설정과 성능 한계에 대한 공학적 해결이 빠르게 진행되고 있음 현실적인 접근은 L1 합의는 보안을 우선하고 L2에서 ZKP로 확장성과 프라이버시를 확보하는 계층화 설계임 명확한 목표 지표 설정과 파라미터 거버넌스 자동화된 검증과 관측 가능성을 갖춘 운영이 장기적 안정성을 보장함\n참고자료 https://bitcoin.org/bitcoin.pdf https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ https://arxiv.org/abs/1710.09437 https://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf https://z.cash/technology/zksnarks/ https://zkproof.org https://vitalik.ca/general/2021/12/06/pos2021.html https://www.lgcns.com/blog/cns-tech/security/29926/ ","permalink":"https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함\n이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름\n합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함\nPoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임\n실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\u003c/p\u003e\n\u003ch3 id=\"합의가-필요한-이유와-기준\"\u003e합의가 필요한 이유와 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음\u003c/li\u003e\n\u003cli\u003e활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨\u003c/li\u003e\n\u003cli\u003e최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨\u003c/li\u003e\n\u003cli\u003e시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요\u003c/li\u003e\n\u003cli\u003e성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건\u003c/li\u003e\n\u003cli\u003e탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pow-작업증명-핵심\"\u003ePoW 작업증명 핵심\u003c/h3\u003e\n\u003cp\u003e정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조\n구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요\n난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행\n보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미\n장점\u003c/p\u003e","title":"블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용"},{"content":"개요 채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임 역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음 이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨 아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\n핵심 개념과 정의 블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부 트랜잭션 계정 상태를 변화시키는 요청 또는 메시지 채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체 작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙 난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할 넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값 메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합 블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합 왜 채굴이 필요한가 탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음 예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함 채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함 PoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\n생성 어렵게 만들면 공격자가 과거를 마음대로 재구성하기 어려워짐 검증 쉽게 만들면 모든 노드가 빠르게 유효성 확인이 가능함 동작 원리와 절차 PoW 기반 네트워크에서 채굴자가 블록을 만드는 일반 흐름은 다음과 같음\n사용자가 지갑으로 트랜잭션에 서명하고 네트워크에 브로드캐스트함 노드가 트랜잭션을 수신해 로컬 메모리풀에 적재함 채굴자가 메모리풀에서 수수료가 유리하고 유효한 트랜잭션을 선별해 임시 블록 후보를 구성함, 블록 가스 한도 내에서 수익 최대화 목표 각 트랜잭션의 서명과 잔고 및 논리적 제약을 검증하고, 로컬 가상머신에서 실행하여 상태 전이를 시뮬레이션함 블록 헤더에 포함될 머클 루트, 이전 블록 해시, 타임스탬프, 난이도, 넌스 등을 조립함 채굴기가 넌스를 바꿔가며 헤더 해시가 목표 난이도 기준 이하가 되도록 반복 계산함, 목표를 만족하면 유효한 작업증명 완료 채굴자는 찾은 증명과 함께 블록을 전파함, 함께 전파되는 상태 요약은 다른 노드가 결과를 빠르게 확인하도록 돕는 용도 다른 노드는 증명 검증 후 로컬 실행으로 상태를 재현해 일치 여부 확인함 다수 노드가 유효하다고 인정하면 해당 블록이 체인에 연결되고 이전 블록 위에 최종성 확률이 쌓이기 시작함 블록을 제안한 채굴자는 보상과 포함된 트랜잭션 수수료를 수령함 보상 구조와 인센티브 채굴 보상은 크게 두 부분으로 구성됨\n기본 보상 새 블록 생성 보상, 네트워크 규칙에 의해 일정 주기로 조정될 수 있음 수수료 보상 블록에 포함된 트랜잭션이 지불하는 수수료의 합계, 수요와 혼잡도에 따라 변동 역사적으로 이더리움 PoW에서는 기본 보상이 네트워크 업그레이드를 거치며 5 → 3 → 2 단위로 축소된 바 있음, 혼잡 시에는 수수료 비중이 커져 채굴자 수익에 큰 영향을 줌 PoW의 경제적 설계는 보상을 통해 정직한 참여를 유도하고, 높은 계산 비용을 통해 악의적 재작성 비용을 크게 만듦 증명 생성은 계산적으로 어렵지만 검증은 매우 쉬움, 따라서 네트워크 전체가 빠르게 합의 상태를 공유할 수 있음 비용 구조와 수익성 판단 채굴 수익성은 단순 보상 규모가 아니라 총비용 대비 순이익으로 판단함\n하드웨어 비용 GPU 또는 ASIC 장비, 보조 부품, 예비 부품, 감가상각 전력 비용 소비 전력과 단가, 지역별 전력 정책, 피크 요금 운영 비용 냉각과 환기, 먼지 및 습도 대응, 전기 배선과 안정화 장치, 모니터링 시스템, 공간 임대, 유지보수 인력 네트워크 난이도와 코인 가격, 수수료 시장, 장비 효율이 동적으로 상호작용하기 때문에 손익분기점은 수시로 변함 개별 상황 가정 후 계산기를 활용해 해시레이트, 전력 소모, 전기요금, 난이도, 수수료를 넣고 일일 혹은 월간 예상 수익을 추정하는 접근 권장 가격 변동성, 난이도 조정, 장비 고장률, 가동률 저하, 네트워크 정책 변경 위험을 보수적으로 반영하는 것 중요 채굴 방식 비교 CPU 채굴 초기에는 가능했으나 현재는 연산 밀도가 낮아 경제성 부족 GPU 채굴 범용성과 병렬성 확보, 여러 장을 리그로 구성해 확장 가능, 시장 유통성과 중고 처분 용이성이 장점이나 전력 효율은 ASIC 대비 불리 ASIC 채굴 특정 알고리즘 전용 설계로 높은 해시당 전력 효율 제공, 다만 초기 투자비 크고 알고리즘 혹은 시장 변화에 취약, 세대 교체 주기가 짧아 감가상각 리스크 큼 클라우드 채굴 하드웨어 없이 해시레이트 임대, 초기 비용과 운영 부담 감소 장점이 있으나 계약 불투명성, 수익 분배 구조, 커스터디 리스크에 각별한 주의 필요 채굴 풀의 역할과 구조 개인이 단독으로 블록을 찾을 확률은 매우 낮음, 풀은 참여자의 해시 파워를 모아 변동성을 줄이고 보다 자주 보상을 획득하도록 함 풀 보상 분배는 기여도 기반으로 수행되며 PPS, PPLNS 등 다양한 정산 방식 존재, 각 방식의 리스크와 변동성 특성 상이함 풀 선택 시 고려 요소 운영 투명성, 수수료율, 지연시간, 서버 위치와 품질, 최소 출금 한도, 보안 공지 대응력, 탈중앙성에 미치는 영향 풀 집중화는 네트워크 보안에 부정적일 수 있으므로 단일 풀이 과도한 비중을 차지하는 상황은 경계 필요\n보안과 한계, 운영상의 베스트프랙티스 전력과 열 관리 과부하 차단기와 분산 배전, 항온항습과 적절한 배기 경로 설계, 화재 감시 시스템 구축 펌웨어와 드라이버 신뢰 가능한 소스만 사용, 자동 업데이트 비활성 후 검증 배포, 설정 백업 유지 물리 보안 장비 잠금과 출입 통제, 원격 전원 차단 장치 준비, 영상과 환경 센서 모니터링 풀 및 지갑 보안 출금 화이트리스트, 다중서명 혹은 하드웨어 월렛 사용, 풀 API 토큰 보호 재무 관리 변동성 헤지 전략, 정기적인 손익 분석, 감가상각과 현금 흐름 관리 규제와 환경 고려 지역 규제 준수, 소음 규제 대응, 재생에너지 사용 검토, 전력 계약 합법성 확인 PoW는 높은 에너지 비용과 장비 자본 집약이라는 구조적 한계를 가짐, 반면 공격 비용을 높여 보안을 확보한다는 장점 존재 간단 예시로 보는 합의와 순서 보장 순서1 Alice → Bob 1 단위 전송 요청 생성 및 서명 순서2 네트워크에 전파되어 메모리풀에 대기 순서3 채굴자가 유효성을 확인하고 블록 후보에 포함 순서4 채굴자가 유효한 작업증명을 먼저 찾으면 블록 전파 순서5 다른 노드가 빠르게 검증 후 채택, 전 세계가 동일한 순서로 상태를 갱신 이 흐름이 반복되며 이중지불 시도가 자연스럽게 배제됨, 잘못된 순서나 잔고 부족 요청은 유효성 검증에서 탈락함 이더리움 전환 사례에서 얻는 시사점 이더리움은 PoW에서 PoS로 전환하며 에너지 소비를 대폭 감소시키고 채굴 경제학에서 스테이킹 경제학으로 무게중심을 이동시켰음 PoW 채굴의 개념과 절차는 여전히 유효한 학습 주제이며, PoW 네트워크 운영과 보안 모델 이해에 핵심적임 네트워크 설계는 기술과 경제 인센티브의 균형 위에 서며, 보상 구조와 비용 구조를 함께 설계해야 지속 가능성이 확보됨\n마무리 채굴은 블록을 만드는 생산 행위이자 합의를 물리적으로 고정하는 보안 장치임 동작 원리를 이해하면 트랜잭션 순서 보장, 이중지불 방지, 경제 인센티브 설계를 하나의 체계로 연결해 볼 수 있음 실제 투자나 운영을 고려한다면 전력 단가, 장비 효율, 난이도, 수수료 시장, 규제 리스크를 보수적으로 평가하고, 풀 선택과 보안 운용에 표준 절차를 갖추는 것이 우선임 PoW와 PoS의 차이를 비교해 각 네트워크의 보안 가정을 명확히 이해하는 태도가 중요함\n참고자료 https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining/ https://ethereum.org/en/roadmap/merge/ https://en.wikipedia.org/wiki/Double-spending https://etherscan.io/ether-mining-calculator https://www.fidelity.com/learning-center/trading-investing/crypto/what-is-mining ","permalink":"https://blog.jsontapose.com/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임\n역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음\n이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨\n아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부\u003c/li\u003e\n\u003cli\u003e트랜잭션 계정 상태를 변화시키는 요청 또는 메시지\u003c/li\u003e\n\u003cli\u003e채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체\u003c/li\u003e\n\u003cli\u003e작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙\u003c/li\u003e\n\u003cli\u003e난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할\u003c/li\u003e\n\u003cli\u003e넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값\u003c/li\u003e\n\u003cli\u003e메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합\u003c/li\u003e\n\u003cli\u003e블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"왜-채굴이-필요한가\"\u003e왜 채굴이 필요한가\u003c/h3\u003e\n\u003cp\u003e탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음\n예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함\n채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함\nPoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\u003c/p\u003e","title":"블록체인 채굴 개념과 동작 원리 PoW 보상 구조 이더리움 전환 사례"},{"content":"개요 Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표 ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구 핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\n배경과 목적 이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼 저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적 L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것 ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\n핵심 개념 Layer 2\nL1의 합의와 보안을 상속받아 트랜잭션을 오프체인에서 처리한 후 압축된 증거를 L1에 제출하는 확장 계층 목표는 가스 비용 절감, TPS 증가, 빠른 최종성 확보 ZK Rollup\n트랜잭션 배치를 실행한 결과가 올바름을 증명하는 유효성 증명 제출 방식 모든 원시 트랜잭션 데이터를 L1에 게시하지 않고 상태 변화의 유효성만 증명하여 확정 가능 Optimistic Rollup 대비 사후 분쟁 윈도우 감소, 빠른 확정성 기대 ZK Stack\nZK Rollup을 구성하기 위한 오픈 프레임워크 시퀀서, 증명기, 검증 계약, 데이터 가용성, 브리징 등 구성요소를 모듈 단위로 조립하는 설계 지향 데이터 가용성과 EIP-4844\n상태 차이와 배치 관련 데이터를 블롭 형태로 게시하여 비용 효율을 높이는 전략 블롭 데이터는 일정 기간 보존되며, 검증과 재구성에 필요한 최소 요건 충족을 목표 동작 원리와 구조 트랜잭션 수명주기 개요 사용자가 JSON-RPC를 통해 L2 네트워크로 트랜잭션 제출, 멤풀 적재 시퀀서가 트랜잭션을 실행해 블록화 후 배치 생성 사용자에게 즉시 실행 응답 반환 가능, 최종성은 L1 커밋·검증 후 확보 배치가 L1로 전송되어 데이터 가용성 보장 상태로 커밋됨 ZK 증명이 생성되어 L1 검증 계약에서 확인됨 검증 완료 후 배치 실행 확정, 상태 루트와 로그가 온체인 기준으로 고정 L1 상호작용 단계 커밋 단계\n시퀀서가 L1 롤업 컨트랙트에 배치 커밋 호출 수행 EIP-4844 블롭을 통해 상태 차이 등 필요한 데이터의 가용성 보장 증명 단계\n배치 실행의 유효성을 ZK 증명으로 생성하여 L1에 제출 검증 계약이 증명을 확인하여 상태 전이의 정당성 확립 실행 단계\n검증 완료 즉시 배치가 확정 처리되며, L2 로그를 포함한 머클 구조가 저장됨 구성 요소 Sequencer 계층\nRPC 서비스: 트랜잭션 제출, 상태 조회 등 API 제공 Sequencer: 트랜잭션 정렬·실행·블록화, 검증 제약을 준수하는 실행 파이프라인 유지 L1 연동 오퍼레이터: 입금, 업그레이드 등 L1 이벤트 동기화 및 배치 커밋 전송 역할 Prover \u0026amp; Verifier 파이프라인\n증인 생성 단계: 거래 세부 공개 없이 유효함을 입증하기 위한 데이터 구성 회로 실행 단계: VM 실행의 정합성을 검증하는 회로를 기준으로 증명 생성 및 검증 수행 연산 코드, 스토리지 상호작용, 사전컴파일 통합 등을 포함하는 실행 정합성 보장 목표 배치 전체를 순회하며 최종 상태 루트까지의 업데이트 일관성 확인 증명 압축 단계: L2에서 생성된 큰 STARK류 증명을 소형 SNARK류로 압축하여 L1 검증 비용 절감 L1 Rollup Contracts\n블롭을 사용해 상태 차이와 압축된 바이트코드 저장 유효성 증명 수신·검증 L1↔L2 메시징과 브리징 지원 네이티브 계정 추상화 Abstract의 모든 계정은 스마트 컨트랙트 계정으로 동작하며 동일한 트랜잭션 수명주기 준수 EOA와 CA 이원화 대신 IAccount 인터페이스 기반의 단일 모델 적용 EOA 지갑으로 서명해도 실행 경로에서는 기본 계정 구현체로 변환되어 처리됨 가스 지불은 본인 또는 페이마스터를 통해 유연하게 수행 가능\n트랜잭션 플로우 제출\nJSON-RPC로 트랜잭션 제출, 멤풀 적재 from 필드를 스마트 컨트랙트 계정 주소로 설정 가능 부트로더 처리\n멤풀에서 트랜잭션을 읽어 배치 단위로 처리 NonceHolder 시스템 컨트랙트 질의로 nonce 사용 여부 확인 from 주소에 코드가 없으면 기본 계정 구현으로 해석해 실행 경로 표준화 스마트 컨트랙트 계정 검증·실행\nvalidateTransaction 호출로 실행 허용 여부 판단 및 접근 제어 수행 executeTransaction 호출로 실제 실행 경로 진입 payForTransaction 또는 prepareForPaymaster 호출로 가스 지불 경로 선택 페이마스터 경로 선택적 수행\nvalidateAndPayForPaymasterTransaction 호출로 후원 여부 결정 및 가스 지불 집행 postTransaction 훅으로 사후 처리 로직 수행 가능 스마트 컨트랙트 지갑 설계 포인트 IAccount 인터페이스 구현 기반 표준 동작 확보 onlyBootloader 제약으로 부트로더 외 호출 차단 컨트랙트 배포는 시스템 컨트랙트를 통한 isSystemCall 경로 사용 효율적 실행을 위한 저수준 호출 라이브러리 활용 권장 가스 지불은 부트로더에 직접 지불 또는 페이마스터 입력 처리 함수 사용 Nonce 관리 트랜잭션 시작 전 NonceHolder 시스템 컨트랙트의 validateNonceUsage 호출로 중복 사용 방지 유효성 검사 단계에서 nonce를 소비 처리해야 함 옵션\nminNonce 증가로 해당 값 미만 nonce 일괄 사용 처리 setValueUnderNonce를 통해 특정 nonce 슬롯에 0이 아닌 값 기록 편의 메서드 incrementMinNonceIfEquals 사용 권장 NonceHolder 호출에는 트랜잭션의 isSystem 플래그 설정 필요, 시스템 호출 유틸 사용 권장 서명 검증과 EIP-1271 스마트 컨트랙트 계정은 EOA와 달리 고정 서명 검증 로직이 없으므로 EIP-1271 구현 권장 isValidSignature를 통해 임의 로직으로 서명 유효성 판단 가능, EIP-712 타입 데이터 서명과 결합 시 사용자 경험 및 보안 개선 기대\ncontract ERC1271 { // bytes4(keccak256(\u0026#34;isValidSignature(bytes32,bytes)\u0026#34;)) bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature( bytes32 _hash, bytes memory _signature ) public view returns (bytes4 magicValue) {} } Paymaster 개념 다른 계정을 대신해 가스비를 지불하는 스마트 컨트랙트 역할 IPaymaster 인터페이스 준수 필수 계정 소유자의 가스비 직접 지불을 대체해 비용 스폰서십, 토큰 기반 가스 지불 등 사용성 개선 제공 실행 경로에서는 prepareForPaymaster 이후 paymaster가 검증과 결제를 수행 오남용 방지를 위한 한도·쿨다운·화이트리스트 정책 필요\nAGW(Abstract Global Wallet) 개요 네이티브 계정 추상화를 전제로 한 사용자 온보딩 레이어 이메일, 소셜, 패스키 등 친숙한 로그인으로 최초 가입 후 동일 계정으로 트랜잭션 생성 가능 핵심은 서명자 관리와 복구, 다중 서명자, 가스 스폰서십 등 계정 수명주기 운영을 일관된 UX로 제공하는 것\nAGW 작동 방식 1단계 EOA 생성 사용자 로그인 방식을 통해 내부적으로 EOA 생성 2단계 스마트 컨트랙트 지갑 배포 배포 초기화 시 1단계 EOA를 승인된 서명자로 등록 이후 단계 서명자 추가·삭제, 패스키 기반 서명자 등록, 모듈 확장 등 계정 운영 기능 사용 스마트 컨트랙트 지갑은 네이티브 1급 시민으로 동작하며, 기본 곡선인 secp256k1 중심 운영 권장 패스키 확장 시 secp256r1 서명자 지원 가능, EIP-712 기반 서명 검증 로직 조합 권장\n스마트 지갑 기능 모듈 예 복구 모듈 이메일 복구, 가디언 복구 등 키 분실 시 계정 복원 경로 제공 페이마스터 연동 트랜잭션 가스비 후원, 특정 토큰 지불 라우팅 구성 다중 서명자 역할 기반 서명 정책, 임계값 승인 정책 확장 패스키 지원 FIDO 기반 기기 서명자를 지갑에 연결해 무서버 키 경험 제공 주의 사항과 트레이드오프 데이터 가용성 비용\n블롭 가격은 네트워크 수요에 따라 변동, 배치 크기와 커밋 주기 최적화 필요 증명 대기 시간\n증명 생성은 계산 집약적, 하드웨어와 회로 최적화 상태에 따라 지연 발생 가능 사용자 응답은 즉시성 확보 가능하나 L1 최종성은 증명 완료 이후 확보 시퀀서 검열 리스크\n단일 시퀀서 운영 시 트랜잭션 포함 지연 가능성 존재 추후 분산화 로드맵, 포크 선택 규칙, 포스 인클루전 메커니즘 고려 필요 브리징과 메시징 안전성\nL1 확정 전 교차체인 메시지 사용 시 미확정 리스크 존재 지연 큐, 취소·재시도 정책, 상태 증명 기반 수령 조건 명시 필요 페이마스터 남용 방지\n한도, 속도 제한, 수신자·함수 화이트리스트 운용 토큰 기반 가스 지불은 환산 레이트 변동과 유동성 부족 문제 고려 Nonce 경쟁과 재진행\n중복 제출 방지, 재전송 정책, minNonce 관리 정책 표준화 필요 간단 예시와 실무 팁 JSON-RPC 제출 시 from을 스마트 컨트랙트 계정 주소로 지정해 계정 자체 검증 로직 구동 검증 단계에서 nonce 소비를 먼저 처리해 재진입·중복 실행 방지 EIP-712 타입 데이터 서명 사용으로 서명 범위와 목적을 명확히 표현 부트로더 전용 함수는 onlyBootloader로 차단, 외부 호출 경로 executeTransactionFromOutside를 별도 제어 L1 상호작용은 commit → prove → execute 순서 준수, 운영 관점에서 배치 커밋 지표와 증명 큐 길이를 모니터링 운영 베스트 프랙티스 배치 정책\n수요에 따른 동적 배치 크기와 커밋 주기 조정, 블롭 단가와 증명 대기 시간의 균형 추구 가시성 확보\n시퀀서 지연, 증명 생성 시간, 실패율, 큐 길이, L1 가스 단가, 블롭 단가 대시보드화 계정 추상화 보안\nvalidateTransaction에서 호출자·서명·정책 일관성 검증, 실패 시 명시적 에러 코드 반환 페이마스터 입력 파싱과 예산 검사 철저, 사후 훅에서 외부 호출 시 재진입 방지 릴리즈 전략\n테스트넷에서 계정·페이마스터·브리징 경로를 통합 리허설, 가스 상한과 오류 복구 시나리오 검증 회로와 증명 백엔드\n회로 업데이트는 롤링 업그레이드 전략 채택, 검증 키 교체와 컨트랙트 버전 호환성 체크리스트 운영 마무리 Abstract는 ZK Rollup과 EIP-4844를 결합해 확장성과 비용 효율을 확보하고, 네이티브 계정 추상화로 개발자와 사용자의 상호작용을 단순화하는 접근을 취함 시퀀서·증명 파이프라인·L1 계약 간 경계를 명확히 하고, 계정 추상화와 페이마스터 정책을 보안 우선으로 설계하면 운영 안정성을 크게 높일 수 있음 이 문서의 개념과 베스트 프랙티스를 기준으로 트랜잭션 수명주기, 지갑 모듈, 데이터 가용성 튜닝을 체계적으로 검토할 것을 권장함\n참고자료 https://abs.xyz/ https://eips.ethereum.org/EIPS/eip-4844 https://eips.ethereum.org/EIPS/eip-1271 https://era.zksync.io/docs/ https://vitalik.ca/general/2021/01/05/rollup.html https://ethereum.org/en/roadmap/danksharding/ ","permalink":"https://blog.jsontapose.com/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAbstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표\nZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구\n핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\u003c/p\u003e\n\u003ch3 id=\"배경과-목적\"\u003e배경과 목적\u003c/h3\u003e\n\u003cp\u003e이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼\n저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적\nL2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것\nZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\u003c/p\u003e","title":"Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW"},{"content":"개요 Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임 ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음 프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\n핵심 개념과 정의 Public Client\n퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트 블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당 Wallet Client\n개인키를 보유한 계정에 대해 트랜잭션 서명과 전송을 수행하는 클라이언트 시뮬레이션, 가스 추정, nonce 처리, write 컨트랙트 호출 담당 Transport\nHTTP나 WebSocket 등 JSON-RPC 통신 방법 추상화 계층 성능과 안정성에 영향을 주는 핵심 요소 Chain 구성\nchain 객체에 chainId, 네트워크 이름, 기본 RPC 엔드포인트, 네이티브 통화 단위 등의 메타데이터 포함 올바른 체인 설정이 시뮬레이션과 서명, 전송의 전제 조건 ABI 기반 타입 안전성\nABI를 바탕으로 함수 이름, 파라미터, 반환형에 대한 타입 추론 제공 런타임 이전에 오타나 파라미터 타입 오류를 차단하는 효과 데이터 타입\n금액, 블록 번호, 가스 등 정수 값은 BigInt 반환이 기본 주소, 바이트 데이터는 0x 프리픽스 hex 문자열 사용 동작 원리와 구조 읽기 흐름\nPublic Client가 RPC 호출을 통해 블록이나 상태를 조회함 컨트랙트 읽기 시 getContract 또는 readContract 유틸을 사용하여 call 실행 쓰기 흐름\nWallet Client가 계정을 보유하고 시뮬레이션으로 가스와 파라미터를 검증한 뒤 트랜잭션 전송 simulateContract 결과를 writeContract에 그대로 전달하는 패턴이 안전하고 권장됨 분리의 이점\n읽기와 쓰기 책임이 분리되어 보안 경계와 테스트 용이성 향상 서버 환경에서는 Public Client만 배포해 민감 키가 없는 조회 전용 API 제공 가능 설치와 환경 준비 패키지 설치\nnpm install viem 필수 준비물\n신뢰 가능한 RPC 엔드포인트 URL 준비 테스트넷에서는 faucet로 ETH 확보 환경 변수로 개인키, RPC URL 등 민감정보 관리 권장 사용법 1: 네트워크 연결과 블록 조회 아래 스니펫은 메인넷에 연결하고 최신 블록과 블록 번호를 조회하는 최소 예시임\nimport { createPublicClient, http } from \u0026#34;viem\u0026#34;; import { mainnet } from \u0026#34;viem/chains\u0026#34;; const publicClient = createPublicClient({ chain: mainnet, transport: http(process.env.RPC_URL), }); const run = async () =\u0026gt; { const block = await publicClient.getBlock(); const blockNumber = await publicClient.getBlockNumber(); // block 해시, 타임스탬프, 가스 사용량 등 핵심 필드 사용 console.log(block.hash, block.timestamp, block.gasUsed); console.log(blockNumber); }; run(); blockNumber는 BigInt 반환값임 gas, 수수료, 블록 번호 등 정수 값 처리 시 숫자 오버플로 방지를 위해 BigInt 유지 또는 명시적 변환 필요 http 전송 대신 웹소켓 전송도 가능하나 서버 환경 안정성, 프록시 구성, 리밸런싱 전략 고려 필요 사용법 2: 컨트랙트 읽기와 쓰기 한 스니펫에서 읽기와 쓰기를 묶어 핵심 흐름만 정리함\nimport { getContract, createPublicClient, createWalletClient, http, } from \u0026#34;viem\u0026#34;; import { sepolia } from \u0026#34;viem/chains\u0026#34;; import { privateKeyToAccount } from \u0026#34;viem/accounts\u0026#34;; const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.RPC_URL), }); const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`); const walletClient = createWalletClient({ account, chain: sepolia, transport: http(process.env.RPC_URL), }); // 읽기 예시 const contract = getContract({ address: \u0026#34;0xYourContractAddress\u0026#34;, abi: YourAbi, client: publicClient, }); const name = await contract.read.name(); // 쓰기 예시 const { request } = await publicClient.simulateContract({ address: \u0026#34;0xYourContractAddress\u0026#34;, abi: YourAbi, functionName: \u0026#34;store\u0026#34;, args: [100n], account, }); const txHash = await walletClient.writeContract(request); console.log(name, txHash); address에는 목표 컨트랙트 주소 입력 abi에는 실제 ABI 배열 주입 read 호출은 call을 사용하므로 가스 소모 없음 write 호출은 시뮬레이션으로 가스, 인자, 권한 문제를 사전 검증한 뒤 전송 txHash로 익스플로러에서 상태 확인 가능 동작 살펴보기와 실전 팁 getContract와 read\ngetContract는 ABI를 바탕으로 타입 안전한 메서드 집합 생성 contract.read.balanceOf(\u0026lsquo;0x\u0026hellip;\u0026rsquo;)처럼 각 함수가 자동 완성되며 잘못된 함수명이나 인자 타입을 컴파일 타임에 차단 simulateContract와 writeContract\n시뮬레이션 단계에서 revert 이유와 디코딩된 오류를 확인 가능 request에는 to, data, value, gas, maxFeePerGas 등 전송에 필요한 필드가 완성되어 포함됨 writeContract에 request를 그대로 넘겨 불일치 위험 최소화 가스 수수료와 EIP-1559\n대부분 체인은 baseFee 기반의 maxFeePerGas, maxPriorityFeePerGas 조합 사용 시뮬레이션 결과를 그대로 쓰거나, 트래픽이 많은 시간대에는 우선순위 수수료를 다소 상향해 확정 속도 확보 BigInt와 단위 처리\nERC-20 amount, 수수료 모두 BigInt로 다룸 parseUnits, formatUnits 유틸 사용으로 10진 문자열과 wei 단위 간 변환 안정화 체인 불일치와 계정 네트워크\nwalletClient와 simulateContract의 chain은 동일해야 함 RPC URL이 다른 체인을 가리키면 nonce, 수수료, 시뮬레이션 결과가 어긋나 실패 가능 주의사항과 한계 개인키 보호\nPRIVATE_KEY는 서버 비밀 변수 관리 또는 HSM, KMS 연동 고려 프런트엔드 환경에 개인키 하드코딩 금지 RPC 신뢰도와 레이트 리밋\n공용 RPC는 속도와 가용성이 낮을 수 있음 상용 환경은 신뢰 가능한 제공자와 백업 엔드포인트 구성 권장 재시도와 오류 처리\n네트워크 에러, 서버 오류, 체인 재구성 등 다양한 실패 케이스 존재 지수 백오프, idempotency 고려, 트랜잭션 재전송 시 nonce 관리 필요 테스트넷과 가스\n테스트넷은 faucet 지급 지연, 빈 블록, 비활성 노드 등 특성이 존재 가스 부족, 체인 혼잡에 따른 확정 지연을 정상 동작 범위로 간주할 수 있어야 함 ABI 신뢰성\n오타 또는 잘못된 ABI는 런타임 revert를 유발함 배포된 바이트코드와 ABI 매칭 검증 권장 베스트 프랙티스 시뮬레이션 우선 전략\n모든 write 호출 전 simulateContract로 가스와 인자 검증 환경 변수 분리\nRPC_URL, PRIVATE_KEY, CONTRACT_ADDRESS를 환경 변수로 분리해 배포 환경별 설정 편의 확보 블록 간 일관성\n이벤트나 상태를 조합해 읽을 때는 동일 블록 높이 기준을 유지하는 스냅샷 전략 고려 멀티콜 활용\n여러 read를 묶어 왕복 비용 절감 가능 로깅과 관찰성\ntxHash, nonce, gasUsed, effectiveFeePerGas, 블록 번호를 구조화 로그로 남겨 운영 이슈 분석 용이성 확보 간단 예시로 보는 검증 흐름 writeContract에서 반환된 txHash 확인 체인 익스플로러에서 해당 txHash 조회로 블록 포함 여부, 리시트 상태, 이벤트 로그 검증 컨트랙트의 view 함수로 최종 상태 교차 확인 이 흐름을 자동화해 배치나 백엔드 작업에서 신뢰도 있는 완료 판정 기준으로 사용 가능\n마무리 Viem은 읽기와 쓰기 클라이언트 분리, 시뮬레이션 중심의 전송 흐름, 타입 안전한 ABI 접근이라는 명확한 철학을 가짐 이 기본기만 갖추면 블록 조회, 컨트랙트 읽기, 트랜잭션 생성이라는 세 가지 축을 빠르게 실무에 적용 가능 개인키와 RPC 관리, 시뮬레이션과 가스 전략, 오류 처리라는 운영 디테일을 함께 설계하면 프로덕션에서도 일관된 안정성을 확보할 수 있음\n참고자료 https://viem.sh/docs https://viem.sh/docs/clients/public https://viem.sh/docs/clients/wallet https://viem.sh/docs/actions/public/getBlock https://viem.sh/docs/contract/readContract https://viem.sh/docs/contract/writeContract https://ethereum.org/en/developers/docs/apis/json-rpc https://etherscan.io https://docs.alchemy.com/reference/ethereum-apis ","permalink":"https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eViem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임\nethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음\n프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePublic Client\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트\u003c/li\u003e\n\u003cli\u003e블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWallet Client\u003c/p\u003e","title":"Viem으로 이더리움 읽기·쓰기 시작하기 가이드"},{"content":"개요 영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함 블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임 이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\n목적과 맥락 비밀을 공개하지 않고 유효성만 검증하려는 요구 증가 퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대 오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구 핵심 개념과 정의 Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체 Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체 Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식 Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명 Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제 Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립 영지식 증명의 세 가지 성질 완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨 건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤 영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함 직관적 예시 알리바바 동굴 동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음 검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함 Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2 k회 독립 반복하면 모두 속일 확률 2^-k로 급감 검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함 핵심 포인트\n비밀 노출 없이 유효성만 확인 가능 무작위 도전과 반복으로 사기 가능성 급감 대화 기록만으로 비밀 자체를 유추 불가 형식적 관점과 시뮬레이터 대화형 증명은 Prover P와 Verifier V가 커밋-챌린지-리스폰스 구조로 상호작용함 Transcript는 도전값과 응답 및 공개 상태를 포함하는 관찰 기록을 의미함 영지식성은 시뮬레이터 S가 비밀 없이도 실제와 분포가 같은 Transcript를 생성할 수 있음을 요구함 의미는 검증자가 얻은 정보가 공개 난수로도 재현 가능한 수준에 한정됨을 보장한다는 것임 사전 공모 이슈와 설계 포인트 대화형 프로토콜에선 검증자와 Prover가 사전 공모했다면 제3자는 배제 불가 이슈가 생김 이 경우를 지정 검증자 영지식 designated-verifier ZK로 분류 가능 공개 검증이 필요하면 비대화형 영지식 NIZK 또는 공개 검증 가능한 Σ-프로토콜 조합을 사용해 누구나 검증 가능하게 설계 필요 Fiat–Shamir 변환으로 도전값을 해시로 결정하면 제3자도 단일 증명을 검증 가능 운영 시 검증자의 내부 시드나 도전값 생성 과정을 과도하게 공개하면 지정 검증자 시나리오의 영지식성이 약화될 수 있음 대화형과 비대화형 대화형 Interactive 실시간으로 도전과 응답을 주고받는 구조. 장점은 단순성과 강한 보안 모델. 단점은 왕복 상호작용과 제3자 설득 한계 가능 비대화형 Non-Interactive 하나의 짧은 증명을 생성해 누구나 검증. Fiat–Shamir로 대화형 도전을 해시로 대체. SNARK와 STARK 등에서 표준 사용 트레이드오프 네트워크 왕복 제거와 공개 검증 가능성 vs 해시를 랜덤 오라클로 보는 가정과 경우에 따라 신뢰 설정 필요 디지털 서명과의 차이 신원 노출 서명은 공개키로 서명자 신원이 구조적으로 드러남. ZK는 신원과 비밀 모두 숨기고 유효성만 증명 가능 제3자 설득 서명은 메시지-서명 쌍을 누구나 검증 가능해 완전 설득 지향. ZK도 NIZK나 공개 검증 가능한 구성에선 제3자 설득 가능. 다만 지정 검증자 ZK에선 제3자 설득이 제한됨 프록시 릴레이 공격 대화형 식별 프로토콜은 중간자 릴레이 공격 위험 존재. 세션 바인딩과 채널 인증, 도전값 바인딩으로 완화 필요. 서명은 보통 프로토콜 레벨 인증과 채널 보안으로 대응 연결 고리 Σ-프로토콜에 Fiat–Shamir를 적용하면 서명 스킴으로 전환 가능. 대표가 Schnorr 서명임 ZKP Under the Hood 이산로그 기반 Σ-프로토콜 가장 고전적인 지식증명은 이산로그 가정 위에서 동작함 공통 입력 y = g^x mod p에서 x가 비밀이며 Prover는 x를 안다는 사실을 증명함\n기본 설정 큰 소수 p와 생성원 g를 가진 소수 차수 q 부분군 선택. 연산은 지수에서 mod q로 수행 공통 값 y = g^x mod p는 공개. x는 Prover만 아는 비밀 1비트 챌린지 버전 직관 커밋 Prover가 임의의 r를 뽑아 C = g^r mod p 전송 챌린지 Verifier가 z ∈ {0,1} 전송 응답 z = 0이면 r 공개. z = 1이면 s = r + x mod q 공개 검증 z = 0이면 g^r ≟ C 확인. z = 1이면 g^s ≟ C · y 확인 Prover가 x를 모르면 두 경우를 동시에 만족시키는 응답을 준비 불가. 1회 속임 확률 1/2. k회 반복 시 2^-k로 감소 일반화된 Schnorr 식별 프로토콜 도전값 c를 Z_q에서 무작위 선택 커밋 C = g^r 응답 s = r + c·x mod q 검증 g^s ≟ C · y^c 비대화형으로는 c = H(domain, context, g, y, C)로 정하고 단일 증명을 생성함. 여기서 H는 도메인 분리와 컨텍스트 바인딩을 포함한 해시 함수이며 랜덤 오라클 가정 하에서 분석함 주의사항 안전한 구현은 군 차수 q 기준으로 지수 연산 수행 필요 r은 CSPRNG로 매 증명마다 새로 생성. r 재사용은 즉시 비밀 유출로 이어짐 해시 입력엔 도메인 분리 태그와 세션 ID, 검증자 식별 등 컨텍스트를 바인딩해 재생 공격과 교차 프로토콜 간섭을 방지 필요 간단 검증 스니펫 예시 아래는 원리 전달용 최소 형태임. 실제 구현에선 안전한 군 선택, 상수시간 연산, 에러 처리 포함 필요\n## 공개 파라미터 p, g, y와 커밋 C, 도전 z, 응답 resp를 검증하는 예시 def verify_one_bit(p, g, y, C, z, resp): if z == 0: ## resp == r return pow(g, resp, p) == C else: ## resp == s = r + x mod q return pow(g, resp, p) == (C * y) % p def verify_schnorr(p, g, y, C, c, s): ## 일반형 검증식 g^s == C * y^c mod p left = pow(g, s, p) right = (C * pow(y, c, p)) % p return left == right 확률적 보장과 파라미터 선택 1회 속임 확률은 1 / |ChallengeSpace| 임 1비트 도전이면 1/2. k회 독립 반복 시 2^-k로 수렴 NIZK나 공개 검증에서는 도전 공간을 128비트 이상으로 설정해 단일 증명으로 충분한 사운드니스 확보 권장 블록체인 환경에서는 검증 비용과 증명 크기, 사운드니스 비트를 함께 고려해 회로 크기와 파라미터를 선택 필요 설계 포인트와 운영 수칙 그룹과 곡선 선택 secp256k1, P-256, BLS12-381, Bandersnatch, ristretto255 등 표준 계열 우선 고려 난수 생성 CSPRNG 필수. 커밋 nonce r 재사용 금지. 시스템 RNG 품질 모니터링 필요 파라미터 바인딩 도전 해시에 프로토콜 식별자, 세션 ID, 검증자 식별 또는 채널 특성 포함해 세션 고정 효과 확보 트랜스크립트 관리 지정 검증자 시나리오에서는 불필요한 내부 난수 공개를 줄임. 공개 검증 목표면 처음부터 NIZK 또는 SNARK류 선택 부채널 대응 타이밍 누수와 캐시 기반 누수에 대비해 상수시간 구현과 블라인딩 적용 리플레이 및 릴레이 방지 세션 바인딩, nonce, 타임스탬프, 채널 인증 적용 회귀 방지 회로나 명세 변경 시 검증 규칙에 대한 테스트 자동화와 호환성 체크 필요 SNARK vs STARK vs Bulletproofs 한눈 비교 항목 SNARK STARK Bulletproofs 설정 일부 시스템 신뢰 설정 필요. Plonk류는 범용 SRS 가능 투명 설정. 신뢰 설정 불요 신뢰 설정 불요 증명 크기 매우 작음 수십 바이트 수준까지 가능 비교적 큼 수십 KB 이상 로그 크기. 범위증명은 수 KB 수준 검증 비용 빠름. 온체인 친화적 보통에서 빠름. 해시 중심 검증 비용 큼. 집계로 완화 가능 보안 가정 페어링과 다항식 약속 등 수학적 가정 해시 기반 IOP와 FRI. 포스트 양자 내성 기대 내적 논증 기반. 일반군 가정 활용 예 zkEVM, 롤업, 영지식 브리지 투명한 롤업, 대규모 추적 증명 범위증명, UTXO 프라이버시 각 계열의 실제 성능은 구현과 회로 구조, 하드웨어에 크게 의존함\n블록체인 적용 예 잔액과 금액을 숨긴 비공개 전송과 감사 가능성 확보 신원 속성 최소 공개 KYC 예 나이 이상 여부만 증명 영지식 롤업 상태 전개 증명과 데이터 가용성 보완 오라클 입력의 유효성 증명과 오프체인 계산 검증 MPC와 결합한 다자 프라이버시 계산의 결과 정합성 증명 자주 묻는 질문 ZK면 항상 제3자 설득 불가임? 아님. NIZK나 공개 검증 가능한 구성에선 누구나 검증 가능함 STARK는 포스트 양자 보안 보장임? 양자에 대해 알려진 공격이 약하다는 의미의 내성 기대 수준임. 수학적 증명된 보장은 아님 왜 r 재사용이 위험함? 서로 다른 도전에 같은 r을 쓰면 x가 선형식으로 노출됨 왜 q 모듈러를 강조함? 안전한 지수 연산의 정의역은 군 차수 q이기 때문임. p-1 전역 모듈러는 안전하지 않을 수 있음 검증과 회귀 방지 체크리스트 사운드니스 목표 비트와 도전 공간이 요구 수준 충족하는지 점검 난수 생성 모듈 품질과 시드 관리 상태 감사 도메인 분리 태그와 세션 ID가 해시 입력에 포함되는지 확인 재생 공격과 프록시 릴레이 가능성에 대한 테스트와 채널 인증 적용 상수시간 연산 준수 여부와 메모리 접근 패턴 누수 점검 회로 변경 시 검증 규칙 스냅샷과 회귀 테스트 자동화 마무리 영지식 증명은 비밀을 드러내지 않고도 유효성을 설득하는 체계임 완전성-건전성-영지식성의 삼각을 이해하고 대화형과 비대화형의 차이를 파악하면 설계 선택이 명확해짐 실무에서는 안전한 군 선택과 난수, 도전 공간 크기, 세션 및 채널 바인딩, 신뢰 설정과 부채널 대응을 종합적으로 관리 필요 목표는 비밀을 지키면서도 누구나 또는 지정된 상대가 납득할 수 있는 검증 가능한 시스템을 만드는 것임\n참고 링크 https://en.wikipedia.org/wiki/Zero-knowledge_proof https://en.wikipedia.org/wiki/Interactive_proof_system https://en.wikipedia.org/wiki/Schnorr_identification https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic https://en.wikipedia.org/wiki/SNARK https://en.wikipedia.org/wiki/STARK_(cryptography) https://en.wikipedia.org/wiki/Bulletproofs https://hyun-jeong.medium.com ","permalink":"https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함\n블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임\n이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\u003c/p\u003e\n\u003ch2 id=\"목적과-맥락\"\u003e목적과 맥락\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e비밀을 공개하지 않고 유효성만 검증하려는 요구 증가\u003c/li\u003e\n\u003cli\u003e퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대\u003c/li\u003e\n\u003cli\u003e오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProver 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체\u003c/li\u003e\n\u003cli\u003eVerifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체\u003c/li\u003e\n\u003cli\u003eWitness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식\u003c/li\u003e\n\u003cli\u003eStatement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명\u003c/li\u003e\n\u003cli\u003eChallenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제\u003c/li\u003e\n\u003cli\u003eTranscript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"영지식-증명의-세-가지-성질\"\u003e영지식 증명의 세 가지 성질\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨\u003c/li\u003e\n\u003cli\u003e건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤\u003c/li\u003e\n\u003cli\u003e영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"직관적-예시-알리바바-동굴\"\u003e직관적 예시 알리바바 동굴\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음\u003c/li\u003e\n\u003cli\u003e검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함\u003c/li\u003e\n\u003cli\u003eProver가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2\u003c/li\u003e\n\u003cli\u003ek회 독립 반복하면 모두 속일 확률 2^-k로 급감\u003c/li\u003e\n\u003cli\u003e검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e핵심 포인트\u003c/p\u003e","title":"영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이"},{"content":"개념과 배경 Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함 짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨 노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\n핵심 용어 정리 스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\n오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\n리오그 깊이 교체되는 블록의 개수로 측정함\n메인 체인 선택 규칙\nPoW에선 누적 작업량이 큰 체인이 우선됨 이더리움 PoS에선 LMD-GHOST 포크초이스를 따르되 마지막 최종화 지점 하위만 후보가 됨 왜 리오그가 생김 네트워크 지연이나 전파 경합으로 같은 높이의 블록이 동시에 생성됨 일부 노드는 A를, 다른 노드는 B를 바탕으로 다음 블록을 쌓음 시간이 지나 우세한 체인이 결정되면 노드가 그 체인으로 교체함 버려진 체인의 트랜잭션은 소실되는 게 아니라 다시 메모풀로 돌아가 재포함을 기다림 합의별 리오그의 차이 PoW 계열 직관 우세 체인 기준은 블록 수가 아니라 누적 작업량임 자연 발생 리오그는 보통 깊이 1에서 끝남 보안 관례로 비트코인은 6컨펌 정도를 사람·서비스가 안전 구간으로 삼는 경우가 많음 다수 해시 파워를 가진 상대는 더 깊은 리오그를 인위적으로 만들 수 있으므로 고가치 결제일수록 더 많은 컨펌을 기다리는 전략이 쓰임 이더리움 PoS 직관 슬롯은 12초, 32슬롯이 1에폭이며 포크초이스는 LMD-GHOST와 FFG 최종화 규칙을 함께 사용함 헤드는 가장 최근 가중치가 높은 체인 머리, 세이프 헤드는 보수적 추정, 파이널라이즈드는 FFG로 최종화된 체크포인트 아래 체인 상태를 뜻함 정상 조건에선 리오그 깊이가 작고 파이널라이즈드 이후로의 리오그는 대규모 비정상 행동 없이는 사실상 불가에 가까움 대략 두 개의 에폭이 지나면 보통 최종화되어 실사용에선 약 12분 남짓을 강한 확정 구간으로 본다는 관례가 있음 환경과 네트워크 상황에 따라 달라질 수 있음 L2에서의 리오그 관점 L2→L1 메시지는 L1에 기록되고 관련 규칙을 충족하면 재전송하지 않음 옵티미스틱 롤업은 챌린지 윈도우가 지나야 강한 확정으로 취급하며 그 전에는 지연을 감안해야 함 L1이 뒤집히는 아주 이례적인 상황을 제외하면 L1에 최종적으로 기록된 상태는 다시 뒤집히지 않는다는 점을 전제로 시스템을 설계함 리오그와 헷갈리기 쉬운 것들 RBF나 수수료 경쟁으로 인해 메모풀에서 트랜잭션이 교체되는 현상은 리오그와 별개임 프로토콜 업그레이드를 위한 하드포크는 합의 규칙 자체를 바꾸는 이벤트이며 자연 발생 리오그와는 범주가 다름 과거 이더리움 PoW 시절의 옴머 포함은 스테일 블록 보상 메커니즘일 뿐 리오그 자체가 아님 서비스 설계에 미치는 영향 결제와 출금\n자산·위험도·체인별로 컨펌 수 정책을 문서화해 운영함 고가치 결제는 더 많은 컨펌을 요구하고 저가치·소액은 사용자 경험을 위해 낮출 수 있음 데이터 처리\n인덱싱은 높이만 저장하지 말고 블록 해시와 부모 해시를 함께 저장 리오그 감지 시 롤백 가능한 저널을 두고 되감기 후 재처리 트랜잭션 처리\n멱등성 확보를 위해 논스·컨트랙트 상태·이벤트 ID를 함께 검증 재방송은 동일 논스로 수행해 중복 실행을 피함 UX\n잠정 상태 표시와 컨펌 카운터 제공 세이프 헤드와 파이널라이즈드의 차이를 사용자에게 명확히 안내 리오그 감지와 대응 패턴 헤드 해시 변화 모니터링과 특정 깊이 이상 변화시 경보\n최신 N개 블록의 체인ID·높이·해시·부모 해시·도착 시각을 원장과 별도 테이블에 윈도우로 관리\n확정 레벨별로 파이프라인을 분기\n헤드 기준 실시간 기능 세이프 기준 중요 알림 파이널 기준 영구 저장 간단 의사코드\nonNewBlock(b): save(b.height, b.hash, b.parent) if parentNotHead(): // reorg 발생 rollbackUntilCommonAncestor() replayFromAncestor() routePipelinesByCommitment(head, safe, finalized) 운영 체크리스트 컨펌 정책과 리오그 최대 허용 깊도가 문서화되어 있음 인덱서가 롤백과 재처리를 지원함 알림 시스템이 헤드 전환과 리오그 이벤트를 기록함 파이널라이즈드 구간만 영구 저장하거나 백그라운드 확정화 작업을 운영함 L2의 챌린지 윈도우와 브리지 지연을 고려해 타임라인을 설계함 간단 시나리오 한국과 미국에서 같은 높이 블록이 동시에 생성됨 각 지역 노드가 자신이 먼저 본 블록 위로 다음 블록을 쌓음 한쪽 체인이 한 블록 더 빨리 쌓이며 우세해지면 다른 쪽은 스테일 처리됨 스테일 체인에 있던 거래는 메모풀로 돌아가 메인 체인에 재포함을 기다림\n참고자료 https://en.bitcoin.it/wiki/Chain_Reorganization?utm_source=chatgpt.com https://learnmeabitcoin.com/technical/blockchain/chain-reorganization/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/?utm_source=chatgpt.com https://www.alchemy.com/overviews/ethereum-commitment-levels?utm_source=chatgpt.com ","permalink":"https://blog.jsontapose.com/posts/blockchain-reorg-chain-reorganization-f4966a/","summary":"\u003ch2 id=\"개념과-배경\"\u003e개념과 배경\u003c/h2\u003e\n\u003cp\u003eReorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함\n짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨\n노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\u003c/p\u003e\n\u003ch2 id=\"핵심-용어-정리\"\u003e핵심 용어 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\u003c/p\u003e","title":"블록체인 Reorg(체인 재구성) 이해"},{"content":"개요 프라이빗키 관리 방식에 따라 암호화폐 월렛은 커스토디얼(custodial) 과 논커스토디얼(noncustodial) 로 구분됨 각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 초보자도 이해할 수 있게 정리하면서 실무자가 바로 적용할 수 있는 체크리스트까지 제시함\n핵심 개념 커스토디얼 월렛 제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조 로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\n논커스토디얼 월렛 사용자가 프라이빗키를 직접 보유·관리하는 구조 브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\n핵심 차이 한 줄 정리 키의 소유·통제 주체가 제3자인가 사용자 본인인가의 차이\n모델별 동작 원리와 구성 커스토디얼 키 보관 중앙화된 키 보관소와 접근제어 체계를 운용 보통 핫월렛 과 콜드월렛 을 분리해 즉시성 vs 보관 안정성을 균형 있게 설계함 운영 통제 권한 분리, 변경 이력 추적, 승인 워크플로, 이상 징후 모니터링을 포함 유저 경험 계정 비밀번호·2FA 등 웹서비스 UX에 가깝고 분실 시 고객지원으로 복구 가능성이 있음 논커스토디얼 키 생성·저장·복구를 사용자 단말 또는 전용 기기에서 수행 하드웨어 지갑은 기기 내 보안영역에서 서명 연산을 수행해 키를 외부로 노출하지 않음 시드 문구(BIP‑39) 와 HD 지갑(BIP‑32, BIP‑44) 로 여러 주소를 파생해 사용함 분실·도난·손상에 대비한 백업·복구 절차가 필수임 하이브리드 접근 멀티시그 N개 중 M개 서명이 있어야 지출 가능 운영자 간 책임 분산과 단일 키 손실 리스크 완화에 효과적 키 분할과 복구 Shamir Secret Sharing 은 백업·복구에 적합하나 서명 자체는 수행하지 않음 임계값 서명(MPC/TSS) 여러 파티가 키 조각을 재조합 없이 공동 서명 단일 실패 지점 제거와 유연한 권한 정책이 장점 보안·규제·운영 관점 비교 구분 커스토디얼 논커스토디얼 키 소유 서비스 사업자 사용자 복구 용이성 계정 기반 복구 지원 가능 사용자가 책임, 백업 실패 시 복구 불가 보안 초점 내부자 위협·핫월렛 침해·운영 취약점 피싱·악성코드·물리 분실·백업 실패 컴플라이언스 관할에 따라 수탁 라이선스·KYC/AML 등 요구 가능 개인 사용은 상대적으로 자유, 조직은 회계·규정 준수 정책 필요 확장성/운영 기업 통제·감사 로그·승인 워크플로에 유리 사용자 자율성 최상, 표준화된 기업 통제는 구현 난이도 존재 일반 용도 거래소·커스터디 업체·핀테크 개인 보관·DAO 금고·개별 팀 지갑 위협 모델 수립 가이드 가치와 빈도 소액·빈번 결제는 접근성·자동화 우선, 대액·장기 보관은 보존·격리가 우선 공격면 피싱 링크·악성 확장프로그램·사기 승인 서명, 내부자 오남용, 인프라 취약점, 물리적 분실 복구 요구 사람 교체·기기 손상·지역 재해 등 현실 시나리오에서 얼마나 빨리 복구 가능한지 평가 감사 가능성 로그 불변성·승인 이력·역활분리와 규정 준수 증빙 가능성 점검 커스토디얼 선택 체크리스트 운영 보안 핫·콜드 분리, 다중인증, 권한 분리, 변경관리, 침해사고 대응 계획 보유 여부 키 관리 체계 HSM 또는 동급 보안 모듈 사용, 키 생성·보관·회전 절차 문서화, 접근 통제 로그 유지 감사·인증 SOC 2 Type II, ISO/IEC 27001, 취약점 스캐닝·모의침투 주기 운영 여부 재무·보험 보험 범위와 면책 조항을 명확히 공개하는지, 준비금·준법 체계 확인 규제 준수 관할 내 라이선스·KYC/AML 의무 이행, 제재 대응 정책 보유 논커스토디얼 선택 체크리스트 백업·복구 시드 문구 오프라인 보관, 금고·내화 금속 플레이트 등 물리 보안, 복구 리허설 정기 수행 기기 보안 하드웨어 지갑 사용, 펌웨어 서명 검증, 기기 PIN·패스프레이즈 사용, 분실 시 스스로 wipe 가능한지 확인 트랜잭션 안전 서명 전 도메인 분리 정보를 기기 화면에서 직접 확인, 승인 범위·스팸 토큰·허가 영속성 점검 멀티시그·MPC 병용 단일 키 실패 지점 제거, 역할 기반 승인 정책 적용 자동화 요구 스케줄 결제·트리거 송금 등 자동화는 지갑 권한 최소화와 일회성 권한 부여로 제한 운영 베스트 프랙티스 핵심 원칙 최소 권한, 강한 인증, 분리 보관, 반복 검증 지출 정책 금액 구간별 다른 승인 경로 적용, 시간지연 타임락과 알림으로 오탐·오남용 방지 주소 화이트리스트 높은 금액은 사전 등록 주소로만 송금 모니터링 대기열 이상, 실패율 급증, 신규 승인 요청 급증, 지출 한도 임계 접근 알림 키 수명주기 관리 생성·배포·사용·보관·회수·폐기 전 과정 문서화와 정기 점검 사고 대응 유출 의심 즉시 키 회전, 멀티시그 참여자 교체, 브리지·거래소 연락망 업데이트, 법무·준법 협업 라인 확보 시나리오별 권장 아키텍처 개인 사용자 데일리 소액은 모바일 지갑 사용 장기 보관·대액은 하드웨어 지갑과 오프라인 백업 병행 승인 내역 정기 점검과 피싱 훈련 연습 권장\n소규모 팀/스타트업 운영비 지출용 커스토디얼 핫월렛 + 멀티시그 콜드 보관 회계·승인 로그를 공유 드라이브가 아닌 전용 감사 시스템에 적재\n기업·DAO 금고 MPC 기반 금고 또는 다중 하드웨어 지갑 멀티시그 역할 기반 접근제어와 오프보딩 절차, 비상 시나리오의 대체 서명자 지정\n자주 하는 실수와 교정 Shamir 분할 = 안전한 서명이라고 오해 Shamir는 복구용 비밀 분할 기법이고 서명은 수행하지 않음 서명 분산은 MPC/TSS 를 사용함 하드웨어 지갑이면 무조건 안전 펌웨어 진위 검증, 공급망 위협, 화면 검증 습관 없으면 위험이 남음 보험이 있으니 안심 보험은 조건과 면책이 많아 모든 손실을 보장하지 않음 범위·상한·예외를 반드시 확인해야 함 커스토디얼은 모두 동일 보안 수준·감사 성숙도·규제 준수·재무 건전성에 큰 차이가 있음 최소 보안 기준 가이드 개인 하드웨어 지갑 1대 이상, 시드 문구 오프라인 백업 2곳, 패스프레이즈 병행, 피싱 훈련 팀 멀티시그 M‑of‑N, 변경 승인 워크플로, 월간 복구 리허설, 화이트리스트 송금 기업 MPC 금고 또는 멀티시그 금고, HSM 또는 동급 보안 모듈, SOC 2 Type II·침투테스트, 사고 대응 플레이북 운영 간단 권장 흐름 1 단계 자산 규모 분류와 위협 모델 정의 2 단계 논커스토디얼·커스토디얼·하이브리드 중 적합 아키텍처 선정 3 단계 백업·복구 문서화와 정기 리허설 시행 4 단계 멀티시그 또는 MPC로 단일 실패 지점 제거 5 단계 지출 정책·화이트리스트·모니터링·사고 대응 체계 운영\n결론 프라이빗키 소유·통제가 보안과 편의의 출발점임 대액·장기 자산은 논커스토디얼과 멀티시그·MPC 조합이 유리하고 업무 자동화·고객 지원이 중요한 경우 커스토디얼이 효율적일 수 있음 모든 선택은 위협 모델·규정 준수·복구 요구를 기준으로 문서화하고 정기적으로 검증해야 함\n참고자료 BIP‑32 계층적 결정성 지갑 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP‑39 니모닉 문구 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP‑44 파생 경로 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki Torus Key Infrastructure 개요 https://docs.tor.us/key-infrastructure/overview NIST SP 800‑57 Part 1 키 관리 권고 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final FIPS 140‑3 암호 모듈 보안 요구사항 https://csrc.nist.gov/publications/detail/fips/140/3/final AICPA SOC 2 안내 https://www.aicpa-cima.com/resources/article/what-is-soc-2 ","permalink":"https://blog.jsontapose.com/posts/custodial-vs-noncustodial-wallets-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e프라이빗키 관리 방식에 따라 암호화폐 월렛은 \u003cstrong\u003e커스토디얼(custodial)\u003c/strong\u003e 과 \u003cstrong\u003e논커스토디얼(noncustodial)\u003c/strong\u003e 로 구분됨\n각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 \u003cstrong\u003e초보자도 이해할 수 있게\u003c/strong\u003e 정리하면서 \u003cstrong\u003e실무자가 바로 적용할 수 있는 체크리스트\u003c/strong\u003e까지 제시함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e커스토디얼 월렛\u003c/strong\u003e\n제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조\n로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e논커스토디얼 월렛\u003c/strong\u003e\n사용자가 프라이빗키를 직접 보유·관리하는 구조\n브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e핵심 차이 한 줄 정리\u003c/strong\u003e\n키의 \u003cstrong\u003e소유·통제 주체\u003c/strong\u003e가 제3자인가 사용자 본인인가의 차이\u003c/p\u003e","title":"커스토디얼 vs 논커스토디얼 월렛 비교"},{"content":"개요 블록체인은 중앙 기관 없이 참여자들이 거래를 기록·검증·공유하는 분산 원장 기술임 이 글은 블록체인을 초보자 친화적으로 설명하고, 실무 체크리스트까지 정리함\n큰 그림: 시스템 구성 노드(Node): 블록체인 소프트웨어 실행 주체\n풀노드: 모든 블록·트랜잭션 검증·저장 라이트 클라이언트: 헤더·머클 증명 기반 최소 검증 (참고) 아카이브 노드: 오래된 상태 포함 전체 상태 유지(필수 아님) 블록(Block): 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\n합의(Consensus): 어떤 블록이 정식 이력인지 네트워크가 공동으로 결정하는 규칙\nPoW: 작업증명(연산 경쟁) PoS: 지분증명(검증자·보증금 기반) 해시(Hash)와 위·변조 방지 해시 함수(SHA-256, Keccak-256 등): 입력을 고정 길이로 압축하는 일방향 함수임\n충돌 가능성은 이론상 존재하나 실무적으로 극히 낮음 입력이 조금만 바뀌어도 출력이 크게 달라져 무결성 검증에 적합 체인 무결성: 각 블록 헤더에 이전 블록의 해시가 포함됨 → 중간 블록 하나만 바꿔도 이후 전체를 재계산해야 하므로 변조 난이도 매우 높음\n블록헤더와 머클트리(데이터 구조) 블록헤더 대표 필드(비트코인 예시)\nversion, prev_block_hash, merkle_root, timestamp, bits(난이도), nonce 헤더 전체를 해시한 값이 블록 ID 역할을 함 머클트리(Merkle Tree)\n트랜잭션 목록을 해시 이진트리로 요약 → 머클루트(루트 해시) 로 대표 라이트 클라이언트는 머클 증명만 받아 특정 트랜잭션 포함 여부를 검증 가능(SPV) 거래 흐름: 생성 → 서명 → 전파 → 블록 포함 → 확정 생성: 송신자가 수신자 주소·금액으로 트랜잭션 생성 서명: 개인키로 전자서명(비대칭키: ECDSA/secp256k1 등) 전파: P2P 네트워크로 브로드캐스트 → 각 노드의 mempool 에 적재 블록 포함: 합의 규칙에 따라 트랜잭션이 블록에 포함 확정(Finality/확인수): 후속 블록이 더해질수록 되돌리기 어려움 비트코인: 평균 블록 간격 ≈ 10분, 확인수 6 관행(사용처·금액 따라 상이) 이더리움(현행 PoS): 슬롯 ≈ 12초, 체크포인트·파이널리티 개념 사용(정상 시 약 2 에폭에서 최종화, 대략 10~15분 수준). “N 블록이면 충분” 같은 단정 대신 파이널리티 달성 여부 확인이 안전함 상태 모델: UTXO vs 계정(Account) UTXO(비트코인 계열)\n“사용하지 않은 트랜잭션 출력(코인)”을 조합해 지불, 잔돈은 새 UTXO로 생성 장점: 병렬화에 유리, 프라이버시 패턴 일부 이점 유의: 선택/잔돈 전략, 수수료(단위: sat/vByte) 최적화 필요 계정 모델(이더리움 계열)\n계정 잔액·컨트랙트 상태(State) 갱신 장점: 스마트 컨트랙트·상태머신 구현 용이 유의: 상태 증가(State bloat)·가스 비용·리플레이 방지(EIP-155) 등 고려 PoW(작업증명): 난이도·보상·보안 원리: 헤더 + nonce 바꿔가며 목표값(난이도) 이하 해시 찾기 난이도 조정: 네트워크 해시파워 변화에 맞춰 목표 평균 블록 시간 유지(예: 비트코인 2016블록마다 ≈ 2주 간격 조정) 보상: 블록 보상(반감기 존재) + 수수료 보안성: 공격자는 네트워크 해시의 과반수 수준 필요 → 대형 체인에서는 경제적·물리적 비용 거대 간단 PoW 의사코드(개념 학습용)\ntarget = difficulty_to_target(bits) nonce = 0 while True: header = serialize(version, prev_hash, merkle_root, timestamp, bits, nonce) h = sha256d(header) # SHA256(SHA256(header)) if h \u0026lt; target: print(\u0026#34;Found!\u0026#34;, nonce, h.hex()) break nonce += 1 실무 팁\n해시 라이브러리·엔디언 처리·직렬화 포맷(가변 길이 정수 등) 정확도 중요 반감기 이벤트는 채굴 수익성·해시파워·보안에 직격 영향 PoS(지분증명): 검증자·파이널리티·리스크 원리: 토큰 스테이킹 으로 검증자 선정(무작위 + 지분 가중 + 추가 규칙)\n블록·어테스테이션: 검증자가 블록 제안·감사(투표) 수행\n파이널리티: 일정 조건(예: ≥ 2/3 가중치가 찬성) 만족 시 체크포인트 최종화\n위협 모델\nNothing-at-Stake: 여러 체인에 동시 투표 유혹 → 슬래싱 으로 억제 롱레인지 공격: 과거부터 조용히 대체 체인 생성 → 약한 주관성(weak subjectivity)·체크포인트·동기화 규칙으로 방어 수수료와 가스: Bitcoin vs Ethereum Bitcoin: 수수료 = 바이트 크기 × 단가(sat/vByte)\n수수료 추정은 mempool 혼잡도·정책 영향 큼 Ethereum(EIP-1559)\nBase Fee(블록에 의해 자동 조정, 소각) + Priority Fee(팁) + gas_used 사용자 입장: 예상 가능한 수수료 + 혼잡 시 팁으로 우선순위 확보 컨트랙트 호출은 가스 한도 내에서만 실행됨(한도 부족 시 revert) 포크(Fork)와 체인 재조직(Reorg) 소프트 포크: 규칙 강화로 하위 호환 유지(예: SegWit 트랜잭션 가변성 해결, 블록 용량 효율화) 하드 포크: 규칙 불일치 → 미업데이트 노드와 체인 분리 가능(예: ETH/ETC) 운영 유의\n포크 전후 송금 보수적 운영(리플레이·정책 불확실성) 거래소·지갑 대응 계획 사전 확인 자연스런 재조직(reorg) 는 드물지만 발생 가능 → 높은 가치 송금은 여유 확인수/파이널리티 확보 보안 메커니즘·공격 모델 51% 공격(PoW): 과반 해시파워로 더 긴 체인을 만들어 이중지불 가능\n대형 체인: 비용·탐지 리스크 막대 중소 체인: 실질 리스크 존재 → 심도 있는 모니터링·안전 확인수 확대 권장 네트워크 공격: 이클립스(Eclipse)·Sybil·시간 왜곡 등 → 피어 다양화·시계 동기화·피어 밴 정책 필요\n지갑·키 관리\n개인키 유출 = 자금 유출 권장: 하드웨어 지갑, 멀티시그, 콜드월렛, 백업 시 BIP39 시드 문구 별도·오프라인 보관 확장성: 온체인 한계와 오프체인/Layer2 온체인 한계: 블록 크기·주기 제약 → TPS 제한, 탈중앙화·보안·확장성(블록체인 트릴레마) 간 트레이드오프 존재\n오프체인 결제(라이트닝 네트워크)\n양자 간 결제 채널 열고 다수 거래를 오프체인 처리, 최종 상태만 온체인 정산 핵심 메커니즘: 타임락, 페널티 트랜잭션, 경로 탐색 장점: 속도·수수료 우수 / 과제: UX·유동성·라우팅 Rollup(이더리움 L2)\nOptimistic Rollup: 사기 증명 기반, 이의제기 기간 후 확정 ZK Rollup: 영지식 증명 기반, 검증 빠름(증명 생성 비용·지연 고려) 데이터 가용성(DA): L1에 핵심 데이터 또는 블롭(EIP-4844) 으로 게시 → L2 상태 재구성 가능성 확보 로드맵: 프로토-덴크샤딩(EIP-4844) → 데이터 비용 절감, 장기적으론 완전 덴크샤딩으로 확장성 개선 MEV \u0026amp; PBS(이더리움)\nMEV: 거래 재배치·추출을 통한 가치 → 사용성·공정성 이슈 PBS: 제안자/빌더 분리로 역할 분담, 중앙화·검열 리스크 완화 시도 실무 체크리스트(운영·보안·개발) 노드 운영\n최신 클라이언트·보안 패치 적용, 피어 다변화 모니터링: 블록 지연, reorg, mempool 혼잡, 디스크/네트워크 지표 지갑·키 관리\n하드웨어 지갑·멀티시그·콜드스토리지 적용 시드 백업(오프라인), 접근 통제(2인 승인 등) 스마트 컨트랙트(이더리움)\n감사(Audit)·포멀 검증·테스트넷 충분 운용 가스 최적화: 저장소 쓰기 최소화, 재진입·정수 오버플로 방지, 최신 컴파일러 사용 업그레이드 전략: 프록시 패턴·권한 관리(Owner/Role)·타임락 수수료 전략\nBitcoin: sat/vByte 동적 설정, 급행·보통·저속 정책 분리 Ethereum: EIP-1559의 maxFeePerGas/maxPriorityFeePerGas 합리 설정 포크·네트워크 이벤트 대응\n공지 수집, 송금 동결/완화 기준, 고객 안내 시나리오 준비 간단 비교 표 항목 비트코인(PoW) 이더리움(PoS, Merge 이후) 블록 간격 ~10분 슬롯 ~12초(에폭=32 슬롯) 최종성 확률적(확인수↑) 체크포인트 최종성(정상 시 2 에폭 내외) 수수료 바이트 기준(sat/vByte) EIP-1559(BaseFee 소각 + Tip) 상태 모델 UTXO 계정 + 스마트 컨트랙트 확장성 방향 SegWit·Taproot·Lightning Rollup(Optimistic/ZK) + EIP-4844 자주 틀리는 포인트 “이더리움은 N 블록이면 안전” → (X) 현재는 파이널리티 달성 여부로 판단하는 게 정확함 “PoS는 그냥 코인 많이 가진 사람 승리” → (X) 무작위성·메시지 투표·슬래싱·최종성 규칙이 결합된 프로토콜 전체가 보안 근거임 “SegWit은 리플레이 공격 방지” → (부분 부정확) 핵심 목적은 트랜잭션 가변성(malleability) 해결 및 용량 효율화임 결론 블록체인은 암호학(해시·서명), 분산합의(PoW/PoS), 네트워크 설계가 맞물린 시스템임 설계 선택(PoW vs PoS, UTXO vs 계정, 온체인 vs 오프체인)이 보안·성능·분산화에 직접 영향 실무 핵심은 키 관리·노드 보안·포크/이벤트 대응·수수료 전략·컨트랙트 품질 보증임 확장성은 Layer2 + 데이터 가용성 + 프로토콜 개선을 병행하는 다층 해법이 현실적임 참고자료 비트코인 개요: https://bitcoin.org/ko/how-it-works 비트코인 개발자 가이드(데이터 구조·프로토콜): https://developer.bitcoin.org/devguide/ 이더리움 화이트페이퍼: https://ethereum.org/en/whitepaper/ 이더리움 PoS/합의 문서: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ EIP-1559(수수료 시장): https://eips.ethereum.org/EIPS/eip-1559 EIP-4844(프로토-덴크샤딩/블롭): https://eips.ethereum.org/EIPS/eip-4844 Lightning BOLT 사양: https://github.com/lightning/bolts SegWit 개요(트랜잭션 가변성 개선): https://bitcoinops.org/en/topics/segwit/ ","permalink":"https://blog.jsontapose.com/posts/blockchain-principles-mining-hash-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인은 \u003cstrong\u003e중앙 기관 없이\u003c/strong\u003e 참여자들이 거래를 기록·검증·공유하는 \u003cstrong\u003e분산 원장\u003c/strong\u003e 기술임\n이 글은 블록체인을 \u003cstrong\u003e초보자 친화적으로\u003c/strong\u003e 설명하고, \u003cstrong\u003e실무 체크리스트\u003c/strong\u003e까지 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"큰-그림-시스템-구성\"\u003e큰 그림: 시스템 구성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e노드(Node)\u003c/strong\u003e: 블록체인 소프트웨어 실행 주체\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e풀노드\u003c/strong\u003e: 모든 블록·트랜잭션 검증·저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트 클라이언트\u003c/strong\u003e: 헤더·머클 증명 기반 최소 검증\u003c/li\u003e\n\u003cli\u003e(참고) \u003cstrong\u003e아카이브 노드\u003c/strong\u003e: 오래된 상태 포함 전체 상태 유지(필수 아님)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e블록(Block)\u003c/strong\u003e: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e합의(Consensus)\u003c/strong\u003e: 어떤 블록이 정식 이력인지 네트워크가 \u003cstrong\u003e공동으로\u003c/strong\u003e 결정하는 규칙\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoW: 작업증명(연산 경쟁)\u003c/li\u003e\n\u003cli\u003ePoS: 지분증명(검증자·보증금 기반)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해시hash와-위변조-방지\"\u003e해시(Hash)와 위·변조 방지\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 함수(SHA-256, Keccak-256 등)\u003c/strong\u003e: 입력을 고정 길이로 압축하는 일방향 함수임\u003c/p\u003e","title":"블록체인이란? 블록체인 개념 총정리"},{"content":"개요 이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함 개념 정의에 그치지 않고 운영 시 주의점, 보상·출금 흐름, 짧은 체인 재구성(Reorg) 원인과 완화책까지 다룸\n개념과 배경 PoS는 PoW의 에너지 경쟁을 대체해 예치된 지분을 바탕으로 검증자를 선정하는 합의 메커니즘임 이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 검증자 기반 보안 모델로 이행함\n주요 속성 요약\n에너지 소비 대폭 축소 스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨 위반 시 슬래싱과 페널티로 예치금이 감소함 계층 분리와 Beacon Chain의 역할 이더리움은 합의 계층(Beacon Chain) 과 실행 계층(Execution Layer) 를 분리해 설계함\n실행 계층은 트랜잭션 처리와 EVM 실행을 담당함 Beacon Chain은 시간 관리와 역할 배정, 투표 집계, 최종성 판단을 담당함 Beacon Chain의 핵심 기능\n슬롯과 에포크라는 통일된 시간 프레임 제공 매 슬롯의 블록 제안자와 증명자 배정 증명자 투표를 집계해 정당한 체인과 최종성을 결정함 이 분리는 클라이언트 다양성 확보와 확장 로드맵에 유리한 아키텍처 선택임\n시간 구조와 동작 단위 슬롯(slot)\n블록 제안이 가능한 최소 시간 단위 1 슬롯 = 12초 슬롯마다 1명의 제안자만 지정됨 제안자가 제때 블록을 제안하지 못하면 슬롯 미스로 간주하고 빈 슬롯이 될 수 있음 에포크(epoch)\n1 에포크 = 32 슬롯 ≈ 6분 24초 에포크 단위로 위원회 재편성, 랜덤 시드 갱신, 최종성 관련 집계가 이뤄짐 에포크는 체크포인트 역할을 하며 최종성 로직의 기준 단위로 사용됨 검증자와 스테이킹 규칙 최소 32 ETH를 예치해야 정식 검증자가 됨 한 검증자 계정에 반영되는 유효 예치 상한은 32 ETH임 더 많은 ETH를 운용하려면 32 ETH 단위로 여러 검증자를 운영해야 함 검증자 활성·비활성 전환에는 대기 큐와 지연이 존재함 보상 기회는 전체 검증자 대비 보유 검증자 수에 비례해 증가함 예를 들어 64 ETH로 두 검증자를 운영하면 제안·투표 참여 기회가 대략 두 배가 됨\n제안자(Proposer)와 증명자(Attester) 매 슬롯 한 명의 제안자가 블록을 제안함 다수의 증명자가 해당 블록에 대해 attestation 을 제출함 검증자들은 여러 위원회(committee) 로 무작위 배정되어 병렬로 검증을 수행함 집계된 투표는 포크 선택과 최종성 판단에 사용됨 위원회 구조의 목적은 검증 부담 분산 과 독립 다중 관측 을 통해 안전성과 처리량을 동시에 확보하는 것임\n무작위성과 검증자 배정 이더리움은 RANDAO 믹스 를 사용해 예측이 어렵고 조작에 강한 난수를 생성함 역사적으로 VRF나 VDF 같은 대안이 거론되었으나 현재 메인넷은 RANDAO 기반을 사용함 생성된 난수는 차기 에포크의 제안자·위원회 배정에 활용됨 특정 주체가 지속 우선 선정되는 편향을 줄이는 것이 목표임 포크 선택과 최종성 개요 포크 선택은 LMD‑GHOST 를 기반으로 하며 최신 메시지를 반영해 가장 무거운 서브트리를 선택함 짧은 지연으로 더 나은 블록을 선택하도록 proposer boost 가 도입되어 reorg 위험을 줄임 최종성은 Casper FFG 를 통해 에포크 수준 체크포인트를 정당화·최종화함 일정 이상 검증자 참여가 확보되면 체크포인트가 finalized 상태가 되어 경제적으로 되돌리기 매우 어려워짐 보상과 벌칙의 구조 보상 항목\n블록 제안 보상 제안자가 유효 블록을 포함할 때 수취 증명 보상 attestation을 정확하고 신속하게 제출한 검증자에게 지급 동기화 위원회 보상 라이트 클라이언트 지원을 위한 서명 참여 검증자에게 지급 벌칙과 슬래싱\n오프라인이나 지연 제출 등에는 경미한 페널티 가 부과됨 체인이 장기간 미파이널리티 상태에 빠지면 inactivity leak 이 발생해 페널티가 점진적으로 커짐 슬래싱 은 이중 제안 혹은 이중·감싸기 투표 같은 안전성 위반에 적용되며 금액과 네트워크 상황에 따라 손실이 커질 수 있음 동일 키를 여러 노드에서 가동하면 슬래싱 위험이 급증하므로 금지해야 함 보상 규모와 페널티는 전체 활성 예치 규모와 참여율 등 네트워크 상태에 따라 동적으로 변함\n출금과 인출 흐름 2023년 상반기 업그레이드 이후 출금 기능 이 활성화됨 부분 출금 은 32 ETH 초과분이 자동으로 실행 계층의 출금 주소로 전달됨 완전 출금 은 검증자가 정상 종료를 통해 활성 집합에서 빠진 뒤 전 잔액을 인출하는 흐름임 출금 처리는 블록당 포함 가능한 수가 제한되어 있어 대기 지연이 발생할 수 있음 출금 주소 유형과 자격 전환이 올바르게 설정되어 있어야 자동 처리가 가능함 운영 포인트\n출금 대기 시간과 큐 상태를 모니터링해 유동성을 관리함 출금 주소 관리 실수를 방지하기 위해 변경 절차를 문서화하고 검증 절차를 둠 Reorg가 발생하는 이유와 완화책 Reorg는 PoS에서도 짧은 길이 로 발생할 수 있음 주요 원인\n블록·attestation 전파 지연으로 노드 간 관측 차이가 발생함 슬롯 미스 이후 후속 제안자가 다른 선행 상태를 기준으로 블록을 만들 수 있음 노드 시간 동기화 불량이나 리소스 병목으로 처리 지연이 발생함 완화책\n시간 동기화는 chrony 등으로 정확히 유지함 고품질 피어 확보와 충분한 피어 수를 유지하고 네트워크 지연을 최소화함 최신 클라이언트와 다양한 클라이언트 조합으로 클라이언트 다양성 을 보장함 proposer boost와 attest 포함 지연 지표를 모니터링해 파라미터와 인프라를 튜닝함 대부분의 reorg는 1~2 블록에서 수렴하며 최종성 규칙으로 빠르게 안정화됨\n운영 체크리스트 노드와 인프라\n최신 합의·실행 클라이언트 유지 피어 수·지연·대역폭·디스크 IOPS 모니터링 장애를 분리하기 위해 실행·합의 클라이언트의 조합을 다양화함 키 관리\n슬래싱 방지 파일과 원격 서명기 사용 시 중복 서명 방지 설정 확인 단일 실패 지점 제거를 위해 핫·백업 구성과 자동 페일오버를 명확히 구분함 키 백업과 복구 절차를 오프라인으로 주기 점검함 운영 정책\n32 ETH 단위로 검증자를 수평 확장해 장애 격리와 보상 변동성을 줄임 모니터링 지표를 표준화함 참여율, attestation 포함 거리, 미스 슬롯, reorg 발생률, 동기화 위원회 가동률, 출금 큐 길이 등 MEV‑Boost 사용 시 릴레이 다양화와 로컬 빌더 폴백을 준비해 가용성과 검열 리스크를 낮춤 위험과 중앙화 고려 거대 스테이킹 풀과 커스터디 집중은 검열·단일 실패 지점 위험을 키움 클라이언트 다양성 부족은 버그 발생 시 네트워크 안정성을 해칠 수 있음 리퀴드 스테이킹 파생상품은 유동성을 제공하지만 의사결정 집중과 딜레마를 유발할 수 있음 정책과 거버넌스, 릴레이·빌더 다양화, 커뮤니티 모니터링으로 리스크를 분산해야 함 마무리 이더리움 PoS는 RANDAO 기반 무작위성, LMD‑GHOST 포크 선택, Casper FFG 최종성, 검증자 보상·벌칙 체계 를 결합해 에너지 효율과 보안을 동시에 달성하려는 설계임 운영자는 시간 동기화와 피어 품질, 키 관리, 클라이언트 다양성, 보상·출금 파이프라인을 지속적으로 점검해야 함 짧은 reorg는 네트워크 현실에서 발생할 수 있으나 적절한 인프라와 파라미터 튜닝, 최신 클라이언트 운용으로 빈도와 영향을 최소화할 수 있음\n참고자료 이더리움 PoS 개요 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos 합의 사양과 가스퍼 개요 https://github.com/ethereum/consensus-specs EIP‑4895 출금과 Capella 업그레이드 참고 https://eips.ethereum.org/EIPS/eip-4895 합의 계층 클라이언트와 실행 계층 클라이언트 목록 https://ethereum.org/en/developers/docs/nodes-and-clients MEV‑Boost 운영 가이드 참고 https://www.flashbots.net ","permalink":"https://blog.jsontapose.com/posts/ethereum-pos-proof-of-stake-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함\n개념 정의에 그치지 않고 \u003cstrong\u003e운영 시 주의점\u003c/strong\u003e, \u003cstrong\u003e보상·출금 흐름\u003c/strong\u003e, \u003cstrong\u003e짧은 체인 재구성(Reorg) 원인과 완화책\u003c/strong\u003e까지 다룸\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003ePoS는 PoW의 에너지 경쟁을 대체해 \u003cstrong\u003e예치된 지분을 바탕으로 검증자를 선정\u003c/strong\u003e하는 합의 메커니즘임\n이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 \u003cstrong\u003e검증자 기반 보안 모델\u003c/strong\u003e로 이행함\u003c/p\u003e\n\u003cp\u003e주요 속성 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에너지 소비 대폭 축소\u003c/li\u003e\n\u003cli\u003e스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨\u003c/li\u003e\n\u003cli\u003e위반 시 슬래싱과 페널티로 예치금이 감소함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"계층-분리와-beacon-chain의-역할\"\u003e계층 분리와 Beacon Chain의 역할\u003c/h3\u003e\n\u003cp\u003e이더리움은 \u003cstrong\u003e합의 계층(Beacon Chain)\u003c/strong\u003e 과 \u003cstrong\u003e실행 계층(Execution Layer)\u003c/strong\u003e 를 분리해 설계함\u003c/p\u003e","title":"이더리움 PoS(Proof of Stake) 소개"},{"content":"개요 NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 리빌, 에어드롭, 화이트리스트, 마켓플레이스를 실무 관점으로 정리함 핵심은 개념 이해를 넘어 운영 체크리스트, 보안 리스크, 가격 형성 메커니즘까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\n공통 전제와 기본 개념 NFT 표준 주로 ERC‑721과 ERC‑1155를 사용함 721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\n메타데이터와 저장소 토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장 중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\n로열티 EIP‑2981 표준이 존재하나 집행은 마켓별 정책에 의존하는 경향이 있음 창작자 수익 분배 구조를 미리 확인 필요\n리빌 Reveal 정의 민팅 직후에는 공통 플레이스홀더 이미지를 노출하고, 이후 시점에 각 토큰의 최종 속성·이미지를 공개하는 절차를 말함\n왜 쓰는가\n판매 초기의 기대감 형성과 공정한 희소성 배분 유도 초반 스니핑을 줄이고 커뮤니티 이벤트와 연동하기 위함 가격 형성상 특징\n리빌 전에는 외형과 속성이 같아 보여 가격 수렴이 발생하기 쉬움 리빌 후에는 속성 조합·희소성에 따라 재평가가 빠르게 진행됨 희귀 속성은 프리미엄이 붙고 평범 속성은 하방 압력이 커지는 패턴이 일반적임 공정성·신뢰 장치\n프로비넌스 해시 공개로 민팅 전 전체 순서를 커밋해 치환·조작 가능성을 낮춤 메타데이터 동결과 BaseURI 고정으로 리빌 후 임의 수정 리스크 축소 온체인 또는 영속 스토리지에 최종 자료 고정 운영 체크리스트\n리빌 시점, 방식(일괄·구간·랜덤 시프트), 프로비넌스 공개 여부 확인 메타데이터 저장소와 동결 계획 점검 리빌 직후 가격 변동성 대비 유동성 전략 수립 에어드롭 Airdrop 정의 NFT 또는 토큰을 무상 배포해 초기 유입과 참여 보상을 유도하는 방식\n유형\n푸시형 프로젝트가 직접 전송 클레임형 스냅샷 기준 자격자에게 기간 내 청구 권한 부여 조건형 소셜 참여, 보유 토큰, 온체인 행위 등 조건을 충족해야 함 비용과 유동성\n가스 부담 주체가 누구인지 확인 필요 수령 자산의 2차 유동성 가능성과 잠금 조건 여부 확인 보안 체크리스트\n개인키·시드 문구 요청은 100% 사기 setApprovalForAll 무제한 승인 요구, 임의 Permit 서명 요구, 낯선 도메인의 서명 팝업에 주의 의심 에어드롭은 더스팅 공격 가능성 고려, 상호작용 자체를 피하는 것이 안전한 경우 많음 현실적 기대치\n극소수 성공 사례를 제외하면 무료 배포물의 평균 가치는 시간 경과에 따라 하락하는 경향 로드맵, 팀 신뢰도, 파트너십, 토큰 설계까지 종합 평가 필요 화이트리스트 Allowlist 정의 특정 지갑에게 민팅 우선권을 부여하는 명단을 의미하며 줄여서 화리라 부름 포용적 표현으로 Allowlist 용어를 쓰는 프로젝트가 많음\n부여 방식\n커뮤니티 기여, 미션, 추천, 보유 토큰 기반 토큰 게이팅 온체인 머클 증명으로 명단을 검증해 가스·데이터 비용을 절감 타입\n보장형 배정량이 확정되어 민팅 시점에 구매 가능 경쟁형 FCFS나 시간 창을 두어 네트워크 상태·속도에 따라 성공 여부가 갈림 래플형 추첨으로 공정 배분 시도 실무 체크리스트\n1인당 구매 한도, 민팅가, 시간 창, 체인·네트워크 확인 가스 워 방지 장치 유무 확인(쿨다운, 랜덤 시프트, 캡) 어뷰징·봇 통제 정책 확인, 위반 시 박탈 규정 숙지 주의\nAllowlist를 과다 남발하는 프로젝트는 민팅 종료 후 가격 하락 리스크가 크므로 유통 설계와 수요 검증 필요 NFT 마켓플레이스 역할 NFT의 가시화, 매매, 오더북을 제공하는 플랫폼을 의미함 글로벌로 OpenSea, Blur, Rarible 등이 대표적이며 국내에는 Klip Drops, 업비트 NFT 등이 존재함\n거래 방식\n고정가 리스팅 판매자가 원하는 가격 제시 경매형 영국식 상승 경매, 더치 경매 등 변형 포함 오퍼 특정 토큰 혹은 전체 컬렉션에 대한 구매 제안 접수 집계기가 여러 거래소의 유동성을 묶어 더 나은 가격·체결 속도를 제공하기도 함 핵심 지표와 해석 요령\n바닥가 Floor 컬렉션 내 최저 매물가이나 거래된 가격이 아님 얕은 호가에 의해 왜곡 가능하므로 체결 이력, 호가 두께, 분포를 함께 보아야 함 체결량·보유 분포 단기 매물 출회 압력과 고래 집중도 파악에 유용함 워시 트레이딩 자기계약 간 거래로 볼륨 부풀리기가 발생할 수 있어 탐지 지표 참고 필요 수수료와 로열티\n마켓 수수료와 창작자 로열티 정책이 거래소마다 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 선택적인 경우가 많아 실제 지급 여부를 확인해야 함 보안과 권한 관리\n판매 전 부여한 무제한 승인은 거래 후 revoke 툴로 회수 권장 피싱 도메인과 서명 위임 요청에 대한 교육이 필수 플랫폼 선택 기준\n유동성 규모, 수수료 구조, 지원 체인, 커뮤니티 활성도, 집계기 연동 여부, 로열티 정책 일관성 확인 빠른 판단 가이드 리빌 일정과 프로비넌스 공개, 메타데이터 동결 계획을 먼저 확인 에어드롭 은 개인키·시드·무제한 승인 요구 시 즉시 중단 화이트리스트 는 한도·가격·시간 창과 검증 방식(머클) 확인 마켓플레이스 는 바닥가만 보지 말고 체결 이력·호가 두께·수수료·로열티 정책까지 함께 판단 예시 시나리오 개인 사용자 민팅 직후 리빌 전 거래는 변동성 대비 효익이 낮을 수 있어 리빌 일정 확인 후 접근 수령한 에어드롭은 승인 요청이 없는지 먼저 점검하고 필요 시 상호작용을 피함 프로젝트 운영자 머클 기반 Allowlist와 프로비넌스 커밋으로 신뢰 확보 메타데이터 동결과 영속 스토리지 사용으로 변경 리스크 최소화 워시 트레이딩 방지 메시지와 리스팅 교육 자료를 함께 제공 마무리 리빌은 가치 재평가의 계기 에어드롭은 초기 분배와 참여 보상 수단 화이트리스트는 수요 조절과 공정 배분 장치 마켓플레이스는 가격 발견과 유동성의 장 각 제도의 의도·설계·리스크를 이해하고 보안 수칙을 지키면 의사결정의 품질을 높일 수 있음\n참고자료 ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 OpenZeppelin Merkle 증명 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography Ethereum 개발자 문서 NFT 개요 https://ethereum.org/en/developers/docs/standards/tokens/ 추가 읽을거리 https://magazine.cheil.com/51780 ","permalink":"https://blog.jsontapose.com/posts/nft-23q12akw/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 \u003cstrong\u003e리빌\u003c/strong\u003e, \u003cstrong\u003e에어드롭\u003c/strong\u003e, \u003cstrong\u003e화이트리스트\u003c/strong\u003e, \u003cstrong\u003e마켓플레이스\u003c/strong\u003e를 실무 관점으로 정리함\n핵심은 개념 이해를 넘어 \u003cstrong\u003e운영 체크리스트\u003c/strong\u003e, \u003cstrong\u003e보안 리스크\u003c/strong\u003e, \u003cstrong\u003e가격 형성 메커니즘\u003c/strong\u003e까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"공통-전제와-기본-개념\"\u003e공통 전제와 기본 개념\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNFT 표준\u003c/strong\u003e\n주로 ERC‑721과 ERC‑1155를 사용함\n721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메타데이터와 저장소\u003c/strong\u003e\n토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장\n중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\u003c/p\u003e","title":"NFT 핵심 용어 정리"},{"content":"서문 NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움 이 글은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고 구매·발행·보관 시 유의사항과 운영 관행을 담는 것을 목표로 함\n개념과 배경 NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함 동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 고유 식별자와 속성을 가져 상호 교환 시 동일 가치를 보장하지 않음 블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음 온체인 소유권이 저작권·초상권 등 법적 권리와 자동 동치가 아님에 유의해야 함\nNFT는 보통 세 요소로 이해하면 실무에 유리함\n디지털 미디어 이미지·영상·음원·게임 아이템 등 사용자에게 보이는 대상 메타데이터 이름·설명·속성·미디어 링크를 담은 JSON 문서 스마트컨트랙트 발행·이전 규칙을 구현한 코드로 표준은 주로 ERC‑721과 ERC‑1155를 사용함 대부분의 프로젝트는 미디어 파일을 체인 밖에 보관하고 메타데이터에 링크를 넣는 오프체인 저장을 택함 장기 보존성을 위해 IPFS·Arweave 같은 영속형 스토리지 사용과 메타데이터 동결 계획이 중요함\n메인넷과 인프라 이해 NFT는 이더리움·폴리곤·솔라나·클레이튼 등 메인넷 혹은 L2 위에서 발행·거래됨 거래 실행에는 가스비가 들며 이더리움은 EIP‑1559 기반의 베이스피와 우선순위 팁 구조를 가짐 네트워크 상태와 우선순위 설정에 따라 체결 속도와 비용이 크게 달라짐 거래와 토큰 상태는 블록 탐색기에서 확인 가능하며 예시는 이더스캔과 클레이튼 스코프 등이 있음\n체인별 계약 주소·체인 ID가 다르므로 피싱 사이트가 제시하는 계약을 탐색기에서 교차 확인하는 습관이 필요함 브리징과 크로스체인 전송 시에는 락 앤 민트 모델·메시지 지연·브리지 보안을 이해하고 한도·대기 시간을 고려해야 함\n지갑과 보안 지갑은 주소와 그 주소를 통제하는 프라이빗 키·시드 문구를 관리함 메타마스크·카이카스 같은 브라우저 확장형은 편리하지만 핫월렛이라 위험 노출이 큼 대액·장기 보관 자산은 하드웨어 지갑에 두고 일상 거래는 별도 소액용 지갑을 쓰는 분리 보관이 권장됨\n시드 문구 보관 원칙\n오프라인 백업과 물리 분산 보관 사진·클라우드·메신저 업로드 금지 테스트 복구 절차를 정기 수행 권한과 서명 보안\n웹사이트 연결 시 도메인·체인·요청 권한을 확인하고 setApprovalForAll 무제한 승인은 꼭 필요한 범위에만 부여 거래가 아닌 서명 요청도 자산 이전 권한을 위임할 수 있으니 상세를 읽고 필요 시 거부 사용이 끝난 승인 권한은 권한 취소 도구로 주기적으로 회수 민팅 Minting 실무 절차 민팅은 메타데이터와 미디어 링크를 컨트랙트에 기록해 토큰을 새로 발행하는 행위 민팅이 체인에 포함되면 이벤트 로그에서 Transfer 이벤트의 From 주소가 0x0000000000000000000000000000000000000000 로 표시되는 것이 일반적임\n두 가지 맥락을 구분하면 혼동이 줄어듦\n프로젝트 관점 컨트랙트를 배포하고 토큰을 생성하는 개발·운영 작업 구매자 관점 민팅 페이지에서 최초 구매에 참여하는 행위 민팅 유형과 운영 포인트\n퍼블릭 민팅 누구나 가능하며 인기 컬렉션은 즉시 매진되므로 가스 전략과 자동화 대비가 필요 프라이빗 민팅 Allowlist 사전 등록 지갑만 참여 가능하며 일반적으로 가격·수량·시간 창이 별도로 정의됨 무료 민팅 민팅가는 0이지만 가스비가 들며 사후 로열티·수수료 구조를 확인해야 함 민팅 전 체크리스트\n계약 주소·체인·민팅가·한도·시간 창을 공지와 탐색기에서 이중 확인 메타데이터 저장 방식과 리빌·프로비넌스 계획을 확인 페이지가 제시하는 컨트랙트 소스 공개·감사 여부 확인 가스비 상한과 우선순위 팁을 과도하게 올려 불필요한 낭비가 없도록 시뮬레이션 마켓플레이스와 2차 거래 오픈씨·블러·라리블 등 마켓플레이스에 지갑을 연결해 리스팅과 오퍼를 관리함 주요 거래 방식은 고정가 리스팅·경매·컬렉션 오퍼 등이 있으며 유동성은 거래소마다 상이함\n가격 해석과 유의점\n바닥가 floor 는 현재 최저 매물가일 뿐 실제 체결가가 아님 체결 이력·호가 두께·보유 분포를 함께 봐야 수급을 판단할 수 있음 워시 트레이딩 으로 볼륨이 부풀려질 수 있으므로 비정상 패턴에 주의 로열티와 수수료\n마켓 수수료 와 크리에이터 로열티 정책은 플랫폼별로 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 거래소 정책에 의존하는 경우가 많음 실제 로열티 지급 여부와 비율을 거래 전 확인 필요 권한과 보안\n리스팅 과정에서 부여한 무제한 승인은 판매 종료 후 회수 권장 낯선 도메인의 서명 팝업과 필드가 비정상적으로 긴 메시지는 피싱 징후일 수 있음 메타데이터·저장·리빌 운영 메타데이터 는 ERC‑721 메타데이터 스펙의 name·description·image·attributes 필드를 따르는 것이 일반적 저장소 는 IPFS·Arweave 같이 링크 무결성과 장기 보존에 유리한 방식을 권장 리빌 은 발행 직후 플레이스홀더를 제공하고 이후 속성을 공개하는 절차로 가격 재평가가 일어남 조작 의심을 줄이기 위해 프로비넌스 해시 공개·랜덤 시드·베이스 URI 잠금 같은 신뢰 장치를 제공하는 것이 실무 베스트 프랙티스임 운영·커뮤니티 관행과 실무 팁 프로젝트 운영자 관점\n컨트랙트 소스 공개와 보안 감사 진행 Allowlist를 머클 증명으로 검증해 가스와 데이터 비용을 절감 봇 완화를 위한 레이트 리밋·쿨다운·인증을 설계 리빌 일정·기준·랜덤 방식과 메타데이터 동결 계획을 사전 공지 로열티 정책을 명확히 하고 플랫폼별 집행 차이에 대한 안내 제공 구매자·보유자 관점\n리빌 전후의 가격 변동성과 유동성 얕음에 대비 권한 관리와 피싱 방지 교육을 습관화 브리지·체인 전환 전에는 수수료·지연·보안 리스크를 점검 에어드롭·민팅 DM은 대부분 피싱일 가능성이 높으므로 공식 채널만 신뢰 빠른 점검 체크리스트 계약 주소·체인·민팅가·수량 한도·시간 창 교차 확인 메타데이터 저장소와 리빌·프로비넌스 공개 여부 확인 마켓 수수료·로열티 정책·체결 이력과 호가 두께 확인 권한 부여 최소화와 사용 후 권한 회수 습관 유지 시드 문구 오프라인 분산 보관과 정기 복구 테스트 수행 마무리 NFT는 표준·메타데이터·컨트랙트 권한·저장 전략이 서로 맞물려 동작하는 생태계임 개념을 이해하는 것만으로는 부족하며 보안과 운영 절차를 마련해야 실전에서 손실을 줄일 수 있음 민팅·거래·보관 단계별로 위의 체크리스트를 적용하면 의사결정 품질을 안정적으로 끌어올릴 수 있음\n참고자료 Etherscan 블록 탐색기 https://etherscan.io Klaytn Scope 블록 탐색기 https://scope.klaytn.com OpenSea 마켓플레이스 https://opensea.io MetaMask 지갑 https://metamask.io ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 Ethereum 개발자 문서 토큰 표준 개요 https://ethereum.org/en/developers/docs/standards/tokens Klaytn 개발자 문서 https://docs.klaytn.foundation ","permalink":"https://blog.jsontapose.com/posts/nft-concept-20gd0fl/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003eNFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움\n이 글은 \u003cstrong\u003e실무자 관점\u003c/strong\u003e에서 NFT의 핵심 개념을 단계적으로 정리하고 \u003cstrong\u003e구매·발행·보관 시 유의사항\u003c/strong\u003e과 \u003cstrong\u003e운영 관행\u003c/strong\u003e을 담는 것을 목표로 함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eNFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함\n동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 \u003cstrong\u003e고유 식별자와 속성\u003c/strong\u003e을 가져 상호 교환 시 동일 가치를 보장하지 않음\n블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음\n온체인 소유권이 \u003cstrong\u003e저작권·초상권 등 법적 권리와 자동 동치가 아님\u003c/strong\u003e에 유의해야 함\u003c/p\u003e","title":"NFT란? NFT 핵심 개념 정리"}]