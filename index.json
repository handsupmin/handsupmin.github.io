[{"content":"개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\n쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\n이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\n1. 핵심 용어 정리 오프체인 서명 (Off-chain Signature) 블록체인 외부(주로 백엔드 서버)에서 생성된 디지털 서명을 의미함 이 방식은 서명을 생성하는 과정에서 가스비가 들지 않고, 서버의 다양한 로직과 결합할 수 있는 장점이 있음\n메타 트랜잭션 (Meta-transaction) 사용자가 가스비를 직접 내지 않고, 트랜잭션에 대한 의도만 \u0026lsquo;서명\u0026rsquo;으로 표현하면, 제3의 대리인(Relayer)이 이를 대신 실행하고 수수료를 지불하는 패턴임 오프체인 서명은 이 메타 트랜잭션을 구현하는 핵심 기술임\n가스리스 트랜잭션 (Gasless Transaction) 메타 트랜잭션을 통해 사용자가 느끼기에 가스비 없이 트랜잭션을 처리하는 경험을 의미함 서비스 제공자가 페이마스터 등을 통해 가스비를 대납함으로써 구현됨\nEIP-712 단순 문자열이 아닌, 구조화된 데이터에 대한 서명 표준임 이 표준을 사용하면 사용자가 자신이 무엇에 서명하는지 명확히 알 수 있으며, 다른 체인이나 다른 컨트랙트에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지할 수 있어 보안성이 매우 높음\n2. 오프체인 서명 검증의 전체 흐름 서버, 사용자, 그리고 컨트랙트 간의 상호작용은 다음과 같은 단계로 이루어짐\n사용자 요청 사용자의 클라이언트(웹/앱)는 트랜잭션을 바로 블록체인에 보내는 대신, 트랜잭션에 필요한 정보들을 백엔드 서버에 API 요청으로 보냄\n서버 검증 및 서명 서버는 요청이 유효한지 검증함 (예: 우리 서비스의 정식 사용자인가? 요청 내용이 합당한가?) 검증이 완료되면, 서버는 EIP-712 표준에 따라 트랜잭션 파라미터가 담긴 메시지를 만들고, 서버의 개인키로 이 메시지에 서명함\n사용자 트랜잭션 제출 서버는 생성된 서명(signature)과 관련 데이터들을 사용자에게 다시 응답으로 보내줌 사용자의 클라이언트는 이 서명 데이터를 포함하여 트랜잭션를 구성하고, 최종적으로 블록체인(스마트 컨트랙트)에 제출함\n컨트랙트 검증 스마트 컨트랙트는 제출된 트랜잭션을 받아 서명이 유효한지 검증함 검증에 성공하면, 컨트랙트는 약속된 작업을 수행함 (예: 가스비 대납, 아이템 지급 등)\n3. 핵심 원리: 컨트랙트의 서명 검증 과정 컨트랙트는 서버의 개인키를 모르는데, 어떻게 서버가 서명했다는 것을 신뢰할 수 있을까? 이 과정은 암호학적 원리를 이용해 세 단계로 진행됨\n1단계: 데이터 해시(Hash) 재구성 컨트랙트는 사용자가 제출한 파라미터들(userAddress, expiryTimestamp 등)을 받아, 서버가 서명을 생성했을 때와 완벽히 동일한 구조와 순서로 이 데이터들을 조합하여 해시(hash) 값을 다시 계산함\n이때 EIP-712 표준에 따라 컨트랙트의 이름, 버전, 체인 ID 등이 포함된 도메인 분리자(Domain Separator)가 해시와 함께 사용되어 다른 컨트랙트에서 서명이 재사용되는 것을 막음\n// 1. 전달받은 파라미터로 해시 재계산 bytes32 hash = keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice )); bytes32 digest = hashTypedDataV4(hash); // 도메인 분리자와 결합2단계: 서명자 주소 복원 ecrecover라는 암호학적 함수는 메시지 해시(digest)와 서명값(signature), 이 두 가지를 입력받아 해당 서명을 만들 수 있는 유일한 공개키, 즉 서명자의 주소를 역으로 계산해냄 이 과정에서 서버의 개인키는 절대 노출되지 않음\n// 2. 서명에서 주소 복원 address recoveredAddress = digest.recover(signature);3단계: 서명자 주소 비교 마지막으로, 2단계에서 복원된 주소가 스마트 컨트랙트에 미리 저장된 신뢰할 수 있는 서버의 주소(signer)와 일치하는지 비교함 두 주소가 일치한다면, 이 서명은 우리가 신뢰하는 서버가 생성한 유효한 서명임이 증명된 것임\n// 3. 복원된 주소가 signer와 일치하는지 확인 require(signer == recoveredAddress, \u0026#34;Paymaster: Invalid signer\u0026#34;);4. 데이터 무결성: 서명된 데이터는 어떻게 신뢰하는가? \u0026ldquo;만약 사용자가 유효한 서명을 받은 뒤, 파라미터 값만 몰래 바꿔서 제출하면 어떡하지?\u0026rdquo; 결론부터 말하면, 불가능함\n서명 검증 과정 자체가 데이터의 무결성을 보장하기 때문임 만약 사용자가 파라미터를 1비트라도 변경하면, 1단계에서 재구성되는 해시값이 원래의 해시값과 완전히 달라짐 결과적으로 2단계에서 주소 복원에 실패하거나 엉뚱한 주소를 반환하게 되어, 3단계의 주소 비교에서 반드시 실패하게 됨\n이처럼, 서명은 데이터의 해시와 한 쌍으로 묶여있기 때문에 데이터가 조금이라도 변조되면 서명은 즉시 무효가 됨 이 원리 덕분에 우리는 데이터가 서버가 승인한 원본 그대로임을 신뢰할 수 있음\n마무리 오프체인 서명 검증은 온체인의 신뢰성과 오프체인의 유연성을 결합한 강력한 패턴임 이를 통해 가스비 소모 없이 복잡한 비즈니스 로직을 온체인 시스템에 안전하게 적용할 수 있음 서명 검증 과정 자체가 데이터의 무결성과 서명자의 신뢰성을 동시에 보장하므로, 다양한 분야에서 보안성과 효율성을 높이는 데 활용될 수 있음\n","permalink":"https://blog.jsontapose.com/posts/off-chain-signature-verification-542a33/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음\n이때 \u003cstrong\u003e오프체인 서명 검증\u003c/strong\u003e(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\u003c/p\u003e\n\u003cp\u003e쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음\n가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\u003c/p\u003e\n\u003cp\u003e이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\u003c/p\u003e","title":"오프체인 서명 검증(Off-chain Signature Verification)이란?"},{"content":"개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\nzkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\n문제 정의: 단순 설계 페이마스터의 명확한 한계 가장 먼저 검토한 toAddressPaymaster는 특정 컨트랙트로 향하는 트랜잭션의 가스비만 대납해주는 단순한 모델임. 하지만 이 방식은 두 가지 치명적인 허점을 가짐\n의도치 않은 트랜잭션 허용: 신규 사용자에게 지갑을 만들어주는 AccountFactory 컨트랙트 주소를 페이마스터에 등록할 경우, 우리 서비스와 무관한 모든 사용자가 이 팩토리를 사용할 때 발생하는 가스비를 우리가 전부 대납하게 됨. 페이마스터가 의도치 않게 공공재가 되어버리는 상황\n가스비 소모 공격에 취약: gasLimit을 검증하는 로직이 없어, 악의적 사용자가 가스비를 비정상적으로 높게 책정해 트랜잭션 한 번으로 페이마스터의 모든 자금을 고갈시킬 수 있는 위험이 존재함\n결론적으로 우리가 허용한 사용자가 우리가 의도한 작업을 할 때 발생하는 합리적인 수준의 가스비만을 선별적으로 대납할 똑똑한 방법이 필요했음\n해결의 실마리: Off-chain Signature Verification 이 문제의 해결책으로 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 도입하기로 결정함\n이 패턴은 블록체인 외부(서버)에서 생성된 디지털 서명을 블록체인 위(스마트 컨트랙트)에서 검증하는 방식임. 즉, 가스비 대납 여부를 컨트랙트가 단독으로 결정하는 게 아니라, 우리가 통제하는 서버의 \u0026lsquo;허가\u0026rsquo;를 받아 결정하게 만드는 것\n이 과정에서 다음과 같은 주요 개념들이 활용됨\n메타 트랜잭션(Meta-transaction): 사용자가 직접 트랜잭션을 생성하고 가스비를 지불하는 대신, 트랜잭션의 내용이 될 데이터에 서명만 함. 그러면 이 서명을 받은 대리인(Relayer)이 실제 트랜잭션으로 만들어 수수료를 대신 내고 블록체인에 제출하는 패턴. 우리가 구현할 페이마스터는 zkSync 시스템이 릴레이어 역할을 해주는 메타 트랜잭션의 일종임\nEIP-712: 단순 텍스트가 아닌, json처럼 구조화된 데이터에 대한 서명 표준. 사용자가 무엇에 서명하는지 명확히 인지할 수 있고, 다른 컨트랙트나 체인에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지하는 도메인 분리(Domain Separator) 기능을 포함하고 있어 페이마스터 서명에 필수적임\n구현 과정: 서명 기반 페이마스터 설계 및 개발 전체 흐름은 서버의 서명 생성(Off-chain)과 컨트랙트의 서명 검증(On-chain) 두 단계로 나뉨\n1. 서버 (Off-chain): 서명 생성 단계 사용자가 트랜잭션을 실행하기 직전, 클라이언트는 트랜잭션 데이터를 백엔드 서버로 전송함. 서버는 다음 절차를 수행\n요청 검증: 요청을 보낸 사용자가 우리 서비스의 유효한 사용자인지, 트랜잭션 내용이 비즈니스 로직에 부합하는지 등을 검증\n가스비 추정 및 파라미터 설정: 트랜잭션에 필요한 가스비를 추정하고, 여기에 약간의 버퍼를 더해 recommendedGasLimit과 recommendedGasPrice를 결정. 서명이 유효할 시간(expiryTimestamp)도 설정함\nEIP-712 서명 생성: 검증된 파라미터들을 바탕으로 EIP-712 표준에 따라 구조화된 데이터를 만들고, 서버만 안전하게 보관하고 있는 개인키로 이 데이터에 서명함\n// 서버에서 EIP-712 타입에 맞춰 서명할 데이터를 구성 const domain = { name: \u0026#34;SignatureBasedPaymaster\u0026#34;, version: \u0026#34;1\u0026#34;, chainId: chainId, verifyingContract: PAYMASTER_ADDRESS }; const types = { SignatureBasedPaymaster: [ { name: \u0026#39;userAddress\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;expiryTimestamp\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasLimit\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasPrice\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] }; const value = { /* userAddress, expiryTimestamp 등 실제 값 */ }; // 서버의 개인키로 서명 생성 const signature = await signerWallet.signTypedData(domain, types, value);이 서명값과 관련 파라미터들을 클라이언트에 반환하면, 클라이언트는 이 데이터를 트랜잭션과 함께 zkSync 네트워크로 전송함\n2. 컨트랙트 (On-chain): 서명 검증 단계 사용자의 트랜잭션은 zkSync 부트로더(Bootloader)를 통해 페이마스터 컨트랙트의 validateAndPayForPaymasterTransaction 함수를 호출함. 이 함수는 서명 검증의 핵심임\n데이터 재구성: 트랜잭션에 포함된 userAddress, expiryTimestamp, recommendedGasLimit 등의 파라미터를 가져와 서버가 서명했던 것과 완벽히 동일한 구조와 순서로 해시(hash)를 다시 만듦\n서명자 복원: 재구성한 해시와 트랜잭션에 포함된 서명(signature)을 이용해 암호학적 함수(ecrecover)를 호출. 이를 통해 이 서명을 생성한 주소를 역으로 계산해냄\n서명자 검증: 복원된 주소가 컨트랙트에 미리 저장해 둔 우리 서버의 주소(signer)와 일치하는지 확인. 일치해야만 서버가 허가한 유효한 요청으로 간주함\n만약 누군가 서버로부터 받은 서명을 그대로 두고 파라미터(ex: 가스비)를 변경하려 시도하면, 1번 단계에서 생성되는 해시값이 달라져 3번 검증 단계에서 실패하게 됨. 이를 통해 데이터의 무결성과 서명자의 신뢰성을 동시에 확보함\n// 1. 서버가 서명했을 데이터의 해시를 컨트랙트에서 동일하게 재구성 bytes32 digest = hashTypedDataV4(keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice ))); // 2. 서명과 재구성된 해시를 사용해 서명자 주소를 복원 address recoveredSigner = digest.recover(signature); // 3. 복원된 주소가 우리가 신뢰하는 서버의 주소(signer)와 일치하는지 확인 require( signer == recoveredSigner, \u0026#34;Paymaster: Invalid signer\u0026#34; ); // ... 검증 통과 후 가스비 대납 로직 실행결론 및 회고 zkSync의 페이마스터는 사용자의 가스비를 대신 지불하는 기능을 손쉽게 구현할 수 있는 강력한 기반을 제공함 개발자는 이를 통해 사용자의 진입 장벽을 낮추고 UX를 크게 개선할 수 있음\n하지만 여기에 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 결합함으로써, 단순한 가스비 대납을 넘어 정교한 권한 제어가 가능해짐 서버에서 각 요청을 사전에 검증하고 서명을 발급하는 방식은 다음과 같은 명확한 이점을 가져왔음\n운영 안정성: 누가, 언제, 어떤 트랜잭션의 가스비를 지원받을지 서버단에서 유연하게 제어할 수 있어, 무분별한 비용 소모를 막고 예측 가능한 운영이 가능\n보안 강화: 허가된 주체만이 서명을 통해 가스비를 사용할 수 있으므로, 초기 모델의 가장 큰 문제였던 자금 고갈 공격과 의도치 않은 트랜잭션 허용을 원천적으로 차단할 수 있었음\n결론적으로, zkSync의 편리한 온체인 기능과 서버의 오프체인 로직을 결합한 이 접근법은 보안과 운영 안정성을 모두 확보하는 효과적인 해결책이었음 이를 통해 시스템의 자산을 안전하게 보호하며 지속 가능한 서비스를 운영할 수 있는 견고한 토대를 마련하게 되었음\n","permalink":"https://blog.jsontapose.com/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 \u003cstrong\u003e가스비\u003c/strong\u003e(Gas Fee)임\n아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임\n이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 \u003cstrong\u003e가스리스 트랜잭션\u003c/strong\u003e(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\u003c/p\u003e\n\u003cp\u003ezkSync Era는 이를 위해 \u003cstrong\u003e페이마스터\u003c/strong\u003e(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\u003c/p\u003e","title":"안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)"},{"content":"SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\n주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\nSSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\n장점 간단한 구현 EventSource API(이 예제에선 안 썼지만)는 사용이 매우 간편하며 자동 재연결 기능까지 내장함. 서버 측도 기존 HTTP 서버에서 헤더 설정만 추가하면 됨 HTTP 친화적 (HTTP/2의 강력한 이점) HTTP/1.1의 한계: 브라우저는 동일 도메인당 최대 6개 연결 제한이 있어, SSE가 1개를 점유하면 다른 API 요청이 지연(Head-of-Line Blocking)될 수 있음 HTTP/2의 해결책: HTTP/2는 하나의 TCP 연결 내에서 여러 요청/응답을 스트림(Stream)으로 다중화(Multiplexing)함. 즉, SSE 연결(스트림 1)이 열려 있는 상태에서도 다른 API 요청(스트림 2, 3)이 동일한 TCP 연결을 통해 지연 없이 동시에 처리됨 결론: 프로덕션 환경에서는 6개 연결 제한 회피를 위해 HTTP/2 (HTTPS) 환경 구성을 강력히 권장함 유지보수 용이 프로토콜 자체가 단순하여 디버깅이나 유지보수가 웹소켓보다 쉬움 한계 단방향 통신 (One-way) 가장 큰 한계로, 오직 서버에서 클라이언트로만 데이터를 보낼 수 있음. 클라이언트가 서버로 데이터를 보내려면 별도의 fetch나 axios를 사용한 POST 요청이 필요함 연결 수 제한 (HTTP/1.1) 위에서 언급했듯이, HTTP/1.1 환경에서는 브라우저의 도메인당 연결 수 제한(보통 6개)에 영향을 받음 프로토콜: 표준 HTTP SSE는 웹소켓(WebSocket)처럼 ws:// 같은 별도의 프로토콜을 사용하지 않음 우리가 일반적으로 사용하는 표준 HTTP/1.1 (또는 HTTP/2) 프로토콜 위에서 동작함\n핵심 동작 원리는, 클라이언트의 최초 HTTP GET 요청에 대해 서버가 연결을 종료(close)하지 않고, 응답을 스트리밍하는 것임\nSSE 연결 (서버 측 설정) 클라이언트가 SSE 연결을 요청할 때(예: /events), 서버는 일반적인 HTML이나 JSON이 아닌, 이벤트 스트림임을 알리는 특정 HTTP 헤더로 응답해야 함\nContent-Type: text/event-stream (필수) Connection: keep-alive (연결 유지) Cache-Control: no-cache (중간 프록시나 브라우저가 응답을 캐시하지 않도록 방지) // Node.js (Express 예시) // npm install express import express from \u0026#34;express\u0026#34;; const app = express(); // 연결된 모든 클라이언트(res 객체)를 저장 const clients = new Set(); app.get(\u0026#34;/events\u0026#34;, (req, res) =\u0026gt; { // 1. SSE 연결을 위한 필수 헤더 설정 res.writeHead(200, { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/event-stream\u0026#34;, Connection: \u0026#34;keep-alive\u0026#34;, \u0026#34;Cache-Control\u0026#34;: \u0026#34;no-cache\u0026#34;, }); // 2. 연결된 클라이언트를 Set에 추가 clients.add(res); console.log(\u0026#34;Client connected\u0026#34;); // 3. 클라이언트가 연결을 끊었을 때의 처리 req.on(\u0026#34;close\u0026#34;, () =\u0026gt; { clients.delete(res); console.log(\u0026#34;Client disconnected\u0026#34;); }); }); app.listen(3000, () =\u0026gt; console.log(\u0026#34;SSE server listening on port 3000\u0026#34;)); SSE 연결 (클라이언트 측 - EventSource 미사용) 브라우저에는 EventSource라는 SSE 전용 API가 있지만, 여기서는 SSE가 HTTP 위에서 어떻게 동작하는지 명확히 보기 위해 fetch API의 스트리밍 기능을 사용함\nfetch를 사용하면 서버의 응답 바디(body)를 ReadableStream으로 받아 청크(chunk) 단위로 처리할 수 있음\n// Client-side (Browser JS) async function connectSSE() { let response; try { response = await fetch(\u0026#34;http://localhost:3000/events\u0026#34;); } catch (error) { console.error(\u0026#34;Connection failed:\u0026#34;, error); return; } // 1. 응답 바디에서 ReadableStream의 리더(reader)를 가져옴 const reader = response.body.getReader(); // 2. 텍스트 디코더 준비 (바이너리 데이터를 UTF-8 텍스트로 변환) const decoder = new TextDecoder(); // 3. 스트림이 끝날 때(done)까지 무한 루프 while (true) { const { done, value } = await reader.read(); if (done) { console.log(\u0026#34;Stream finished\u0026#34;); break; // 서버가 연결을 종료함 } // 4. 수신된 바이너리 청크(value)를 텍스트로 디코딩 const rawChunk = decoder.decode(value); // (이후 이 청크를 파싱하는 로직이 필요함) parseStreamChunk(rawChunk); } } // (파싱 로직은 아래 \u0026#39;이벤트 파싱\u0026#39; 섹션 참고) connectSSE(); SSE 이벤트 형식과 송신 (서버 측) SSE는 정해진 텍스트 형식을 사용함. 가장 중요한 필드는 data:임 각 메시지는 두 번의 개행(\\n\\n)으로 구분됨\ndata: [보낼 데이터] (필수) event: [이벤트 이름] (옵션, 클라이언트가 이벤트를 구분할 때 사용) id: [메시지 ID] (옵션, 재연결 시 마지막 ID를 서버로 보냄) clients Set에 저장된 res 객체에 res.write()를 사용해 데이터를 전송함\n// Node.js (Express) - 서버 어디에서든 호출 가능 // 모든 연결된 클라이언트에게 브로드캐스트하는 함수 function broadcast(eventName, data) { // 1. (옵션) \u0026#39;update\u0026#39;라는 이름의 이벤트를 지정 const message = `event: ${eventName}\\n` + // 2. (필수) 실제 데이터를 \u0026#39;data:\u0026#39; 필드에 담아 전송 `data: ${data}\\n` + // 3. (필수) 메시지의 끝을 알리는 개행 전송 `\\n`; for (const res of clients) { res.write(message); } } // 2초마다 모든 클라이언트에게 \u0026#39;update\u0026#39; 이벤트 전송 setInterval(() =\u0026gt; { broadcast(\u0026#34;update\u0026#34;, `This is message number ${Date.now()}`); }, 2000); JSON 데이터 전송 시 주의점 data: 필드가 여러 줄일 경우 파서는 이를 \\n으로 이어붙임 이는 JSON을 여러 줄의 data: 필드로 쪼개어 보내면 안 된다는 것을 의미함\n// 서버에서 JSON 전송 시 const payload = { user: \u0026#34;test\u0026#34;, value: 123 }; // [Good ✅] JSON은 반드시 한 줄의 data 필드로 전송 broadcast(\u0026#34;update\u0026#34;, JSON.stringify(payload)); // (전송되는 텍스트: \u0026#39;event: update\\ndata: {\u0026#34;user\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;value\u0026#34;:123}\\n\\n\u0026#39;) // [Bad ❌] 아래와 같이 여러 data 라인에 걸쳐 JSON을 쪼개면 // res.write(`data: {\u0026#34;user\u0026#34;: \u0026#34;test\u0026#34;,\\n`) // res.write(`data: \u0026#34;value\u0026#34;: 123}\\n\\n`) // 클라이언트 파서는 망가진 텍스트(\u0026#39;{\u0026#34;user\u0026#34;: \u0026#34;test\u0026#34;,\\n\u0026#34;value\u0026#34;: 123}\u0026#39;)를 받게 되어 // JSON.parse()에서 오류가 발생함 SSE 이벤트 파싱 (클라이언트 측 - EventSource 미사용) 서버가 보낸 데이터 청크는 메시지 경계(\\n\\n)와 정확히 일치하지 않을 수 있음 따라서 클라이언트는 데이터를 버퍼(buffer)에 쌓아두고, 메시지 구분자(\\n\\n)가 나타날 때마다 파싱해야 함\n// Client-side (Browser JS) let buffer = \u0026#34;\u0026#34;; // 수신된 청크를 임시 저장할 버퍼 // connectSSE()의 read() 루프에서 호출되는 함수 function parseStreamChunk(rawChunk) { // 1. 버퍼에 새로 수신된 청크를 추가 buffer += rawChunk; // 2. 버퍼에서 메시지 구분자(\\n\\n)를 찾음 let boundary = buffer.indexOf(\u0026#34;\\n\\n\u0026#34;); // 3. 구분자가 존재하면 (즉, 메시지가 하나 이상 완성되면) while (boundary !== -1) { // 4. 완성된 메시지 한 개를 추출 (구분자 앞까지) const rawMessage = buffer.substring(0, boundary); // 5. 버퍼에서 처리된 메시지+구분자 제거 buffer = buffer.substring(boundary + 2); // 6. 추출한 메시지 파싱 parseMessage(rawMessage); // 7. 버퍼에 또 다른 메시지가 있는지 확인 boundary = buffer.indexOf(\u0026#34;\\n\\n\u0026#34;); } } // 수신된 raw 메시지를 파싱하는 헬퍼 함수 function parseMessage(rawMessage) { const lines = rawMessage.split(\u0026#34;\\n\u0026#34;); let eventType = \u0026#34;message\u0026#34;; // event: 필드가 없으면 기본값 \u0026#39;message\u0026#39; let eventData = \u0026#34;\u0026#34;; for (const line of lines) { if (line.startsWith(\u0026#34;event:\u0026#34;)) { eventType = line.substring(6).trim(); } else if (line.startsWith(\u0026#34;data:\u0026#34;)) { // data 필드가 여러 줄일 경우를 대비해 (JSON이 아닌 경우) eventData += line.substring(5).trim(); } } if (eventData) { console.log(`[Event Received] Type: ${eventType}, Data: ${eventData}`); // 여기서 DOM을 업데이트하거나 알림을 표시하는 등 실제 작업 수행 } } 하트비트 (Heartbeat) 일부 프록시 서버나 방화벽은 일정 시간 동안 데이터 전송이 없으면 해당 연결을 유휴(idle) 상태로 간주하고 강제로 종료할 수 있음 이를 방지하기 위해 서버는 주기적으로 의미 없는 데이터(주석)를 보내 연결이 살아있음을 알려야 함. 이를 하트비트라고 함\nSSE 스펙에서 콜론(:)으로 시작하는 라인은 주석으로 취급되며 클라이언트에서 무시됨\n// Node.js (Express) - 서버 측 // 15초마다 하트비트 전송 setInterval(() =\u0026gt; { // : 주석은 클라이언트의 message 이벤트로 전달되지 않음 const heartbeatMessage = \u0026#34;: heartbeat\\n\\n\u0026#34;; for (const res of clients) { res.write(heartbeatMessage); } }, 15000);클라이언트 측에서는 parseMessage 함수가 event:나 data:가 아닌 라인을 무시하므로 별도 코드가 필요 없음\n서버에서 특정 연결 강제 종료 인증 만료, 중복 로그인 등의 이유로 서버가 특정 사용자의 연결을 선별적으로 종료해야 할 수 있음\n// Node.js (Express) - /events 핸들러 app.get(\u0026#34;/events\u0026#34;, (req, res) =\u0026gt; { // ... 헤더 설정 ... // (실제로는 JWT 등에서 파싱한 ID) res.locals.userId = \u0026#34;user-\u0026#34; + Math.floor(Math.random() * 1000); clients.add(res); req.on(\u0026#34;close\u0026#34;, () =\u0026gt; { clients.delete(res); }); }); // (어드민 API 등) 특정 사용자를 종료시켜야 할 때 function kickUser(userIdToKick, reason) { for (const res of clients) { if (res.locals.userId === userIdToKick) { // 1. 클라이언트가 처리할 수 있는 에러 이벤트를 전송 const message = `event: error\\ndata: ${JSON.stringify({ code: \u0026#34;KICKED\u0026#34;, reason: reason, })}\\n\\n`; res.write(message); // 2. 스트림을 정상적으로 종료 (클라이언트의 req.on(\u0026#39;close\u0026#39;)가 호출됨) res.end(); console.log(`Kicked user: ${userIdToKick}`); break; } } } // 예시: 5초 뒤 특정 유저 강제 종료 setTimeout(() =\u0026gt; { // (실제로는 ID를 특정해야 함) if (clients.size \u0026gt; 0) { const userToKick = clients.values().next().value.locals.userId; kickUser(userToKick, \u0026#34;Session expired\u0026#34;); } }, 5000); 마무리 SSE는 단방향 실시간 데이터(알림, 시세, 피드) 전송이 필요할 때 구현이 간단하고 효율적인 훌륭한 선택지임\n반면, 채팅이나 실시간 온라인 게임처럼 클라이언트와 서버가 지속적으로 데이터를 주고받는 양방향 통신이 필수적이라면 웹소켓이 적합함\n프로젝트의 요구사항을 명확히 파악하고, 단방향인지 양방향인지를 기준으로 적절한 기술 스펙을 고르는 것이 중요함\n참고자료 MDN - Server-Sent Events 사용하기 https://developer.mozilla.org/ko/docs/Web/API/Server-Sent_Events/Using_Server-Sent_Events WHATWG - Server-Sent Events 스펙 https://html.spec.whatwg.org/multipage/server-sent-events.html ","permalink":"https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/","summary":"\u003ch1 id=\"sseserver-sent-events란-무엇인가\"\u003eSSE(Server-Sent Events)란 무엇인가\u003c/h1\u003e\n\u003cp\u003eSSE는 \u003cstrong\u003eServer-Sent Events\u003c/strong\u003e의 약자로, 서버가 클라이언트로 \u003cstrong\u003e실시간 데이터를 단방향으로 푸시\u003c/strong\u003e(push)할 수 있게 해주는 웹 기술임\n클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\u003c/p\u003e\n\u003cp\u003e주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"sse-vs-웹소켓-그리고-한계\"\u003eSSE vs 웹소켓, 그리고 한계\u003c/h2\u003e\n\u003cp\u003eSSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\u003c/p\u003e","title":"SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)"},{"content":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026amp; 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u0026gt;\u0026gt;= 1 return h == root코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","permalink":"https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e머클트리는 블록체인에서 거래 집합을 \u003cstrong\u003e안전하고 효율적으로 요약·검증\u003c/strong\u003e하기 위해 쓰이는 핵심 자료구조임\n블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 \u003cstrong\u003e고정 크기 해시 하나\u003c/strong\u003e로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임\n이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-구조\"\u003e핵심 개념과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e머클트리는 보통 \u003cstrong\u003e이진 트리\u003c/strong\u003e 형태로 구현함\u003c/li\u003e\n\u003cli\u003e거래들을 \u003cstrong\u003e리프(leaf)\u003c/strong\u003e 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 \u003cstrong\u003e루트 해시\u003c/strong\u003e를 얻음\u003c/li\u003e\n\u003cli\u003e해시 함수는 체인별로 다르며 비트코인은 \u003cstrong\u003e더블 SHA‑256\u003c/strong\u003e, 이더리움은 트라이 구조에서 \u003cstrong\u003eKeccak‑256\u003c/strong\u003e 을 사용함\u003c/li\u003e\n\u003cli\u003e최상단 해시를 \u003cstrong\u003e머클루트(Merkle root)\u003c/strong\u003e 라 부르며 크기는 해시 함수에 따라 고정됨\u003c/li\u003e\n\u003cli\u003e리프 수가 홀수일 때는 마지막 리프를 \u003cstrong\u003e복제해 짝을 맞추는 방식\u003c/strong\u003e이 일반적이며 비트코인은 이 규칙을 사용함\u003c/li\u003e\n\u003cli\u003e트리 깊이는 리프 수 N에 대해 \u003cstrong\u003e⌈log₂ N⌉\u003c/strong\u003e 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-장점\"\u003e동작 원리와 장점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인접 노드 해시 \u003cstrong\u003eH_left || H_right\u003c/strong\u003e 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e무결성 검증\u003c/strong\u003e\n단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적 포함 증명\u003c/strong\u003e\n특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 \u003cstrong\u003e형제 해시들만\u003c/strong\u003e 있으면 됨\n필요한 해시 개수는 \u003cstrong\u003eO(log N)\u003c/strong\u003e 으로 작아 대역폭과 검증 비용이 작음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장성 보조\u003c/strong\u003e\n리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"블록-헤더와-경량-노드spv\"\u003e블록 헤더와 경량 노드(SPV)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함\u003c/li\u003e\n\u003cli\u003e경량 노드(SPV)는 \u003cstrong\u003e블록 전체가 아니라 헤더 체인만\u003c/strong\u003e 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 \u003cstrong\u003e머클 증명\u003c/strong\u003e 을 받아 포함 여부를 검증함\u003c/li\u003e\n\u003cli\u003e이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨\u003c/li\u003e\n\u003cli\u003e이더리움은 전통적인 이진 머클트리 대신 \u003cstrong\u003e머클‑패트리샤 트라이(MPT)\u003c/strong\u003e 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"구현-세부와-체인별-차이\"\u003e구현 세부와 체인별 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비트코인\u003c/strong\u003e\u003c/p\u003e","title":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"},{"content":"개요 자바스크립트에서 + 단항 연산자는 Number 호출의 축약형으로 동작함 문자열이나 다양한 타입을 숫자로 바꾸려는 순간에 +value와 Number(value)는 같은 의미이고, parseInt는 문자열에서 정수 접두부만 뽑아내는 파서에 가까움 같아 보이지만 목적과 실패 조건이 다르므로 상황에 맞게 선택 필요\n핵심 개념 unary plus +x ECMAScript의 ToNumber 규칙 적용 Number(x)와 동일한 변환 결과 반환 Number(value) 숫자 전체 표현식이어야 함 공백 트림은 허용하지만 유효하지 않은 문자가 섞이면 NaN 반환 parseInt(string, radix) 문자열의 왼쪽부터 주어진 기수(radix, 2~36)로 해석 가능한 정수 접두부만 파싱 유효하지 않은 문자를 만나면 거기서 파싱 중단 접두부 숫자가 하나도 없으면 NaN 반환 ES5+에서 기본 기수는 10이지만, 0x/0X 접두사는 16진수로 처리됨 동작 차이와 사례 전체 일치 vs 접두 파싱 Number('12px') → NaN parseInt('12px', 10) → 12 소수와 지수 표기 Number('10.5') → 10.5, Number('1e3') → 1000 parseInt('10.5', 10) → 10 (소수부 절삭) 빈 문자열과 공백 Number('') → 0, Number(' ') → 0 parseInt('') → NaN 비문자열 입력 +true → 1, +false → 0, +null → 0, +undefined → NaN parseInt(true, 10) → NaN (문자열로 변환 시 \u0026rsquo;true\u0026rsquo;라서 숫자 접두부 없음) 진법 접두사 처리 차이 Number('0x10') → 16, parseInt('0x10') → 16 Number('0b101') → 5 (ES2015+), parseInt('0b101') → 0\n참고로 parseInt('101', 2) → 5 처럼 radix를 명시해야 기대대로 동작함 BigInt 관련 +10n은 TypeError 발생 Number(10n)은 10으로 변환되나 정밀도 손실 가능성 존재 선택 기준 전체 문자열이 유효한 숫자여야 하고 실수, 지수 표기도 허용해야 함 +value 또는 Number(value) 선택 가독성 우선이면 Number(value) 추천, 축약을 선호하면 +value 선택 문자열 앞부분에서 정수만 뽑고 싶거나 비 10진수 파싱 필요 parseInt(str, radix) 선택 항상 radix 명시 권장 소수부를 보존하면서 부분 파싱이 필요 parseFloat 고려 다만 parseFloat도 접두 파싱이므로 전체 일치 검증이 필요하면 Number 사용 권장 베스트 프랙티스 숫자 변환 의도 전달이 중요할 때 Number(value) 사용 정수 파싱 시 parseInt(str, 10)처럼 radix를 항상 명시 사용자 입력 검증이 필요하면 정규식 또는 스키마 검증으로 전체 형식 검증 후 Number 변환 성능 미세 최적화보다 가독성과 실패 조건의 명확성을 우선 간단 예시 Number(\u0026#39;12\u0026#39;) // 12 +\u0026#39;12\u0026#39; // 12 parseInt(\u0026#39;12\u0026#39;,10) // 12 Number(\u0026#39;12px\u0026#39;) // NaN parseInt(\u0026#39;12px\u0026#39;,10) // 12 Number(\u0026#39;0b101\u0026#39;) // 5 parseInt(\u0026#39;0b101\u0026#39;) // 0, radix 명시 필요 parseInt(\u0026#39;101\u0026#39;, 2) // 5 결론 +는 Number의 축약형이 맞음 전체 숫자 표현식으로서의 유효성을 요구할 때 + 또는 Number 사용, 접두부 정수 추출이나 진법 파싱에는 parseInt 사용 의도를 코드에 드러내고, 실패 조건을 일관되게 가져가는 쪽으로 선택하는 것이 유지보수에 유리함\n참고자료 https://stackoverflow.com/questions/17106681/parseint-vs-unary-plus-when-to-use-which https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt ","permalink":"https://blog.jsontapose.com/posts/unary-plus-vs-parseint-160cb0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e자바스크립트에서 \u003ccode\u003e+\u003c/code\u003e 단항 연산자는 \u003ccode\u003eNumber\u003c/code\u003e 호출의 축약형으로 동작함\n문자열이나 다양한 타입을 숫자로 바꾸려는 순간에 \u003ccode\u003e+value\u003c/code\u003e와 \u003ccode\u003eNumber(value)\u003c/code\u003e는 같은 의미이고, \u003ccode\u003eparseInt\u003c/code\u003e는 문자열에서 정수 접두부만 뽑아내는 파서에 가까움\n같아 보이지만 목적과 실패 조건이 다르므로 상황에 맞게 선택 필요\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eunary plus \u003ccode\u003e+x\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eECMAScript의 ToNumber 규칙 적용\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNumber(x)\u003c/code\u003e와 동일한 변환 결과 반환\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNumber(value)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e숫자 전체 표현식이어야 함\u003c/li\u003e\n\u003cli\u003e공백 트림은 허용하지만 유효하지 않은 문자가 섞이면 \u003ccode\u003eNaN\u003c/code\u003e 반환\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseInt(string, radix)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e문자열의 왼쪽부터 주어진 기수(radix, 2~36)로 해석 가능한 정수 접두부만 파싱\u003c/li\u003e\n\u003cli\u003e유효하지 않은 문자를 만나면 거기서 파싱 중단\u003c/li\u003e\n\u003cli\u003e접두부 숫자가 하나도 없으면 \u003ccode\u003eNaN\u003c/code\u003e 반환\u003c/li\u003e\n\u003cli\u003eES5+에서 기본 기수는 10이지만, \u003ccode\u003e0x\u003c/code\u003e/\u003ccode\u003e0X\u003c/code\u003e 접두사는 16진수로 처리됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-차이와-사례\"\u003e동작 차이와 사례\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e전체 일치 vs 접두 파싱\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNumber('12px')\u003c/code\u003e → \u003ccode\u003eNaN\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseInt('12px', 10)\u003c/code\u003e → \u003ccode\u003e12\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e소수와 지수 표기\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNumber('10.5')\u003c/code\u003e → \u003ccode\u003e10.5\u003c/code\u003e, \u003ccode\u003eNumber('1e3')\u003c/code\u003e → \u003ccode\u003e1000\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseInt('10.5', 10)\u003c/code\u003e → \u003ccode\u003e10\u003c/code\u003e (소수부 절삭)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e빈 문자열과 공백\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNumber('')\u003c/code\u003e → \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eNumber('   ')\u003c/code\u003e → \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseInt('')\u003c/code\u003e → \u003ccode\u003eNaN\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e비문자열 입력\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+true\u003c/code\u003e → \u003ccode\u003e1\u003c/code\u003e, \u003ccode\u003e+false\u003c/code\u003e → \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e+null\u003c/code\u003e → \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e+undefined\u003c/code\u003e → \u003ccode\u003eNaN\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseInt(true, 10)\u003c/code\u003e → \u003ccode\u003eNaN\u003c/code\u003e (문자열로 변환 시 \u0026rsquo;true\u0026rsquo;라서 숫자 접두부 없음)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e진법 접두사 처리 차이\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNumber('0x10')\u003c/code\u003e → \u003ccode\u003e16\u003c/code\u003e, \u003ccode\u003eparseInt('0x10')\u003c/code\u003e → \u003ccode\u003e16\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNumber('0b101')\u003c/code\u003e → \u003ccode\u003e5\u003c/code\u003e (ES2015+), \u003ccode\u003eparseInt('0b101')\u003c/code\u003e → \u003ccode\u003e0\u003c/code\u003e\u003cbr\u003e\n참고로 \u003ccode\u003eparseInt('101', 2)\u003c/code\u003e → \u003ccode\u003e5\u003c/code\u003e 처럼 radix를 명시해야 기대대로 동작함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eBigInt 관련\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+10n\u003c/code\u003e은 TypeError 발생\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNumber(10n)\u003c/code\u003e은 \u003ccode\u003e10\u003c/code\u003e으로 변환되나 정밀도 손실 가능성 존재\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"선택-기준\"\u003e선택 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e전체 문자열이 유효한 숫자여야 하고 실수, 지수 표기도 허용해야 함\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e+value\u003c/code\u003e 또는 \u003ccode\u003eNumber(value)\u003c/code\u003e 선택\u003c/li\u003e\n\u003cli\u003e가독성 우선이면 \u003ccode\u003eNumber(value)\u003c/code\u003e 추천, 축약을 선호하면 \u003ccode\u003e+value\u003c/code\u003e 선택\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e문자열 앞부분에서 정수만 뽑고 싶거나 비 10진수 파싱 필요\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparseInt(str, radix)\u003c/code\u003e 선택\u003c/li\u003e\n\u003cli\u003e항상 \u003ccode\u003eradix\u003c/code\u003e 명시 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e소수부를 보존하면서 부분 파싱이 필요\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparseFloat\u003c/code\u003e 고려\u003c/li\u003e\n\u003cli\u003e다만 \u003ccode\u003eparseFloat\u003c/code\u003e도 접두 파싱이므로 전체 일치 검증이 필요하면 \u003ccode\u003eNumber\u003c/code\u003e 사용 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"베스트-프랙티스\"\u003e베스트 프랙티스\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e숫자 변환 의도 전달이 중요할 때 \u003ccode\u003eNumber(value)\u003c/code\u003e 사용\u003c/li\u003e\n\u003cli\u003e정수 파싱 시 \u003ccode\u003eparseInt(str, 10)\u003c/code\u003e처럼 radix를 항상 명시\u003c/li\u003e\n\u003cli\u003e사용자 입력 검증이 필요하면 정규식 또는 스키마 검증으로 전체 형식 검증 후 \u003ccode\u003eNumber\u003c/code\u003e 변환\u003c/li\u003e\n\u003cli\u003e성능 미세 최적화보다 가독성과 실패 조건의 명확성을 우선\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003eNumber\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;12\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e      \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e+\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;12\u0026#39;\u003c/span\u003e             \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eparseInt\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;12\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e10\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003eNumber\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;12px\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e    \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// NaN\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eparseInt\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;12px\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e10\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 12\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003eNumber\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;0b101\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e   \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 5\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eparseInt\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;0b101\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 0, radix 명시 필요\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eparseInt\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;101\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 5\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"결론\"\u003e결론\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e+\u003c/code\u003e는 \u003ccode\u003eNumber\u003c/code\u003e의 축약형이 맞음\n전체 숫자 표현식으로서의 유효성을 요구할 때 \u003ccode\u003e+\u003c/code\u003e 또는 \u003ccode\u003eNumber\u003c/code\u003e 사용, 접두부 정수 추출이나 진법 파싱에는 \u003ccode\u003eparseInt\u003c/code\u003e 사용\n의도를 코드에 드러내고, 실패 조건을 일관되게 가져가는 쪽으로 선택하는 것이 유지보수에 유리함\u003c/p\u003e","title":"JavaScript에서 unary plus(+)와 parseInt 비교 및 선택 기준"},{"content":"개요 pageLoadStrategy는 WebDriver가 페이지 이동 명령을 언제 완료로 판단할지 결정하는 세션 단위 설정값임. 핵심은 document.readyState 조회 시점을 어떻게 보느냐이며 전략별 대기 조건이 다름. 기본값은 normal이며, 네트워크 리소스가 많아 느린 페이지에서 eager 또는 none으로 바꿔 세션 체감 속도를 높일 수 있음\nSPA처럼 자바스크립트가 동적으로 화면을 채우는 사이트에서는 readyState가 complete여도 실제 사용자 관점의 완료와 다를 수 있음. 전략 변경 시 명시적 대기 조합 설계가 필수임\n주의할 점은 get 등 URL 기반 내비게이션과 달리, 클릭이나 폼 제출로 발생한 내비게이션에는 동일한 대기 규칙이 그대로 적용되지 않을 수 있음. 이 경우에도 별도의 대기 전략으로 안정성을 확보해야 함\n전략별 동작 pageLoadStrategy는 document.readyState 값에 기반하여 다음과 같이 동작함\nnormal → readyState가 complete일 때까지 대기. HTML과 서브리소스 다운로드 완료 시점까지 기다리는 동작에 가까움 eager → readyState가 interactive일 때까지 대기. DOM 접근 가능 상태. 이미지 등 일부 리소스는 계속 로드 중일 수 있음 none → readyState값과 무관. 내비게이션 명령을 사실상 즉시 반환. 이후 로딩 진행 중 상태에서 테스트 로직이 실행됨 document.readyState는 현재 문서의 로딩 상태를 표현함. complete는 준수한 완료 기준으로 보이지만, 동적 렌더링이 많은 페이지에서는 UI 준비 완료의 보증이 아님\n언제 어떤 전략을 쓰나 normal 서버 렌더링 중심 페이지. 리소스가 과도하지 않고 완전한 로드가 타당한 기본값 초기 진입 안정성이 최우선일 때 선택 eager DOM만 준비되면 바로 상호작용 가능한 플로우. 이미지나 추적 스크립트가 느린 케이스에서 체감 속도 향상 DOMContentLoaded 이후 명시적 대기로 특정 요소 조건을 보강하는 패턴과 궁합이 좋음 none 초기에 특정 API 응답이나 특정 DOM 스냅샷만 확보하면 되는 플로우 페이지 초기화 로직을 테스트 측에서 주도적으로 동기화할 수 있을 때만 추천. 명시적 대기 없으면 불안정해짐 이 값은 세션 전체에 적용됨. 테스트 케이스별로 상이한 대기 정합이 필요한 경우 드라이버 세션을 분리하는 편이 관리가 쉬움\n언어별 설정 예시 필요 최소 설정만 예시로 표기\nJava ChromeOptions options = new ChromeOptions(); options.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(options); Python from selenium import webdriver from selenium.webdriver.chrome.options import Options opts = Options() opts.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=opts)Selenium 4에서는 DesiredCapabilities 사용 대신 각 브라우저 Options를 사용하는 방식 권장. 레거시 코드에서 setCapability(\u0026ldquo;pageLoadStrategy\u0026rdquo;, \u0026ldquo;eager\u0026rdquo;)를 보게 되더라도 신규 코드는 Options API로 통일하는 편이 좋음\n동작 맥락과 주의 사항 반환 시점의 범위\npageLoadStrategy는 세션의 내비게이션 명령 반환 시점을 정의. 일반적으로 driver.get과 같은 직접 URL 이동에 명확히 적용됨 유저 인터랙션 기반 내비게이션은 드라이버 구현 및 브라우저별 차이가 있을 수 있으므로, 클릭 후 특정 상태를 명시적 대기로 보강하는 습관 필요 eager와 none 사용 시 동기화 전략\neager는 DOM 접근이 가능하지만 이미지나 비필수 리소스가 진행 중일 수 있음. CSS 지연으로 레이아웃 셰이크가 발생할 수 있어 요소 가시성, 크기 안정성 등의 조건으로 명시적 대기 설계 권장 none은 초기 HTML 수신 직후 로직이 이어지므로, 네비게이션 완료를 자체 조건으로 정의해야 함. 예를 들어 특정 루트 컨테이너 존재, 핵심 API 응답 반영 여부, 스피너 소멸 여부 등을 WebDriverWait으로 보장 브라우저별 구현 차\n전략 개념은 W3C WebDriver 스펙에 정의되어 있으나 드라이버 구현 및 버전에 따라 세부 타이밍이 다를 수 있음 ChromeDriver는 77 버전대부터 eager를 정식 지원. 현재는 주요 드라이버에서 normal, eager, none 모두 사용 가능. 환경 차에 따른 타이밍 변동에 대비해 대기 조건을 결과 중심으로 설계 권장 암묵적 대기와의 상호작용\n암묵적 대기(implicit wait)는 요소 탐색에만 영향을 주며 페이지 로드 완료와는 별개. pageLoadStrategy 조정 시에는 명시적 대기(explicit wait)를 우선 적용 권장 성능과 안정성의 트레이드오프\neager와 none은 테스트 체감 속도를 높일 수 있으나, 준비되지 않은 DOM 또는 스타일 상태에서 상호작용하려다 실패할 수 있음 정상 케이스와 실패 케이스 모두에서 동일하게 안정 동작하는 대기 조건을 최소 세트로 유지하는 것이 중요함 베스트 프랙티스 기본값은 normal로 시작하고 병목이 명확할 때 eager로 전환. none은 명시적 동기화 설계가 준비된 경우에만 사용 대기 조건은 UI 최종 상태보다 테스트 목적에 직접 연관된 불변 조건으로 작성. 예) 핵심 컨테이너 존재, 특정 데이터 렌더 수량 충족, 로딩 스피너 제거 등 테스트 중간 단계에서 네비게이션을 야기하는 액션에는 항상 후속 명시적 대기를 배치. 클릭 성공만으로 페이지 준비 완료를 가정하지 않음 세션 전역 설정이므로 케이스마다 요구 조건이 다르면 드라이버 세션을 분리하거나, 공통 초기화 훅에서 옵션을 명시적으로 주입 불안정 징후가 보이면 브라우저별 드라이버 버전을 고정하고, 로컬과 CI의 네트워크/CPU 자원 차이에 따른 타이밍 편차를 모니터링 간단 체크리스트 현재 케이스에서 완전한 페이지 로드가 진짜 필요한가 동적 로딩이 많은가. 필요 DOM만 확보되면 충분한가 eager 또는 none 사용 시 명시적 대기 조건이 정의되어 있는가 클릭 기반 네비게이션 이후의 동기화 전략이 있는가 로컬과 CI 환경에서 동일하게 재현 가능한가 참고 normal은 완전 로드를 보장하는 진실의 순간이 아님. complete 이후에도 SPA는 데이터를 비동기로 적재함 eager는 DOMContentLoaded를 기준으로 빠르게 반환. 이미지 등은 지연될 수 있음 none은 드라이버 차단을 최소화하지만 모든 동기화를 테스트 코드가 책임짐 마무리 pageLoadStrategy는 테스트 속도와 안정성의 균형을 조절하는 레버임. normal로 시작해 병목과 목적을 기준으로 eager 또는 none을 선택하고, 명시적 대기로 관찰 가능한 완료 조건을 고정하면 플래키니스를 줄이면서 실행 시간을 단축할 수 있음. 드라이버와 브라우저 버전에 따른 미세한 차이를 흡수하도록 결과 중심의 대기를 설계하는 것이 핵심임\n참고자료 https://www.selenium.dev/documentation/webdriver/drivers/options/ https://www.selenium.dev/documentation/webdriver/waits/ https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState https://www.w3.org/TR/webdriver/#dfn-table-of-page-load-strategies https://www.w3.org/TR/webdriver/#h-navigation https://html.spec.whatwg.org/multipage/dom.html#the-document's-readystate https://stackoverflow.com/questions/43734797/page-load-strategy-for-chrome-driver-updated-till-selenium-v3-12-0 ","permalink":"https://blog.jsontapose.com/posts/selenium-webdriver-pageloadstrategy-guide-8cac26/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003epageLoadStrategy는 WebDriver가 페이지 이동 명령을 언제 완료로 판단할지 결정하는 세션 단위 설정값임. 핵심은 document.readyState 조회 시점을 어떻게 보느냐이며 전략별 대기 조건이 다름. 기본값은 normal이며, 네트워크 리소스가 많아 느린 페이지에서 eager 또는 none으로 바꿔 세션 체감 속도를 높일 수 있음\u003c/p\u003e\n\u003cp\u003eSPA처럼 자바스크립트가 동적으로 화면을 채우는 사이트에서는 readyState가 complete여도 실제 사용자 관점의 완료와 다를 수 있음. 전략 변경 시 명시적 대기 조합 설계가 필수임\u003c/p\u003e\n\u003cp\u003e주의할 점은 get 등 URL 기반 내비게이션과 달리, 클릭이나 폼 제출로 발생한 내비게이션에는 동일한 대기 규칙이 그대로 적용되지 않을 수 있음. 이 경우에도 별도의 대기 전략으로 안정성을 확보해야 함\u003c/p\u003e","title":"Selenium WebDriver pageLoadStrategy 동작 원리와 설정 가이드"},{"content":"개념/배경 CTE는 WITH로 정의하는 이름 있는 임시 결과셋 바로 다음 한 개 DML에서만 참조 가능하며 실행이 끝나면 범위 소멸 가독성 향상과 쿼리 구조 분리에 유용함\n사용법 WITH cte_name (col1, col2) AS ( SELECT ... ) DML필요 시 컬럼 목록 생략 가능하나 명시를 권장\n주의사항 일부 DBMS에서는 배치 내에서 CTE 앞에 오는 쿼리를 세미콜론으로 종료 필요 CTE 범위는 바로 뒤 한 개 DML로 한정됨 복잡한 쿼리에서 과도한 중첩 사용은 계획 복잡도 증가 가능 참고자료 https://s2choco.tistory.com/34 https://learn.microsoft.com/sql/t-sql/queries/with-common-table-expression-transact-sql ","permalink":"https://blog.jsontapose.com/posts/cte-common-table-expression-with-usage-4e5d41/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eCTE는 WITH로 정의하는 이름 있는 임시 결과셋\n바로 다음 한 개 DML에서만 참조 가능하며 실행이 끝나면 범위 소멸\n가독성 향상과 쿼리 구조 분리에 유용함\u003c/p\u003e\n\u003ch3 id=\"사용법\"\u003e사용법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eWITH\u003c/span\u003e cte_name \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ecol1\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e col2\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eAS\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDML\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e필요 시 컬럼 목록 생략 가능하나 명시를 권장\u003c/p\u003e\n\u003ch3 id=\"주의사항\"\u003e주의사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e일부 DBMS에서는 배치 내에서 CTE 앞에 오는 쿼리를 세미콜론으로 종료 필요\u003c/li\u003e\n\u003cli\u003eCTE 범위는 바로 뒤 한 개 DML로 한정됨\u003c/li\u003e\n\u003cli\u003e복잡한 쿼리에서 과도한 중첩 사용은 계획 복잡도 증가 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://s2choco.tistory.com/34\"\u003ehttps://s2choco.tistory.com/34\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/sql/t-sql/queries/with-common-table-expression-transact-sql\"\u003ehttps://learn.microsoft.com/sql/t-sql/queries/with-common-table-expression-transact-sql\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"CTE(Common Table Expression) 개념과 WITH 사용법 요약"},{"content":"개념/배경 Unobtrusive JavaScript는 HTML 구조와 JS 동작을 분리하는 접근 철학 HTML은 의미와 콘텐츠, CSS는 표현, JS는 상호작용과 상태 제어 담당 인라인 스크립트와 이벤트 속성 제거, 외부 스크립트에서 안전하게 바인딩하는 방식 지향\n핵심 목표는 접근성 보장, 점진적 향상, 유지보수성과 테스트 용이성 개선, 캐시 효율 상승, 보안 취약점 노출 감소\n핵심 원칙 HTML은 의미 중심 마크업 유지 CSS는 표현만 담당 JS는 DOMContentLoaded 이후 동작 주입 인라인 onclick 등 이벤트 속성 사용 금지 기능 감지 우선, UA 스니핑 지양 데이터 훅은 data-* 속성 사용, 스타일 훅과 분리 JS 미동작 상황에서도 기본 기능 유지, 점진적 향상 고려 모듈 분리와 의존성 최소화 동작 방식 마크업은 링크와 폼이 기본 동작을 스스로 제공하도록 설계 JS는 존재하면 기본 동작을 확장하거나 향상 이벤트 바인딩은 외부 스크립트에서 선택자 기반으로 수행, 인라인 스크립트 제거\n간단 예시\n\u0026lt;!-- 지양 --\u0026gt; \u0026lt;a href=\u0026#34;/download\u0026#34; onclick=\u0026#34;return doDownload()\u0026#34;\u0026gt;Download\u0026lt;/a\u0026gt; \u0026lt;!-- 지향 --\u0026gt; \u0026lt;a href=\u0026#34;/download\u0026#34; data-action=\u0026#34;download\u0026#34;\u0026gt;Download\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { const el = document.querySelector(\u0026#39;[data-action=\u0026#34;download\u0026#34;]\u0026#39;) if (!el) return el.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { e.preventDefault() doDownload() }) }) \u0026lt;/script\u0026gt;주의사항 및 베스트 프랙티스 키보드 내비게이션 보장, 포커스 순서와 가시 포커스 유지 이벤트 위임 사용 시 범위 최소화, 예기치 않은 버블링 영향 차단 data-* 값은 신뢰하지 않음, 검증 및 방어 코드 포함 네트워크 지연이나 JS 비활성 환경에서 기본 기능 작동 확인 번들 분할과 지연 로딩 적용 시 의존 순서와 초기 하이드레이션 경계 명확화 마무리 Unobtrusive JavaScript의 요지는 역할 분리와 안전한 동작 주입 HTML은 의미, CSS는 표현, JS는 행동이라는 경계를 지키면 접근성, 성능, 유지보수성이 동시에 개선됨\n참고자료 https://developer.mozilla.org/en-US/docs/Glossary/Unobtrusive_JavaScript https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Separation_of_concerns ","permalink":"https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eUnobtrusive JavaScript는 HTML 구조와 JS 동작을 분리하는 접근 철학\nHTML은 의미와 콘텐츠, CSS는 표현, JS는 상호작용과 상태 제어 담당\n인라인 스크립트와 이벤트 속성 제거, 외부 스크립트에서 안전하게 바인딩하는 방식 지향\u003c/p\u003e\n\u003cp\u003e핵심 목표는 접근성 보장, 점진적 향상, 유지보수성과 테스트 용이성 개선, 캐시 효율 상승, 보안 취약점 노출 감소\u003c/p\u003e\n\u003ch3 id=\"핵심-원칙\"\u003e핵심 원칙\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHTML은 의미 중심 마크업 유지\u003c/li\u003e\n\u003cli\u003eCSS는 표현만 담당\u003c/li\u003e\n\u003cli\u003eJS는 DOMContentLoaded 이후 동작 주입\u003c/li\u003e\n\u003cli\u003e인라인 onclick 등 이벤트 속성 사용 금지\u003c/li\u003e\n\u003cli\u003e기능 감지 우선, UA 스니핑 지양\u003c/li\u003e\n\u003cli\u003e데이터 훅은 data-* 속성 사용, 스타일 훅과 분리\u003c/li\u003e\n\u003cli\u003eJS 미동작 상황에서도 기본 기능 유지, 점진적 향상 고려\u003c/li\u003e\n\u003cli\u003e모듈 분리와 의존성 최소화\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-방식\"\u003e동작 방식\u003c/h3\u003e\n\u003cp\u003e마크업은 링크와 폼이 기본 동작을 스스로 제공하도록 설계\nJS는 존재하면 기본 동작을 확장하거나 향상\n이벤트 바인딩은 외부 스크립트에서 선택자 기반으로 수행, 인라인 스크립트 제거\u003c/p\u003e","title":"Unobtrusive JavaScript와 HTML·JS 분리 원칙"},{"content":"개요 C#에서 키와 값으로 데이터를 저장하는 대표 컬렉션은 Hashtable과 Dictionary 두 가지가 있음 표면적인 사용법은 비슷하지만 제네릭 지원 여부와 타입 처리 방식이 달라 성능과 안정성에서 차이 발생 핵심 차이와 간단 예시, 선택 기준 정리\n핵심 차이 Hashtable\n비제네릭 컬렉션, Key와 Value가 object로 저장됨 값 형식 저장 시 박싱 발생, 꺼낼 때 언박싱 또는 캐스팅 비용 발생 컴파일 타임 타입 체크 부재, 런타임 캐스팅 오류 위험 높음 레거시 코드와의 호환성은 높으나 일반적으로 권장되지 않음 Dictionary\u0026lt;TKey, TValue\u0026gt;\n제네릭 컬렉션, 선언 시 Key와 Value의 타입 고정 박싱/언박싱 없음(값 형식 포함), 타입 안정성 확보 대체로 더 빠르고 풍부한 API 제공 참고로 언박싱은 값 형식에만 해당되는 개념이며, 참조 형식에 대한 as 또는 캐스트는 언박싱이 아님\n사용 예시 Hashtable 최소 예시 var table = new Hashtable() table[\u0026#34;k1\u0026#34;] = 1 // 값 형식 → 박싱 발생 int v = (int)table[\u0026#34;k1\u0026#34;] // 언박싱 필요 Dictionary 최소 예시 var dict = new Dictionary\u0026lt;string, ExampleClass\u0026gt;() dict.Add(\u0026#34;data1\u0026#34;, new ExampleClass { Name = \u0026#34;item1\u0026#34;, Count = 1 }) if (dict.TryGetValue(\u0026#34;data1\u0026#34;, out var item)) Console.WriteLine(item.Name)선택 기준과 주의 언제 Dictionary 선택\n고정된 타입을 저장할 때 기본 선택 값 형식을 자주 저장하거나 성능 민감할 때 유리 API 사용성, 가독성, 컴파일 타임 타입 체크 확보 언제 Hashtable 선택\n레거시 코드나 비제네릭 API와의 호환이 필요한 경우에 한정 다양한 타입을 섞어 저장해야 한다면 대안으로 Dictionary\u0026lt;string, object\u0026gt; 고려 가능 공통 주의사항\n키는 null 불가, 값은 null 허용 여부는 타입에 따라 다름 키 타입은 Equals와 GetHashCode의 일관성 필수, 그렇지 않으면 조회 실패나 중복 키 문제 발생 멀티스레드 환경에서 동시 수정 필요 시 외부 동기화 또는 ConcurrentDictionary 사용 권장 ContainsKey 후 인덱서 접근 대신 TryGetValue 사용으로 이중 조회 방지 열거 순서에 의존한 로직 지양, 구현에 따라 변경 가능성 존재 마무리 사용법은 비슷하지만 타입 안정성과 성능 측면에서 Dictionary가 일반적인 기본값 Hashtable은 특별한 호환성 요구가 있을 때만 선택 값 형식 저장, 타입 안정성, 성능 요구가 있다면 Dictionary를 우선 고려 다양한 타입 혼재가 필요하면 Dictionary\u0026lt;string, object\u0026gt;나 구분 가능한 래퍼 타입으로 모델링 권장\n참고자료 https://learn.microsoft.com/dotnet/api/system.collections.hashtable https://learn.microsoft.com/dotnet/api/system.collections.generic.dictionary-2 https://learn.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing https://learn.microsoft.com/dotnet/api/system.collections.concurrent.concurrentdictionary-2 ","permalink":"https://blog.jsontapose.com/posts/csharp-hashtable-vs-dictionary-f52312/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eC#에서 키와 값으로 데이터를 저장하는 대표 컬렉션은 Hashtable과 Dictionary 두 가지가 있음\n표면적인 사용법은 비슷하지만 제네릭 지원 여부와 타입 처리 방식이 달라 성능과 안정성에서 차이 발생\n핵심 차이와 간단 예시, 선택 기준 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-차이\"\u003e핵심 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHashtable\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비제네릭 컬렉션, Key와 Value가 object로 저장됨\u003c/li\u003e\n\u003cli\u003e값 형식 저장 시 박싱 발생, 꺼낼 때 언박싱 또는 캐스팅 비용 발생\u003c/li\u003e\n\u003cli\u003e컴파일 타임 타입 체크 부재, 런타임 캐스팅 오류 위험 높음\u003c/li\u003e\n\u003cli\u003e레거시 코드와의 호환성은 높으나 일반적으로 권장되지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDictionary\u0026lt;TKey, TValue\u0026gt;\u003c/p\u003e","title":"C# Hashtable vs Dictionary 비교와 선택 기준"},{"content":"개요 링크를 새 탭에서 열 때 a 태그에 target=\u0026quot;_blank\u0026quot;를 많이 사용함 이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음 rel=\u0026ldquo;noopener noreferrer\u0026quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨\n핵심 개념 target: 링크 대상 브라우징 컨텍스트 지정 window.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체 rel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지 rel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개 target 값 정리 _self: 현재 탭에서 열기, 기본값이라 명시 생략 가능 _blank: 새 탭에서 열기 target=\u0026quot;_blank\u0026quot;만 사용할 때의 문제 보안 취약점 발생 가능 악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재 원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음 성능 간섭 가능성 새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음 무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음 해결책 rel=\u0026ldquo;noopener\u0026rdquo; 새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단 탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화 rel=\u0026ldquo;noreferrer\u0026rdquo; 이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지 분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려 사용 예시 필수 최소 속성만 명시\n링크 열기\n보안 우선이면 noopener 필수, 개인정보 보호까지 필요하면 noreferrer 추가 리퍼러 기반 분석이 필요하면 rel=\u0026ldquo;noopener\u0026quot;만 적용하고 noreferrer는 생략 동작 확인 새 탭에서 window.opener가 null이면 noopener 적용 상태 예시 콘솔 확인용 코드 한 줄 console.log(window.opener) 주의 사항과 베스트 프랙티스 최신 브라우저 일부는 target=\u0026quot;_blank\u0026quot;에 대해 기본적으로 noopener를 적용하기도 함 다만 적용 범위와 시점이 브라우저마다 달라 명시적으로 rel=\u0026ldquo;noopener\u0026quot;를 추가하는 것이 안전함 외부 도메인으로 나가는 링크는 기본적으로 target=\u0026quot;_blank\u0026rdquo; + rel=\u0026ldquo;noopener\u0026rdquo; 적용 권장 내부 네비게이션은 새 탭 강제 대신 사용자 선택 존중 권장 조직 차원에서 링크 컴포넌트의 기본값으로 rel=\u0026ldquo;noopener\u0026quot;를 강제하고, 필요 시 noreferrer를 옵션으로 제공하는 패턴 권장 마무리 새 탭 열기 자체는 간단하지만 보안과 프라이버시, 성능까지 고려하면 기본값만으로는 부족함 target=\u0026quot;_blank\u0026quot;에는 최소 rel=\u0026ldquo;noopener\u0026quot;를 명시하고 상황에 따라 rel=\u0026ldquo;noreferrer\u0026quot;를 선택 적용하는 것을 기본 원칙으로 가져갈 것\n참고자료 MDN a 요소 target 속성 개요와 동작 rel=noopener의 배경과 리버스 태브내빙 설명 Lighthouse의 noopener 권고와 진단 기준 참고자료 https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel https://mathiasbynens.github.io/rel-noopener/ https://web.dev/external-anchors-use-rel-noopener/ ","permalink":"https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e링크를 새 탭에서 열 때 a 태그에 target=\u0026quot;_blank\u0026quot;를 많이 사용함\n이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음\nrel=\u0026ldquo;noopener noreferrer\u0026quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003etarget: 링크 대상 브라우징 컨텍스트 지정\u003c/li\u003e\n\u003cli\u003ewindow.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체\u003c/li\u003e\n\u003cli\u003erel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지\u003c/li\u003e\n\u003cli\u003erel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"target-값-정리\"\u003etarget 값 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e_self: 현재 탭에서 열기, 기본값이라 명시 생략 가능\u003c/li\u003e\n\u003cli\u003e_blank: 새 탭에서 열기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"target_blank만-사용할-때의-문제\"\u003etarget=\u0026quot;_blank\u0026quot;만 사용할 때의 문제\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e보안 취약점 발생 가능\n악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재\n원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음\u003c/li\u003e\n\u003cli\u003e성능 간섭 가능성\n새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음\n무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"해결책\"\u003e해결책\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003erel=\u0026ldquo;noopener\u0026rdquo;\n새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단\n탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화\u003c/li\u003e\n\u003cli\u003erel=\u0026ldquo;noreferrer\u0026rdquo;\n이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지\n분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cp\u003e필수 최소 속성만 명시\u003c/p\u003e","title":"a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer"},{"content":"개요 Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임 원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음 희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨\n구문 arr.map(callback(currentValue[, index[, array]])[, thisArg])\ncallback 현재 요소를 변환해 새 요소를 생성하는 함수 currentValue 현재 요소 값 index 선택 현재 요소의 인덱스 array 선택 map을 호출한 원본 배열 thisArg 선택 콜백 실행 시 this로 사용할 값 반환값 각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환 원본 배열과 길이는 동일하고 희소성도 보존됨\n동작 원리와 특징 순회 범위 고정 첫 콜백이 호출되기 전에 배열의 길이 스냅샷이 결정됨 추가와 삭제 map 진행 중 추가된 요소는 방문하지 않음, 방문 전 삭제된 요소는 건너뜀 값 읽기 시점 요소 값은 방문 시점의 최신 값이 콜백에 전달됨 희소 배열 처리 값이 없는 인덱스는 콜백 미호출, 결과 배열에서도 동일 인덱스가 빈 슬롯으로 남음 this 바인딩 thisArg가 주어지면 콜백의 this로 사용되고, 없으면 undefined가 기본값으로 들어감. 최종 this는 일반적인 this 바인딩 규칙을 따름 불변성 보장 map 자체는 원본을 수정하지 않음. 단 콜백 내부에서 원본을 바꾸면 그 영향은 순회 타이밍에 따라 결과에 반영될 수 있음 언제 map을 쓰는가 변환 목적 각 요소를 다른 값으로 치환해 새 배열로 만들 때 사용 forEach와 비교 forEach는 반환값이 없고 부수효과 중심. map은 새 배열 생성 중심 flatMap과 비교 요소를 배열로 변환하고 1단계 평탄화가 필요하면 flatMap 권장 간단 예시 숫자 변환 numbers.map(Math.sqrt) 제곱근 배열 생성 객체 재구성 list.map(({ key, value }) =\u0026gt; ({ [key]: value })) 키-값 쌍을 객체로 매핑 문자열에도 적용 가능 Array.prototype.map.call('Hello', ch =\u0026gt; ch.charCodeAt(0)) 문자 코드 배열 생성 유사 배열 처리 Array.from(document.querySelectorAll('select option:checked'), el =\u0026gt; el.value) NodeList를 값 배열로 변환 까다로운 사례와 주의 parseInt와 map의 조합 혼동 포인트 map은 콜백에 (value, index, array)를 전달함 parseInt는 두 번째 인자로 기수(radix)를 받음 ['1','2','3'].map(parseInt)는 내부적으로 parseInt('1', 0), parseInt('2', 1), parseInt('3', 2)를 호출하므로 결과가 [1, NaN, NaN]이 됨 안전한 대안 arr.map(x =\u0026gt; parseInt(x, 10)) 또는 arr.map(Number) 사용. Number는 부동소수점과 지수표현을 숫자로 변환함 희소 배열 보존 의도적으로 빈 슬롯을 제거하려면 map 전에 filter로 값 존재 여부를 확인하거나 map 이후에 compaction 절차 필요 성능 고려 대형 배열에서 불필요한 할당을 줄이려면 변환이 필요할 때만 map 사용. 변환 없이 반복이 목적이면 for-of나 forEach가 더 적합할 수 있음 콜백 작성 팁 순수 함수 지향 동일 입력은 동일 출력 보장. 부수효과 최소화 권장 명시적 반환 값 콜백은 항상 새 값을 반환해야 함. 반환 누락 시 undefined가 채워짐 thisArg 사용 지양 화살표 함수와 클로저를 우선 고려. 필요한 경우에만 thisArg 전달 동작 세부 규칙 요약 길이 스냅샷 고정 map 시작 시 len 결정, 이후 변경은 순회 범위에 영향 없음 요소 추가 무시 순회 중 추가된 인덱스는 미방문 요소 삭제 무시 방문 전 삭제된 인덱스는 미방문 값 갱신 반영 방문 시점에 읽은 값 사용 희소성 유지 원본의 빈 슬롯은 결과에도 빈 슬롯으로 유지 최소 스니펫 모음 제곱근 배열 const roots = [1, 4, 9].map(Math.sqrt) 두 배 만들기 const doubled = [1, 4, 9].map(n =\u0026gt; n * 2) 안전한 정수 변환 const ints = ['1','2','3'].map(s =\u0026gt; parseInt(s, 10)) 빠른 숫자 변환 const nums = ['1.1','2.2e2'].map(Number) NodeList 값 추출 const values = Array.from(document.querySelectorAll('select option:checked'), el =\u0026gt; el.value) 문자열 문자 코드 const codes = Array.prototype.map.call('Hi', ch =\u0026gt; ch.charCodeAt(0)) 폴리필 요약 map은 ES5에서 도입됨. 매우 오래된 환경에서는 폴리필이 필요할 수 있음 표준 알고리즘은 this를 객체화하고 길이를 Uint32로 계산, 각 존재하는 인덱스에 대해 콜백을 call로 호출하고 결과를 동일 인덱스에 기록하는 흐름을 따름 자체 구현 시 다음 조건을 충족해야 함 this가 null 또는 undefined인 경우 TypeError 발생 callback이 함수가 아니면 TypeError 발생 존재하는 인덱스에만 콜백 호출, 결과 배열에 동일 인덱스로 기록 희소성 보존과 길이 스냅샷 규칙 준수 실무에선 검증된 표준 폴리필이나 런타임의 내장 구현 사용 권장 호환성 현대 브라우저와 일반적인 서버 런타임에서 폭넓게 지원됨. 레거시 환경 대상이 아니라면 추가 조치 불필요 베스트 프랙티스 목적 분리 변환은 map, 필터링은 filter, 축약은 reduce로 역할 분리 체이닝 설계 map → filter → reduce 등 파이프라인 가독성 유지 희소 배열 다루기 전처리로 빈 슬롯 제거 또는 기본값 채우기 고려 parseInt 사용 시 radix 명시. 필요 시 Number로 단순 변환 배열이 아닌 대상에는 Array.from 또는 명시적 call로 map 적용 같이 보기 Array.prototype.forEach 반복만 필요할 때 선택 Array.prototype.flatMap 1단계 평탄화가 필요한 변환에 사용 Array.from 유사 배열을 배열로 변환하거나 생성 시 맵 함수 제공 가능 참고 링크 요약 사양의 map 알고리즘과 콜백 호출 규칙은 TC39 ECMAScript 명세를 따름 parseInt와 map의 상호작용 이슈는 잘 알려진 사례로, 콜백 인자 전달 규칙을 이해하면 쉽게 피할 수 있음 참고자료 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map http://www.wirfs-brock.com/allen/posts/166 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach ","permalink":"https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eArray.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임\n원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음\n희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨\u003c/p\u003e\n\u003ch3 id=\"구문\"\u003e구문\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003earr.map(callback(currentValue[, index[, array]])[, thisArg])\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecallback 현재 요소를 변환해 새 요소를 생성하는 함수\u003c/li\u003e\n\u003cli\u003ecurrentValue 현재 요소 값\u003c/li\u003e\n\u003cli\u003eindex 선택 현재 요소의 인덱스\u003c/li\u003e\n\u003cli\u003earray 선택 map을 호출한 원본 배열\u003c/li\u003e\n\u003cli\u003ethisArg 선택 콜백 실행 시 this로 사용할 값\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"반환값\"\u003e반환값\u003c/h3\u003e\n\u003cp\u003e각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환\n원본 배열과 길이는 동일하고 희소성도 보존됨\u003c/p\u003e","title":"JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴"},{"content":"개요 미디어 쿼리는 뷰포트나 사용자 환경에 따라 CSS를 조건부로 적용하기 위한 기능임 다른 언어의 if 조건문과 유사하게 조건이 참일 때만 특정 스타일이 활성화됨\n핵심 개념 @media 규칙과 하나 이상의 조건으로 구성 조건은 화면 폭, 해상도, 사용자 선호도 등 미디어 특성으로 표현됨 조건이 참이면 블록 내부 스타일이 캐스케이딩에 참여하고 거짓이면 무시됨\n문법과 구조 @media (조건) { /* 스타일 */ }조건 예시\nmax-width: 상한 폭 이하에서 적용 min-width: 하한 폭 이상에서 적용 논리 결합 and, not 사용 가능 동작 원리 브라우저가 런타임에 조건을 평가함 윈도우 리사이즈나 기기 회전, OS 설정 변경 시 즉시 재평가되어 스타일 재적용됨 충돌 시 일반 CSS 우선순위 규칙을 따름 우선순위 \u0026gt; 특이성 \u0026gt; 선언 순서 모바일 퍼스트 전략 권장 min-width 기준으로 점진적 확장 구성\n간단 예시 폭 600px 이하에서 .desktop 숨김, 1000px 이상에서 .mobile 숨김\n@media (max-width: 600px) { .desktop { display: none } } @media (min-width: 1000px) { .mobile { display: none } }prefers-color-scheme 운영 체제의 라이트/다크 모드 선호를 감지하여 스타일 분기 가능 값은 대개 light, dark, no-preference 사용 기본 스타일을 라이트로 두고 다크만 덮어쓰는 방식이 단순함\n@media (prefers-color-scheme: light) { /* 라이트 전용 */ } @media (prefers-color-scheme: dark) { /* 다크 전용 */ }접근성 고려 필요 대비, 명도, 링크 가시성 점검 권장\n주의와 베스트 프랙티스 브레이크포인트는 겹침 최소화 인접 구간 경계 명확히 정의 단위 일관성 유지 px 기준 사용 시 팀 컨벤션 문서화 선언 순서 관리 공통 스타일 → 특화 스타일 → 미디어 쿼리 순으로 배치 DevTools로 다양한 뷰포트와 OS 테마 전환 테스트 수행 마무리 미디어 쿼리는 조건부 스타일의 표준 수단임 뷰포트 기반 분기와 prefers-color-scheme를 조합하면 반응형과 테마 대응을 단순하게 유지 가능함\n참고자료 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries https://developer.mozilla.org/en-US/docs/Web/CSS/@media https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme ","permalink":"https://blog.jsontapose.com/posts/css-media-queries-prefers-color-scheme-9b1dbe/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e미디어 쿼리는 뷰포트나 사용자 환경에 따라 CSS를 조건부로 적용하기 위한 기능임\n다른 언어의 if 조건문과 유사하게 조건이 참일 때만 특정 스타일이 활성화됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003e@media 규칙과 하나 이상의 조건으로 구성\n조건은 화면 폭, 해상도, 사용자 선호도 등 미디어 특성으로 표현됨\n조건이 참이면 블록 내부 스타일이 캐스케이딩에 참여하고 거짓이면 무시됨\u003c/p\u003e\n\u003ch3 id=\"문법과-구조\"\u003e문법과 구조\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e@\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003emedia\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e조건\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e/* 스타일 */\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e조건 예시\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emax-width: 상한 폭 이하에서 적용\u003c/li\u003e\n\u003cli\u003emin-width: 하한 폭 이상에서 적용\u003c/li\u003e\n\u003cli\u003e논리 결합 and, not 사용 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cp\u003e브라우저가 런타임에 조건을 평가함\n윈도우 리사이즈나 기기 회전, OS 설정 변경 시 즉시 재평가되어 스타일 재적용됨\n충돌 시 일반 CSS 우선순위 규칙을 따름 우선순위 \u0026gt; 특이성 \u0026gt; 선언 순서\n모바일 퍼스트 전략 권장 min-width 기준으로 점진적 확장 구성\u003c/p\u003e","title":"CSS 미디어 쿼리 기본기와 prefers-color-scheme 적용"},{"content":"window load는 js css 이미지 등 모든 리소스 로드 완료 시점 발생 document DOMContentLoaded는 초기 DOM 파싱 완료 시점 발생, 외부 리소스 비대기\nUI 바인딩 초기화는 DOMContentLoaded 이미지 크기 등 전체 리소스 필요 계산은 load\nbody onload window.onload에 매핑됨 마지막 할당만 유효 덮어쓰기 방지용 addEventListener 권장\n참고자료 https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload ","permalink":"https://blog.jsontapose.com/posts/window-load-vs-document-domcontentloaded-b80cb4/","summary":"\u003cp\u003ewindow load는 js css 이미지 등 모든 리소스 로드 완료 시점 발생\ndocument DOMContentLoaded는 초기 DOM 파싱 완료 시점 발생, 외부 리소스 비대기\u003c/p\u003e\n\u003cp\u003eUI 바인딩 초기화는 DOMContentLoaded\n이미지 크기 등 전체 리소스 필요 계산은 load\u003c/p\u003e\n\u003cp\u003ebody onload window.onload에 매핑됨 마지막 할당만 유효\n덮어쓰기 방지용 addEventListener 권장\u003c/p\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/API/Window/load_event\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"window load vs document DOMContentLoaded 트리거 차이와 사용 시점"},{"content":"개요 nvarchar와 nchar를 사용할 때 n이 곧 문자 개수라고 가정하는 경우가 많음 하지만 SQL Server에서 nchar(n), nvarchar(n)의 n은 문자 개수가 아니라 2바이트 단위의 길이, 즉 바이트 페어(byte-pair) 개수로 정의됨 문자 집합 범위에 따라 한 문자가 1개 혹은 2개의 바이트 페어를 사용할 수 있어 저장 가능한 문자의 실제 개수는 달라짐\n핵심 개념과 정의 nchar(n), nvarchar(n)의 n은 0~4000 바이트 페어 범위의 길이 의미 하나의 바이트 페어는 2바이트로, 내부적으로 UTF-16 코드 유닛 단위로 이해 가능 유니코드 BMP 범위(0~65,535) 문자는 보통 1 바이트 페어 사용 보조 평면 범위(65,536~1,114,111) 문자는 서러게이트 페어로 2 바이트 페어 사용 따라서 n이 문자의 최대 개수를 보장하지 않음 char(n), varchar(n)은 n이 바이트 수 의미라는 점에서 유사한 맥락이나, nvarchar/nchar는 바이트 페어 기준이라는 차이 존재 추가 기본값 규칙\nn을 명시하지 않고 데이터 정의나 변수 선언을 하면 기본 길이 1 적용 CAST에서 n을 생략하면 기본 길이 30 적용 크기 선택 가이드\nnchar 고정 길이 데이터에 적합 nvarchar 가변 길이 데이터에 적합 nvarchar(max) 길이가 4000 바이트 페어를 초과할 가능성이 있는 경우 선택 그 밖의 타입과 옵션\nsysname은 null 불가 nvarchar(128)과 동등하며 데이터베이스 오브젝트 이름에 사용 nchar, nvarchar 컬럼은 COLLATE로 별도 지정하지 않으면 데이터베이스 기본 콜레이션 상속 nchar, nvarchar에는 SET ANSI_PADDING이 항상 ON으로 적용, OFF는 무효 문자열 리터럴과 N 프리픽스\n유니코드 문자열 리터럴은 항상 N 접두사를 붙여 NVARCHAR로 해석되게 표시 권장 N 없이 작성하면 데이터베이스의 기본 코드 페이지로 변환되어 일부 문자가 손실될 수 있음 SQL Server 2019 이후 UTF-8 사용 가능 콜레이션을 적용하면 기본 코드 페이지가 UTF-8을 지원하여 char/varchar에서도 유니코드 저장 가능하지만, nvarchar/nchar 사용 시에는 여전히 N 접두사 관용 유지 권장 SC 콜레이션 사용 여부에 따라 내부적으로 UCS-2 또는 UTF-16 경로로 처리되므로 혼동 방지를 위해 N 접두사 일관 사용이 안전 동작 원리와 저장 구조 nvarchar는 논리적으로 UTF-16 코드 유닛 단위 저장 BMP 문자는 1 코드 유닛, 보조 평면 문자는 2 코드 유닛 필요 nvarchar(n)에서 n은 코드 유닛 2개 묶음인 바이트 페어 개수로 취급되므로, n 범위 내에서 BMP 문자 위주면 더 많은 문자를 담을 수 있고 이모지 같은 보조 평면 문자가 섞이면 같은 n에서도 저장 가능한 문자 수가 줄어듦 예시로 nvarchar(10) 컬럼에 BMP 문자만 저장하면 최대 10자 가능하지만, 보조 평면 문자가 포함되면 10자보다 적게 저장됨 사용 시 주의와 베스트 프랙티스 설계 단계에서 길이 제약을 문자 수가 아닌 저장 단위로 모델링할 것 사용자 입력에서 문자 수 제한을 걸 때에도 저장 실패나 잘림 방지 위해 코드 유닛 기준 검증 권장 길이 n은 0~4000 바이트 페어 범위 내에서 선택, 더 크면 nvarchar(max) 고려 nchar는 패딩 특성으로 고정 길이 정렬과 일정한 저장 패턴이 필요한 경우 유리하지만 불필요한 저장 공간 증가 가능 nvarchar는 길이 변동이 큰 일반 텍스트에 적합, 인덱스 키 길이 제한 고려 필요 문자열 리터럴에는 N 접두사 습관화, 특히 다국어와 이모지 처리 환경에서 데이터 손실 예방 COLLATE로 UTF-8을 사용할지, UTF-16 계열인 nvarchar를 표준으로 삼을지 일관된 전략 수립 ANSI_PADDING은 nchar/nvarchar에 항상 ON이라는 점을 전제로 길이와 패딩 규칙 이해 필요 간단 예시 N 접두사 유무 차이 확인 -- 유니코드로 의도 표현 SELECT N\u0026#39;가나다\u0026#39;, N\u0026#39;😀\u0026#39; -- 접두사 없이 작성 시 데이터베이스 기본 코드 페이지에 따라 손실 가능 SELECT \u0026#39;가나다\u0026#39;, \u0026#39;😀\u0026#39; 저장 단위와 길이 함수 차이 확인 -- LEN은 문자 길이, DATALENGTH는 바이트 길이 반환 SELECT LEN(N\u0026#39;가😀\u0026#39;) AS char_len , DATALENGTH(N\u0026#39;가😀\u0026#39;) / 2 AS byte_pairs nvarchar(10)에서 보조 평면 문자가 차지하는 저장 단위로 인해 문자 수가 10 미만이 될 수 있음 요약 nvarchar, nchar의 n은 문자 수가 아닌 바이트 페어 수 의미 BMP 문자는 1 바이트 페어, 보조 평면 문자는 2 바이트 페어 사용 n 미지정 시 기본값은 정의문/선언에서 1, CAST에서는 30 nchar는 고정 길이, nvarchar는 가변 길이, nvarchar(max)는 4000 바이트 페어 초과 가능성 대응 sysname은 null 불가 nvarchar(128) 동등 타입 콜레이션 미지정 시 데이터베이스 기본 콜레이션 적용, ANSI_PADDING은 항상 ON 유니코드 리터럴은 N 접두사 사용 권장, UTF-8 콜레이션 사용 시에도 일관성 유지가 안전 참고자료 공식 문서에서 nchar, nvarchar 길이 정의 및 기본값, 콜레이션과 저장 차이 확인 권장 참고자료 https://learn.microsoft.com/sql/t-sql/data-types/nchar-and-nvarchar-transact-sql https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql https://learn.microsoft.com/sql/relational-databases/collations/collation-and-unicode-support#storage_differences https://learn.microsoft.com/sql/relational-databases/collations/collations https://learn.microsoft.com/sql/t-sql/functions/len-transact-sql ","permalink":"https://blog.jsontapose.com/posts/sql-server-nvarchar-nchar-length-misconception-c1f1aa/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003envarchar와 nchar를 사용할 때 n이 곧 문자 개수라고 가정하는 경우가 많음\n하지만 SQL Server에서 nchar(n), nvarchar(n)의 n은 문자 개수가 아니라 2바이트 단위의 길이, 즉 바이트 페어(byte-pair) 개수로 정의됨\n문자 집합 범위에 따라 한 문자가 1개 혹은 2개의 바이트 페어를 사용할 수 있어 저장 가능한 문자의 실제 개수는 달라짐\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003enchar(n), nvarchar(n)의 n은 0~4000 바이트 페어 범위의 길이 의미\u003c/li\u003e\n\u003cli\u003e하나의 바이트 페어는 2바이트로, 내부적으로 UTF-16 코드 유닛 단위로 이해 가능\u003c/li\u003e\n\u003cli\u003e유니코드 BMP 범위(0~65,535) 문자는 보통 1 바이트 페어 사용\u003c/li\u003e\n\u003cli\u003e보조 평면 범위(65,536~1,114,111) 문자는 서러게이트 페어로 2 바이트 페어 사용\u003c/li\u003e\n\u003cli\u003e따라서 n이 문자의 최대 개수를 보장하지 않음\u003c/li\u003e\n\u003cli\u003echar(n), varchar(n)은 n이 바이트 수 의미라는 점에서 유사한 맥락이나, nvarchar/nchar는 바이트 페어 기준이라는 차이 존재\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e추가 기본값 규칙\u003c/p\u003e","title":"SQL Server nvarchar와 nchar 길이 단위 오해 바로잡기"},{"content":"개요 Array.prototype.reduce는 배열을 하나의 값으로 축약하는 표준 API 배열의 각 요소에 대해 리듀서 함수를 순차 실행하고 누산기 값을 반환 집계, 변환, 그룹핑, 파이프라인 구성 등 다양한 패턴에 사용\n구문 arr.reduce(callback[, initialValue])\ncallback에 누산 로직 정의 initialValue가 있으면 누산기의 시작값으로 사용, 없으면 배열의 첫 요소가 시작값 매개변수 callback(accumulator, currentValue, currentIndex, array) accumulator: 누산된 값 currentValue: 현재 요소 값 currentIndex: 현재 인덱스 array: 원본 배열 initialValue (옵션) 누산기의 초기값 제공하지 않으면 배열 첫 요소가 초기값이 되어 콜백은 두 번째 요소부터 시작 반환값 축약 결과로 얻은 최종 누산값 동작 방식 왼쪽에서 오른쪽으로 순회하며 callback을 한 번씩 호출 initialValue 미제공 빈 배열이면 TypeError 발생 요소가 하나뿐이면 그 요소를 그대로 반환하며 callback은 호출되지 않음 initialValue 제공 배열이 비어 있어도 initialValue를 그대로 반환하며 callback은 호출되지 않음 희소 배열의 빈 슬롯은 건너뜀 누산기는 어떤 타입도 가능하며 객체, 맵, 프라미스 등으로 확장 가능 주의 사항과 베스트 프랙티스 가능한 항상 initialValue 지정 권장 빈 배열 입력 시 예외 방지, 타입 안정성 확보 누산기 불변성 유지 권장 객체 누산 시 얕은 복사 또는 구조 분해 사용 고려 콜백은 순수 함수 지향 외부 상태 변경 최소화, 테스트 용이성 확보 읽기 어려운 과도한 축약 로직은 map, filter, for\u0026hellip;of 등으로 분리 고려 희소 배열에서 빈 슬롯은 콜백이 호출되지 않음에 유의 오른쪽에서 왼쪽으로 처리해야 하면 reduceRight 사용 간단 예시 합계 계산\n[0, 1, 2, 3].reduce((acc, cur) =\u0026gt; acc + cur, 0)\n초기값의 차이\n[].reduce((acc, cur) =\u0026gt; acc + cur) → TypeError [].reduce((acc, cur) =\u0026gt; acc + cur, 0) → 0 빈 슬롯은 건너뜀\n[1, , 3].reduce((acc, cur) =\u0026gt; acc + cur, 0) // 4\n객체 배열 합계\nitems.reduce((sum, it) =\u0026gt; sum + it.value, 0)\n중첩 배열 평탄화\nnested.reduce((acc, cur) =\u0026gt; acc.concat(cur), [])\n빈도수 집계\nnames.reduce((m, n) =\u0026gt; ((m[n] = (m[n] || 0) + 1), m), {})\n프라미스 순차 실행\nfns.reduce((p, fn) =\u0026gt; p.then(fn), Promise.resolve(input))\nmap을 reduce로 구현 가능하지만 가독성 저하 가능\narr.reduce((res, v, i, a) =\u0026gt; (res[i] = fn(v, i, a), res), [])\n동작 예시 해설 초기값 없이 합계 계산 시 첫 요소가 누산기가 되고 두 번째 요소부터 콜백 실행\n[0, 1, 2, 3, 4].reduce((acc, cur) =\u0026gt; acc + cur)의 호출 순서 개념\n1회차 acc=0, cur=1 → 1 2회차 acc=1, cur=2 → 3 3회차 acc=3, cur=3 → 6 4회차 acc=6, cur=4 → 10 최종 반환값 10 초기값을 10으로 주면 인덱스 0부터 시작하여 5회 호출되고 최종 20 반환\n에지 케이스 체크리스트 빈 배열 + initialValue 미지정 → TypeError 단일 요소 배열 + initialValue 미지정 → 콜백 미호출, 단일 요소 반환 빈 배열 + initialValue 지정 → 콜백 미호출, initialValue 반환 희소 배열의 빈 슬롯은 미호출 누산기가 참조 타입일 때 의도치 않은 공유/변경 주의 성능 팁 불필요한 배열 복사 최소화 전략 설계 평탄화 시 concat보다 push + 전개 연산자 혼용 비용 고려 대규모 데이터 처리 시 순수 반복문 대비 오버헤드 존재 가능 가독성과 유지보수 이점을 우선하되, 병목 구간은 프로파일링 후 대체 고려 함께 보면 좋은 API reduceRight: 오른쪽에서 왼쪽으로 축약 map, filter: 전처리 또는 필터링과 조합하여 파이프라인 구성 용이 Set, Array.from: 중복 제거 시 대안 마무리 reduce는 배열을 하나의 값으로 축약하는 범용 도구 initialValue 지정과 콜백의 순수성 확보가 안전한 사용의 핵심 읽기 쉬운 축약 로직과 타입 일관성을 유지하면 대부분의 집계·변환 문제를 간결하게 해결 가능\n참고자료 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce ","permalink":"https://blog.jsontapose.com/posts/javascript-array-prototype-reduce-guide-677e4e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eArray.prototype.reduce는 배열을 하나의 값으로 축약하는 표준 API\n배열의 각 요소에 대해 리듀서 함수를 순차 실행하고 누산기 값을 반환\n집계, 변환, 그룹핑, 파이프라인 구성 등 다양한 패턴에 사용\u003c/p\u003e\n\u003ch3 id=\"구문\"\u003e구문\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003earr.reduce(callback[, initialValue])\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecallback에 누산 로직 정의\u003c/li\u003e\n\u003cli\u003einitialValue가 있으면 누산기의 시작값으로 사용, 없으면 배열의 첫 요소가 시작값\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"매개변수\"\u003e매개변수\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ecallback(accumulator, currentValue, currentIndex, array)\n\u003cul\u003e\n\u003cli\u003eaccumulator: 누산된 값\u003c/li\u003e\n\u003cli\u003ecurrentValue: 현재 요소 값\u003c/li\u003e\n\u003cli\u003ecurrentIndex: 현재 인덱스\u003c/li\u003e\n\u003cli\u003earray: 원본 배열\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003einitialValue (옵션)\n\u003cul\u003e\n\u003cli\u003e누산기의 초기값\u003c/li\u003e\n\u003cli\u003e제공하지 않으면 배열 첫 요소가 초기값이 되어 콜백은 두 번째 요소부터 시작\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"반환값\"\u003e반환값\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e축약 결과로 얻은 최종 누산값\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-방식\"\u003e동작 방식\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e왼쪽에서 오른쪽으로 순회하며 callback을 한 번씩 호출\u003c/li\u003e\n\u003cli\u003einitialValue 미제공\n\u003cul\u003e\n\u003cli\u003e빈 배열이면 TypeError 발생\u003c/li\u003e\n\u003cli\u003e요소가 하나뿐이면 그 요소를 그대로 반환하며 callback은 호출되지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003einitialValue 제공\n\u003cul\u003e\n\u003cli\u003e배열이 비어 있어도 initialValue를 그대로 반환하며 callback은 호출되지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e희소 배열의 빈 슬롯은 건너뜀\u003c/li\u003e\n\u003cli\u003e누산기는 어떤 타입도 가능하며 객체, 맵, 프라미스 등으로 확장 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의-사항과-베스트-프랙티스\"\u003e주의 사항과 베스트 프랙티스\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e가능한 항상 initialValue 지정 권장\n\u003cul\u003e\n\u003cli\u003e빈 배열 입력 시 예외 방지, 타입 안정성 확보\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e누산기 불변성 유지 권장\n\u003cul\u003e\n\u003cli\u003e객체 누산 시 얕은 복사 또는 구조 분해 사용 고려\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e콜백은 순수 함수 지향\n\u003cul\u003e\n\u003cli\u003e외부 상태 변경 최소화, 테스트 용이성 확보\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e읽기 어려운 과도한 축약 로직은 map, filter, for\u0026hellip;of 등으로 분리 고려\u003c/li\u003e\n\u003cli\u003e희소 배열에서 빈 슬롯은 콜백이 호출되지 않음에 유의\u003c/li\u003e\n\u003cli\u003e오른쪽에서 왼쪽으로 처리해야 하면 reduceRight 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e합계 계산\u003c/p\u003e","title":"JavaScript Array.prototype.reduce 개념과 안전한 활용 가이드"},{"content":"개요 클라이언트에서 서버로 들어오는 요청 데이터를 DTO로 다루면 변환과 검증의 경계를 명확히 유지 가능함 class-transformer는 입력을 클래스 인스턴스로 변환하는 역할, class-validator는 변환된 인스턴스의 유효성 검증 역할 두 라이브러리를 함께 쓰면 DTO 레이어에서 데이터 정합성을 선제적으로 보장 가능함\n핵심 개념 DTO 데이터 전송 객체, 외부 입력을 내부 도메인으로 들이기 전 구조와 제약을 고정하는 경계 class-transformer plain object ↔ 클래스 인스턴스 변환, 노출/제외 필드 제어 class-validator 데코레이터 기반 유효성 규칙 선언, 실행 시 검증 에러 수집 설치 npm install class-transformer class-validator사용 흐름과 최소 예시 입력 JSON 수신 → DTO 클래스로 변환 → DTO 인스턴스 검증 → 실패 시 에러 응답, 성공 시 비즈니스 로직으로 전달 import { Expose, Exclude, plainToInstance } from \u0026#39;class-transformer\u0026#39; import { IsInt, IsString, validate } from \u0026#39;class-validator\u0026#39; class UserDTO { @IsString() @Expose() name: string @IsInt() @Expose() age: number @Exclude() password?: string } const dto = plainToInstance(UserDTO, payload) const errors = await validate(dto) if (errors.length) { // 검증 실패 처리 }포인트\nplainToInstance로 클래스 인스턴스 생성 validate로 데코레이터 규칙에 따라 유효성 확인 실패 시 errors에 필드, 제약, 메시지 포함 @Expose와 @Exclude로 변환 제어 @Expose 변환 시 포함 대상 명시, DTO가 의도한 필드만 노출 @Exclude 변환 시 제외 대상 명시, 민감정보 누락 보장 보수적으로 @Exclude 기본 적용 후 필요한 필드만 @Expose로 허용하는 화이트리스트 전략 권장 실패 사례와 에러 포맷 name에 숫자, age에 문자열 입력 같은 타입 불일치 발생 시 검증 실패 대표 에러 구조 예시 property 검증 대상 필드명 value 입력값 constraints 위반된 규칙과 메시지 맵 이 정보로 400 응답 본문을 표준화하거나 로깅에 활용 가능 주의사항과 베스트프랙티스 타입 변환 기대치 명시 필요 class-validator는 타입 강제 변환을 수행하지 않음 문자열 \u0026ldquo;123\u0026quot;을 숫자로 쓰고 싶다면 class-transformer 설정으로 명시적 변환 추가 또는 DTO 필드에 적절한 변환 로직 구성 입력 신뢰 금지 원칙 DTO는 외부 경계, 모든 필드에 최소한의 제약 부여 권장 필요 시 커스텀 제약으로 도메인 규칙 캡슐화 에러 메시지 관리 내부용 상세 메시지와 외부 노출 메시지 분리 다국어나 코드 기반 메시지 테이블로 매핑하는 어댑터 계층 둠 직렬화 경계 유지 컨트롤러 응답 직전에도 class-transformer로 직렬화 스텝 명시, @Exclude 누락으로 민감정보 노출되는 사고 방지 테스트 전략 DTO 단위테스트에 정상/에지/악성 페이로드 케이스 고정 스냅샷보다 constraints 키 기반 검증 권장 간단 패턴 정리 입력 수신 → plainToInstance(UserDTO, input) validate(dto) → 실패 시 에러 매핑 후 400 반환 성공 시 비즈니스 로직 실행, 응답 직전 직렬화 단계에서 @Expose/@Exclude 적용 마무리 class-transformer와 class-validator를 DTO 경계에 결합하면 변환과 검증을 선언적으로 관리 가능함 입력 정합성을 초기에 보장하고, 민감정보 노출을 통제하며, 도메인으로 들어오는 데이터의 품질을 균일하게 유지할 수 있음 적절한 변환 정책, 에러 표준화, 테스트 고정으로 운영 안정성 향상 기대\n참고자료 https://github.com/typestack/class-transformer https://github.com/typestack/class-validator ","permalink":"https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e클라이언트에서 서버로 들어오는 요청 데이터를 DTO로 다루면 변환과 검증의 경계를 명확히 유지 가능함\nclass-transformer는 입력을 클래스 인스턴스로 변환하는 역할, class-validator는 변환된 인스턴스의 유효성 검증 역할\n두 라이브러리를 함께 쓰면 DTO 레이어에서 데이터 정합성을 선제적으로 보장 가능함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDTO 데이터 전송 객체, 외부 입력을 내부 도메인으로 들이기 전 구조와 제약을 고정하는 경계\u003c/li\u003e\n\u003cli\u003eclass-transformer plain object ↔ 클래스 인스턴스 변환, 노출/제외 필드 제어\u003c/li\u003e\n\u003cli\u003eclass-validator 데코레이터 기반 유효성 규칙 선언, 실행 시 검증 에러 수집\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"설치\"\u003e설치\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enpm install class-transformer class-validator\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"사용-흐름과-최소-예시\"\u003e사용 흐름과 최소 예시\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e입력 JSON 수신 → DTO 클래스로 변환 → DTO 인스턴스 검증 → 실패 시 에러 응답, 성공 시 비즈니스 로직으로 전달\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e Expose\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e Exclude\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e plainToInstance \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;class-transformer\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e IsInt\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e IsString\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e validate \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;class-validator\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eclass\u003c/span\u003e UserDTO \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@IsString\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@Expose\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  name: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@IsInt\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@Expose\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  age: \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@Exclude\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  password?: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e dto \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e plainToInstance\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003eUserDTO\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e payload\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e errors \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e validate\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003edto\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003eerrors\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elength\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 검증 실패 처리\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e포인트\u003c/p\u003e","title":"class-transformer와 class-validator로 DTO 변환·검증 패턴 정리"},{"content":"개요 TypeScript의 declare 키워드는 외부에서 이미 구현된 값의 타입 정보를 컴파일러에 알려주는 용도임 실제 구현은 다른 런타임 환경이나 스크립트에 존재하고, TypeScript는 타입 검사만 수행함 선언은 자바스크립트 코드로 출력되지 않음\n핵심 개념 declare function: 외부에 존재하는 함수의 시그니처만 제공하는 선언 사용 위치: 주로 .d.ts 선언 파일, 필요 시 .ts에서도 가능하지만 빌드 결과물에는 코드가 생성되지 않음 목적: 컴파일 타임에 타입을 인지시켜 오류를 줄이고, IDE 보조 기능을 활성화함 언제 사용하나 타입 정보가 없는 외부 자바스크립트 라이브러리 사용 시 글로벌로 노출된 함수나 변수를 TypeScript가 모를 때 JS와 TS 혼용 프로젝트에서 점진적 마이그레이션을 진행할 때 예시 글로벌 함수 선언 // 이미 어딘가에서 구현된 전역 함수가 있다고 가정 // my-globals.d.ts declare function myGlobalFunction(msg: string): void이렇게 선언하면 TypeScript가 함수 존재와 시그니처를 인식함\n모듈 타입 선언 // ambient 모듈 선언 declare module \u0026#34;some-external-lib\u0026#34; { export function externalFunc(): void }해당 모듈 임포트 시 타입 정보를 활용 가능\n함수 오버로드 선언이 필요한 경우 declare function search(q: string): string[] declare function search(q: RegExp): string[]런타임 구현은 외부에 있고, 타입 시스템에 가능한 호출 형태만 명시\n주의 사항과 한계 declare는 타입 정보만 제공, 본문을 가진 구현과 함께 사용할 수 없음 선언만 있고 런타임 구현이 없으면 ReferenceError 등 런타임 오류 발생 가능 글로벌 선언은 범위를 오염시킬 수 있음. 모듈 선언 형태 선호, 불가피할 때에만 declare global 사용 권장 any 남발 지양. 최소한의 정확한 시그니처 제공이 유지보수에 유리함 타입 패키지가 존재하면 직접 선언보다 공식 타입 정의(@types 등) 우선 사용 권장 베스트 프랙티스 선언은 가능한 별도 .d.ts 파일로 분리 전역 보강이 필요하면 명시적으로 영역을 한정 declare global { function myGlobalFunction(msg: string): void } export {} 실제 런타임 유무를 항상 검증. 빌드 단계에서는 통과하더라도 실행 환경에 구현이 없으면 실패함 마무리 declare function은 구현 없이 타입 시스템에 외부 함수의 시그니처를 알려주는 수단임 타입 안전성과 도구 지원을 얻되, 선언과 실제 구현이 일치하도록 관리하는 것이 핵심임 주 사용처는 .d.ts 파일이며, 외부 라이브러리 통합과 점진적 TS 도입에 유용함\n참고자료 https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html https://www.typescriptlang.org/docs/handbook/declaration-merging.html https://www.typescriptlang.org/docs/handbook/2/modules.html ","permalink":"https://blog.jsontapose.com/posts/typescript-declare-function-53e697/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript의 declare 키워드는 외부에서 이미 구현된 값의 타입 정보를 컴파일러에 알려주는 용도임\n실제 구현은 다른 런타임 환경이나 스크립트에 존재하고, TypeScript는 타입 검사만 수행함\n선언은 자바스크립트 코드로 출력되지 않음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003edeclare function: 외부에 존재하는 함수의 시그니처만 제공하는 선언\u003c/li\u003e\n\u003cli\u003e사용 위치: 주로 .d.ts 선언 파일, 필요 시 .ts에서도 가능하지만 빌드 결과물에는 코드가 생성되지 않음\u003c/li\u003e\n\u003cli\u003e목적: 컴파일 타임에 타입을 인지시켜 오류를 줄이고, IDE 보조 기능을 활성화함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"언제-사용하나\"\u003e언제 사용하나\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e타입 정보가 없는 외부 자바스크립트 라이브러리 사용 시\u003c/li\u003e\n\u003cli\u003e글로벌로 노출된 함수나 변수를 TypeScript가 모를 때\u003c/li\u003e\n\u003cli\u003eJS와 TS 혼용 프로젝트에서 점진적 마이그레이션을 진행할 때\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"예시\"\u003e예시\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e글로벌 함수 선언\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 이미 어딘가에서 구현된 전역 함수가 있다고 가정\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// my-globals.d.ts\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003edeclare\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e myGlobalFunction\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003emsg: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003evoid\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e이렇게 선언하면 TypeScript가 함수 존재와 시그니처를 인식함\u003c/p\u003e","title":"TypeScript에서 declare function의 개념과 사용 시점"},{"content":"개요 값 복사에서 가장 흔한 실수는 얕은 복사와 깊은 복사의 차이를 간과하는 것임 이 글은 JSON 해킹이나 라이브러리 대신 브라우저와 런타임이 제공하는 structuredClone으로 깊은 복사를 안정적으로 수행하는 방법과 주의점을 정리함\n얕은 복사 JavaScript의 전개 연산자 \u0026hellip;로 만드는 복사는 기본적으로 얕은 복사임 겉 모양과 1단계 속성은 복제되지만 중첩된 객체는 동일 참조를 공유함\nconst myOriginal = { someProp: \u0026#34;with a string value\u0026#34;, anotherProp: { withAnotherProp: 1, andAnotherProp: true } } const myShallowCopy = { ...myOriginal } myShallowCopy.aNewProp = \u0026#34;a new value\u0026#34; console.log(myOriginal.aNewProp) // ^ logs `undefined` myShallowCopy.anotherProp.aNewProp = \u0026#34;a new value\u0026#34; console.log(myOriginal.anotherProp.aNewProp) // ^ logs `a new value` 기본형 값은 값 자체가 복사되지만 객체 같은 참조형은 레퍼런스가 복사됨 따라서 중첩된 구조를 안전하게 분리하려면 깊은 복사가 필요함\n깊은 복사 깊은 복사는 객체 그래프를 따라가며 재귀적으로 새 값을 만들어 원본과 내부 상태를 공유하지 않게 하는 것 과거에는 lodash의 cloneDeep이나 JSON.parse(JSON.stringify()) 같은 차선책을 많이 사용함\nconst myDeepCopy = JSON.parse(JSON.stringify(myOriginal))JSON 기반 방식은 빠른 편이지만 제약이 큼\n순환 참조 구조에서 예외 발생 Map, Set, Date, RegExp, ArrayBuffer 등 내장 타입 손실 또는 예외 발생 함수는 직렬화 과정에서 사라짐 structuredClone 소개 웹 플랫폼과 런타임 전반에서 값 전달과 저장을 위해 사용해 온 알고리즘이 구조적 복제 structured clone임 IndexedDB 저장 또는 postMessage를 통한 영역 간 전송이 대표 사례 이제 동일 알고리즘이 structuredClone API로 공개되어 일반 코드에서 직접 사용 가능\nconst myDeepCopy = structuredClone(myOriginal)핵심 포인트\n순환 참조 처리 가능 주요 내장 타입 지원 범위 넓음 일반적으로 JSON 해킹 대비 더 강력하고 상황에 따라 더 빠름 동작과 제약 structuredClone의 동작과 한계는 다음과 같음\n프로토타입 체인 보존 안 됨, 사용자 정의 클래스 인스턴스는 일반 객체로 복제되는 경향 함수는 복제 대상 아님, 존재 시 폐기됨 일부 값은 복제 불가, 대표적으로 DOM 노드 등 Error 계열은 환경과 구현에 따라 지원 범위 상이할 수 있음, 필요 시 대상 환경에서 호환성 확인 권장 이 제약이 문제라면 라이브러리 기반 커스텀 깊은 복사 전략이 대안이 될 수 있음 예를 들어 특정 클래스 인스턴스는 toJSON과 reviver 같은 별도 프로토콜로 복원 전략을 설계하거나, 타입별 분기 처리로 수동 복제를 구현하는 방식 고려\n지원 범위 현대 브라우저, Node.js, Deno 등 주요 환경에서 structuredClone 사용 가능 레거시 환경 대상이라면 가능 여부를 사전에 확인하거나 폴백 전략 필요\n성능 관점 소형 단순 객체는 JSON 방식도 매우 빠른 편이나 타입 손실과 제약이 존재함 구조가 크거나 다양한 내장 타입을 포함하는 경우 structuredClone이 더 일관되고 유리한 선택지인 경우가 많음 오버헤드 없이 직접 제공되는 API이므로 깊은 복사의 기본 선택지로 두는 것이 합리적임\n예시와 베스트프랙티스 불변성 유지를 위해 사본을 만들어 변형해야 할 때 기본적으로 structuredClone 사용 성능 임계 경로에서는 실제 데이터 형태와 크기로 벤치마크 후 선택 사용자 정의 클래스가 섞여 있다면 복제 이후 원하는 형태로 재구성하는 어댑터 계층 두기 복제 불가 대상이 포함될 수 있으면 사전 필터링 또는 스키마 설계 단계에서 제거 마무리 깊은 복사를 안전하게 처리해야 하는 상황에서 더 이상 JSON 해킹이나 범용 라이브러리에 의존할 필요가 줄어듦 structuredClone을 기본값으로 채택하고, 제약이 충돌하는 특수 케이스에만 보완 전략을 추가하는 접근 추천\n참고자료 https://developer.mozilla.org/en-US/docs/Web/API/structuredClone https://developer.mozilla.org/en-US/docs/Glossary/Primitive https://surma.dev/things/deep-copy/ https://caniuse.com/mdn-api_structuredclone https://nodejs.org/api/globals.html#structuredclonevalue-options ","permalink":"https://blog.jsontapose.com/posts/javascript-structuredclone-deep-copy-shallow-copy-7cdc3a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e값 복사에서 가장 흔한 실수는 얕은 복사와 깊은 복사의 차이를 간과하는 것임\n이 글은 JSON 해킹이나 라이브러리 대신 브라우저와 런타임이 제공하는 structuredClone으로 깊은 복사를 안정적으로 수행하는 방법과 주의점을 정리함\u003c/p\u003e\n\u003ch3 id=\"얕은-복사\"\u003e얕은 복사\u003c/h3\u003e\n\u003cp\u003eJavaScript의 전개 연산자 \u0026hellip;로 만드는 복사는 기본적으로 얕은 복사임\n겉 모양과 1단계 속성은 복제되지만 중첩된 객체는 동일 참조를 공유함\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e myOriginal \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  someProp\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;with a string value\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  anotherProp\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    withAnotherProp\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    andAnotherProp\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e myShallowCopy \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e...\u003c/span\u003emyOriginal \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emyShallowCopy\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eaNewProp \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;a new value\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econsole\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003emyOriginal\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eaNewProp\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// ^ logs `undefined`\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emyShallowCopy\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eanotherProp\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eaNewProp \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;a new value\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econsole\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003emyOriginal\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eanotherProp\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eaNewProp\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// ^ logs `a new value`\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e기본형 값은 값 자체가 복사되지만 객체 같은 참조형은 레퍼런스가 복사됨\n따라서 중첩된 구조를 안전하게 분리하려면 깊은 복사가 필요함\u003c/p\u003e","title":"JavaScript 깊은 복사 vs 얕은 복사, structuredClone 사용 가이드"},{"content":"개요 Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임 순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦 이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함\nR.prop 개념과 문법 목적과 동작 원리\n객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구 속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환 커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함 시그니처\nR.prop(propName, obj) → any 커링 지원, 부분 적용 가능 간단 예시\nconst getName = R.prop(\u0026rsquo;name') getName({ name: \u0026lsquo;Alice\u0026rsquo;, age: 25 }) ⇒ \u0026lsquo;Alice\u0026rsquo; getName({ age: 25 }) ⇒ undefined 조합에서의 쓰임새\n컬렉션 변환에서 map과 조합해 특정 필드 집계에 활용 파이프라인의 초입에서 안전한 데이터 선택자로 사용 주의\n중첩 경로는 R.path 사용 권장 null 또는 undefined 대상에 대한 접근 시에도 오류 없이 undefined 반환 설치와 로드 npm install ramda 또는 pnpm add ramda CommonJS 환경에서는 const R = require(\u0026lsquo;ramda\u0026rsquo;) ESM/TS에서는 import * as R from \u0026lsquo;ramda\u0026rsquo; TypeScript 타입 정의 포함되어 별도 @types 설치 불요 Ramda의 설계 철학과 장점 핵심 개념\n순수 함수 중심 설계, 입력이 같으면 출력도 같음, 부작용 최소화 불변성 지향, 원본 데이터 변경 대신 사본 반환 모든 주요 함수 커링 지원, 부분 적용을 통해 의도와 맥락을 코드에 드러냄 함수 → 데이터 인자 순서 통일, compose와 pipe로 읽기 좋은 데이터 흐름 구성 효과\n선언적 코드 스타일 유도, 제어 흐름 대신 데이터 흐름 표현 테스트 용이성 증가, 예측 가능한 동작 조합 가능한 작은 함수 단위로 유지보수성 향상 컬렉션 변환의 기본기 맵과 리듀스의 Ramda 버전 특징\nR.map(f, list) 형태의 인자 순서, 커링 친화적 설계 R.reduce(reducer, init, list)로 누적 계산 표현 간결화 합계는 R.sum, 평균은 R.mean 등 단축 함수 사용 권장 짧은 스니펫\nconst names = R.map(R.prop(\u0026#39;name\u0026#39;))(users) const total = R.reduce((acc, x) =\u0026gt; acc + x, 0)(nums)가변 인자 함수 적용\n배열을 펼쳐 인자로 적용해야 하는 경우 R.apply 사용 예시 용도는 Math.max, Math.min 같은 내장 함수 호출 커링과 자리 표시자 R.curry로 부분 적용을 일상화\n다인자 함수를 맥락마다 일부 인자 고정해 재사용 단위로 분해 앞쪽 인자부터 고정되는 점 고려해 인자 순서를 의도적으로 설계 자리 표시자 R.__\n특정 인자를 비워두고 뒤 인자부터 고정하고 싶을 때 사용 짧은 스니펫\nconst volume = R.curry((d, w, h) =\u0026gt; d * w * h) const area = volume(1) area(3, 4) // 12 함수 조합과 파이프라인 R.pipe와 R.compose\npipe는 왼쪽에서 오른쪽으로 데이터 흐름 표현에 적합 compose는 수학적 표기와 같이 오른쪽에서 왼쪽으로 평가 조합 결과는 다시 1급 함수로 재사용 가능 짧은 스니펫\nconst normalize = R.pipe(Math.sqrt, Math.round, String) normalize(10) // \u0026#39;3\u0026#39; 원소와 속성 접근 유틸리티 R.nth(n, list) 안전한 n번째 원소 접근, 없으면 undefined R.prop(k, obj) 안전한 단일 속성 접근, 없으면 undefined R.path([k1, k2, \u0026hellip;], obj) 중첩 경로 안전 접근 이들 함수는 예외 대신 undefined를 반환하므로 파이프라인 중간에 안전하게 삽입 가능함\n컬렉션 생성과 가공 생성\nR.range(from, to) 반열린 구간 수열 생성, 끝값 제외 R.repeat(item, n) 동일 원소 반복 리스트 생성 필터와 정렬\nR.filter(pred, list) 조건을 만족하는 원소만 유지 R.sort(compare, list) 비교 함수를 이용한 정렬, 불변성 유지 R.reverse(listOrString) 역순 변환 연결과 분할\nR.concat(a, b) 리스트 또는 문자열 연결 R.append(x, list) 뒤에 원소 추가한 새 리스트 반환 R.prepend(x, list) 앞에 원소 추가한 새 리스트 반환 R.head(list) 첫 원소 안전 참조, 없으면 undefined R.take(n, list), R.takeLast(n, list) 앞뒤에서 n개 취함 R.drop(n, list), R.dropLast(n, list) 앞뒤에서 n개 제거 R.slice(from, to, list) 구간 슬라이스, Infinity로 끝까지 표현 가능 객체 불변 업데이트\nR.assoc(k, v, obj) 키를 v로 갱신한 새 객체 반환 R.dissoc(k, obj) 키 제거한 새 객체 반환 깊은 경로는 R.assocPath, R.dissocPath 사용 고려 집합 연산 중복 제거와 멱등 연산을 기반으로 한 집합 다루기\nR.union(a, b) 합집합, 좌측 우선 보존 규칙으로 순서 결정 R.intersection(a, b) 교집합, a의 순서를 보존하며 b에 존재하는 원소만 유지 R.difference(a, b) 차집합, a에서 b에 포함된 원소 제거 주의\nRamda의 집합 연산은 참조 동등성 또는 지정된 동등 비교 규칙에 의존함 객체 요소의 동등성 비교가 필요한 경우 R.unionWith, R.intersectionWith 등 커스텀 비교자 사용 고려 논리와 조건 유틸리티 타입 검사\nR.is(Ctor, val) 생성자 기반 인스턴스 여부 검사 커링으로 특정 타입 가드 유틸 생성에 용이 논리 부정\nR.complement(pred) 논리 결과 반전 함수 생성 양·음의 범위\nR.all(pred, list) 모두 참인지 검사 R.any(pred, list) 하나라도 참인지 검사 상수 함숫값\nR.T 항진 함수, 항상 true 반환 R.F 항진 함수, 항상 false 반환 R.always(x) 항상 x를 반환하는 함수 생성 분기 구성\nR.cond([[pred1, f1], [pred2, f2], \u0026hellip;]) 다중 분기를 표현하는 조합기 TypeScript에서의 Ramda 타입 정의\nRamda는 자체 타입 정의를 포함, 일반적인 사용에서 추가 설치 없이 타입 안전성 확보 가능 복잡한 조합이나 가변 길이 파이프라인에서 추론 경계 존재, 필요 시 함수 경계에 명시적 타입 주석 권장 실전 팁\n컬렉션 연산에서는 제네릭 타입 변수의 구체화를 돕기 위해 람다식 인자에 타입 주석 추가 R.path, R.assocPath 사용 시 경로와 결과 타입을 명시해 추론 실패에 대비 짧은 스니펫\ntype User = { name: string; age: number } const users: User[] = [ { name: \u0026#39;A\u0026#39;, age: 25 }, { name: \u0026#39;B\u0026#39;, age: 30 } ] const names: string[] = R.map((u: User) =\u0026gt; u.name)(users) R.prop 심화 활용 패턴 배열에서 특정 필드 수집\nR.map(R.prop(\u0026lsquo;field\u0026rsquo;), list)로 간결하게 필드 리스트 생성 기본값과의 결합\nR.pipe(R.prop(\u0026lsquo;field\u0026rsquo;), R.defaultTo(defaultValue))로 안전한 디폴트 적용 안전한 중첩 접근\nR.pipe(R.path([\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;]), R.defaultTo(fallback)) 사용 옵셔널 체이닝과 비교\n언어 레벨 옵셔널 체이닝 a?.b?.c는 문법 설탕, Ramda는 함수 조합으로 동일 흐름을 데이터 파이프라인으로 유지 일관된 형식의 함수형 파이프라인을 선호한다면 R.path 기반 접근 유지 권장 흔한 함정과 우회 전략 R.and와 R.or의 오해\nR.and와 R.or는 이항 불 연산을 커링한 함수로, 전달된 피연산자 자체의 진리성만 평가함 R.and(fn1, fn2)(x)처럼 술어 함수를 인자로 넘기면 fn1과 fn2 함수 객체가 모두 truthy이므로 결과가 항상 truthy가 되는 문제가 발생함 동일 인자 x에 대해 두 술어를 모두 평가하는 목적이라면 R.both(pred1, pred2) 또는 R.allPass([pred1, pred2]) 사용 동일하게 OR 조합이 필요하면 R.either 또는 R.anyPass 사용 짧은 스니펫\nconst isNotNil = R.complement(R.isNil) const isNotEmpty = (v: any) =\u0026gt; !(Array.isArray(v) \u0026amp;\u0026amp; v.length === 0) \u0026amp;\u0026amp; v !== \u0026#39;\u0026#39; const valid = R.both(isNotNil, isNotEmpty) valid(undefined) // false valid(\u0026#39;0x1234\u0026#39;) // true 인자 순서와 커링\nJS 내장 Array.map은 수신자 메서드 형태로 데이터 → 함수 순서, Ramda는 함수 → 데이터 순서 조합과 부분 적용을 적극 사용하려면 Ramda의 순서가 유리 지나친 조합과 타입 추론 붕괴\n단계가 많은 pipe에서 중간 단계 타입이 모호하면 추론 실패 가능성 존재 경계마다 반환 타입 주석 추가 또는 조합 단위를 의미 있게 쪼개기 권장 성능과 가독성 균형\n소규모 유틸을 과도하게 조합하면 호출 오버헤드와 디버깅 난도가 증가할 수 있음 파이프라인 단계 수를 의미 중심으로 제한, 필요한 곳에서만 미세 최적화 실전 조합 레시피 데이터 정규화 파이프라인\n공백 트리밍 → 소문자화 → 빈 문자열을 null로 치환하는 흐름을 pipe로 명시 예 R.pipe(R.trim, R.toLower, v =\u0026gt; v === \u0026rsquo;\u0026rsquo; ? null : v) 불변 업데이트로 조건적 갱신\n특정 필드가 존재할 때만 새 값 적용 예 R.when(R.has(\u0026lsquo;flag\u0026rsquo;), R.assoc(\u0026lsquo;updated\u0026rsquo;, true)) 컬렉션에서 안전한 선택 후 변환\n예 R.pipe(R.map(R.prop(\u0026lsquo;id\u0026rsquo;)), R.filter(Boolean), R.uniq) 조건 분기 단순화\n다중 if-else를 R.cond로 옮겨 비즈니스 규칙을 데이터로 표현 요약 R.prop은 안전한 속성 접근의 기본 단위, 커링과 조합에서 재사용성 높음 Ramda는 함수 → 데이터 인자 순서로 조합 친화적인 API를 제공, 불변성과 순수 함수 원칙을 일관되게 지원 파이프라인은 pipe와 compose로 구성, 컬렉션 변환은 map·filter·reduce 계열로 단순화 술어 조합에는 R.both·R.either·R.allPass·R.anyPass 사용, R.and·R.or는 값 조합용이라는 점 주의 TypeScript에서는 복잡한 조합 경계에 타입 주석을 더해 추론을 보조 참고 링크 공식 문서와 REPL에서 함수 동작을 빠르게 실험 가능\n함수형 패러다임에 익숙하지 않다면 작은 단위의 파이프라인부터 도입 권장\nRamda Docs https://ramdajs.com/docs/\nTry Ramda REPL https://ramdajs.com/repl/\nFunctional Programming with Ramda.js https://www.sitepoint.com/functional-programming-with-ramda/\n자바스크립트로 함수형 프로그래밍하기 개요 글 https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html\n참고자료 https://ramdajs.com/docs/ https://ramdajs.com/repl/ https://www.sitepoint.com/functional-programming-with-ramda/ https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html https://www.npmjs.com/package/ramda ","permalink":"https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eRamda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임\n순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦\n이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"rprop-개념과-문법\"\u003eR.prop 개념과 문법\u003c/h3\u003e\n\u003cp\u003e목적과 동작 원리\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구\u003c/li\u003e\n\u003cli\u003e속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환\u003c/li\u003e\n\u003cli\u003e커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e시그니처\u003c/p\u003e","title":"Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항"},{"content":"개요 SWC는 Rust로 작성된 초고속 TypeScript/JavaScript 컴파일러 겸 트랜스파일러 동일한 작업을 수행하는 Babel이나 tsc 대비 10~20배 수준의 성능 향상이 보고됨 Rust로 구현되어 JS 런타임 기반 도구 대비 낮은 오버헤드와 높은 병렬 처리 효율 확보\n핵심 개념 목적 TS/JS 소스 코드를 목표 런타임에서 실행 가능한 코드로 빠르게 변환 특징 타입 체크 미포함, 변환에 집중해 극단적 속도 추구 적용 범위 컴파일 단계와 테스트 실행, 개발 서버 부팅, CI 빌드 가속에 유효 채택 사례 Next.js에 기본 통합됨, 서버 프레임워크에서도 선택지로 확산 중\n왜 SWC인가 기존 파이프라인의 병목\ntsc 타입 체크와 컴파일을 한 번에 수행해 대규모 코드베이스에서 지연 증가 Babel 변환 유연성은 높지만 TS 처리와 플러그인 조합이 무거워질수록 느려짐 SWC의 이점\n타입 체크 제외 변환만 빠르게 처리해 빌드 시간을 단축 Rust 구현 대규모 모노레포에서도 안정적인 처리량과 짧은 레이턴시 확보 생태계 통합 Next.js가 컴파일러로 채택, 서버 사이드 프로젝트에서도 선택 폭 확대 동작 원리와 구조 파서 TS와 최신 JS 문법을 빠르게 AST로 변환 트랜스폼 타깃 환경에 맞춰 문법 다운레벨링 및 최적화 수행 코드 생성 모듈 시스템과 타깃 버전에 맞춰 결과 코드 출력 병렬화 Rust 스레딩과 효율적인 메모리 사용으로 빌드 시간 단축 타입 체크는 별도 도구로 분리하는 설계 철학을 가짐\n정적 분석과 컴파일 속도는 상충 관계에 가까움 팀 필요에 따라 tsc \u0026ndash;noEmit 또는 타입 전용 CI 단계로 분리 운영 권장 NestJS에서 SWC를 쓰는 이유 서버 프로젝트는 규모가 커질수록 ts-node 실행과 빌드 시간이 선형에 가깝게 증가하기 쉬움 SWC 도입 시 다음 영역에서 체감 이득 발생\n개발 서버 부팅 시간 단축 테스트 러너의 트랜스파일 단계 가속 프로덕션 빌드 시간 단축과 CI 대기 시간 감소 Nest 10 이후 버전에서 SWC 사용을 쉽게 구성할 수 있는 옵션이 제공되며 실무에서도 권장되는 선택지로 자리 잡는 중 프로젝트 특성에 따라 esbuild 등 대안과 비교 후 채택 권장\n언제 특히 유리한가 패키지 수와 코드량이 많은 모노레포 CI 대기열이 길고 빌드 병목이 빈번한 파이프라인 핫 리로드가 느려 개발 피드백 루프가 길어진 환경 ts-node 기반 재시작이 답답한 개발 서버 Next.js와의 조합은 프론트엔드에서, NestJS와의 조합은 백엔드에서 DX를 개선하는 안전한 선택지로 평가됨\n주의사항과 한계 타입 체크 미포함 런타임 전 품질 보증을 위해 분리된 타입 검사 단계 필요 플러그인 생태계 Babel 대비 생태계 성숙도 차이가 존재할 수 있음 트랜스폼 호환성 특정 고급 트랜스폼이나 실험적 문법은 별도 설정 또는 제한 가능성 디버깅 소스맵 품질은 계속 개선 중이며 환경별 설정 점검 필요 베스트 프랙티스\n로컬 개발은 SWC로 속도 확보, CI에서 tsc \u0026ndash;noEmit로 타입 보증 변환 타깃과 모듈 타입을 런타임 환경에 맞춰 최소화 설정 캐시 디렉터리와 스레드 수는 CI 실행기 스펙에 맞춰 조정 간단 적용 예 기본 .swcrc 예시\n{ \u0026#34;jsc\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2019\u0026#34;, \u0026#34;parser\u0026#34;: { \u0026#34;syntax\u0026#34;: \u0026#34;typescript\u0026#34;, \u0026#34;decorators\u0026#34;: true } }, \u0026#34;module\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;commonjs\u0026#34; }, \u0026#34;sourceMaps\u0026#34;: true }CLI로 src를 dist로 변환하는 예\nnpx swc src -d dist타입 검사는 분리 실행\nnpx tsc --noEmit마무리 SWC는 타입 검사와 변환을 분리해 빌드 병목을 줄이는 전략에 최적화된 도구 대규모 코드베이스와 긴 CI 파이프라인, 느린 개발 서버 피드백 루프에서 체감 이득이 큼 프레임워크 통합이 성숙해지는 추세로 안전하게 도입 가능한 시점 타입 품질 게이트를 분리하고 최소 설정으로 시작해 점진 적용 권장\n참고자료 https://swc.rs/ https://swc.rs/docs https://nextjs.org/docs/advanced-features/compiler https://vercel.com/blog/swc ","permalink":"https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eSWC는 Rust로 작성된 초고속 TypeScript/JavaScript 컴파일러 겸 트랜스파일러\n동일한 작업을 수행하는 Babel이나 tsc 대비 10~20배 수준의 성능 향상이 보고됨\nRust로 구현되어 JS 런타임 기반 도구 대비 낮은 오버헤드와 높은 병렬 처리 효율 확보\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003e목적  TS/JS 소스 코드를 목표 런타임에서 실행 가능한 코드로 빠르게 변환\n특징  타입 체크 미포함, 변환에 집중해 극단적 속도 추구\n적용 범위  컴파일 단계와 테스트 실행, 개발 서버 부팅, CI 빌드 가속에 유효\n채택 사례  Next.js에 기본 통합됨, 서버 프레임워크에서도 선택지로 확산 중\u003c/p\u003e","title":"SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트"},{"content":"개요 차세대 프론트엔드 빌드 도구 Vite 요약 Vue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤 프랑스어로 vite는 빠름을 의미함\n핵심 가치\n개발 서버 즉시 기동에 가까운 체감 속도 HMR이 가볍고 빠르게 동작 의존성 프리번들을 esbuild로 처리해 개발 경험 가속 프로덕션 빌드는 Rollup으로 안정적 번들 생성 배경과 문제 기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조\n프로젝트 규모가 커질수록 첫 기동이 지연 코드 변경 반영 또한 번들 재생성 비용으로 지연 발생 개발 체감 문제\n개발 서버 시작 수십 초 이상 소요되는 케이스 빈번 단순 수정에도 수 초 단위 대기 발생 핵심 개념 Native ESM 기반 개발 서버 브라우저가 import/export를 네이티브로 처리 Vite는 원본 모듈을 그대로 서빙하고, 브라우저가 필요한 모듈만 on-demand로 요청하는 흐름 프로젝트 크기와 무관하게 첫 요청까지의 대기 시간이 매우 짧게 유지되는 경향 예시\n\u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/src/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;// 브라우저가 직접 의존 모듈을 가져감 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; HMR(Hot Module Replacement) 페이지 전체 리로드 없이 변경 모듈만 대체 전체 번들 재생성 없음 변경 모듈과 영향 범위만 빠르게 갱신 체감 반응 시간이 수십 ms 수준으로 안정적 esbuild 기반 사전 번들링 node_modules 의존성은 esbuild로 프리번들 처리 esbuild는 Go로 구현되어 일반 JS 번들러 대비 10~100배 수준의 처리 속도 보고됨 의존성 변경 빈도가 낮아 캐시 효과 큼 초기 요청시 의존성 로딩에 대한 오버헤드 축소 개발과 프로덕션의 분리 개발은 ESM 서빙 + esbuild 프리번들, 프로덕션은 Rollup 최적화 번들 생성\n구분 개발(Dev) 프로덕션(Build) 방식 Native ESM + esbuild Rollup 번들링 목표 빠른 기동·빠른 수정 반영 코드 스플릿·트리셰이킹·압축 결과물 원본 모듈 서빙 중심 최적화된 번들 산출 명령 예시\nnpm run dev # 개발 서버 npm run build # 프로덕션 빌드Webpack 대비 비교 포인트 항목 Webpack Vite 개발 서버 시작 전체 번들 사전 생성으로 지연 발생 ESM 서빙으로 즉시 가동에 근접 HMR 속도 번들 재생성 비용으로 상대적 지연 변경 모듈 중심 갱신으로 매우 빠름 설정 복잡도 플러그인·로더 구성 복잡 기본값이 실용적, 최소 설정으로 시작 가능 빌드 도구 Webpack 자체 번들링 Rollup 기반 프로덕션 번들 생태계 성숙도 매우 높음 빠른 성장세, 주요 프레임워크 지원 충분 설정 예시 기본 설정만으로도 충분한 케이스 다수, 필요시 플러그인과 서버 옵션 정도 확장\n// vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import react from \u0026#39;@vitejs/plugin-react\u0026#39; export default defineConfig({ plugins: [react()], server: { port: 3000 }, build: { outDir: \u0026#39;dist\u0026#39; }, })지원 범위 프레임워크: React, Vue, Svelte, Preact, Lit 등 주요 프레임워크 지원 언어: TypeScript, JSX, TSX를 추가 설정 없이 사용 가능 CSS: CSS Modules, Sass, Less, PostCSS 파이프라인 지원 정적 자산: 이미지, 폰트, JSON 등 자산 로딩 처리 Vitest와의 관계 Vitest는 Vite의 변환 파이프라인을 재사용하는 테스트 프레임워크\nvite.config 공유 가능, 설정 일관성 유지 ESM 기반 변환과 캐시 이득을 그대로 활용 Vite 프로젝트에서 바로 도입 가능, 실행 속도 면에서 유리 주의와 베스트 프랙티스 개발과 배포의 동작 경로가 다름을 전제로 검증 플로우 분리 권장 개발은 ESM 직서빙, 배포는 Rollup 번들 결과물 기준 검증 필요 대형 의존성은 프리번들 캐시를 활용하되, 의존성 업데이트 시 캐시 무효화 동작 확인 권장 HMR 경계 모듈에서 상태 보존 이슈가 있을 수 있으므로, 상태 관리 계층의 갱신 전략 점검 필요 경로 별칭, 환경 변수, 자산 처리 등은 기본값으로 충분하나 팀 컨벤션에 맞는 최소 설정만 추가 권장 요약 Native ESM으로 즉시 기동에 가까운 개발 경험 제공 HMR은 변경 모듈 중심으로 가벼운 교체 수행 esbuild로 의존성 프리번들링, 캐싱으로 반복 비용 절감 프로덕션은 Rollup으로 최적화된 번들 생성 설정 부담 낮고, 주요 프레임워크와 언어 지원 폭넓음 한 줄 요약 Vite = 개발 중 기다림을 최소화하는 ESM 중심 빌드 도구\n참고자료 https://vitejs.dev/guide/ https://vitejs.dev/guide/why.html https://esbuild.github.io/ https://rollupjs.org/ https://vitest.dev/ ","permalink":"https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e차세대 프론트엔드 빌드 도구 Vite 요약\nVue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤\n프랑스어로 vite는 빠름을 의미함\u003c/p\u003e\n\u003cp\u003e핵심 가치\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발 서버 즉시 기동에 가까운 체감 속도\u003c/li\u003e\n\u003cli\u003eHMR이 가볍고 빠르게 동작\u003c/li\u003e\n\u003cli\u003e의존성 프리번들을 esbuild로 처리해 개발 경험 가속\u003c/li\u003e\n\u003cli\u003e프로덕션 빌드는 Rollup으로 안정적 번들 생성\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"배경과-문제\"\u003e배경과 문제\u003c/h3\u003e\n\u003cp\u003e기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트 규모가 커질수록 첫 기동이 지연\u003c/li\u003e\n\u003cli\u003e코드 변경 반영 또한 번들 재생성 비용으로 지연 발생\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e개발 체감 문제\u003c/p\u003e","title":"Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드"},{"content":"개요 Vite 기반의 테스트 프레임워크 Vitest 소개 및 실무 사용 패턴 정리 Jest와 거의 동일한 API를 제공하고, Vite의 ESM/HMR을 활용해 빠른 재실행을 제공함 Vite 프로젝트에서는 최소 설정으로 바로 사용 가능\n빠른 실행과 재실행, watch 효율 높음 Jest API 호환성 높아 러닝 커브 낮음 TypeScript 네이티브 지원 1. 기본 구조 테스트 파일 명명 규칙 *.spec.ts 또는 *.test.tsdescribe(name, fn) 관련 테스트를 그룹화하는 컨테이너\nimport { describe, it, expect } from \u0026#39;vitest\u0026#39; describe(\u0026#39;계산기\u0026#39;, () =\u0026gt; { it(\u0026#39;두 수를 더한다\u0026#39;, () =\u0026gt; { expect(1 + 2).toBe(3) }) it(\u0026#39;두 수를 뺀다\u0026#39;, () =\u0026gt; { expect(5 - 3).toBe(2) }) }) 첫 번째 인자: 그룹 이름 두 번째 인자: 테스트 콜백 중첩 describe 구성 가능 it(name, fn) / test(name, fn) 개별 테스트 케이스 정의, 두 API는 동일 동작\nit(\u0026#39;유효한 이메일이면 true를 반환\u0026#39;, () =\u0026gt; { expect(isValidEmail(\u0026#39;test@example.com\u0026#39;)).toBe(true) }) test(\u0026#39;유효한 이메일이면 true를 반환\u0026#39;, () =\u0026gt; { expect(isValidEmail(\u0026#39;test@example.com\u0026#39;)).toBe(true) })중첩 describe 출력 예 describe(\u0026#39;UserService\u0026#39;, () =\u0026gt; { describe(\u0026#39;create\u0026#39;, () =\u0026gt; { it(\u0026#39;유효한 데이터로 유저 생성\u0026#39;, () =\u0026gt; { /* ... */ }) it(\u0026#39;중복 이메일이면 에러\u0026#39;, () =\u0026gt; { /* ... */ }) }) describe(\u0026#39;delete\u0026#39;, () =\u0026gt; { it(\u0026#39;존재하는 유저 삭제\u0026#39;, () =\u0026gt; { /* ... */ }) }) })UserService create ✓ 유효한 데이터로 유저 생성 ✓ 중복 이메일이면 에러 delete ✓ 존재하는 유저 삭제 2. expect와 매처 expect(value) 검증 시작점, 다양한 매처 체이닝 지원\nexpect(실제값).matcher(기대값)기본 비교 매처 toBe(expected) 엄격 동등 비교 ===, 원시값 비교에 사용\nexpect(1 + 2).toBe(3) expect(\u0026#39;hello\u0026#39;).toBe(\u0026#39;hello\u0026#39;) expect(true).toBe(true) // 객체/배열은 참조 비교라 실패 expect({ a: 1 }).toBe({ a: 1 }) // 실패 toEqual(expected) 깊은 동등 비교, 객체/배열 내용 비교\nexpect({ name: \u0026#39;John\u0026#39;, age: 30 }).toEqual({ name: \u0026#39;John\u0026#39;, age: 30 }) expect([1, 2, 3]).toEqual([1, 2, 3]) expect({ user: { name: \u0026#39;John\u0026#39; }, items: [1, 2] }).toEqual({ user: { name: \u0026#39;John\u0026#39; }, items: [1, 2] })toStrictEqual(expected) toEqual보다 엄격, undefined 속성·희소 배열·클래스 인스턴스까지 체크\nexpect({ a: 1, b: undefined }).toEqual({ a: 1 }) expect({ a: 1, b: undefined }).toStrictEqual({ a: 1 }) // 실패 class User { name = \u0026#39;John\u0026#39; } expect(new User()).toEqual({ name: \u0026#39;John\u0026#39; }) expect(new User()).toStrictEqual({ name: \u0026#39;John\u0026#39; }) // 실패 Truthiness 매처 toBeTruthy / toBeFalsy JavaScript truthy/falsy 규칙 기반 검증\n// Truthy: 0, \u0026#39;\u0026#39;, null, undefined, NaN, false 외의 모든 값 expect(1).toBeTruthy() expect(\u0026#39;hello\u0026#39;).toBeTruthy() expect([]).toBeTruthy() expect({}).toBeTruthy() // Falsy: 0, \u0026#39;\u0026#39;, null, undefined, NaN, false expect(0).toBeFalsy() expect(\u0026#39;\u0026#39;).toBeFalsy() expect(null).toBeFalsy()toBeNull / toBeUndefined / toBeDefined 명확한 의도 표현에 유용\nexpect(null).toBeNull() expect(undefined).toBeUndefined() expect(\u0026#39;value\u0026#39;).toBeDefined()숫자 비교 매처 toBeGreaterThan / toBeLessThan / toBeGreaterThanOrEqual / toBeLessThanOrEqual expect(10).toBeGreaterThan(5) expect(10).toBeGreaterThanOrEqual(10) expect(3).toBeLessThan(5) expect(3).toBeLessThanOrEqual(3)toBeCloseTo(n, precision?) 부동소수점 오차 허용 비교, precision 기본값 2\nexpect(0.1 + 0.2).toBeCloseTo(0.3) expect(0.1 + 0.2).toBeCloseTo(0.3, 5)문자열 매처 toMatch(regexp | string) 정규식 또는 부분 문자열 매칭\nexpect(\u0026#39;hello world\u0026#39;).toMatch(/world/) expect(\u0026#39;hello world\u0026#39;).toMatch(\u0026#39;world\u0026#39;) expect(\u0026#39;hello world\u0026#39;).toMatch(/^hello/) expect(\u0026#39;Error: 404\u0026#39;).toMatch(/Error: \\d+/)toContain(item) 문자열에 부분 문자열 포함 여부\nexpect(\u0026#39;hello world\u0026#39;).toContain(\u0026#39;world\u0026#39;)배열/이터러블 매처 toContain(item) 배열에 특정 요소 포함 여부\nexpect([1, 2, 3]).toContain(2) const obj = { id: 1 } expect([obj]).toContain(obj) expect([{ id: 1 }]).toContain({ id: 1 }) // 실패: 참조 다름 toContainEqual(item) 배열 내 객체를 깊게 비교\nexpect([{ id: 1 }, { id: 2 }]).toContainEqual({ id: 1 })toHaveLength(n) 배열·문자열의 길이 검증\nexpect([1, 2, 3]).toHaveLength(3) expect(\u0026#39;hello\u0026#39;).toHaveLength(5) expect({ length: 3 }).toHaveLength(3)예외 검증 매처 toThrow(error?) 함수가 에러를 던지는지 검증, 함수 참조를 전달해야 함\nexpect(() =\u0026gt; { throw new Error(\u0026#39;fail\u0026#39;) }).toThrow() expect(() =\u0026gt; { throw new Error(\u0026#39;Invalid email\u0026#39;) }).toThrow(\u0026#39;Invalid email\u0026#39;) expect(() =\u0026gt; { throw new Error(\u0026#39;User 123 not found\u0026#39;) }).toThrow(/not found/) class ValidationError extends Error {} expect(() =\u0026gt; { throw new ValidationError(\u0026#39;invalid\u0026#39;) }).toThrow(ValidationError)잘못된 사용 예\n// 즉시 실행되어 실패 expect(throwingFn()).toThrow() // 올바른 사용 expect(() =\u0026gt; throwingFn()).toThrow()rejects.toThrow 비동기 에러 async function asyncFail() { throw new Error(\u0026#39;async error\u0026#39;) } await expect(asyncFail()).rejects.toThrow(\u0026#39;async error\u0026#39;) await expect(Promise.reject(new Error(\u0026#39;fail\u0026#39;))).rejects.toThrow()부정 not 모든 매처 앞에서 반대 조건 검증\nexpect(5).not.toBe(3) expect([1, 2]).not.toContain(5) expect(null).not.toBeDefined() expect(() =\u0026gt; safeFn()).not.toThrow() 3. Setup과 Teardown beforeAll(fn) 모든 테스트 전 1회 실행, DB 연결·서버 시작 등 공용 리소스 준비\nimport { beforeAll } from \u0026#39;vitest\u0026#39; let db: Database beforeAll(async () =\u0026gt; { db = await Database.connect() })afterAll(fn) 모든 테스트 후 1회 실행, 리소스 정리\nimport { afterAll } from \u0026#39;vitest\u0026#39; afterAll(async () =\u0026gt; { await db.disconnect() })beforeEach(fn) 각 테스트 전 매번 실행, 상태 격리\nimport { beforeEach, vi } from \u0026#39;vitest\u0026#39; beforeEach(() =\u0026gt; { vi.clearAllMocks() })afterEach(fn) 각 테스트 후 매번 실행, 정리 작업\nimport { afterEach } from \u0026#39;vitest\u0026#39; afterEach(() =\u0026gt; { cleanup() })실행 순서 예시\nbeforeAll ← 1번 ├── beforeEach ← 매번 │ └── 테스트 1 │ └── afterEach ← 매번 ├── beforeEach ← 매번 │ └── 테스트 2 │ └── afterEach ← 매번 afterAll ← 1번 4. Mock 함수 vi.fn(implementation?) 가짜 함수 생성, 호출 추적 및 반환값 제어 가능\nimport { vi } from \u0026#39;vitest\u0026#39; const mockFn = vi.fn() const mockAdd = vi.fn((a, b) =\u0026gt; a + b) mockAdd(1, 2) // 3 사용 목적\n외부 의존성 격리 호출 인자·횟수 검증 상황에 따른 반환값 제어 Mock 함수 메서드 mockReturnValue(value) 항상 동일 값 반환\nconst mockFn = vi.fn() mockFn.mockReturnValue(42) mockFn() // 42 mockReturnValueOnce(value) 지정된 호출 횟수만 특정 값 반환 후 기본 동작\nconst mockFn = vi.fn() mockFn .mockReturnValueOnce(1) .mockReturnValueOnce(2) .mockReturnValue(999)mockResolvedValue(value) Promise.resolve(value) 반환\nconst mockFetch = vi.fn() mockFetch.mockResolvedValue({ data: \u0026#39;success\u0026#39; }) await mockFetch()동일 표현\nmockFn.mockImplementation(() =\u0026gt; Promise.resolve(value))mockResolvedValueOnce(value) 한 번만 resolve\nmockFn .mockResolvedValueOnce({ page: 1 }) .mockResolvedValueOnce({ page: 2 })mockRejectedValue(error) Promise.reject(error) 반환\nconst mockFetch = vi.fn() mockFetch.mockRejectedValue(new Error(\u0026#39;Network error\u0026#39;))mockRejectedValueOnce(error) 한 번만 reject 후 정상 동작 설정 가능\nmockFn .mockRejectedValueOnce(new Error(\u0026#39;일시적 에러\u0026#39;)) .mockResolvedValue({ success: true })mockImplementation(fn) 구현 자체 교체\nconst mockFn = vi.fn() mockFn.mockImplementation((x, y) =\u0026gt; x * y)조건 분기 예\nmockHttpClient.get.mockImplementation(async (url, params) =\u0026gt; { if (params.page === 1) return { list: [1, 2], totalPage: 2 } if (params.page === 2) return { list: [3, 4], totalPage: 2 } return { list: [], totalPage: 2 } })mockImplementationOnce(fn) 일회성 구현 교체\nmockFn .mockImplementationOnce(() =\u0026gt; \u0026#39;first\u0026#39;) .mockImplementationOnce(() =\u0026gt; \u0026#39;second\u0026#39;) .mockImplementation(() =\u0026gt; \u0026#39;default\u0026#39;)Mock 초기화 메서드 mockClear() 호출 기록만 초기화, 구현은 유지\nconst mockFn = vi.fn().mockReturnValue(42) mockFn() mockFn.mockClear()mockReset() 호출 기록과 구현 초기화, 반환값 undefined로 복귀\nconst mockFn = vi.fn().mockReturnValue(42) mockFn.mockReset()mockRestore() 원본 구현 복구, vi.spyOn으로 만든 spy 대상\nconst obj = { method: () =\u0026gt; \u0026#39;original\u0026#39; } const spy = vi.spyOn(obj, \u0026#39;method\u0026#39;).mockReturnValue(\u0026#39;mocked\u0026#39;) spy.mockRestore()전역 Mock 초기화 vi.clearAllMocks() 모든 mock 호출 기록 초기화 vi.resetAllMocks() 호출 기록과 구현 초기화 vi.restoreAllMocks() 모든 spy 원복 beforeEach(() =\u0026gt; { vi.clearAllMocks() })Mock 검증 매처 const mockFn = vi.fn() mockFn() expect(mockFn).toHaveBeenCalled() expect(mockFn).toHaveBeenCalledTimes(1) mockFn(\u0026#39;hello\u0026#39;, 123) expect(mockFn).toHaveBeenCalledWith(\u0026#39;hello\u0026#39;, 123) mockFn(1) mockFn(2) mockFn(3) expect(mockFn).toHaveBeenLastCalledWith(3) expect(mockFn).toHaveBeenNthCalledWith(1, \u0026#39;hello\u0026#39;, 123) 5. 모듈 Mocking vi.mock(path, factory?) 모듈 전체를 mock으로 교체, import 이전에 가로채기 수행\nimport { vi } from \u0026#39;vitest\u0026#39; import { fetchData } from \u0026#39;./api\u0026#39; // mock된 상태로 import vi.mock(\u0026#39;./api\u0026#39;, () =\u0026gt; ({ fetchData: vi.fn(), saveData: vi.fn(), }))동작 원리\nvi.mock은 파일 단위로 호이스팅되어 실제 import보다 먼저 실행 대상 모듈 로딩을 가로채 mock 버전으로 대체 이후 해당 모듈을 import하면 mock된 export 제공 Node 내장 모듈 mock vi.mock(\u0026#39;node:fs/promises\u0026#39;, () =\u0026gt; ({ readFile: vi.fn(), writeFile: vi.fn(), })) it(\u0026#39;파일 읽기 테스트\u0026#39;, async () =\u0026gt; { const fs = await import(\u0026#39;node:fs/promises\u0026#39;) vi.mocked(fs.readFile).mockResolvedValue(\u0026#39;file content\u0026#39;) })부분 mock 일부만 교체하고 나머지는 실제 구현 유지\nvi.mock(\u0026#39;./utils\u0026#39;, async (importOriginal) =\u0026gt; { const actual = await importOriginal\u0026lt;typeof import(\u0026#39;./utils\u0026#39;)\u0026gt;() return { ...actual, dangerousFunction: vi.fn(), } }) 6. vi.spyOn(object, method) 기존 메서드를 감시, 실제 구현 유지하며 호출·반환 추적 또는 선택적 교체\nconst calculator = { add: (a: number, b: number) =\u0026gt; a + b } const spy = vi.spyOn(calculator, \u0026#39;add\u0026#39;) calculator.add(1, 2) expect(spy).toHaveBeenCalledWith(1, 2) expect(spy).toHaveReturnedWith(3)vi.fn vs vi.spyOn 비교\nvi.fn: 새 mock 함수 생성, 원본 없음, 복구 개념 없음 vi.spyOn: 기존 메서드 감시, 원본 유지, mockRestore로 복구 가능 구현 교체와 복구\nconst spy = vi.spyOn(calculator, \u0026#39;add\u0026#39;) spy.mockImplementation((a, b) =\u0026gt; 0) spy.mockRestore() 7. vi.mocked(fn, deep?) TypeScript 타입 단언 헬퍼, 런타임 영향 없음\nimport { fetchData } from \u0026#39;./api\u0026#39; vi.mock(\u0026#39;./api\u0026#39;) // fetchData.mockResolvedValue(...) 는 타입 에러 vi.mocked(fetchData).mockResolvedValue({ data: \u0026#39;test\u0026#39; })deep 옵션으로 중첩 메서드까지 mock 타입 적용\nconst mockService = { nested: { method: vi.fn() } } vi.mocked(mockService, true).nested.method.mockReturnValue(1) 8. 비동기 테스트 async/await it(\u0026#39;비동기 데이터를 가져온다\u0026#39;, async () =\u0026gt; { const data = await fetchData() expect(data).toEqual({ id: 1 }) })resolves / rejects Promise 결과를 직접 검증\nawait expect(asyncFn()).resolves.toBe(42) await expect(asyncFn()).resolves.toEqual({ data: \u0026#39;success\u0026#39; }) await expect(failingFn()).rejects.toThrow(\u0026#39;error\u0026#39;) await expect(failingFn()).rejects.toBeInstanceOf(ValidationError) 9. 테스트 제어 it.only / describe.only 특정 테스트만 실행\nit.only(\u0026#39;이것만 실행\u0026#39;, () =\u0026gt; { /* ... */ }) describe.only(\u0026#39;이 그룹만\u0026#39;, () =\u0026gt; { /* ... */ })it.skip / describe.skip 특정 테스트 건너뜀\nit.skip(\u0026#39;이건 건너뜀\u0026#39;, () =\u0026gt; { /* ... */ }) describe.skip(\u0026#39;이 그룹 건너뜀\u0026#39;, () =\u0026gt; { /* ... */ })it.todo 향후 작성할 테스트 명시\nit.todo(\u0026#39;나중에 구현할 테스트\u0026#39;) 10. Best Practices 테스트 독립성 유지 // Bad: 테스트 간 상태 공유 let counter = 0 it(\u0026#39;테스트1\u0026#39;, () =\u0026gt; { counter++ }) it(\u0026#39;테스트2\u0026#39;, () =\u0026gt; { expect(counter).toBe(1) }) // Good: 매 테스트 초기화 beforeEach(() =\u0026gt; { vi.clearAllMocks() })명확한 테스트 이름 // Bad it(\u0026#39;test1\u0026#39;, () =\u0026gt; { /* ... */ }) // Good it(\u0026#39;유효하지 않은 이메일이면 ValidationError를 던짐\u0026#39;, () =\u0026gt; { /* ... */ }) it(\u0026#39;페이지가 2개 이상이면 모든 페이지 순회\u0026#39;, () =\u0026gt; { /* ... */ })AAA 패턴 적용 it(\u0026#39;유저 생성 시 이메일 저장\u0026#39;, async () =\u0026gt; { // Arrange const userData = { email: \u0026#39;test@example.com\u0026#39;, name: \u0026#39;John\u0026#39; } mockRepository.save.mockResolvedValue({ id: 1, ...userData }) // Act const result = await userService.create(userData) // Assert expect(result.email).toBe(\u0026#39;test@example.com\u0026#39;) expect(mockRepository.save).toHaveBeenCalledWith(userData) })필요한 것만 mock // Bad: 사용하지 않는 메서드까지 mock const mockLogger = { log: vi.fn(), warn: vi.fn(), error: vi.fn(), debug: vi.fn(), verbose: vi.fn(), trace: vi.fn() } // Good: 필요한 메서드만 const mockLogger = { warn: vi.fn() } as unknown as Logger구현이 아닌 동작을 테스트 // Bad: 내부 구현 의존 expect(service[\u0026#39;_internalArray\u0026#39;]).toContain(item) // Good: 공개 인터페이스 기준 검증 expect(service.getAll()).toContain(item) 11. CLI 명령어 # 전체 테스트 실행 npx vitest run # watch 모드 npx vitest # 특정 파일만 실행 npx vitest user.service.spec.ts # 테스트 이름 패턴 매칭 npx vitest --grep \u0026#34;유저 생성\u0026#34; # 커버리지 리포트 npx vitest run --coverage # UI 모드 npx vitest --ui마무리 Vitest는 Vite 생태계와 맞물려 빠른 피드백 루프를 제공함 Jest 호환 API를 활용해 기존 경험을 그대로 가져오면서, 모듈 mocking과 spy, 비동기 매처를 조합해 안정적인 단위 테스트 체계를 구축 가능\n참고자료 https://vitest.dev/guide/ https://vitest.dev/api/ https://vitest.dev/guide/mocking https://jestjs.io/docs/expect https://vitejs.dev/guide/ ","permalink":"https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eVite 기반의 테스트 프레임워크 Vitest 소개 및 실무 사용 패턴 정리\nJest와 거의 동일한 API를 제공하고, Vite의 ESM/HMR을 활용해 빠른 재실행을 제공함\nVite 프로젝트에서는 최소 설정으로 바로 사용 가능\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e빠른 실행과 재실행, watch 효율 높음\u003c/li\u003e\n\u003cli\u003eJest API 호환성 높아 러닝 커브 낮음\u003c/li\u003e\n\u003cli\u003eTypeScript 네이티브 지원\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"1-기본-구조\"\u003e1. 기본 구조\u003c/h2\u003e\n\u003ch3 id=\"테스트-파일-명명-규칙\"\u003e테스트 파일 명명 규칙\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*.spec.ts     또는     *.test.ts\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"describename-fn\"\u003edescribe(name, fn)\u003c/h3\u003e\n\u003cp\u003e관련 테스트를 그룹화하는 컨테이너\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e describe\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e it\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e expect \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;vitest\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edescribe\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;계산기\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  it\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;두 수를 더한다\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    expect\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e).\u003c/span\u003etoBe\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  it\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;두 수를 뺀다\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    expect\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e5\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e).\u003c/span\u003etoBe\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e첫 번째 인자: 그룹 이름\u003c/li\u003e\n\u003cli\u003e두 번째 인자: 테스트 콜백\u003c/li\u003e\n\u003cli\u003e중첩 describe 구성 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"itname-fn--testname-fn\"\u003eit(name, fn) / test(name, fn)\u003c/h3\u003e\n\u003cp\u003e개별 테스트 케이스 정의, 두 API는 동일 동작\u003c/p\u003e","title":"Vitest 완벽 가이드"},{"content":"개요 API DTO를 다룰 때 class-transformer의 @Expose, @Exclude, @Type와 plainToInstance, excludeExtraneousValues 옵션을 정확히 이해해야 데이터 노출 제어와 변환 일관성을 확보할 수 있음 아래는 개념 정의와 동작 방향, 자주 생기는 오해 정리 및 최소 예시\n@Expose와 @Exclude 핵심 개념\n@Expose: 변환 대상으로 명시적 노출 표시 @Exclude: 변환에서 제외 표시 기본 전략은 include-all에 가까움. 즉 아무 옵션 없이 변환하면 대부분의 필드가 그대로 따라옴. 진짜 필드 필터링을 원하면 @Exclude 사용 또는 excludeExtraneousValues 옵션과 함께 @Expose 사용 필요 동작 원리\nplain → instance 변환 시 기본값으로는 평문에 있는 키가 인스턴스에 거의 그대로 주입됨 특정 필드를 제거하려면 해당 필드에 @Exclude 적용 또는 옵션 excludeExtraneousValues: true와 @Expose 병행 사용 필요 instance → plain 변환 시 @Exclude가 있으면 직렬화 결과에서 빠짐 @Expose({ name })로 키 이름 매핑 가능. 이때 이름 변경은 instance → plain 방향에서 보이는 것임 주의\n@Expose만 달아놓고 옵션 없이 plainToInstance를 호출해도 비노출 필드가 자동으로 사라지지 않음 명시적 제외가 필요하면 @Exclude 또는 excludeExtraneousValues와 @Expose 조합 사용 필요 최소 스니펫\nclass UserDto { @Expose() name: string @Exclude() password: string } 키 이름 매핑: @Expose({ name })의 방향성 정의\n@Expose({ name: \u0026lsquo;full_name\u0026rsquo; })는 양방향 매핑 설정 plain → instance: plain의 full_name → 클래스의 name으로 주입 instance → plain: 클래스의 name → plain의 full_name으로 직렬화 자주 하는 실수\nplainToInstance만 호출하고 이름이 바뀐 plain을 기대함. 키 변경은 instance → plain에서 보이는 것이므로 instanceToPlain 사용 필요 최소 스니펫\nclass UserDto { @Expose({ name: \u0026#39;full_name\u0026#39; }) name: string } // plain → instance 시 full_name이 name으로 들어옴 // instance → plain 시 name이 full_name으로 나감 excludeExtraneousValues 목적\nDTO에 명시되지 않았거나 @Expose가 붙지 않은 필드를 변환 결과에서 제외해 데이터 무결성과 보안 강화 동작\nplain → instance에서 옵션 excludeExtraneousValues: true 사용 시 @Expose가 붙은 필드만 주입 instance → plain에서도 동일 옵션 사용 시 @Expose가 붙은 필드만 직렬화 최소 스니펫\nconst dto = plainToInstance(UserDto, plain, { excludeExtraneousValues: true })주의\n이 옵션을 쓰면 @Expose가 실질적으로 필터 역할을 함. 클래스에 정의만 되어 있고 @Expose 없는 필드는 제외됨 필드가 많을수록 필터링 비용이 있으므로 DTO 범위를 최소화해 사용 권장 plainToInstance 기본기 목적\n평문 객체를 지정한 클래스 인스턴스로 변환해 타입 기반 접근과 메서드 활용 가능하게 함 핵심 포인트\n배열 입력도 동일하게 처리. 결과는 인스턴스 배열 중첩 객체 변환은 @Type으로 타입 힌트 제공 필요 plainToClass는 구버전 명칭. plainToInstance 사용 권장 최소 스니펫\nconst instance = plainToInstance(ClassCtor, plain) @Type과 Swagger @ApiProperty(type)의 차이 역할 구분\n@Type(() =\u0026gt; ChildDto) 런타임 변환 목적. 중첩 객체나 배열 요소 타입 힌트 제공 예: tracks: ChildDto[] 변환 시 각 요소를 ChildDto로 인스턴스화 @ApiProperty({ type: ChildDto, isArray: true }) 문서 목적. OpenAPI 스키마를 명시해 Swagger UI에 타입 정보 노출 왜 둘 다 필요한가\n문서화는 빌드 타임 타입 정보만으로 자동 완전 추론 불가. @ApiProperty로 명시 필요 런타임 데이터 변환은 TypeScript 타입이 사라짐. @Type으로 힌트 제공 필요 최소 스니펫\nclass ParentDto { @Expose() @Type(() =\u0026gt; ChildDto) items: ChildDto[] } 방향별 변환 요약 plain → instance excludeExtraneousValues: true일 때 @Expose로 화이트리스트 제어 @Exclude는 지정 필드 차단 @Expose({ name })로 입력 키 매핑 지원 @Type으로 중첩 타입 힌트 제공 instance → plain @Exclude 적용 필드 제외 @Expose({ name }) 키 이름 변경 반영 excludeExtraneousValues: true면 @Expose 없는 필드 제거 자주 하는 오해와 디버깅 포인트 오해: @Expose만 붙이면 비노출 필드가 자동 제외됨 사실: 제외를 원하면 @Exclude 또는 excludeExtraneousValues와 함께 사용 필요 오해: @Expose({ name })를 쓰면 plainToInstance 결과가 바뀐 키로 보임 사실: 키 변경은 instance → plain에서 보이며, plain → instance에서는 매핑으로만 사용됨 오해: @Type 없이도 중첩 배열이 알아서 변환됨 사실: 런타임 타입 정보가 없으므로 @Type 필요 콘솔 출력 혼동 instance를 그대로 console.log 하면 인스턴스 구조가 보일 뿐 직렬화 결과가 아님. 키 변경이나 제외 결과를 확인하려면 instanceToPlain 사용 필요 최소 스니펫\nconst plain = instanceToPlain(instance, { excludeExtraneousValues: true }) 베스트 프랙티스 외부 입력을 받는 DTO에는 excludeExtraneousValues와 @Expose 조합으로 화이트리스트 기반 변환 적용 출력 DTO는 @Expose({ name })로 API 스키마와 명확히 매핑. 내부 도메인 모델과 API 응답 모델 분리 권장 민감 정보는 @Exclude로 이중 차단. 변환 옵션 누락 시에도 노출 방지 중첩 구조에는 @Type을 일관되게 지정. 배열 요소 타입 명시 필수 변환 경계 최소화. 필요할 때만 변환 수행해 성능 부담 완화 간단 예시 모음 비노출 필드 제외 class SecureDto { @Expose() username: string @Expose() role: string @Exclude() password: string } 이름 매핑과 직렬화 확인 class UserDto { @Expose({ name: \u0026#39;full_name\u0026#39; }) name: string } const plain = instanceToPlain(plainToInstance(UserDto, { full_name: \u0026#39;Alice\u0026#39; })) // plain은 { full_name: \u0026#39;Alice\u0026#39; } 중첩 배열 변환 class ItemDto { @Expose() id: number } class ListDto { @Expose() @Type(() =\u0026gt; ItemDto) items: ItemDto[] } 마무리 @Expose와 @Exclude는 필드 노출 제어의 선언적 기준, excludeExtraneousValues는 이를 강제 적용하는 실행 옵션, @Type은 런타임 변환의 타입 힌트, @ApiProperty(type)은 문서화 표준화 수단임 방향성과 옵션의 결합을 정확히 이해하면 DTO 경계를 안전하게 유지하면서 직렬화와 역직렬화에서 일관된 결과를 얻을 수 있음\n참고자료 https://github.com/typestack/class-transformer https://github.com/typestack/class-transformer#expose-and-exclude https://github.com/typestack/class-transformer#using-expose-to-transform-property-names https://docs.nestjs.com/openapi/decorators https://docs.nestjs.com/techniques/serialization ","permalink":"https://blog.jsontapose.com/posts/class-transformer-expose-exclude-type-plain-to-instance-exclude-extraneous-values-8baf8a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAPI DTO를 다룰 때 class-transformer의 @Expose, @Exclude, @Type와 plainToInstance, excludeExtraneousValues 옵션을 정확히 이해해야 데이터 노출 제어와 변환 일관성을 확보할 수 있음\n아래는 개념 정의와 동작 방향, 자주 생기는 오해 정리 및 최소 예시\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"expose와-exclude\"\u003e@Expose와 @Exclude\u003c/h3\u003e\n\u003cp\u003e핵심 개념\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e@Expose: 변환 대상으로 명시적 노출 표시\u003c/li\u003e\n\u003cli\u003e@Exclude: 변환에서 제외 표시\u003c/li\u003e\n\u003cli\u003e기본 전략은 include-all에 가까움. 즉 아무 옵션 없이 변환하면 대부분의 필드가 그대로 따라옴. 진짜 필드 필터링을 원하면 @Exclude 사용 또는 excludeExtraneousValues 옵션과 함께 @Expose 사용 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e동작 원리\u003c/p\u003e","title":"class-transformer의 @Expose/@Exclude, @Type, plainToInstance, excludeExtraneousValues 정확히 이해하고 쓰기"},{"content":"개요 동일한 문제를 TypeORM의 JOIN으로 해결할 수도 있고, 각 테이블을 개별 조회한 뒤 코드에서 매핑할 수도 있음 어떤 접근이 더 효율적인지는 데이터 크기, 관계 복잡도, 인덱스 상태, 네트워크 제약, 성능 요구사항에 따라 달라짐 핵심 장단점과 선택 기준을 정리함\nTypeORM에서 JOIN 사용하는 경우 장점\n단일 쿼리로 필요한 데이터 수집 가능, 왕복 횟수 감소로 지연시간 이점 DB가 JOIN과 실행계획을 최적화하는 경우 비용 최소화 기대 1:N, N:M 같은 관계 질의를 쿼리로 명시적으로 표현 가능 필터링, 정렬, 그룹화 등 집계성 처리에서 DB 연산 활용 용이 페이지네이션과 함께 일관된 결과를 만들기 수월함 단점\n관계가 많아질수록 쿼리 복잡도 상승, 디버깅 비용 증가 대형 테이블 간 JOIN은 잘못된 인덱싱 시 성능 저하 유발 중복 로우로 인한 결과 폭증과 전송량 증가 가능성 존재 예시 스니펫\nconst users = await getRepository(User) .createQueryBuilder(\u0026#39;u\u0026#39;) .leftJoinAndSelect(\u0026#39;u.posts\u0026#39;, \u0026#39;p\u0026#39;) .where(\u0026#39;u.isActive = :isActive\u0026#39;, { isActive: true }) .getMany()코드 레벨에서 매핑하는 경우 장점\n쿼리 자체는 단순, 리포지토리 경계가 명확해 유지보수 용이 DB로 표현하기 까다로운 복잡한 비즈니스 규칙을 코드로 유연하게 처리 가능 개별 엔터티를 캐시 계층에 적재해 재사용 가능, 반복 접근 비용 절감 단점\n여러 번의 쿼리로 네트워크 왕복 증가, 지연시간 누적 위험 트랜잭션 경계 밖에서 조합 시 일관성 저하 가능성 대량 데이터에서 코드 측 필터링과 조인 구현 비용 커짐, N+1 쿼리 패턴 발생 위험 예시 스니펫\nconst users = await getRepository(User).find() const posts = await getRepository(Post).find() const usersWithPosts = users.map(u =\u0026gt; ({ ...u, posts: posts.filter(p =\u0026gt; p.userId === u.id), }))선택 기준 JOIN 선호 상황\nDB 인덱스가 적절히 구성되어 있고 조인 키 카디널리티가 양호한 경우 네트워크 왕복을 최소화해야 하는 환경, 단일 요청 내 일관된 결과가 중요한 경우 필터링, 정렬, 그룹화, 페이지네이션을 DB에서 처리해 전송량을 줄여야 하는 경우 대용량 데이터 처리에서 스캔 범위를 줄이고 실행계획 최적화 이점이 큰 경우 코드 매핑 선호 상황\n복잡한 비즈니스 규칙으로 인해 SQL 표현이 과도하게 복잡해지는 경우 엔터티 단위 캐시를 적극 활용해 재조회 비용을 낮출 수 있는 경우 데이터 규모가 작거나 쿼리 비용이 낮아 코드 조합의 오버헤드가 미미한 경우 주의 포인트\nN+1 쿼리 패턴 방지 필요, 필요한 관계를 명시적 JOIN 또는 일괄 로딩으로 해결 권장 JOIN 시 선택 컬럼 최소화로 중복 데이터 전송 방지 인덱스 유효성 점검, 조인 키와 필터링 컬럼에 적절한 인덱스 구성 권장 트랜잭션 경계 내에서 일관성 요구 시 하나의 쿼리 또는 동일 커넥션에서 처리 고려 권장 전략 기본값으로는 DB가 잘하는 일은 DB에 위임, 즉 JOIN으로 필터링·정렬·집계를 먼저 고려 도메인 규칙이 복잡하거나 캐시 효과가 큰 경로에서는 코드 매핑 병행, 단 N+1 방지 가드 레일 마련 대용량에서 JOIN 사용 시 필요한 컬럼만 선택, 적절한 페이지네이션과 인덱스 튜닝을 선행 작은 데이터셋 또는 관리형 캐시가 있는 경우 코드 조합으로 단순화, 필요 시 배치 조회로 왕복 최소화 마무리 단순 관계나 집계 중심 요구에는 JOIN이 일관성과 성능 측면에서 유리함 복잡한 도메인 규칙이나 캐시 친화적 워크로드에는 코드 수준 매핑이 개발 생산성과 운영 비용 면에서 합리적 선택일 수 있음 데이터 규모, 인덱스 품질, 네트워크 제약, 일관성 요구를 기준으로 두 접근을 혼합하는 전략이 현실적인 해법임\n참고자료 https://typeorm.io/select-query-builder https://typeorm.io/relations https://www.postgresql.org/docs/current/indexes-intro.html ","permalink":"https://blog.jsontapose.com/posts/typeorm-join-vs-code-level-mapping-a0eaa9/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e동일한 문제를 TypeORM의 JOIN으로 해결할 수도 있고, 각 테이블을 개별 조회한 뒤 코드에서 매핑할 수도 있음\n어떤 접근이 더 효율적인지는 데이터 크기, 관계 복잡도, 인덱스 상태, 네트워크 제약, 성능 요구사항에 따라 달라짐\n핵심 장단점과 선택 기준을 정리함\u003c/p\u003e\n\u003ch3 id=\"typeorm에서-join-사용하는-경우\"\u003eTypeORM에서 JOIN 사용하는 경우\u003c/h3\u003e\n\u003cp\u003e장점\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 쿼리로 필요한 데이터 수집 가능, 왕복 횟수 감소로 지연시간 이점\u003c/li\u003e\n\u003cli\u003eDB가 JOIN과 실행계획을 최적화하는 경우 비용 최소화 기대\u003c/li\u003e\n\u003cli\u003e1:N, N:M 같은 관계 질의를 쿼리로 명시적으로 표현 가능\u003c/li\u003e\n\u003cli\u003e필터링, 정렬, 그룹화 등 집계성 처리에서 DB 연산 활용 용이\u003c/li\u003e\n\u003cli\u003e페이지네이션과 함께 일관된 결과를 만들기 수월함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점\u003c/p\u003e","title":"TypeORM JOIN vs 코드 레벨 매핑 선택 기준과 실무 트레이드오프"},{"content":"개요 tsconfig.json은 TypeScript 컴파일러 tsc의 설정 파일이며 프로젝트를 어떻게 컴파일할지 정의함\nTypeScript 코드가 JavaScript로 변환되는 경로에 대한 스위치 보드 역할 수행\nTypeScript (.ts) ↓ [ tsc ] ← tsconfig.json이 규칙 제공 ↓ JavaScript (.js)module 옵션 출력되는 JavaScript의 모듈 시스템 선택\n모듈 시스템의 변화 요약\n없음, 전역 스코프 공유 CommonJS, require/module.exports 중심 AMD, 브라우저 환경 define/require ES Modules, 표준 import/export 주요 값과 용도\ncommonjs Node.js 구버전 호환 es2015/es6 표준 ESM, 브라우저·번들러 환경 es2020 ESM + dynamic import 사용 환경 es2022 ESM + top-level await 사용 환경 esnext 최신 ESM 기능 추적 nodenext Node.js 16+의 ESM 출력·해석 규칙 반영 node16 Node.js 16의 ESM과 CJS 혼합 환경 대응 같은 코드의 다른 출력 예시\n// 원본 TypeScript import { foo } from \u0026#39;./utils\u0026#39; export const bar = foo + 1module: \u0026ldquo;commonjs\u0026rdquo; 출력\n\u0026#34;use strict\u0026#34; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }) const utils_1 = require(\u0026#34;./utils\u0026#34;) exports.bar = utils_1.foo + 1module: \u0026ldquo;es2015\u0026rdquo; 출력\nimport { foo } from \u0026#39;./utils\u0026#39; export const bar = foo + 1moduleResolution 옵션 import 경로를 어떻게 찾을지 결정하는 규칙이며 module과 함께 설계하는 것이 안전함\nimport { foo } from \u0026#39;./utils\u0026#39; // ↑ 이 경로를 어떤 규칙으로 해석할지 선택 주요 값과 짝\nnode Node.js CommonJS 해석 규칙, module: commonjs와 궁합 node16 Node.js 16 ESM 규칙, module: node16과 궁합 nodenext 최신 Node.js ESM 규칙, module: nodenext와 궁합 bundler 번들러의 해석 규칙 가정, Vite·Webpack 등과 사용 classic TypeScript 1.x 규칙, 신규 프로젝트 비권장 node와 nodenext의 차이 핵심\nnode\n확장자 생략 허용, ./utils.ts 또는 ./utils/index.ts 탐색 package.json의 main 필드 우선 사용 nodenext\nESM 표준 준수, import 시 확장자 명시 요구되는 환경 TypeScript 소스가 .ts여도 import는 .js로 작성, 런타임 기준 경로이기 때문 package.json의 exports 필드 사용 // 소스: ./utils.ts // 컴파일 후: ./utils.js // import 경로는 빌드 산출물 기준으로 작성 import { foo } from \u0026#39;./utils.js\u0026#39;권장 조합 환경별 안전한 조합 안내\nNode.js 16+ module: nodenext, moduleResolution: nodenext Node.js 구버전 module: commonjs, moduleResolution: node Vite/Webpack module: esnext, moduleResolution: bundler 브라우저 직접 로딩 module: es2022, moduleResolution: bundler 예시 설정 해석 { \u0026#34;module\u0026#34;: \u0026#34;nodenext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;nodenext\u0026#34; }의미\nNode.js 16+ 환경에서 ESM 방식으로 출력 및 해석 import 경로에 확장자 명시 필요, 보통 .js로 작성 package.json의 exports 필드 기반 해석 지원 최신 Node.js 표준 흐름을 따름 기타 주요 옵션 target\n출력 JavaScript 문법 수준을 지정 예시 \u0026#34;target\u0026#34;: \u0026#34;es2022\u0026#34; es5 IE 호환 레벨, var/function 중심 es6/es2015 let/const, arrow function, class es2017 async/await es2020 optional chaining와 nullish coalescing 포함 es2022 top-level await, class fields esnext 최신 사양 추적, 빌드 타깃 환경에 따라 주의 필요 declaration\n.d.ts 타입 선언 파일 생성 여부 라이브러리 배포 시 필수에 가까움 \u0026#34;declaration\u0026#34;: trueexperimentalDecorators 및 emitDecoratorMetadata\n사용자 데코레이터 사용과 메타데이터 방출 제어 reflect-metadata 의존 생태계에서 필요 \u0026#34;experimentalDecorators\u0026#34;: true, \u0026#34;emitDecoratorMetadata\u0026#34;: truebaseUrl\n상대경로 해소 기준 디렉터리 지정 \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;paths\n경로 별칭 정의, baseUrl과 함께 사용 \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] }strict 계열\nstrict를 true로 설정하면 아래 엄격 옵션 일괄 활성화 세부 예시 \u0026#34;strictNullChecks\u0026#34;: false, \u0026#34;noImplicitAny\u0026#34;: false, \u0026#34;strictBindCallApply\u0026#34;: falseskipLibCheck\nnode_modules 내 .d.ts 타입 체크 스킵으로 빌드 성능 개선 \u0026#34;skipLibCheck\u0026#34;: truesourceMap\n디버깅을 위한 소스맵 생성 \u0026#34;sourceMap\u0026#34;: trueallowSyntheticDefaultImports\ndefault export가 없는 모듈에 대해 default import 허용 타입 체크에만 영향, 출력 코드에는 영향 없음 incremental\n증분 빌드 활성화로 재컴파일 시간 단축 전체 tsconfig 해석 아래는 Node.js 16+ ESM 환경을 가정한 구성 예시\n{ \u0026#34;compilerOptions\u0026#34;: { // 모듈 시스템 \u0026#34;module\u0026#34;: \u0026#34;nodenext\u0026#34;, // Node.js ESM 출력 \u0026#34;moduleResolution\u0026#34;: \u0026#34;nodenext\u0026#34;, // Node.js ESM import 해석 // 출력 설정 \u0026#34;target\u0026#34;: \u0026#34;es2022\u0026#34;, // ES2022 문법 사용 \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, // 출력 폴더 \u0026#34;declaration\u0026#34;: true, // .d.ts 생성 \u0026#34;sourceMap\u0026#34;: true, // 소스맵 생성 \u0026#34;removeComments\u0026#34;: true, // 주석 제거 // 데코레이터 사용 \u0026#34;emitDecoratorMetadata\u0026#34;: true, \u0026#34;experimentalDecorators\u0026#34;: true, // import 관련 \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 성능 \u0026#34;incremental\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, // 타입 체크 예시, 필요 시 엄격 모드 권장 \u0026#34;strictNullChecks\u0026#34;: false, \u0026#34;noImplicitAny\u0026#34;: false, \u0026#34;strictBindCallApply\u0026#34;: false, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: false, \u0026#34;noFallthroughCasesInSwitch\u0026#34;: false } }요약 핵심 옵션과 역할 정리\nmodule 출력 JS 모듈 문법 선택, require와 import 중 무엇을 낼지 정의 moduleResolution import 경로 해석 규칙, Node 해석 규칙 또는 번들러 가정 선택 target 출력 JS 문법 수준, 배포 대상 런타임과 일치 필요 strict* 타입 체크 엄격도, 팀 기준에 따라 일괄 적용 권장 nodenext는 최신 Node.js ESM 표준을 따른다는 의미이며, 확장자 명시와 exports 기반 해석이 전제됨\n마무리 빌드 타깃과 런타임 해석 규칙이 맞아야 런타임 오류가 줄어듦 module과 moduleResolution을 먼저 결정한 뒤 baseUrl, paths, strict, declaration 등 후속 옵션을 정합성 있게 조정하는 흐름 권장 ESM 전환 중이라면 nodenext 조합과 확장자 명시 원칙을 팀 규칙으로 고정하는 것이 안전함\n참고자료 https://www.typescriptlang.org/tsconfig https://www.typescriptlang.org/docs/handbook/2/modules.html https://www.typescriptlang.org/docs/handbook/module-resolution.html https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html https://nodejs.org/api/packages.html https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html ","permalink":"https://blog.jsontapose.com/posts/tsconfig-json-module-module-resolution-guide-05bc37/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003etsconfig.json은 TypeScript 컴파일러 tsc의 설정 파일이며 프로젝트를 어떻게 컴파일할지 정의함\u003c/p\u003e\n\u003cp\u003eTypeScript 코드가 JavaScript로 변환되는 경로에 대한 스위치 보드 역할 수행\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTypeScript (.ts)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ↓\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    [ tsc ]  ← tsconfig.json이 규칙 제공\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        ↓\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJavaScript (.js)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"module-옵션\"\u003emodule 옵션\u003c/h3\u003e\n\u003cp\u003e출력되는 JavaScript의 모듈 시스템 선택\u003c/p\u003e\n\u003cp\u003e모듈 시스템의 변화 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e없음, 전역 스코프 공유\u003c/li\u003e\n\u003cli\u003eCommonJS, require/module.exports 중심\u003c/li\u003e\n\u003cli\u003eAMD, 브라우저 환경 define/require\u003c/li\u003e\n\u003cli\u003eES Modules, 표준 import/export\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주요 값과 용도\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommonjs  Node.js 구버전 호환\u003c/li\u003e\n\u003cli\u003ees2015/es6  표준 ESM, 브라우저·번들러 환경\u003c/li\u003e\n\u003cli\u003ees2020  ESM + dynamic import 사용 환경\u003c/li\u003e\n\u003cli\u003ees2022  ESM + top-level await 사용 환경\u003c/li\u003e\n\u003cli\u003eesnext  최신 ESM 기능 추적\u003c/li\u003e\n\u003cli\u003enodenext  Node.js 16+의 ESM 출력·해석 규칙 반영\u003c/li\u003e\n\u003cli\u003enode16  Node.js 16의 ESM과 CJS 혼합 환경 대응\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e같은 코드의 다른 출력 예시\u003c/p\u003e","title":"tsconfig.json 핵심 옵션 가이드: module과 moduleResolution"},{"content":"개요 이더리움 PoS에서 한 트랜잭션이 네트워크에 전파되고 블록에 포함된 뒤 최종화되기까지의 핵심 흐름 정리 노드별 로컬 mempool, 슬롯 기반 제안자 선정, 검증자 attestation, 포크 선택, 최종화 순서로 진행 현실적으로 일부 제안자는 외부 빌더를 사용할 수 있으나 프로토콜 관점의 기본 흐름을 기준으로 설명\n전체 흐름 1 트랜잭션 발생 및 전파\n사용자가 서명된 트랜잭션 전송 여러 노드가 트랜잭션을 수신하고 각자 로컬 mempool에 저장 mempool은 전역 공유가 아닌 노드 로컬 데이터 구조 2 슬롯과 제안자 선정\n시간은 슬롯 단위로 진행되며 슬롯들은 에포크로 묶임 매 슬롯마다 지분 가중 무작위로 1명의 검증자가 제안자로 선정됨 제안자는 검증자 집합에서만 나옴 일반 노드는 선정 대상이 아님 검증자 입장에서는 자기 차례 개념이 존재하지만 모든 노드의 차례는 아님 3 블록 생성과 제안\n제안자는 자신의 로컬 mempool에서 트랜잭션을 선택해 블록을 구성 상태 전이 규칙을 적용해 블록을 만들고 서명 후 네트워크에 브로드캐스트 현실에서는 일부 제안자가 외부 빌더를 통해 블록을 공급받기도 하나 기본 모델은 제안자가 직접 선택 4 검증자 검증과 attestation\n다른 검증자들은 수신한 블록의 구조 유효성 트랜잭션 유효성 가스 사용량 계산 부모 해시 등을 점검 문제가 없으면 해당 슬롯에 대한 attestation을 생성해 전파 문제가 있거나 더 적합한 체인 헤드가 있으면 해당 블록을 무시하고 다른 후보에 가중치 부여 5 포크 선택과 체인 반영\n노드는 수신된 attestations을 가중치로 사용해 포크 선택 규칙을 적용해 헤드 블록 결정 충분한 가중치가 모이면 제안된 블록이 canonical chain의 헤드로 채택되어 연결 이후 에포크 경계를 통과하며 정당화와 최종화가 진행되며 최종화 이후에는 되돌리기 어려움 6 최종화와 재구성 가능성\n일반적으로 두 개의 연속된 에포크 조건이 충족되면 관련 블록들이 최종화 상태에 도달 최종화 이전에는 네트워크 지연이나 가중치 분포 변화에 따라 짧은 재구성 발생 가능성이 존재 중요한 오해 정리 노드가 순서를 기다리다 블록을 만든다 아님 검증자만 가능하며 매 슬롯 한 명의 제안자만 블록을 제안 모든 노드가 승인해야 블록이 올라간다 아님 지분 기반 다수 검증자의 attestation이 합의에 충분하면 포함 mempool이 하나만 존재한다 아님 노드마다 로컬 mempool 유지 역할 요약 일반 노드 트랜잭션 수신과 로컬 mempool 유지 블록과 attestation 검증 포크 선택 수행 검증자 슬롯에 따라 블록 제안 또는 attestation 수행 스케줄에 따라 역할이 정해짐 제안자 로컬 mempool 기준 트랜잭션 선택 블록 구성 및 서명 후 전파 attester 블록 유효성 검토 후 투표 가중치 제공 빌더 선택적 오프체인 역할 제안자가 위임해 블록을 공급받는 경우가 존재하나 프로토콜 필수 요소는 아님 핵심 요약 모든 노드가 블록을 만드는 구조가 아님 검증자 집합에서 슬롯별 1명이 제안 나머지 검증자는 검증과 attestation으로 가중치 제공 충분한 가중치가 모이면 체인에 반영되고 에포크 진행을 통해 최종화 도달 참고자료 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ https://ethereum.org/en/developers/docs/blocks/ https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#slots-and-epochs https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#finality ","permalink":"https://blog.jsontapose.com/posts/ethereum-pos-tx-to-finality-ef6889/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이더리움 PoS에서 한 트랜잭션이 네트워크에 전파되고 블록에 포함된 뒤 최종화되기까지의 핵심 흐름 정리\n노드별 로컬 mempool, 슬롯 기반 제안자 선정, 검증자 attestation, 포크 선택, 최종화 순서로 진행\n현실적으로 일부 제안자는 외부 빌더를 사용할 수 있으나 프로토콜 관점의 기본 흐름을 기준으로 설명\u003c/p\u003e\n\u003ch3 id=\"전체-흐름\"\u003e전체 흐름\u003c/h3\u003e\n\u003cp\u003e1 트랜잭션 발생 및 전파\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 서명된 트랜잭션 전송\u003c/li\u003e\n\u003cli\u003e여러 노드가 트랜잭션을 수신하고 각자 로컬 mempool에 저장\u003c/li\u003e\n\u003cli\u003emempool은 전역 공유가 아닌 노드 로컬 데이터 구조\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2 슬롯과 제안자 선정\u003c/p\u003e","title":"이더리움 PoS에서 트랜잭션이 블록에 포함되고 최종화되기까지"},{"content":"배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for\u0026hellip;of, 그리고 객체 속성에 적합한 for\u0026hellip;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함\n개념/배경 자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임\nfor 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용 forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가 for\u0026hellip;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능 for\u0026hellip;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재 이터러블과 이터레이터 프로토콜을 따르는 객체에 for\u0026hellip;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임\nforEach의 비동기 한계 forEach는 콜백을 동기적으로 순회함. 콜백 내부에서 비동기 작업을 호출해도 forEach 자체는 해당 작업의 완료를 기다리지 않음. 반환값은 항상 undefined이며 프로미스 체이닝에 직접 쓸 수 없음. break, continue, return으로 흐름 제어 불가\n아래 코드는 바깥 스코프에서 모든 비동기 처리가 끝났는지 보장하지 않음\nitems.forEach(async item =\u0026gt; { await doSomethingAsync(item) }) // 이 시점에 모든 작업이 끝났다고 보장 못함 핵심 포인트\n순회는 동기적으로 완료되고 비동기 작업은 백그라운드로 진행됨 await를 콜백 내부에 써도 forEach 전체의 완료 시점은 추적되지 않음 콜백 결과를 수집해 단일 프로미스로 합치기 어려움 비동기 제어 대안 순차 처리 필요 시 for\u0026hellip;of + await 선택\nfor (const item of items) await doSomethingAsync(item) // 여기 도달 시 순차 처리 완료 병렬 처리 필요 시 map + Promise.all 사용\nawait Promise.all(items.map(item =\u0026gt; doSomethingAsync(item))) // 병렬 실행 후 전부 완료된 시점 순차 누적 계산이 필요하면 reduce + async/await 패턴 고려\nconst result = await items.reduce(async (accP, item) =\u0026gt; { const acc = await accP const next = await stepAsync(acc, item) return next }, Promise.resolve(init))트레이드오프 요약\nfor\u0026hellip;of + await 순차적 안정성, 외부 리소스 제한 정책과 궁합 좋음, 총 소요시간 증가 가능 Promise.all 병렬 성능, 실패 시 전체 거부, 동시성 제한 없으므로 과부하 주의 reduce 기반 순차 누적 로직 표현력 좋음, 가독성 비용 존재 반복문 선택 가이드 인덱스 필요, 조기 종료 필요, 성능 미세 튜닝 필요 for 사용 값만 필요, 동기적 작업, 간결한 선언형 스타일 선호 forEach 사용 이터러블을 값 중심으로 순회, await로 흐름 제어 필요 for\u0026hellip;of 사용 객체 속성 키 순회 for\u0026hellip;in 사용. 배열에는 비권장 참고 이슈\nforEach는 break/continue 불가. 일부 조건에서 return으로 콜백만 종료 가능하나 전체 순회는 계속됨 for\u0026hellip;of는 break/continue/yield/await 등 제어 흐름 조합 용이 배열을 객체처럼 취급해 for\u0026hellip;in을 쓰면 예상치 못한 키 순서, 상속 프로퍼티 순회 등으로 버그 유발 가능 TypeScript/JavaScript의 값과 참조 전달 이해 TypeScript는 JavaScript와 동일한 호출 의미론을 가짐. 자바스크립트는 엄밀히 값에 의한 전달 모델이며 객체의 참조도 값으로 복사됨. 흔히 참조에 의한 전달로 오해하지만 실제로는 참조 값이 복사되어 공유되는 pass-by-sharing 특성에 가깝다고 이해하는 편이 안전함\n원시 타입 number, string, boolean, null, undefined, symbol, bigint는 값이 복사되어 전달됨. 함수 내부 변경이 외부에 영향 없음 객체, 배열, 함수는 참조 값이 복사되어 전달됨. 함수 내부에서 프로퍼티를 변경하면 같은 객체를 가리키므로 외부에서도 변경이 보임. 단, 매개변수 변수에 새 객체를 재할당해도 외부 바인딩은 그대로 유지됨 원시 타입 예시\nlet n = 50 function changeValue(x: number) { x = 100 } changeValue(n) // n은 50 유지 객체 프로퍼티 변경 예시\nconst user = { name: \u0026#39;Original\u0026#39; } function changeObject(o: { name: string }) { o.name = \u0026#39;Changed\u0026#39; } changeObject(user) // user.name은 \u0026#39;Changed\u0026#39; 객체 자체 재할당 예시\nconst user = { name: \u0026#39;Original\u0026#39; } function replaceObject(o: { name: string }) { o = { name: \u0026#39;New\u0026#39; } } replaceObject(user) // 외부 user는 그대로 유지 배열도 동일한 참조 값 복사 특성 적용\nconst arr = [1, 2, 3] function pushItem(a: number[]) { a.push(4) } pushItem(arr) // arr는 [1,2,3,4] 프로퍼티 읽기 시 값 복사 예시. 문자열은 원시 타입이므로 별도 복사본을 가짐\nconst user = { name: \u0026#39;John\u0026#39; } let userName = user.name // \u0026#39;John\u0026#39; 값 복사 userName = \u0026#39;Jane\u0026#39; // user.name에는 영향 없음 실무 체크리스트\n원시와 참조 타입의 전달 차이를 명확히 구분할 것 함수에서 외부 객체를 변경하려는 의도가 없다면 얕은 복사나 깊은 복사로 불변성 유지 고려 비동기 루프에서 완료 시점이 중요하면 for\u0026hellip;of + await 또는 Promise.all을 명시적으로 사용할 것 병렬 처리 시 동시성 제한이 필요하면 p-limit 류의 제한 기법 적용 검토 마무리 forEach는 설계상 비동기 완료를 기다리지 않는 동기 순회 도구임. 비동기 흐름 제어가 필요하면 for\u0026hellip;of + await 또는 Promise.all 같은 명시적 조합 선택이 안전함. 또한 JS/TS는 값에 의한 전달이며 참조 값 복사라는 특성 때문에 객체 내용 변경은 공유되지만 재할당은 외부에 파급되지 않음을 전제하고 코드를 작성할 것\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures https://developer.mozilla.org/en-US/docs/Glossary/Primitive ","permalink":"https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/","summary":"\u003cp\u003e배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for\u0026hellip;of, 그리고 객체 속성에 적합한 for\u0026hellip;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함\u003c/p\u003e\n\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efor 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용\u003c/li\u003e\n\u003cli\u003eforEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가\u003c/li\u003e\n\u003cli\u003efor\u0026hellip;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능\u003c/li\u003e\n\u003cli\u003efor\u0026hellip;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이터러블과 이터레이터 프로토콜을 따르는 객체에 for\u0026hellip;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임\u003c/p\u003e","title":"JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리"},{"content":"개요 이더리움 PoS 환경에서 노드 역할은 레이어 분리로 명확해졌음. 실행을 담당하는 EL, 합의를 담당하는 CL, 검증자 키와 서명을 담당하는 VC로 나뉨. 이 조합으로 일반 풀노드와 밸리데이터 노드가 구성됨. 아래는 각 컴포넌트와 노드 타입의 역할 차이를 실무 관점에서 정리함\n레이어 기준 정의 EL (Execution Layer)\n트랜잭션 실행과 상태 전이 수행 EVM 실행과 가스 계산 담당 mempool 유지 및 트랜잭션 선별 블록 본문에 담기는 실제 tx 처리 관할 무슨 일이 일어났는지 계산하는 층 CL (Consensus Layer)\nPoS 합의 로직과 슬롯·에폭 스케줄 관리 proposer와 attester 선정 블록 헤더 검증과 포크 선택 수행 이 블록을 정본으로 인정할지 결정하는 층 VC (Validator Client)\nBLS 검증자 키 보관과 안전한 서명 수행 CL 지시에 따른 블록 제안 서명 및 attestation 서명 보상·슬래싱과 직접 연관, 키 관리 중요 검증자의 손과 서명 역할 노드 종류별 구성 일반 풀노드 (Full Node)\n구성: EL + CL 기능: tx 수신, mempool 유지, 블록 검증, 체인 동기화 제한: 블록 제안 없음, attestation 없음, 지분 요구 없음 밸리데이터 노드 (Validator Node)\n구성: EL + CL + VC 기능: 풀노드 기능 포함, PoS 합의에 직접 참여 가능: 블록 제안, attestation 수행 요구: 32 ETH 스테이킹 필요 풀노드와 밸리데이터 핵심 차이 구성 요소: 풀노드 EL+CL, 밸리데이터 EL+CL+VC 지분 요구: 풀노드 없음, 밸리데이터 32 ETH 필요 검증 기능: 둘 다 블록 검증 수행 합의 참여: 풀노드 비참여, 밸리데이터 제안·투표 수행 mempool: 둘 다 유지 밸리데이터의 평시 역할과 선정 시 역할 평시\n일반 노드처럼 네트워크 추종 타인이 제안한 블록 검증 후 attestation 제출 대부분 시간은 검증자 역할에 집중 proposer로 선정될 때\nCL이 해당 슬롯의 proposer로 지명 EL이 mempool에서 tx 선택 후 블록 생성 VC가 생성 블록에 서명 네트워크에 블록 제안 전파 잠깐 동안만 블록 제안자 역할 수행 전체 처리 흐름 [tx 발생] → EL mempool → (슬롯 도착) → CL이 proposer 선정 → EL이 블록 생성 → VC가 서명 → 네트워크에 proposal → 다른 Validator들이 검증 + 투표 → 합의되면 체인 반영핵심 요약 EL = 실행 + mempool CL = 합의 + 포크 선택 + 슬롯·에폭 관리 VC = 검증자 키 보관 + 서명 Full Node = EL + CL Validator = Full Node + VC 평소엔 검증자, 선정되면 proposer 역할 수행 주의 사항 키 관리와 슬래싱 리스크 관리 필수. 온라인 이중서명, 잘못된 헤드 추종 등은 슬래싱 대상 EL과 CL는 서로 다른 클라이언트 구현 조합 가능. 안정성과 업그레이드 호환성 고려해 조합 선택 권장 네트워크 지연이나 시간 동기 불량은 미제출·지각 제출로 인한 페널티 유발 가능. 시간 동기와 피어링 상태 점검 필요 참고자료 https://ethereum.org/en/developers/docs/nodes-and-clients/ https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ https://ethereum.org/en/developers/docs/consensus-clients/ https://ethereum.org/en/developers/docs/execution-clients/ https://ethereum.org/en/staking/ ","permalink":"https://blog.jsontapose.com/posts/ethereum-pos-node-types-and-roles-e8a3b8/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이더리움 PoS 환경에서 노드 역할은 레이어 분리로 명확해졌음. 실행을 담당하는 EL, 합의를 담당하는 CL, 검증자 키와 서명을 담당하는 VC로 나뉨. 이 조합으로 일반 풀노드와 밸리데이터 노드가 구성됨. 아래는 각 컴포넌트와 노드 타입의 역할 차이를 실무 관점에서 정리함\u003c/p\u003e\n\u003ch3 id=\"레이어-기준-정의\"\u003e레이어 기준 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eEL (Execution Layer)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e트랜잭션 실행과 상태 전이 수행\u003c/li\u003e\n\u003cli\u003eEVM 실행과 가스 계산 담당\u003c/li\u003e\n\u003cli\u003emempool 유지 및 트랜잭션 선별\u003c/li\u003e\n\u003cli\u003e블록 본문에 담기는 실제 tx 처리 관할\u003c/li\u003e\n\u003cli\u003e무슨 일이 일어났는지 계산하는 층\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCL (Consensus Layer)\u003c/p\u003e","title":"이더리움 PoS 노드의 종류와 역할 정리"},{"content":"개요 TypeScript의 고급 타입은 단순 오류 방지 수준을 넘어 재사용성과 유지보수성을 끌어올리는 핵심 도구임 제네릭, 유니온·인터섹션, 매핑 타입, 조건부 타입, 그리고 실무에서 자주 쓰는 유틸리티 타입을 간단 예시와 함께 정리함\n제네릭 타입을 값처럼 받아서 사용하는 패턴으로, 선언 시점이 아니라 사용 시점에 타입을 결정함 any 대비 타입 정보를 잃지 않으면서 다양한 타입을 수용 가능\n기본 형태 사용 입력과 출력 타입의 관계를 보존하는 데 초점 function wrap(value: any) { return { value } } function wrapBox\u0026lt;T\u0026gt;(value: T) { return { value } } const stringBox = wrapBox(\u0026#34;Hello\u0026#34;) const numberBox = wrapBox(123) T는 관습적 이름이며 의미가 드러나는 이름 사용 권장 제네릭 제한이 필요한 경우 extends를 사용해 제약 가능 ex) 유니온과 인터섹션 여러 타입을 조합해 표현력을 높이는 방법\n유니온 타입 | A 또는 B 의미의 합집합 타입 타입 가드로 분기 처리 필요\ntype ID = string | number function printId(id: ID) { if (typeof id === \u0026#39;string\u0026#39;) { console.log(id.toUpperCase()) } else { console.log(id) } }인터섹션 타입 \u0026amp; A 그리고 B 의미의 교집합 타입 여러 속성을 모두 갖는 구조 합성에 유용\ntype Person = { name: string } type Employee = { employeeId: number } type Staff = Person \u0026amp; Employee const newStaff: Staff = { name: \u0026#34;Kim\u0026#34;, employeeId: 1234 }매핑 타입 기존 타입의 키를 순회하며 새로운 형태로 변환하는 기법 반복 선언을 줄이는 데 효과적\n기본 형태 [K in keyof T] type User = { name: string; age: number } type PartialUser = { [K in keyof User]?: User[K] } const userUpdate: PartialUser = { age: 30 }조건부 타입 타입 차원에서 if-else 분기를 수행\n문법 예시 T extends U ? X : Y type MyExclude\u0026lt;T, U\u0026gt; = T extends U ? never : T type Result = MyExclude\u0026lt;\u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;\u0026gt;유틸리티 타입 매핑·조건부 타입으로 구성된 표준 유틸리티 모음 주요 타입과 용도 중심으로 기억해두면 실무 편의성 상승\nPartial 모든 속성을 선택적으로 변경 업데이트 페이로드 정의에 적합 Pick\u0026lt;T, K\u0026gt; T에서 K에 해당하는 속성만 선택 필요한 최소 필드만 추출 Omit\u0026lt;T, K\u0026gt; T에서 K에 해당하는 속성만 제외 민감 정보 제거 등 필드 차단에 활용 Record\u0026lt;K, T\u0026gt; 키가 K이고 값이 T인 객체 맵 구조 정의에 적합 Readonly 모든 속성을 읽기 전용으로 변경 불변성 유지가 필요한 데이터에 적용 요약과 활용 팁 제네릭은 타입을 인자로 받는 함수라는 관점으로 이해하면 설계가 단순해짐 유니온은 범위를 넓히고 인터섹션은 구체성을 강화함 목적에 맞게 선택 반복 구조가 보이면 매핑 타입 또는 유틸리티 타입부터 검토 분기 처리가 필요한 순간에는 조건부 타입으로 타입 레벨 로직을 모델링 마무리 타입은 문서와 테스트의 역할을 함께 수행함 초기 설계에서 관계와 제약을 타입으로 명시하면 런타임 버그를 조기 차단 가능 팀 단위로 공용 타입 유틸을 축적하면 API 변경과 리팩터링 비용을 꾸준히 줄일 수 있음\n참고자료 https://www.typescriptlang.org/docs/handbook/2/generics.html https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types https://www.typescriptlang.org/docs/handbook/2/mapped-types.html https://www.typescriptlang.org/docs/handbook/2/conditional-types.html https://www.typescriptlang.org/docs/handbook/utility-types.html ","permalink":"https://blog.jsontapose.com/posts/typescript-advanced-type-patterns-d8ee0f/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript의 고급 타입은 단순 오류 방지 수준을 넘어 재사용성과 유지보수성을 끌어올리는 핵심 도구임\n제네릭, 유니온·인터섹션, 매핑 타입, 조건부 타입, 그리고 실무에서 자주 쓰는 유틸리티 타입을 간단 예시와 함께 정리함\u003c/p\u003e\n\u003ch3 id=\"제네릭\"\u003e제네릭\u003c/h3\u003e\n\u003cp\u003e타입을 값처럼 받아서 사용하는 패턴으로, 선언 시점이 아니라 사용 시점에 타입을 결정함\nany 대비 타입 정보를 잃지 않으면서 다양한 타입을 수용 가능\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본 형태 \u003c!-- raw HTML omitted --\u003e 사용\u003c/li\u003e\n\u003cli\u003e입력과 출력 타입의 관계를 보존하는 데 초점\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e wrap\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003evalue: \u003cspan style=\"color:#81a1c1\"\u003eany\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e value \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e wrapBox\u003cspan style=\"color:#eceff4\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eT\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e\u0026gt;(\u003c/span\u003evalue: \u003cspan style=\"color:#81a1c1\"\u003eT\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e value \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e stringBox \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e wrapBox\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e numberBox \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e wrapBox\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e123\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eT는 관습적 이름이며 의미가 드러나는 이름 사용 권장\u003c/li\u003e\n\u003cli\u003e제네릭 제한이 필요한 경우 extends를 사용해 제약 가능 ex) \u003c!-- raw HTML omitted --\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"유니온과-인터섹션\"\u003e유니온과 인터섹션\u003c/h3\u003e\n\u003cp\u003e여러 타입을 조합해 표현력을 높이는 방법\u003c/p\u003e","title":"TypeScript 고급 타입 패턴 정리 — 제네릭, 유니온·인터섹션, 매핑, 조건부, 유틸리티"},{"content":"개요 RxJS는 Reactive Extensions for JavaScript의 약자이며 비동기 데이터 흐름을 스트림 Observable로 다루는 라이브러리임 이벤트, API 응답, 클릭, WebSocket처럼 시간에 따라 변하는 값을 하나의 연속 흐름으로 모델링 가능\n핵심 비교\nPromise는 값 1개 처리 Observable은 값 0개부터 무한대까지 처리 Observable 핵심 정의\n시간에 따라 변경되는 데이터를 push 기반 스트림으로 표현한 객체 구독 subscribe 시점에만 실행되는 lazy 특성 구독 해제 unsubscribe 시 리소스 정리 가능 특징\nlazy 실행으로 불필요한 작업 방지 cancel 가능으로 누수 방지 0~무한개의 값 연속 처리 간단 예시\nimport { Observable } from \u0026#39;rxjs\u0026#39; const obs = new Observable(sub =\u0026gt; { sub.next(1) sub.next(2) sub.complete() }) obs.subscribe(v =\u0026gt; console.log(v))동작 관점\n생성 시 프로듀서 로직을 보관 subscribe 호출 시 프로듀서 실행 후 observer에게 next error complete를 push 각 구독자는 독립적인 실행 흐름 가짐 Subject 핵심 정의\nObservable과 Observer 두 역할을 동시에 수행하는 멀티캐스터 외부에서 next로 값을 밀어 넣을 수 있음 여러 구독자에게 동일 데이터 브로드캐스트 언제 쓰는지\n이벤트를 여러 구독자에게 멀티캐스트할 때 외부 입력으로 스트림을 주도할 때 간단 예시\nimport { Subject } from \u0026#39;rxjs\u0026#39; const s = new Subject\u0026lt;number\u0026gt;() s.subscribe(v =\u0026gt; console.log(\u0026#39;A\u0026#39;, v)) s.subscribe(v =\u0026gt; console.log(\u0026#39;B\u0026#39;, v)) s.next(1) // A와 B 모두 1 수신 Observable vs Subject 차이 요약\nObservable은 내부 프로듀서가 데이터 생성, subscribe마다 독립 실행 Subject는 외부 next 가능, 모든 구독자에게 동일 데이터 전달, 이벤트 버스 역할에 적합 Teardown과 Subscription 정의\nObservable 사용이 끝났을 때 리소스를 해제하는 정리 함수 subscribe 시 등록되고 unsubscribe 호출 시 실행 필요 이유\n이벤트 리스너 누수 방지 interval timeout 등 장기 실행 중지 네트워크 소켓 등 연결 종료 패턴\nconst obs = new Observable(sub =\u0026gt; { const id = setInterval(() =\u0026gt; sub.next(Date.now()), 1000) return () =\u0026gt; clearInterval(id) // teardown }) const subscription = obs.subscribe(v =\u0026gt; console.log(v)) setTimeout(() =\u0026gt; subscription.unsubscribe(), 5000)Subscription 내부 개념\n여러 teardown을 보관하는 컨테이너 unsubscribe 시 등록된 정리 로직 순차 실행 Scheduler 개념 RxJS는 emit 시점과 실행 컨텍스트를 제어하는 Scheduler를 제공함\n마이크로태스크 큐 기반 스케줄링 매크로태스크 큐 setTimeout 기반 animationFrame 기반 queue 기반 동기 플러시 Scheduler로 시간 축과 실행 순서를 제어 가능하므로 Promise나 단순 EventEmitter 대비 구성 가능성이 큼\nOperator 체인 map filter switchMap mergeMap 등 오퍼레이터는 Observable을 입력받아 새로운 Observable을 반환하는 변환기 함수\n형태 요약\nimport { Observable } from \u0026#39;rxjs\u0026#39; function map\u0026lt;T, R\u0026gt;(fn: (v: T) =\u0026gt; R) { return (source: Observable\u0026lt;T\u0026gt;) =\u0026gt; new Observable\u0026lt;R\u0026gt;(sub =\u0026gt; { const inner = source.subscribe({ next: v =\u0026gt; sub.next(fn(v)), error: e =\u0026gt; sub.error(e), complete: () =\u0026gt; sub.complete(), }) return () =\u0026gt; inner.unsubscribe() }) }효과\n오퍼레이터를 이어붙여 체인 구성 데이터 스트림을 함수형 파이프라인처럼 조합 가능 내부 동작 이해 정리 구성 요소\nObserver 패턴으로 next error complete를 push Push 기반 프로듀서가 값을 능동적으로 밀어넣음 Subscription과 Teardown으로 생명주기와 리소스 관리 Scheduler로 실행 컨텍스트와 타이밍 제어 Operators로 스트림 변환 체인 구축 흐름도\nObservable 생성 시점에는 실행 없음 subscribe 호출 시 프로듀서 실행 후 observer로 값 push 중간에 operator가 값을 가공 최종 observer가 결과 수신 unsubscribe 시 teardown 실행으로 정리 베스트 프랙티스 간단 메모 구독은 생성한 곳에서 해제 전략을 함께 설계할 것 operator 체인은 명확한 취지를 가진 최소 구성 유지 Subject는 상태 공유보다는 브리지나 이벤트 멀티캐스트 용도로 제한 스케줄러 사용 시 테스트 환경에서 타이밍을 통제 가능한 전략 선택 한 줄 요약 RxJS는 Observer 패턴과 Push 프로듀서 Subscription과 Teardown Scheduler 그리고 Operator 체인을 조합해 비동기 이벤트 흐름을 스트림처럼 추상화함\n참고자료 https://rxjs.dev/guide/observable https://rxjs.dev/guide/subject https://rxjs.dev/guide/scheduler https://rxjs.dev/guide/operators https://rxjs.dev/api ","permalink":"https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eRxJS는 Reactive Extensions for JavaScript의 약자이며 비동기 데이터 흐름을 스트림 Observable로 다루는 라이브러리임\n이벤트, API 응답, 클릭, WebSocket처럼 시간에 따라 변하는 값을 하나의 연속 흐름으로 모델링 가능\u003c/p\u003e\n\u003cp\u003e핵심 비교\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePromise는 값 1개 처리\u003c/li\u003e\n\u003cli\u003eObservable은 값 0개부터 무한대까지 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"observable-핵심\"\u003eObservable 핵심\u003c/h3\u003e\n\u003cp\u003e정의\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시간에 따라 변경되는 데이터를 push 기반 스트림으로 표현한 객체\u003c/li\u003e\n\u003cli\u003e구독 subscribe 시점에만 실행되는 lazy 특성\u003c/li\u003e\n\u003cli\u003e구독 해제 unsubscribe 시 리소스 정리 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특징\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elazy 실행으로 불필요한 작업 방지\u003c/li\u003e\n\u003cli\u003ecancel 가능으로 누수 방지\u003c/li\u003e\n\u003cli\u003e0~무한개의 값 연속 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e간단 예시\u003c/p\u003e","title":"RxJS 핵심 가이드와 내부 동작 이해 Observable Subject Teardown Scheduler Operator"},{"content":"개요 TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴\nimport \u0026hellip; from \u0026lsquo;@\u0026hellip;\u0026rsquo; import \u0026hellip; from \u0026lsquo;\u0026hellip;\u0026rsquo; import \u0026hellip; from \u0026lsquo;#\u0026hellip;\u0026rsquo; 표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름\n\u0026lsquo;@\u0026lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능 \u0026lsquo;\u0026hellip;\u0026lsquo;는 상대·절대 경로로 파일 시스템 기준 해석 \u0026lsquo;#\u0026lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용 아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함\n\u0026lsquo;@\u0026hellip;\u0026rsquo; 경로의 두 가지 의미 1) 경로 별칭 path alias 의도: 길고 복잡한 상대 경로를 짧게 추상화 설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl 예시 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@models/*\u0026#34;: [\u0026#34;src/models/*\u0026#34;], \u0026#34;@utils/*\u0026#34;: [\u0026#34;src/utils/*\u0026#34;] } } }import { User } from \u0026#39;@models/User\u0026#39; import { calculate } from \u0026#39;@utils/math\u0026#39; 장점 상대 경로를 단순화, 가독성 및 리팩터링 내성 향상 주의 tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님 Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요 예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요 2) 스코프된 패키지 scoped package 의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합 표기: @scope/package-name 형태 @nestjs/swagger, @angular/core 등 사용 이유 네임스페이스로 이름 충돌 회피 관련 패키지의 그룹화와 공개·비공개 관리 설치 npm install @nestjs/swagger 해석 이 경우 \u0026lsquo;@\u0026lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작 tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석 \u0026lsquo;\u0026hellip;\u0026rsquo; 상대·절대 경로 import 상대 경로 \u0026lsquo;./\u0026rsquo;, \u0026lsquo;../\u0026rsquo; 기준으로 현재 파일 위치에서 탐색 절대 경로 \u0026lsquo;/path\u0026rsquo;는 실행 환경마다 기준이 다름 브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석 Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음 예시 import { User } from \u0026#39;./models/User\u0026#39; import { calculate } from \u0026#39;../utils/math\u0026#39; 장점 추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델 모듈 간 물리적 의존 관계가 드러남 단점 디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승 구조 변경 시 경로 대량 수정 발생 \u0026lsquo;#\u0026hellip;\u0026rsquo; 경로의 의미 \u0026lsquo;#{name}\u0026rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의\n1) Node.js 패키지 imports 개념: package.json 의 imports 필드로 패키지 내부 전용 별칭 제공 특징 키는 반드시 \u0026lsquo;#\u0026lsquo;로 시작 동일 패키지 내부 전용. 외부 소비자가 임의로 참조 불가 ESM 해석기에 의해 런타임에서 동작. 번들러 없이도 Node가 직접 이해 설정 예시 { \u0026#34;name\u0026#34;: \u0026#34;my-package\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;imports\u0026#34;: { \u0026#34;#utils\u0026#34;: \u0026#34;./src/utils/index.js\u0026#34;, \u0026#34;#models/*\u0026#34;: \u0026#34;./src/models/*.js\u0026#34; } } 사용 예시 import { calc } from \u0026#39;#utils\u0026#39; import { User } from \u0026#39;#models/User\u0026#39; 장점 런타임이 이해하는 공식 별칭. tsconfig paths와 달리 Node 해석 일관성 확보 외부 공개 API와 내부 경로를 분리하는 캡슐화에 유리 주의 패키지 외부에서는 \u0026lsquo;#\u0026hellip;\u0026rsquo; 경로 사용 불가. 내부 전용 설계임 TypeScript는 nodenext 또는 node16 모듈 해석 설정에서 해당 매핑을 인지 가능. 도구별 지원 상태 확인 필요 2) 브라우저 import maps에서의 별칭 키 개념: 브라우저가 script type=importmap 또는 별도 importmap.json을 통해 모듈 스펙ifier를 URL로 매핑 \u0026lsquo;#\u0026hellip;\u0026lsquo;는 필수 형식 아님. 임의의 bare specifier 사용 가능. 다만 충돌 방지를 위해 \u0026lsquo;#\u0026rsquo; 접두를 쓰는 패턴이 존재 예시 { \u0026#34;imports\u0026#34;: { \u0026#34;#utils\u0026#34;: \u0026#34;/src/utils/\u0026#34;, \u0026#34;#models\u0026#34;: \u0026#34;/src/models/\u0026#34; } }import { User } from \u0026#39;#models/User\u0026#39; 주의 Node.js는 HTML 기반 import maps를 지원하지 않음. Node에서 import maps를 쓰고자 한다면 번들러 또는 서버 사이드 변환 계층 필요 브라우저 타깃이 아닌 순수 Node 런타임에는 package.json imports를 고려하는 편이 적합 차이점 요약 \u0026lsquo;@\u0026hellip;\u0026rsquo; 경로\ntsconfig paths 기반 별칭 또는 npm 스코프 패키지 이름 두 의미 존재 tsconfig paths는 타입 체커 전용 별칭. 런타임 동작을 위해 번들러·로더 설정 동기화 필요 스코프 패키지는 패키지 네임스페이스 표기. 설정 없이 npm 해석 \u0026lsquo;\u0026hellip;\u0026rsquo; 경로\n상대·절대 경로를 직접 명시하는 기본 형태 설정 불필요. 환경 공통 동작 경로가 깊어지면 가독성 저하 \u0026lsquo;#\u0026hellip;\u0026rsquo; 경로\nNode.js package.json 의 imports로 정의하는 내부 전용 별칭 또는 브라우저 import maps에서의 별칭 키로 사용 Node 런타임 관점에서는 package imports가 공식적이고 안정적이며, 외부 노출 불가라는 제약이 있음 브라우저 import maps는 브라우저 전용 메커니즘. Node에서 직접 사용 불가 어떤 방식을 언제 쓸까 작은 프로젝트 또는 간단한 모듈 트리\n상대 경로 유지가 가장 직관적 대규모 코드베이스, 깊은 디렉터리 구조, 다수의 교차 참조\n경로 별칭 도입으로 가독성 확보 Node 런타임 우선이면 package.json imports의 \u0026lsquo;#\u0026hellip;\u0026rsquo; 채택 고려 브라우저 우선이면 import maps 또는 번들러 alias 사용 라이브러리 패키지 내부 캡슐화 강화 필요\n\u0026lsquo;#\u0026hellip;\u0026rsquo; package imports로 내부 경로 보호 및 API 경계 명확화 프레임워크·조직 단위 패키지 묶음 배포\n\u0026lsquo;@scope/name\u0026rsquo; 스코프 패키지로 네임스페이스 관리 실무 주의사항과 베스트 프랙티스 tsconfig paths를 쓰면 반드시 런타임 해석자와 동기화\n번들러 alias, 테스트 러너, ts-node, ESLint import resolver를 함께 맞춤 Node 런타임 기준 별칭 1순위는 package.json imports 고려\n런타임이 직접 이해하므로 환경 의존성 감소 외부에 노출하지 않을 내부 경로에만 적용하는 것이 원칙 브라우저 타깃에서 import maps 사용 시 폴리필·번들링 전략과 함께 설계\n구형 브라우저 호환성, 캐시 전략, 배포 경로 관리 동반 검토 절대 경로 \u0026lsquo;/\u0026hellip;\u0026rsquo; 사용 자제\n브라우저와 Node에서 의미가 달라 이식성 낮음. 환경 단절 이슈 유발 가능 혼용을 최소화하고 팀 컨벤션 수립\n동일 목적의 별칭 체계는 한 가지 메커니즘으로 통일 예) 서버는 \u0026lsquo;#\u0026hellip;\u0026rsquo; imports, 클라이언트는 import maps, 공용 TypeScript는 상대 경로 또는 제한적 paths 간단 예시 스니펫 tsconfig paths로 \u0026lsquo;@utils/*\u0026rsquo; 매핑 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@utils/*\u0026#34;: [\u0026#34;src/utils/*\u0026#34;] } } }import { calc } from \u0026#39;@utils/math\u0026#39; Node package imports로 \u0026lsquo;#utils\u0026rsquo; 매핑 { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;imports\u0026#34;: { \u0026#34;#utils\u0026#34;: \u0026#34;./src/utils/index.js\u0026#34; } }import { calc } from \u0026#39;#utils\u0026#39; 브라우저 import maps에서 \u0026lsquo;#models\u0026rsquo; 매핑 { \u0026#34;imports\u0026#34;: { \u0026#34;#models\u0026#34;: \u0026#34;/src/models/\u0026#34; } }import { User } from \u0026#39;#models/User\u0026#39;마무리 \u0026lsquo;@\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, 상대 경로는 표면적으로 비슷해 보여도 책임 주체와 동작 레이어가 다름\n\u0026lsquo;@\u0026lsquo;는 경로 별칭 또는 스코프 패키지 이름 \u0026lsquo;#\u0026lsquo;는 Node의 package imports 또는 브라우저 import maps 별칭 키 상대·절대 경로는 파일 시스템·URL 기준 직접 지정 런타임이 무엇을 실제로 해석하는지부터 결정한 뒤 별칭 전략을 선택하는 것이 유지보수 비용을 줄이는 가장 확실한 방법임\n참고자료 https://www.typescriptlang.org/tsconfig#paths https://nodejs.org/api/packages.html#imports https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#import_maps https://github.com/WICG/import-maps https://docs.npmjs.com/cli/v10/using-npm/scope ","permalink":"https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript와 ESM에서 자주 보이는 세 가지 import 패턴\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eimport \u0026hellip; from \u0026lsquo;@\u0026hellip;\u0026rsquo;\u003c/li\u003e\n\u003cli\u003eimport \u0026hellip; from \u0026lsquo;\u0026hellip;\u0026rsquo;\u003c/li\u003e\n\u003cli\u003eimport \u0026hellip; from \u0026lsquo;#\u0026hellip;\u0026rsquo;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026lsquo;@\u0026lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능\u003c/li\u003e\n\u003cli\u003e\u0026lsquo;\u0026hellip;\u0026lsquo;는 상대·절대 경로로 파일 시스템 기준 해석\u003c/li\u003e\n\u003cli\u003e\u0026lsquo;#\u0026lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함\u003c/p\u003e\n\u003ch3 id=\"-경로의-두-가지-의미\"\u003e\u0026lsquo;@\u0026hellip;\u0026rsquo; 경로의 두 가지 의미\u003c/h3\u003e\n\u003ch4 id=\"1-경로-별칭-path-alias\"\u003e1) 경로 별칭 path alias\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e의도: 길고 복잡한 상대 경로를 짧게 추상화\u003c/li\u003e\n\u003cli\u003e설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl\u003c/li\u003e\n\u003cli\u003e예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1\"\u003e\u0026#34;compilerOptions\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#81a1c1\"\u003e\u0026#34;baseUrl\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;./\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#81a1c1\"\u003e\u0026#34;paths\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#81a1c1\"\u003e\u0026#34;@models/*\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;src/models/*\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#81a1c1\"\u003e\u0026#34;@utils/*\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;src/utils/*\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e User \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;@models/User\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e calculate \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;@utils/math\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e장점\n\u003cul\u003e\n\u003cli\u003e상대 경로를 단순화, 가독성 및 리팩터링 내성 향상\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e주의\n\u003cul\u003e\n\u003cli\u003etsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님\u003c/li\u003e\n\u003cli\u003eNode.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요\u003c/li\u003e\n\u003cli\u003e예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"2-스코프된-패키지-scoped-package\"\u003e2) 스코프된 패키지 scoped package\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합\u003c/li\u003e\n\u003cli\u003e표기: @scope/package-name 형태\n\u003cul\u003e\n\u003cli\u003e@nestjs/swagger, @angular/core 등\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e사용 이유\n\u003cul\u003e\n\u003cli\u003e네임스페이스로 이름 충돌 회피\u003c/li\u003e\n\u003cli\u003e관련 패키지의 그룹화와 공개·비공개 관리\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e설치\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enpm install @nestjs/swagger\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e해석\n\u003cul\u003e\n\u003cli\u003e이 경우 \u0026lsquo;@\u0026lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작\u003c/li\u003e\n\u003cli\u003etsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-상대절대-경로-import\"\u003e\u0026lsquo;\u0026hellip;\u0026rsquo; 상대·절대 경로 import\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e상대 경로 \u0026lsquo;./\u0026rsquo;, \u0026lsquo;../\u0026rsquo; 기준으로 현재 파일 위치에서 탐색\u003c/li\u003e\n\u003cli\u003e절대 경로 \u0026lsquo;/path\u0026rsquo;는 실행 환경마다 기준이 다름\n\u003cul\u003e\n\u003cli\u003e브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석\u003c/li\u003e\n\u003cli\u003eNode.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e User \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;./models/User\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e calculate \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efrom\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;../utils/math\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e장점\n\u003cul\u003e\n\u003cli\u003e추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델\u003c/li\u003e\n\u003cli\u003e모듈 간 물리적 의존 관계가 드러남\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e단점\n\u003cul\u003e\n\u003cli\u003e디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승\u003c/li\u003e\n\u003cli\u003e구조 변경 시 경로 대량 수정 발생\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"-경로의-의미\"\u003e\u0026lsquo;#\u0026hellip;\u0026rsquo; 경로의 의미\u003c/h3\u003e\n\u003cp\u003e\u0026lsquo;#{name}\u0026rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의\u003c/p\u003e","title":"TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정"},{"content":"개요 목표 이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기 Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음\nCPU 코어와 OS 스레드의 물리적 의미 하드웨어와 OS 레벨 정의를 먼저 정리\nCPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개 스레드 OS 스케줄러가 CPU를 할당하는 최소 단위 동시성 vs 병렬성 코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성 코어 여러 개일 때만 실제 병렬 실행 가능 CPU 관점의 핵심 비용\n실행 유저 코드나 커널 코드가 실제로 CPU 사이클 소모 대기 I O 응답 등으로 CPU 미사용 상태 Blocked 문맥 교환 OS가 실행 중인 스레드를 바꾸는 과정 레지스터 저장 복원, 캐시 오염 등 오버헤드 발생 Node.js의 실행 모델 Actors Node.js 프로세스가 CPU 자원을 소비하는 주체 세 가지로 단순화 가능\n메인 스레드 Event Loop 정체 Node.js 시작 시 생성되는 단 하나의 OS 스레드 역할 V8 엔진 위 JS 실행, 콜백 처리, 비동기 요청 등록 CPU 특징 대부분 사용자 모드에서 CPU 사용 이 스레드가 막히면 애플리케이션 전체가 멈춘 것으로 체감됨 커널 Linux Kernel 정체 OS의 핵심 컴포넌트, 하드웨어 제어 역할 TCP IP 스택, 파일 시스템, epoll 기반 이벤트 통지 처리 CPU 특징 시스템 콜 수행 시 유저 모드와 커널 모드 전환이 일어나며 CPU 사용 libuv 스레드풀 Thread Pool 정체 Node.js 프로세스 내부의 별도 OS 스레드 그룹 기본 4개 역할 OS가 비동기를 직접 제공하지 않거나 CPU 연산이 큰 작업을 오프로딩 파일 I O 완전 비동기 파일 접근은 OS마다 제약 존재 일부 암호화 crypto, 압축 zlib, TLS 연산 일부 dns.lookup 시스템 리졸버 호출 CPU 특징 메인 스레드와 별개로 스케줄링되어 멀티 코어 환경에서 병렬 처리 가능 시나리오별 CPU 자원 흐름 A) 순수 CPU 연산 CPU bound 예 거대한 루프, 복잡한 정규식, 대용량 JSON.parse, 암호화 해싱\n흐름 메인 스레드가 V8 위에서 코드를 연속 실행 CPU 상태 메인 스레드 CPU 점유율 100% 근접 문제점 메인 스레드 점유로 완료된 I O 이벤트나 타이머 콜백 처리가 지연되어 기아 Starvation 발생 사용자는 Node가 멈춘 것으로 인지 해결 worker_threads로 오프로딩하거나 외부 프로세스로 분리 B) 네트워크 I O Network bound 예 HTTP 요청 응답, DB 쿼리 대기\n흐름 요청 메인 스레드가 write 시스템 콜 호출 짧은 CPU 사용 대기 커널이 NIC로 패킷 전송 후 응답 대기 메인 스레드는 Non blocking으로 다른 일 처리 수신 패킷 도착 시 커널 인터럽트 처리 후 epoll로 이벤트 준비 처리 메인 스레드가 깨어나 콜백 실행 CPU 상태 네트워크 대기 시간 동안 CPU 사용량 거의 0 수천 연결도 실제 패킷 처리 시점에만 CPU 사용 집중 특징 스레드풀 불사용 Node.js가 가장 효율적인 영역 C) 파일 I O Disk bound 예 fs.readFile, fs.writeFile Async\n파일 시스템 작업은 libuv 스레드풀로 이관되는 경우가 일반적임 Linux AIO 제약 및 이식성 이슈\n흐름 위임 메인 스레드는 작업을 스레드풀 큐에 넣고 즉시 리턴 작업 스레드풀 스레드가 read write 시스템 콜 수행 후 디스크 응답을 블로킹 대기 완료 작업 완료 시 스레드풀이 메인 스레드에 이벤트 통지 CPU 상태 메인 스레드는 자유롭게 다른 이벤트 처리 스레드풀 스레드는 I O 대기와 메모리 복사 구간에서만 CPU 사용 상태 전환 주의 스레드풀 크기 기본 4개를 초과하는 동시 파일 요청 시 큐 대기 증가로 지연 확대 UV_THREADPOOL_SIZE 튜닝 필요 예시 최소 스니펫 환경변수 기반 스레드풀 크기 조정\nUV_THREADPOOL_SIZE=32 node app.js D) DNS 조회 함정 주의 dns.lookup 도메인 OS의 getaddrinfo 호출을 사용 호출 자체는 블로킹 모델이므로 libuv 스레드풀에서 실행 JS는 블로킹되지 않지만 스레드풀 슬롯을 점유 dns.resolve 도메인 c-ares 기반 비동기 리졸버 사용 네트워크 I O처럼 동작하며 스레드풀 미사용 커널 비동기 메커니즘과 이벤트 루프로 처리 CPU 관점에서 자주 헷갈리는 개념 Node.js는 싱글 스레드다 정확히는 JS 코드 실행 컨텍스트가 메인 스레드 하나라는 의미 실제 프로세스는 libuv 스레드풀 기본 4개와 V8 내부 스레드 GC, 최적화 등 포함 다수 OS 스레드 사용\nAsync 작업은 모두 스레드풀에서 돈다 아님 네트워크 I O HTTP, TCP는 스레드풀을 거치지 않고 epoll kqueue 등 커널 비동기를 사용 CPU 효율 우수 파일 I O, 암호화, 압축, DNS lookup 등은 스레드풀 사용\nCPU 코어가 많으면 Node.js 하나로 충분한가 아님 메인 스레드는 한 번에 코어 1개만 사용 가능 코어 8개면 프로세스 다중화 cluster 또는 worker_threads로 병렬성 확보 필요\n실무 진단 CPU 패턴으로 병목 찾기 모니터링의 CPU 그래프와 지연 시간으로 병목 추론\n증상 CPU 패턴 예상 원인 조치 응답 매우 느림 CPU 100% Core 1개 CPU bound 무한루프, 큰 연산 프로파일링으로 핫스팟 식별, 워커 분리 응답 느림 CPU 낮음 Idle I O bound 외부 API, DB 지연 외부 서비스 상태 점검, 쿼리 튜닝 간헐적 멈춤 톱니바퀴 모양 스파이크 GC 가비지 컬렉션 또는 Burst 작업 메모리 누수 점검, 힙 사이즈 조정 파일 처리 지연 CPU 보통, Latency 증가 스레드풀 고갈 UV_THREADPOOL_SIZE 증가 고려 보강 팁\nTLS 핸드셰이크의 암 복호화는 crypto 연산으로 스레드풀 사용 가능 네트워크 I O 자체와 분리해 관찰 권장 GC 스파이크는 이벤트 루프 지연으로 직결 샘플링 프로파일링과 힙 스냅샷으로 원인 추적 권장 파일 I O가 지배적이면 스토리지 대역폭과 IOPS 지표를 함께 확인 필요 요약 메인 스레드 보호가 최우선 JS 실행이 막히면 서버 전체가 멈춘 것과 다름없음 I O는 대기 시간을 커널이 책임 Node.js는 이 기다림을 비동기로 효율 처리 스레드풀은 만능 아님 파일 시스템과 무거운 연산을 위한 보조 수단 네트워크 처리는 스레드풀과 무관하게 더 효율적으로 동작 마무리 CPU 코어와 OS 스레드의 물리적 제약, 커널 비동기 모델, libuv 스레드풀의 역할을 분리해 보면 병목 지점이 선명해짐 워커 스레드 도입, 프로세스 다중화, 스레드풀 튜닝, 외부 I O 지연 제거 순으로 단계적 최적화 권장\n참고자료 https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick https://nodejs.org/api/cli.html#uv_threadpool_size-size https://nodejs.org/api/worker_threads.html https://nodejs.org/api/dns.html https://nodejs.org/api/fs.html https://libuv.org/ https://man7.org/linux/man-pages/man7/epoll.7.html https://c-ares.org/ ","permalink":"https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e목표  이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기\nNode.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음\u003c/p\u003e\n\u003ch3 id=\"cpu-코어와-os-스레드의-물리적-의미\"\u003eCPU 코어와 OS 스레드의 물리적 의미\u003c/h3\u003e\n\u003cp\u003e하드웨어와 OS 레벨 정의를 먼저 정리\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개\u003c/li\u003e\n\u003cli\u003e스레드  OS 스케줄러가 CPU를 할당하는 최소 단위\u003c/li\u003e\n\u003cli\u003e동시성 vs 병렬성\n\u003cul\u003e\n\u003cli\u003e코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성\u003c/li\u003e\n\u003cli\u003e코어 여러 개일 때만 실제 병렬 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCPU 관점의 핵심 비용\u003c/p\u003e","title":"CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용"},{"content":"개요 Ethereum에서 트랜잭션 순서를 보장하는 핵심 메커니즘은 nonce임. 네트워크에서 자주 겪는 \u0026ldquo;nonce 꼬임\u0026quot;은 대개 트랜잭션 상태와 nonce 소비 규칙을 혼동해서 발생함. 아래는 EOA와 트랜잭션 관계, nonce 정의, 트랜잭션 상태별 nonce 변화 정리\nEOA와 트랜잭션 Ethereum 계정은 두 종류로 구분\nEOA, 개인 키로 서명해 트랜잭션 전송 가능 Contract Account, 스스로 트랜잭션 전송 불가, 외부에서 온 트랜잭션의 실행 흐름 내에서만 호출됨 트랜잭션을 보낸다는 것은 EOA가 서명 후 네트워크에 브로드캐스트한다는 의미. 컨트랙트는 내부 호출과 생성 같은 메시지 호출을 발생시킬 수 있지만 이는 트랜잭션이 아님. 최상위 트랜잭션의 발신자는 항상 EOA\nNonce 정의와 규칙 Nonce는 특정 EOA가 보낸 트랜잭션의 순서를 보장하기 위한 계수. 해당 EOA가 블록에 포함시킨 트랜잭션 개수와 동일하게 증가\n새 주소의 첫 트랜잭션 nonce는 0 이후 블록에 포함될 때마다 1씩 증가 핵심은 성공 여부가 아니라 실행 여부. 블록에 포함되어 EVM이 실행한 순간 nonce는 소비됨. 성공이든 revert든 동일하게 소비됨\n실행 조건은 단순함\ntx.nonce == account.nonce 일 때만 해당 트랜잭션 실행 가능 앞 nonce가 소비되지 않으면 뒤 nonce는 대기 상태. 연속 nonce 충족 필요 예시 표현\n트랜잭션이 블록에 포함되면 nonce 1 증가 트랜잭션의 4가지 상태 트랜잭션은 다음 네 가지 상태 중 하나로 귀결\nPending 노드가 수신 후 mempool에 보관 중 블록에 포함되지 않음, 실행 기록 없음 Mined + Success 블록에 포함되어 정상 실행 상태 변경 반영, nonce 소비 Mined + Revert 블록에 포함되어 실행되었으나 조건 불충족 또는 out-of-gas 등으로 revert 상태 변경은 롤백되나 실행 사실은 유효. nonce 소비 Dropped 블록에 포함되지 않음, mempool에서 제거됨 실행되지 않았으므로 nonce 미소비 상태별 nonce 소비 정리 기준은 블록 포함 후 실행 여부 한 가지\nPending, Dropped는 블록 미포함 → 실행 아님 → nonce 미소비 → 다음 nonce 사용 불가 Mined + Success, Mined + Revert는 블록 포함 및 실행 → nonce 소비 → 다음 nonce 사용 가능 연속 nonce 규칙 때문에 앞선 nonce가 처리되지 않으면 동일 계정의 이후 트랜잭션은 실행 불가. 뒤 nonce가 mempool에 대기할 수는 있지만 블록에서 실행되려면 앞 nonce가 먼저 소비되어야 함\n정리와 시사점 트랜잭션은 EOA만 전송. 컨트랙트는 외부 트랜잭션에 의해 호출되는 대상 Nonce는 EOA 단위 트랜잭션 순서를 나타내는 카운터. 0에서 시작해 블록 포함 시 1씩 증가 성공과 revert를 구분하지 않음. 블록에 포함되어 실행되면 nonce 소비 Pending이나 Dropped는 실행 사실이 없으므로 nonce 변화 없음. 앞 nonce 미소비 시 뒤 nonce 트랜잭션은 절대 실행 불가 Nonce는 트랜잭션 순서를 강제하고 동일 계정 내 재전송 재생 공격을 억제하는 역할 수행 원하면 본 구조 그대로 도식, RPC 호출 예시, viem 또는 ethers를 이용한 상태 판별 코드 스니펫까지 확장 가능\n참고자료 https://ethereum.org/en/developers/docs/accounts/ https://ethereum.org/en/developers/docs/transactions/ https://ethereum.org/en/developers/docs/evm/ ","permalink":"https://blog.jsontapose.com/posts/ethereum-transaction-nonce-states-7cf0f0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eEthereum에서 트랜잭션 순서를 보장하는 핵심 메커니즘은 nonce임. 네트워크에서 자주 겪는 \u0026ldquo;nonce 꼬임\u0026quot;은 대개 트랜잭션 상태와 nonce 소비 규칙을 혼동해서 발생함. 아래는 EOA와 트랜잭션 관계, nonce 정의, 트랜잭션 상태별 nonce 변화 정리\u003c/p\u003e\n\u003ch3 id=\"eoa와-트랜잭션\"\u003eEOA와 트랜잭션\u003c/h3\u003e\n\u003cp\u003eEthereum 계정은 두 종류로 구분\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEOA, 개인 키로 서명해 트랜잭션 전송 가능\u003c/li\u003e\n\u003cli\u003eContract Account, 스스로 트랜잭션 전송 불가, 외부에서 온 트랜잭션의 실행 흐름 내에서만 호출됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e트랜잭션을 보낸다는 것은 EOA가 서명 후 네트워크에 브로드캐스트한다는 의미. 컨트랙트는 내부 호출과 생성 같은 메시지 호출을 발생시킬 수 있지만 이는 트랜잭션이 아님. 최상위 트랜잭션의 발신자는 항상 EOA\u003c/p\u003e","title":"nonce가 꼬인다? 트랜잭션 상태별 nonce의 변화"},{"content":"개요 이더리움 단위 체계는 10의 지수 기반으로 딱 떨어지게 설계됨 EVM은 부동소수점을 지원하지 않으므로 모든 값은 정수로 표현, 단위 나눔과 스케일링이 필수\n단위 환산 1 ETH = 10^9 Gwei = 10^18 Wei\n풀어서 보면 다음과 같음\n1 ETH = 1,000,000,000 Gwei (10억 그웨이) = 1,000,000,000,000,000,000 Wei (100경 웨이) 용도별 구분 Wei: 최소 단위, 스마트 컨트랙트 내부 연산에 사용. Solidity에 소수점 개념 없음 Gwei: 10^9 Wei. 가스 가격 표시 단위로 사용, 사람이 읽고 비교하기 쉬움 Ether: 10^18 Wei. 지갑 잔고, 일상적 송금 금액 표시에 사용 개발자 상식: ERC-20 decimals = 18 ERC-20 토큰에서 decimals를 18로 두는 관례는 이더리움 기본 최소 단위(Wei) 스케일을 그대로 따름 의미: 토큰 1개가 10^18의 최소 단위로 분할 가능 예외: 스테이블 코인처럼 법정화폐 소수 자리를 맞추는 토큰은 decimals 6 등으로 설정하는 경우 있음\n구현 팁 온체인 연산은 항상 정수로 처리. 금액 연산 시 기준 단위를 Wei로 고정 스케일 변환 관례: ETH ↔ Wei 변환 시 1e18 계수 사용. 예) amountInWei = amountInEth * 1e18 프런트엔드 표현 단계에서만 단위 변환 및 포맷팅. 사용자 입력은 문자열 → 정수 스케일 업 후 처리 권장 가스비 표시는 Gwei로 노출, 내부 연산은 Wei로 계산. base fee와 tip 합산 시 단위 혼용 주의 정리 핵심은 정수 기반 단위 스케일 고정과 문맥별 표현 단위 분리 컨트랙트 내부 연산은 Wei, 가스 가격 표시는 Gwei, 사용자 노출은 Ether라는 역할 구분 유지\n참고자료 https://ethereum.org/en/developers/docs/units/ https://ethereum.org/en/developers/docs/gas/ https://eips.ethereum.org/EIPS/eip-20 ","permalink":"https://blog.jsontapose.com/posts/ethereum-units-eth-gwei-wei-decimals-18-83ba11/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이더리움 단위 체계는 10의 지수 기반으로 딱 떨어지게 설계됨\nEVM은 부동소수점을 지원하지 않으므로 모든 값은 정수로 표현, 단위 나눔과 스케일링이 필수\u003c/p\u003e\n\u003ch3 id=\"단위-환산\"\u003e단위 환산\u003c/h3\u003e\n\u003cp\u003e1 ETH = 10^9 Gwei = 10^18 Wei\u003c/p\u003e\n\u003cp\u003e풀어서 보면 다음과 같음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 ETH\u003c/li\u003e\n\u003cli\u003e= 1,000,000,000 Gwei (10억 그웨이)\u003c/li\u003e\n\u003cli\u003e= 1,000,000,000,000,000,000 Wei (100경 웨이)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"용도별-구분\"\u003e용도별 구분\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWei: 최소 단위, 스마트 컨트랙트 내부 연산에 사용. Solidity에 소수점 개념 없음\u003c/li\u003e\n\u003cli\u003eGwei: 10^9 Wei. 가스 가격 표시 단위로 사용, 사람이 읽고 비교하기 쉬움\u003c/li\u003e\n\u003cli\u003eEther: 10^18 Wei. 지갑 잔고, 일상적 송금 금액 표시에 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"개발자-상식-erc-20-decimals--18\"\u003e개발자 상식: ERC-20 decimals = 18\u003c/h3\u003e\n\u003cp\u003eERC-20 토큰에서 decimals를 18로 두는 관례는 이더리움 기본 최소 단위(Wei) 스케일을 그대로 따름\n의미: 토큰 1개가 10^18의 최소 단위로 분할 가능\n예외: 스테이블 코인처럼 법정화폐 소수 자리를 맞추는 토큰은 decimals 6 등으로 설정하는 경우 있음\u003c/p\u003e","title":"이더리움 단위 정리: ETH, Gwei, Wei와 ERC-20 decimals 18"},{"content":"개념/배경 Account Abstraction(AA, 계정 추상화)은 키 기반 EOA에 고정된 지갑 모델을 스마트 컨트랙트로 일반화해 UX를 끌어올리는 접근법. ERC-4337은 이를 프로토콜 변경 없이 애플리케이션 레이어에서 구현하는 표준. 목적은 블록체인을 몰라도 쓸 수 있는 경험을 제공하는 것. 대가로 추가 가스비와 인프라 복잡도가 뒤따름\n장점 요약 가스비 대납과 가스 추상화 지원. Paymaster를 통해 사용자가 ETH 없이도 트랜잭션 가능. 서비스가 대납하거나 보유 토큰으로 지불하는 경로 구성 가능 소셜 복구 및 프로그래머블 보안. 시드 문구 분실 시 다중 승인 기반 복구, 전송 한도, 화이트리스트 등 정책 내장 가능 트랜잭션 배치. Approve → Swap 같은 연속 작업을 한 번의 서명으로 처리, 서명 피로와 왕복 비용 감소 세션 키. 제한된 권한과 기간으로 자동 서명 흐름 구성 가능. 게임 등 빈번한 액션에 유효 단점 요약 높은 가스비. EntryPoint를 경유하며 검증/실행 로직이 추가되어 오버헤드 발생. 메인넷에서는 체감 비용 큼, L2에서는 상대적으로 부담 완화 가능 인프라 복잡도 증가. 노드만으로 부족, Bundler·Paymaster·Aggregator 등 별도 컴포넌트 필요. 이들 장애 시 트랜잭션 정지 리스크 존재 DApp 호환성 이슈. EOA 전제 코드와 충돌 가능. EIP-1271 기반 서명 검증 경로를 지원하지 않는 레거시 DApp에서 로그인/서명 실패 발생 여지 지갑 생성 비용. AA 지갑은 컨트랙트이므로 최초 배포 비용 발생. 첫 트랜잭션 시 지연 배포로 UX 노출 최소화 가능 EntryPoint 병목 구조 ERC-4337에서는 사용자 요청(UserOperation)이 단일 싱글톤 컨트랙트인 EntryPoint를 통해 처리됨. Bundler가 여러 UserOp를 모아 EntryPoint의 handleOps를 호출하는 구조. 병목의 핵심은 서버 과부하라기보다 가스비 오버헤드와 검증 복잡도 증가\n단일 톨게이트 특성. 모든 요청이 EntryPoint에서 Validation과 Execution을 거침. 루프 기반 검증, 수수료 정산, 실패 처리 등 공통 로직이 추가 비용을 야기. 단순 ETH 전송이 21,000 가스인 반면, AA 전송은 대략 42,000~100,000 가스 범위로 보고됨(정책·구현·네트워크 상황에 따라 변동) 검증 단계의 DoS 대응 부담. Bundler는 온체인 전송 전 시뮬레이션으로 유효성 검사를 수행. 검증 시 통과하나 실행 시 실패하도록 설계된 악성 패턴이 존재할 수 있어, EntryPoint는 스토리지 접근 제약 등 엄격한 규칙을 강제. 이로 인해 번들러 노드의 시뮬레이션 CPU 부하 증가, 처리량 병목으로 이어질 수 있음 요약 및 트렌드 핵심 장점. 복구 가능한 지갑, 가스 추상화, 원클릭 실행 등 웹2 수준 UX 달성 핵심 단점. EntryPoint 오버헤드로 인한 가스비 상승, 번들러·페이마스터 등 인프라 복잡도 증가 관찰 포인트. EntryPoint를 경유하는 구조적 오버헤드와 번들러 시뮬레이션 부하가 실비용과 안정성의 주된 제약. 메인넷에서는 비용 민감, L2에서 실사용 적합성이 상대적으로 높음 실무 체크리스트 메인넷 비용 민감 서비스는 L2 우선 고려 번들러와 페이마스터 이중화 및 헬스 체크 구성 서명 경로 EIP-1271 지원 여부를 DApp 통합 단계에서 사전 검증 첫 트랜잭션 시 지갑 지연 배포 전략으로 온보딩 마찰 최소화 마무리 AA는 UX 혁신과 교환으로 비용과 운영 복잡도를 수반. 서비스 모델과 네트워크 환경에 따라 트레이드오프가 크게 달라짐. 구조적 병목을 이해하고 비용 경로와 장애 지점을 설계 단계에서 통제하는 것이 관건\n참고자료 https://eips.ethereum.org/EIPS/eip-4337 https://eips.ethereum.org/EIPS/eip-1271 https://github.com/eth-infinitism/account-abstraction ","permalink":"https://blog.jsontapose.com/posts/erc-4337-account-abstraction-pros-cons-entrypoint-bottleneck-221231/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eAccount Abstraction(AA, 계정 추상화)은 키 기반 EOA에 고정된 지갑 모델을 스마트 컨트랙트로 일반화해 UX를 끌어올리는 접근법. ERC-4337은 이를 프로토콜 변경 없이 애플리케이션 레이어에서 구현하는 표준. 목적은 블록체인을 몰라도 쓸 수 있는 경험을 제공하는 것. 대가로 추가 가스비와 인프라 복잡도가 뒤따름\u003c/p\u003e\n\u003ch3 id=\"장점-요약\"\u003e장점 요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e가스비 대납과 가스 추상화 지원. Paymaster를 통해 사용자가 ETH 없이도 트랜잭션 가능. 서비스가 대납하거나 보유 토큰으로 지불하는 경로 구성 가능\u003c/li\u003e\n\u003cli\u003e소셜 복구 및 프로그래머블 보안. 시드 문구 분실 시 다중 승인 기반 복구, 전송 한도, 화이트리스트 등 정책 내장 가능\u003c/li\u003e\n\u003cli\u003e트랜잭션 배치. Approve → Swap 같은 연속 작업을 한 번의 서명으로 처리, 서명 피로와 왕복 비용 감소\u003c/li\u003e\n\u003cli\u003e세션 키. 제한된 권한과 기간으로 자동 서명 흐름 구성 가능. 게임 등 빈번한 액션에 유효\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"단점-요약\"\u003e단점 요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e높은 가스비. EntryPoint를 경유하며 검증/실행 로직이 추가되어 오버헤드 발생. 메인넷에서는 체감 비용 큼, L2에서는 상대적으로 부담 완화 가능\u003c/li\u003e\n\u003cli\u003e인프라 복잡도 증가. 노드만으로 부족, Bundler·Paymaster·Aggregator 등 별도 컴포넌트 필요. 이들 장애 시 트랜잭션 정지 리스크 존재\u003c/li\u003e\n\u003cli\u003eDApp 호환성 이슈. EOA 전제 코드와 충돌 가능. EIP-1271 기반 서명 검증 경로를 지원하지 않는 레거시 DApp에서 로그인/서명 실패 발생 여지\u003c/li\u003e\n\u003cli\u003e지갑 생성 비용. AA 지갑은 컨트랙트이므로 최초 배포 비용 발생. 첫 트랜잭션 시 지연 배포로 UX 노출 최소화 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"entrypoint-병목-구조\"\u003eEntryPoint 병목 구조\u003c/h3\u003e\n\u003cp\u003eERC-4337에서는 사용자 요청(UserOperation)이 단일 싱글톤 컨트랙트인 EntryPoint를 통해 처리됨. Bundler가 여러 UserOp를 모아 EntryPoint의 \u003ccode\u003ehandleOps\u003c/code\u003e를 호출하는 구조. 병목의 핵심은 서버 과부하라기보다 가스비 오버헤드와 검증 복잡도 증가\u003c/p\u003e","title":"ERC-4337 Account Abstraction의 장단점과 EntryPoint 병목 정리"},{"content":"개념/배경 readonly는 TypeScript 전용 타입 수정자이며 JavaScript 런타임에는 존재하지 않음 컴파일 타임에만 효력이 있으며, 읽기 전용으로 선언된 배열·객체 속성을 수정하려는 코드에 대해 타입 오류를 발생시킴\n핵심 개념 배열 또는 객체 속성의 변경 금지 의도를 타입 수준에서 명시 예를 들어 onChainResult: readonly bigint[]는 블록체인에서 읽어온 결과 배열이 이후 코드 흐름에서 변형되지 않음을 보장하려는 의도 표현 읽기 전용 제약은 타입 체크 시점에만 적용되며, 트랜스파일된 JavaScript에는 제약이 남지 않음\n동작과 제한 읽기 전용 배열은 변경 메서드가 제거된 ReadonlyArray 형태로 다뤄짐 객체의 readonly 속성은 재할당 금지, 단 객체 참조 자체는 다른 값으로 교체 가능할 수 있으므로 설계 시 구분 필요 타입 수준 readonly는 얕은 불변성에 해당하는 경우가 많음. 중첩된 구조까지 불변으로 보장하려면 계층별로 readonly를 적용하거나 별도 불변 모델을 설계해야 함\n사용 예시 // 읽기 전용 배열 const numbers: readonly number[] = [1, 2, 3] numbers.push(4) // Error: Property \u0026#39;push\u0026#39; does not exist on type \u0026#39;readonly number[]\u0026#39; numbers[0] = 0 // Error: Index signature in type \u0026#39;readonly number[]\u0026#39; only permits reading // 읽기 전용 객체 속성 interface User { readonly id: number name: string } const user: User = { id: 1, name: \u0026#34;John\u0026#34; } user.name = \u0026#34;Jane\u0026#34; // OK user.id = 2 // Error: Cannot assign to \u0026#39;id\u0026#39; because it is a read-only property 위 패턴은 데이터 무결성 요구가 있는 도메인에서 의도를 드러내고 실수성 변이를 사전에 차단하는 데 유용함\nJavaScript Object.freeze와의 차이 Object.freeze는 런타임 동작이며 객체를 동결하지만 기본적으로 얕게만 적용됨. 중첩 객체는 별도 처리 필요 TypeScript readonly는 컴파일 타임 제약으로, 런타임 오버헤드를 추가하지 않음 두 방법은 상호 보완적이며, 타입 안전성과 런타임 보호가 동시에 필요하면 병행 고려\nconst arr = Object.freeze([1, 2, 3]) arr.push(4) // Error: Cannot add property 3, object is not extensible 환경이나 모드에 따라 예외 발생 또는 무시 동작이 다를 수 있으므로 런타임 보호에 의존하는 경우 주의\n주의와 베스트프랙티스 외부 시스템에서 유입되는 데이터, 캐시 스냅샷, 계산 결과 등 변형되지 않아야 하는 값은 readonly로 모델링 함수 인자에 readonly 배열을 사용해 호출자와 구현 간 변이 계약을 명확히 표현 const는 변수 재할당 금지, readonly는 구조 내부 변경 금지라는 서로 다른 개념임을 구분 필요 시 중첩 구조에 대한 불변성은 계층적으로 명시하거나 유틸리티 타입과 패턴을 조합해 강화\n마무리 readonly는 변이 금지 의도를 타입으로 명확히 하고, 실수성 수정을 컴파일 단계에서 차단해 코드 품질과 안정성을 높이는 도구임\n참고자료 https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-arrays https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze ","permalink":"https://blog.jsontapose.com/posts/typescript-readonly-usage-immutable-arrays-objects-d79456/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003ereadonly는 TypeScript 전용 타입 수정자이며 JavaScript 런타임에는 존재하지 않음\n컴파일 타임에만 효력이 있으며, 읽기 전용으로 선언된 배열·객체 속성을 수정하려는 코드에 대해 타입 오류를 발생시킴\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003e배열 또는 객체 속성의 변경 금지 의도를 타입 수준에서 명시\n예를 들어 onChainResult: readonly bigint[]는 블록체인에서 읽어온 결과 배열이 이후 코드 흐름에서 변형되지 않음을 보장하려는 의도 표현\n읽기 전용 제약은 타입 체크 시점에만 적용되며, 트랜스파일된 JavaScript에는 제약이 남지 않음\u003c/p\u003e\n\u003ch3 id=\"동작과-제한\"\u003e동작과 제한\u003c/h3\u003e\n\u003cp\u003e읽기 전용 배열은 변경 메서드가 제거된 ReadonlyArray 형태로 다뤄짐\n객체의 readonly 속성은 재할당 금지, 단 객체 참조 자체는 다른 값으로 교체 가능할 수 있으므로 설계 시 구분 필요\n타입 수준 readonly는 얕은 불변성에 해당하는 경우가 많음. 중첩된 구조까지 불변으로 보장하려면 계층별로 readonly를 적용하거나 별도 불변 모델을 설계해야 함\u003c/p\u003e","title":"TypeScript readonly 이해와 사용법, 배열·객체 읽기 전용 타입 지정"},{"content":"개념/배경 CEI 패턴은 Checks-Effects-Interactions의 약자 스마트 컨트랙트 함수에서 실행 순서를 명확히 해 재진입 공격을 줄이는 코드 규칙 핵심은 검증 후 상태 변경을 먼저 완료하고, 외부 호출을 마지막에 수행하는 흐름 유지\n3단계 순서 1. Checks (검증) ↓ 2. Effects (상태 변경) ↓ 3. Interactions (외부 호출)이 순서를 지키면 외부로 제어권이 나가기 전에 내부 상태가 이미 안전하게 반영됨 재진입 시도는 변경된 상태에 의해 자연스럽게 차단됨\n예시로 이해하기 잘못된 순서 위험 function withdraw(uint256 amount) external { // 1. Checks require(balances[msg.sender] \u0026gt;= amount); // 2. Interactions ← 너무 빠름 (bool success, ) = msg.sender.call{value: amount}(\u0026#34;\u0026#34;); require(success); // 3. Effects ← 너무 늦음 balances[msg.sender] -= amount; }문제점\n외부 호출로 제어권이 나간 뒤에야 잔액을 차감 공격자가 receive나 fallback에서 동일 함수를 재호출 가능 공격 흐름\nETH 전송 → 공격자 재진입 → 잔액 아직 차감 안 됨 → 반복 출금올바른 순서 안전 function withdraw(uint256 amount) external { // 1. Checks require(balances[msg.sender] \u0026gt;= amount, \u0026#39;insufficient balance\u0026#39;); // 2. Effects ← 먼저 반영 balances[msg.sender] -= amount; // 3. Interactions ← 나중에 수행 (bool success, ) = msg.sender.call{value: amount}(\u0026#34;\u0026#34;); require(success, \u0026#39;transfer failed\u0026#39;); }효과\n상태를 먼저 변경하므로 재진입 시도 시 조건 검증에서 차단됨 각 단계 설명 1. Checks 검증 조건 확인 단계\n입력값, 권한, 상태 전제조건 검증 상태 읽기만 수행, 변경 없음 불만족 시 즉시 revert // 잔액 확인 require(balances[msg.sender] \u0026gt;= amount); // 권한 확인 require(msg.sender == owner); // 시간 확인 require(block.timestamp \u0026gt;= deadline); // 주소 확인 require(to != address(0));2. Effects 상태 변경 컨트랙트 내부 상태를 변경하는 단계\nstorage 갱신, 소유권 이전, 카운터 증가 등 외부 호출 전에 완료해야 함 재진입 발생 시 이미 변경된 상태에서 시작 balances[msg.sender] -= amount; balances[recipient] += amount; owners[tokenId] = newOwner; status = Status.Completed; totalSupply += 1;3. Interactions 외부 호출 외부 컨트랙트나 주소와 상호작용하는 단계\n제어권이 외부로 넘어가며 재진입 위험 존재 가장 마지막에 배치 // ETH 전송 (bool ok, ) = to.call{value: amount}(\u0026#34;\u0026#34;); require(ok); // 토큰 전송 require(token.transfer(to, amount)); // 외부 컨트랙트 호출 externalContract.someFunction(); // 이벤트는 상태 확정 후 발행 emit Withdrawn(msg.sender, amount); 왜 중요한가 잘못된 순서의 결과\nfunction badWithdraw(uint256 amount) external { require(balances[msg.sender] \u0026gt;= amount); // Interactions 먼저 msg.sender.call{value: amount}(\u0026#34;\u0026#34;); // 재진입 가능 // Effects 나중 balances[msg.sender] -= amount; // 차감이 늦음 }공격 흐름\n1. badWithdraw(100) 호출 2. require 통과, 잔액 100 3. ETH 100 전송 → 공격자 receive 실행 └─ badWithdraw(100) 재호출 └─ 잔액 여전히 100으로 인식 → 또 전송 4. 마지막에야 차감되어 방어 실패올바른 순서의 결과\nfunction goodWithdraw(uint256 amount) external { require(balances[msg.sender] \u0026gt;= amount); // Effects 먼저 balances[msg.sender] -= amount; // Interactions 나중 msg.sender.call{value: amount}(\u0026#34;\u0026#34;); }방어 흐름\n1. goodWithdraw(100) 호출 2. require 통과, 잔액 100 3. 먼저 차감하여 0으로 반영 4. 이후 ETH 전송 중 재진입 시도 └─ require에서 즉시 실패 및 revert 실전 예시 마켓플레이스 구매\nfunction buy(uint256 itemId) external payable { // Checks require(listings[itemId].active, \u0026#39;not for sale\u0026#39;); require(msg.value == listings[itemId].price, \u0026#39;incorrect price\u0026#39;); // Effects address seller = listings[itemId].seller; listings[itemId].active = false; items[itemId].owner = msg.sender; // Interactions (bool ok, ) = seller.call{value: msg.value}(\u0026#34;\u0026#34;); require(ok, \u0026#39;payment failed\u0026#39;); emit Purchased(itemId, msg.sender, msg.value); }NFT 교환\nfunction swap(uint256 tokenIdA, uint256 tokenIdB) external { // Checks require(nft.ownerOf(tokenIdA) == msg.sender, \u0026#39;not owner\u0026#39;); require(nft.ownerOf(tokenIdB) == partner, \u0026#39;partner not owner\u0026#39;); require(approvals[tokenIdA] \u0026amp;\u0026amp; approvals[tokenIdB], \u0026#39;not approved\u0026#39;); // Effects swaps[swapId].completed = true; // Interactions nft.transferFrom(msg.sender, partner, tokenIdA); nft.transferFrom(partner, msg.sender, tokenIdB); emit Swapped(msg.sender, partner, tokenIdA, tokenIdB); } 예외와 주의 require는 어디에 있어도 트랜잭션 전체가 revert되어 상태가 롤백됨\n외부 호출 뒤에 require(success)를 두어도 실패 시 안전하게 되돌림 단, 읽기 전용 체크는 가능한 한 앞단에서 수행 권장 이벤트는 마지막에 발행\n상태가 확정된 후 기록해야 관찰 가능성과 진단 품질이 높아짐 베스트 프랙티스 CEI 패턴은 기본 수칙\nChecks에서 입력과 권한, 컨트랙트 불변식 검증 Effects에서 필요한 상태 변경 모두 반영 Interactions에서만 외부 호출 수행 재진입 보호 장치 추가 권장\nfunction secureFunction() external nonReentrant { // Checks require(conditions); // Effects updateState(); // Interactions externalCall(); }CEI 패턴과 ReentrancyGuard를 함께 사용하면 방어 심도가 올라감\n한 줄 요약 검증 → 상태 변경 → 외부 호출 순서를 지키면 재진입 공격을 구조적으로 차단할 수 있음\n참고자료 https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard https://swcregistry.io/docs/SWC-107 ","permalink":"https://blog.jsontapose.com/posts/cei-pattern-checks-effects-interactions-940c92/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eCEI 패턴은 Checks-Effects-Interactions의 약자\n스마트 컨트랙트 함수에서 실행 순서를 명확히 해 재진입 공격을 줄이는 코드 규칙\n핵심은 검증 후 상태 변경을 먼저 완료하고, 외부 호출을 마지막에 수행하는 흐름 유지\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"3단계-순서\"\u003e3단계 순서\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e1. Checks (검증)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   ↓\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e2. Effects (상태 변경)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   ↓\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e3. Interactions (외부 호출)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e이 순서를 지키면 외부로 제어권이 나가기 전에 내부 상태가 이미 안전하게 반영됨\n재진입 시도는 변경된 상태에 의해 자연스럽게 차단됨\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"예시로-이해하기\"\u003e예시로 이해하기\u003c/h3\u003e\n\u003ch4 id=\"잘못된-순서-위험\"\u003e잘못된 순서 위험\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-solidity\" data-lang=\"solidity\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e \u003cspan style=\"color:#88c0d0\"\u003ewithdraw\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003euint256\u003c/span\u003e amount\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eexternal\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 1. Checks\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#81a1c1\"\u003erequire\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ebalances\u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003emsg\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003esender\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e\u0026gt;=\u003c/span\u003e amount\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 2. Interactions ← 너무 빠름\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003ebool\u003c/span\u003e success\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003emsg\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003esender\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003ecall\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003evalue\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e amount\u003cspan style=\"color:#eceff4\"\u003e}(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#81a1c1\"\u003erequire\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003esuccess\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 3. Effects ← 너무 늦음\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e    balances\u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003emsg\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003esender\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e-=\u003c/span\u003e amount\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e문제점\u003c/p\u003e","title":"CEI 패턴 Checks-Effects-Interactions로 재진입 방어"},{"content":"개요 API 에러 응답을 일관된 JSON 포맷으로 통일하고, 비즈니스 예외와 프레임워크 예외를 한 경로로 수집하는 전역 예외 필터 설계와 구현 정리 핵심은 표준 에러 코드 정의, AppError 기반의 명시적 예외 던지기, GlobalExceptionFilter에서의 단일 포맷 출력, ValidationPipe 결과의 구조화, traceId 기반 상관관계 추적\n요청 흐름 개요\n요청 진입 → ValidationPipe 검증 검증 실패 → 전역 필터에서 표준 응답 변환 검증 통과 → Controller/Service 실행 비즈니스 로직 예외 → AppError 서브클래스 throw → 전역 필터 처리 알 수 없는 예외 → 500으로 표준 응답 변환 최종 응답 포맷은 단일 구조 유지\n{ error: { code, message, details, traceId } } 형태 핵심 개념 에러 코드 중심 관리\nErrorCode Enum으로 전역 에러 코드 집합 관리 문자열 하드코딩 제거 및 프런트엔드와의 계약 명확화 AppError 기반 계층\nHttpException 확장 베이스 클래스 AppError 정의 공통 필드 code, message, details 보유 상황별 편의 서브클래스 제공, 예를 들어 ValidationException, AuthRequiredException, PermissionDeniedException, ConflictException 등 표준 응답 스키마\nErrorResponse 인터페이스를 통해 응답 형태 고정 필수 code, message, traceId와 선택 details로 확장 여지 확보 전역 예외 필터\nAppError, NestJS HttpException, 그 외 unknown 예외를 분기 처리 ValidationPipe 에러 메시지 배열은 VALIDATION_FAILED로 승격하고 details에 원문 유지 404와 같은 공통 예외는 별도 코드 정책에 따라 매핑, 필요 시 NOT_FOUND 코드 도입 고려 traceId를 매 요청 예외 응답에 포함해 서버 로그와 클라이언트 에러 상관관계 추적 관찰 가능성과 보안\nNODE_ENV가 production인 경우 스택 등 민감한 details 노출 금지 5xx는 error 로그, 4xx는 warn 로그 수준으로 구분 기록 동작 원리 1 요청이 애플리케이션에 진입하면 우선 전역 ValidationPipe에서 DTO 기반 입력 검증 수행 2 검증 실패 시 HttpException 형태로 올라오며, 전역 예외 필터에서 ValidationPipe 응답 구조를 해석해 code를 VALIDATION_FAILED로 변경, 메시지 정제, details에는 원인 리스트 보존 3 비즈니스 로직에서 AppError 혹은 서브클래스를 명시적으로 throw하면 전역 예외 필터가 해당 code, message, details를 그대로 사용해 응답 구성 4 프레임워크 기본 HttpException이나 기타 라이브러리에서 발생한 예외는 status를 유지하되 code를 정책에 따라 INVALID_INPUT 또는 기타 코드로 매핑, 알 수 없는 예외는 UNKNOWN_ERROR로 통일 5 모든 경우에 traceId를 생성해 응답과 로그에 포함, 서버 측 Logger로 상황별 로그 수준에 맞춰 기록 6 Express 어댑터 기준으로 Response 객체에 status와 JSON 바디를 설정해 반환\n최소 스니펫 에러 코드 정의 예시\nexport enum ErrorCode { UNKNOWN_ERROR = \u0026#39;UNKNOWN_ERROR\u0026#39;, INVALID_INPUT = \u0026#39;INVALID_INPUT\u0026#39;, VALIDATION_FAILED = \u0026#39;VALIDATION_FAILED\u0026#39;, UNAUTHORIZED = \u0026#39;UNAUTHORIZED\u0026#39;, FORBIDDEN = \u0026#39;FORBIDDEN\u0026#39;, USER_ALREADY_EXISTS = \u0026#39;USER_ALREADY_EXISTS\u0026#39;, }AppError 베이스 클래스를 통한 일관 인터페이스\nexport class AppError extends HttpException { constructor( public readonly code: ErrorCode, message: string, status: HttpStatus = HttpStatus.BAD_REQUEST, public readonly details?: unknown, ) { super(message, status) } }전역 예외 필터 핵심 분기 골자\n@Catch() export class GlobalExceptionFilter implements ExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { const res = host.switchToHttp().getResponse\u0026lt;Response\u0026gt;() const req = host.switchToHttp().getRequest\u0026lt;Request\u0026gt;() const traceId = uuidv4() if (exception instanceof AppError) { // AppError 그대로 변환 } else if (exception instanceof HttpException) { // ValidationPipe와 404 등 매핑 } else { // UNKNOWN_ERROR로 500 처리, 스택 비노출 } // res.status(status).json({ error: { ... , traceId } }) } }애플리케이션 등록 포인트\napp.useGlobalPipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true, transform: true })) app.useGlobalFilters(new GlobalExceptionFilter())서비스 계층에서 명시적 예외 던지기\nif (exists) throw new ConflictException(ErrorCode.USER_ALREADY_EXISTS, \u0026#39;이미 가입된 이메일\u0026#39;, { email })클라이언트가 받는 표준 응답 예시\n{ \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: \u0026#34;USER_ALREADY_EXISTS\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;이미 가입된 이메일\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;test@example.com\u0026#34; }, \u0026#34;traceId\u0026#34;: \u0026#34;a1b2c3d4-e5f6-7890-abcd-ef1234567890\u0026#34; } }주의 사항과 베스트 프랙티스 Express와 Fastify의 HTTP 어댑터 차이 고려 필요, Response 타입과 응답 전송 방식이 다름 ValidationPipe 메시지는 다국어화나 사용자 노출 정책에 맞춰 재가공 추천, 내부 필드명 노출 최소화 404, 401, 403 등 공통 케이스는 별도 ErrorCode를 정의해 가독성과 검색성을 높이기 권장, NOT_FOUND 추가 고려 AppError의 details는 디버깅과 클라이언트 UX에 꼭 필요한 최소 정보만 포함, 민감정보 금지 프로덕션에서 스택 등 내부 구현 노출 방지, traceId로 서버 로그와 상관관계 확보 로깅 레벨 정책 일관 유지, 5xx는 error, 4xx는 warn, 필수 컨텍스트만 포함 API 문서와 동기화, 각 ErrorCode의 의미와 대응 HTTP 상태 코드 표기 기존 라이브러리나 ORM 에러를 AppError로 래핑해 상위 계층에 전파, 예외 전파 경로 단순화 분산 환경에서는 traceId를 요청 헤더로 전달받아 재사용하거나 미존재 시 생성, 서비스 간 연쇄 호출에도 동일 값 전파 간단 예시 흐름 1 클라이언트가 회원가입 요청을 전송 2 DTO 검증 실패 시 ValidationPipe가 400 HttpException 발생, 전역 필터가 VALIDATION_FAILED 코드와 메시지로 표준 응답 변환, details에는 필드별 에러 배열 유지 3 이메일 중복 시 서비스에서 ConflictException(AppError) throw, 전역 필터는 code와 details를 변경 없이 응답에 반영 4 알 수 없는 런타임 에러 발생 시 500 UNKNOWN_ERROR로 변환, 프로덕션에서는 스택 비노출, traceId로 서버 로그 상관관계 확보\n마무리 에러 코드를 단일 Enum으로 집계해 팀 간 커뮤니케이션 비용 절감 AppError를 통해 비즈니스 의도를 가진 예외만 상위로 전파, 예외 처리 비용 감소 GlobalExceptionFilter로 모든 예외의 출력 포맷을 통일, 클라이언트 처리 로직 단순화 traceId로 관찰 가능성 확보, 운영 단계 디버깅 효율 개선 ValidationPipe와 프레임워크 기본 예외도 동일 포맷으로 정규화, API 일관성 유지 NestJS 구조화된 에러 핸들링의 목적은 예외의 의미를 잃지 않으면서도 응답은 표준화하는 것, 위 구조를 기반으로 서비스 상황에 맞는 코드 집합과 로깅 정책만 보강하면 확장 가능\n참고자료 https://docs.nestjs.com/exception-filters https://docs.nestjs.com/exception-filters#binding-filters https://docs.nestjs.com/techniques/validation https://www.npmjs.com/package/uuid ","permalink":"https://blog.jsontapose.com/posts/nestjs-global-exception-filter-standard-error-response-81191e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAPI 에러 응답을 일관된 JSON 포맷으로 통일하고, 비즈니스 예외와 프레임워크 예외를 한 경로로 수집하는 전역 예외 필터 설계와 구현 정리\n핵심은 표준 에러 코드 정의, AppError 기반의 명시적 예외 던지기, GlobalExceptionFilter에서의 단일 포맷 출력, ValidationPipe 결과의 구조화, traceId 기반 상관관계 추적\u003c/p\u003e\n\u003cp\u003e요청 흐름 개요\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e요청 진입 → ValidationPipe 검증\u003c/li\u003e\n\u003cli\u003e검증 실패 → 전역 필터에서 표준 응답 변환\u003c/li\u003e\n\u003cli\u003e검증 통과 → Controller/Service 실행\u003c/li\u003e\n\u003cli\u003e비즈니스 로직 예외 → AppError 서브클래스 throw → 전역 필터 처리\u003c/li\u003e\n\u003cli\u003e알 수 없는 예외 → 500으로 표준 응답 변환\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e최종 응답 포맷은 단일 구조 유지\u003c/p\u003e","title":"NestJS 전역 예외 필터와 표준 오류 응답 설계 가이드"},{"content":"개요 리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함 상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음 대표적 피해 사례로 The DAO 사건이 알려져 있음\n실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임 두 방법을 함께 쓰는 것이 표준에 가까움\n유명한 사례와 최소 취약 패턴 취약한 순서 패턴 핵심\n외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생 이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능 최소 취약 스니펫 예시\nfunction withdraw(uint256 amount) external { require(balances[msg.sender] \u0026gt;= amount, \u0026#34;insufficient\u0026#34;); (bool ok, ) = msg.sender.call{value: amount}(\u0026#34;\u0026#34;); // 외부 호출 선행 require(ok, \u0026#34;transfer failed\u0026#34;); balances[msg.sender] -= amount; // 상태 변경이 뒤늦게 발생 }공격자는 수신 훅에서 재호출하여 동일 검증을 반복 통과함\nreceive() external payable { target.withdraw(1 ether); // 재진입 시도 }결과적으로 예치액 대비 과도한 출금이 가능해짐 Solidity 0.8+ 에서는 언더플로우 자체는 revert되나 핵심 피해는 차감 전 다중 송금이 이미 발생한 지점에 있음\n공격 흐름 요약 1차 호출에서 require 통과 후 외부 전송 발생 수신 훅 receive 또는 fallback에서 동일 함수 또는 다른 취약 함수 재호출 상태 차감 전이라 동일 검증 재통과 반복 전송 발생 후 마지막에 상태 차감 또는 revert 최종적으로 컨트랙트 자금 고갈 또는 비정상 상태 유발 The DAO 2016 사례에서 대규모 자금 유출과 체인 하드포크까지 이어짐\n방어 전략 방법 1 CEI 패턴 우선 상태 변경을 먼저 반영하고 외부 상호작용은 나중에 실행하는 패턴\nfunction withdraw(uint256 amount) external { require(balances[msg.sender] \u0026gt;= amount, \u0026#34;insufficient\u0026#34;); // Checks balances[msg.sender] -= amount; // Effects (bool ok, ) = msg.sender.call{value: amount}(\u0026#34;\u0026#34;); // Interactions require(ok, \u0026#34;transfer failed\u0026#34;); }공격자가 재진입을 시도해도 이미 잔액이 차감되어 require 단계에서 즉시 차단됨\n방법 2 ReentrancyGuard로 추가 안전벨트 OpenZeppelin ReentrancyGuard의 nonReentrant로 진입 중 재진입을 전역 플래그로 차단\nimport \u0026#34;@openzeppelin/contracts/utils/ReentrancyGuard.sol\u0026#34;; contract C is ReentrancyGuard { function withdraw(uint256 amount) external nonReentrant { // CEI와 함께 사용할 것을 권장 } }nonReentrant는 함수 진입 시 상태를 ENTERED로 설정하고 종료 시 복구하는 간단한 락을 제공 재진입 시 즉시 revert 발생\n방법 3 CEI + ReentrancyGuard 병행 CEI 패턴으로 논리적 안전성 확보 ReentrancyGuard로 실수와 교차 함수 재진입을 방어 코드 리뷰와 리팩터링 과정에서 순서가 어긋나는 사고를 줄이는 효과 ReentrancyGuard 동작 원리 내부 구조 요약 핵심은 단일 상태 변수로 진입 상태를 토글하는 락 패턴\nuint256 private _status; uint256 private constant _NOT_ENTERED = 1; uint256 private constant _ENTERED = 2; modifier nonReentrant() { require(_status != _ENTERED, \u0026#34;reentrant call\u0026#34;); _status = _ENTERED; // 락 _; // 본문 실행 _status = _NOT_ENTERED; // 언락 }왜 0 대신 1과 2를 사용하나 가스 관점 SSTORE는 0에서 비영 값으로 변경 시 비용이 크게 발생하는 반면 비영 값에서 비영 값 변경은 상대적으로 저렴함\n0 → 비영 값 전환 비용이 높음 비영 값 ↔ 비영 값 전환은 저렴 따라서 초기값을 1로 두고 1과 2 사이에서 토글하여 저장 비용을 줄이는 설계가 일반적임 네트워크 업그레이드에 따라 세부 비용 모델은 변동될 수 있으나 방향성은 동일함 실무 주의사항 교차 함수 재진입 가능성 인지 같은 함수만 위험한 것이 아님 다른 외부 함수가 동일한 공유 상태에 접근하면 재진입 벡터가 열림 두 함수 모두 nonReentrant 적용 또는 공유 상태 접근 순서를 CEI로 정렬 필요\nnonReentrant 함수 간 내부 호출 금지 제약 nonReentrant가 적용된 함수에서 또 다른 nonReentrant 함수를 직접 호출하면 즉시 revert 발생 해결 패턴\nfunction a() external nonReentrant { _b(); // internal로 분리하여 호출 } function _b() internal { // 실제 로직 분리 }외부 진입점만 nonReentrant를 두고 내부 로직은 internal로 분리하는 계층화 권장\nERC20 대비 ERC721의 상대적 위험도 차이 ERC20 전송 transfer 및 transferFrom은 표준 구현에서 외부 콜백이 없는 경우가 일반적이라 상대적으로 안전 ERC721 safeTransferFrom은 수신자가 컨트랙트이면 onERC721Received 훅을 호출하므로 재진입 표면이 존재 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);NFT 마켓플레이스, 경매, 커스터디 로직 등에서는 nonReentrant 적용을 기본값으로 두는 편이 안전 커스텀 ERC20 구현에서 훅이나 외부 콜을 숨겨두는 경우도 있으므로 신뢰할 수 없는 토큰에 대해서는 보수적으로 대응 필요\n언제 nonReentrant가 필요한가 꼭 필요한 경우 ETH 전송 또는 낮은 수준 호출을 포함하는 함수 safeTransferFrom 기반의 NFT 전송 로직 신뢰할 수 없는 외부 컨트랙트 호출 포함 공유 상태를 변경한 뒤 외부 상호작용이 이어지는 복합 트랜잭션 경로 조건부 적용 표준적 ERC20 전송만 포함된 경로 토큰 구현이 안전하고 외부 훅이 없음을 확신할 때는 생략 가능하나 방어적 적용을 고려 불필요한 경우 view 또는 pure 함수 외부 호출이 전혀 없는 단순 상태 변경 함수 private 또는 internal 전용 헬퍼 함수 자체에는 불필요하나 외부 진입점에서 보호해야 함 가스와 설계 트레이드오프 CEI는 설계 원칙이며 추가 가스 비용 없이 얻는 이점이 큼 ReentrancyGuard는 SLOAD SSTORE가 추가되어 소폭의 가스 비용 증가가 있으나 보안 이득이 훨씬 큼 1과 2를 사용하는 토글 방식으로 SSTORE 비용을 낮추는 최적화 적용 필요 함수에만 nonReentrant를 제한적으로 부여해 가스와 복잡도 균형 유지 테스트와 검증 포인트 재진입 시나리오를 흉내내는 테스트 컨트랙트로 receive fallback을 활용한 재호출 여부 검증 상태 변경 전 외부 호출이 없는지 정적 분석 및 리뷰 수행 다중 함수 경로 교차 검증 동일한 저장소에 접근하는 외부 함수 조합에서 재진입 가능성 체크 업그레이어블 패턴 사용 시 초기화 순서와 가드 상태 변수 초기값 검증 핵심 정리 1순위 CEI 패턴 적용 상태를 먼저 바꾸고 외부 상호작용은 나중에 배치 2순위 ReentrancyGuard로 재진입 락 추가 실수 방지와 교차 함수 재진입 차단 nonReentrant 함수 간 직접 호출 금지 외부 진입점만 보호하고 내부로 로직 분리 ERC721은 훅 존재로 위험도 높음 기본적으로 nonReentrant 적용 권장 가스 최적화는 1과 2 토글 사용 및 필요한 경로에만 가드 적용으로 균형 추구 한 줄 요약 코드 순서는 CEI로 지키고 재진입 락은 ReentrancyGuard로 걸어 이중 방어 구축\n참고자료 https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy https://eips.ethereum.org/EIPS/eip-721 https://eips.ethereum.org/EIPS/eip-2200 https://consensys.net/blog/developers/what-is-a-reentrancy-attack/ ","permalink":"https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함\n상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음\n대표적 피해 사례로 The DAO 사건이 알려져 있음\u003c/p\u003e\n\u003cp\u003e실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임\n두 방법을 함께 쓰는 것이 표준에 가까움\u003c/p\u003e\n\u003ch3 id=\"유명한-사례와-최소-취약-패턴\"\u003e유명한 사례와 최소 취약 패턴\u003c/h3\u003e\n\u003cp\u003e취약한 순서 패턴 핵심\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생\u003c/li\u003e\n\u003cli\u003e이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e최소 취약 스니펫 예시\u003c/p\u003e","title":"스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard"},{"content":"개요 ERC-721에서 전송 권한 위임을 처리하는 두 가지 승인 방식 정리 권한 범위와 사용 시나리오가 달라 오용 시 과권한 위험 발생 가능 핵심 동작과 권한 확인 패턴 중심으로 정리\n핵심 개념 approve(address to, uint256 tokenId)\n특정 NFT 1개에 대한 전송 권한만 부여 예 123번 토큰만 지정한 대상이 전송 가능 토큰별 개별 승인 필요 setApprovalForAll(address operator, bool approved)\n소유한 모든 NFT에 대한 전송 권한 일괄 부여 한 번 승인 시 현재 보유분 + 이후 수령분까지 포함 관리 편의성 높지만 권한 범위 큼 권한 확인 패턴 컨트랙트에서 호출 주체가 대상 토큰에 대해 승인 받았는지 확인 필요 두 방식 모두 대응하는 조건을 만족해야 안전\nrequire( nftContract.getApproved(tokenId) == address(this) || nftContract.isApprovedForAll(owner, address(this)), ERROR_NOT_APPROVED );사용 시나리오 1:1 교환 무료 시나리오\napprove 권장 교환 대상 토큰만 제한적으로 승인 안전성 우선이나 매번 승인 필요 setApprovalForAll 사용 시 한 번만 승인 후 재사용 가능 편의성 높으나 과권한 주의 N:M 교환 유료 시나리오\nsetApprovalForAll 권장 다수 토큰을 한 번에 처리하기 용이 수수료와 UX 측면 유리 주의 사항 setApprovalForAll은 광범위 권한 부여 피싱 컨트랙트나 오용 위험 존재 불필요해지면 승인 철회 권장 approved false로 재호출 또는 개별 approve 초기화 권한 확인 로직에서 두 조건을 모두 커버하지 않으면 특정 케이스 전송 실패 가능 참고자료 https://eips.ethereum.org/EIPS/eip-721 https://docs.openzeppelin.com/contracts/5.x/api/token/erc721 ","permalink":"https://blog.jsontapose.com/posts/erc-721-approve-vs-setapprovalforall-50a1bb/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eERC-721에서 전송 권한 위임을 처리하는 두 가지 승인 방식 정리\n권한 범위와 사용 시나리오가 달라 오용 시 과권한 위험 발생 가능\n핵심 동작과 권한 확인 패턴 중심으로 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003eapprove(address to, uint256 tokenId)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e특정 NFT 1개에 대한 전송 권한만 부여\u003c/li\u003e\n\u003cli\u003e예 123번 토큰만 지정한 대상이 전송 가능\u003c/li\u003e\n\u003cli\u003e토큰별 개별 승인 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003esetApprovalForAll(address operator, bool approved)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e소유한 모든 NFT에 대한 전송 권한 일괄 부여\u003c/li\u003e\n\u003cli\u003e한 번 승인 시 현재 보유분 + 이후 수령분까지 포함\u003c/li\u003e\n\u003cli\u003e관리 편의성 높지만 권한 범위 큼\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"권한-확인-패턴\"\u003e권한 확인 패턴\u003c/h3\u003e\n\u003cp\u003e컨트랙트에서 호출 주체가 대상 토큰에 대해 승인 받았는지 확인 필요\n두 방식 모두 대응하는 조건을 만족해야 안전\u003c/p\u003e","title":"ERC-721 승인 패턴 정리 approve vs setApprovalForAll 사용법과 권한 확인"},{"content":"개요 신규 API 개발 또는 로직 변경 시 서비스의 안정성과 성능을 사전에 검증하기 위한 표준 테스트 프로세스 정의 목적 코드 수준의 비효율 제거와 인프라 병목 식별을 분리해 진행하며, 동일 스택으로 로컬과 서버 환경을 일관되게 관찰하는 것을 권장\n테스트 전략 개요 성능 테스트는 환경과 목적에 따라 두 단계로 구분\nPhase 1 Local 목표 코드 레벨 최적화와 비효율 제거 관점 CPU 스파이크, 메모리 누수, 이벤트 루프 지연, 불필요한 I O 대기 도구 k6 로컬, Clinic.js Phase 2 Dev 서버 목표 시스템 레벨 검증과 병목 지점 확인 관점 DB Redis MQ 한계, 연결 풀 고갈, 큐 적체, 에러율 도구 k6 원격, Prometheus Grafana 도구 구성 부하 생성 k6 JS 기반 스크립팅으로 학습 비용 낮음 CI CD 파이프라인 연동 용이 로컬과 서버 환경 모두에서 실행 가능 모니터링 Grafana Prometheus 인프라 통합 관제에 적합 Redis DB MQ WAS 지표를 일관된 대시보드로 관찰 테스트 중 실시간 병목 구간 가시화 프로파일링 Clinic.js Node.js 내부 지표 심층 분석에 특화 CPU 스파이크, 메모리 누수, 이벤트 루프 지연 원인 파악에 유용 로컬 디버깅 우선 권장 단계별 진행 Step 1 로컬 프로파일링 Local Profiling 질문 내 코드에 논리적 비효율이 없는가 배포 전 로컬에서 가벼운 부하를 주고 코드 결함을 조기에 식별\n1 준비 로컬에서 서버 실행 준비 2 실행 Clinic.js로 서버를 감싸고 트래픽 주입\nclinic doctor --on-port \u0026#39;k6 run scripts/test-local.js\u0026#39; -- node dist/main.js3 분석 생성된 HTML 리포트 확인\nEvent Loop Delay 경고 구간 존재 여부, 비동기 처리 정체 지점 확인 Memory 힙 메모리 미해제 패턴과 상승 추세 확인, 누수 의심 시 재현 절차 고정 I O 불필요한 대기와 동기 호출 여부 확인 Step 2 서버 부하 테스트 Server Load Test 질문 실제 인프라가 목표 트래픽을 견디는가 Redis DB 등 포함 개발 Dev 환경 배포 후 인프라 상호작용을 검증 대규모 부하는 로컬 대신 별도 인스턴스에서 k6 실행 권장\n1 시나리오 작성 k6 스크립트\nSmoke Test VU 1 10 수준으로 기능 정상 동작 확인 Load Test 목표 트래픽 예 1000 RPS 까지 점진 증가 Stress Test 한계점 도달까지 부하 증가, 브레이킹 포인트 파악 2 모니터링 Grafana 대시보드 테스트 중 다음 지표를 한 화면에서 동시 관찰\nWAS 예 NestJS CPU 사용률, 메모리 사용량 Redis 초당 명령 수 Ops sec, CPU 사용률 DB RDBMS 활성 커넥션, 슬로우 쿼리 Job Queue 대기열 적체 여부 Waiting Count 테스트 체크리스트 배포 전 아래 항목 자가 점검 권장\n코드 품질 Local Clinic.js 리포트에 이벤트 루프 지연 Red Zone 없음 불필요한 동기 연산 제거 반복문 내부 DB Redis 호출로 N 1 패턴 발생하지 않음 시스템 안정성 Server 목표 RPS에서 CPU 메모리 임계 내 안정 유지 Redis DB 커넥션 풀 고갈 없음 비동기 처리의 경우 큐 적재 속도보다 처리 속도 우위 에러율 Error Rate 1 퍼센트 미만 부하 테스트 시 주의사항 1 로컬 PC 한계\n수천 RPS 이상은 로컬 네트워크와 장비 성능으로 정확도 저하 가능 별도 서버 인스턴스 예 클라우드에서 k6 실행 권장 2 네트워크 비용\n클라우드에서 외부로 대량 트래픽 송출 시 아웃바운드 비용 발생 가능 동일 VPC 내부 또는 사설 IP를 활용해 비용과 지연 최소화 권장 마무리 로컬 프로파일링으로 코드 비효율을 먼저 제거하고 서버 부하 테스트로 인프라 한계를 명확히 측정하는 이중 단계 접근을 기본으로 삼을 것 k6와 Prometheus Grafana, Clinic.js 조합으로 재현과 관측 가능성을 높이고, 체크리스트 기반으로 배포 리스크를 정량화하는 흐름 유지\n참고자료 https://k6.io/docs/ https://prometheus.io/docs/introduction/overview/ https://grafana.com/docs/ https://clinicjs.org/ https://aws.amazon.com/ec2/pricing/on-demand/ ","permalink":"https://blog.jsontapose.com/posts/api-performance-testing-and-monitoring-guide-2b9e24/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e신규 API 개발 또는 로직 변경 시 서비스의 안정성과 성능을 사전에 검증하기 위한 표준 테스트 프로세스 정의 목적\n코드 수준의 비효율 제거와 인프라 병목 식별을 분리해 진행하며, 동일 스택으로 로컬과 서버 환경을 일관되게 관찰하는 것을 권장\u003c/p\u003e\n\u003ch3 id=\"테스트-전략-개요\"\u003e테스트 전략 개요\u003c/h3\u003e\n\u003cp\u003e성능 테스트는 환경과 목적에 따라 두 단계로 구분\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePhase 1 Local\n\u003cul\u003e\n\u003cli\u003e목표  코드 레벨 최적화와 비효율 제거\u003c/li\u003e\n\u003cli\u003e관점  CPU 스파이크, 메모리 누수, 이벤트 루프 지연, 불필요한 I O 대기\u003c/li\u003e\n\u003cli\u003e도구  k6 로컬, Clinic.js\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePhase 2 Dev 서버\n\u003cul\u003e\n\u003cli\u003e목표  시스템 레벨 검증과 병목 지점 확인\u003c/li\u003e\n\u003cli\u003e관점  DB Redis MQ 한계, 연결 풀 고갈, 큐 적체, 에러율\u003c/li\u003e\n\u003cli\u003e도구  k6 원격, Prometheus Grafana\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"도구-구성\"\u003e도구 구성\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e부하 생성  k6\n\u003cul\u003e\n\u003cli\u003eJS 기반 스크립팅으로 학습 비용 낮음\u003c/li\u003e\n\u003cli\u003eCI CD 파이프라인 연동 용이\u003c/li\u003e\n\u003cli\u003e로컬과 서버 환경 모두에서 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e모니터링  Grafana Prometheus\n\u003cul\u003e\n\u003cli\u003e인프라 통합 관제에 적합 Redis DB MQ WAS 지표를 일관된 대시보드로 관찰\u003c/li\u003e\n\u003cli\u003e테스트 중 실시간 병목 구간 가시화\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e프로파일링  Clinic.js\n\u003cul\u003e\n\u003cli\u003eNode.js 내부 지표 심층 분석에 특화\u003c/li\u003e\n\u003cli\u003eCPU 스파이크, 메모리 누수, 이벤트 루프 지연 원인 파악에 유용\u003c/li\u003e\n\u003cli\u003e로컬 디버깅 우선 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"단계별-진행\"\u003e단계별 진행\u003c/h3\u003e\n\u003ch4 id=\"step-1-로컬-프로파일링-local-profiling\"\u003eStep 1 로컬 프로파일링 Local Profiling\u003c/h4\u003e\n\u003cp\u003e질문  내 코드에 논리적 비효율이 없는가\n배포 전 로컬에서 가벼운 부하를 주고 코드 결함을 조기에 식별\u003c/p\u003e","title":"API 성능 테스트와 모니터링 표준 가이드"},{"content":"개요 Atomic Swap 스마트 컨트랙트는 블록체인에서 두 당사자의 자산을 맞교환할 때 모든 동작이 한 번에 완료되거나 전혀 일어나지 않음을 보장하는 메커니즘을 제공함 사용자 간 신뢰 없이도 안전하게 교환할 수 있게 만드는 자동화 에스크로 역할의 코드임\n핵심 개념: 원자성 원자성은 트랜잭션이 더 쪼갤 수 없는 단위로 실행됨을 의미함\n성공 시: A가 B에게 자산 X를 이전 AND B가 A에게 자산 Y를 이전, 두 동작이 한 묶음으로 처리됨 실패 시: 아무 변경 없음, 각자 자산 유지 중간 상태가 발생하지 않도록 보장하는 것이 핵심임 왜 필요한가 서로 신뢰가 없을 때 누가 먼저 보낼지에 대한 교착 상태 발생함\nA: 네가 먼저 보내라는 요구 B: 상대가 미전송 시 손실 우려 기존에는 중개자 에스크로가 필요했으나, 블록체인에서는 스마트 컨트랙트가 조건부 실행과 롤백으로 동일한 안전성을 제공함 동작 원리 일반적인 교환 흐름 정리\n매칭 성사: 백엔드 매칭 엔진 등에서 User A(NFT X)와 User B(NFT Y) 교환 의사 확인 승인 부여: 각 유저가 컨트랙트에 자산 이동 권한 승인 수행, 예시 setApprovalForAll 또는 approve 호출 실행 트리거: 백엔드 또는 사용자가 컨트랙트의 swap(UserA, NftX, UserB, NftY) 호출 원자적 처리 컨트랙트가 소유권과 승인 상태를 검증함 조건 충족 시 같은 트랜잭션 내에서 양방향 이전 수행 하나라도 불일치 시 전체 Revert 발생, 상태 변경 없음, 가스 비용만 소모됨 이 과정 전체가 단일 트랜잭션으로 묶여 있어 중간 상태가 존재하지 않음 기술적 포인트: Simple Swap vs HTLC Simple Swap, 동일 체인 같은 체인 내에서는 컨트랙트 함수에서 transferFrom(A→B, token1)과 transferFrom(B→A, token2)를 연속 수행하면 EVM 트랜잭션 원자성에 의해 자동으로 원자적 교환 달성 중간 전송 실패 시 전체 트랜잭션 Revert로 이전된 자산도 원복됨 전제 조건: 충분한 승인, 소유권 유효성, 재진입 취약점 방지 등 기본 보안 수칙 준수 HTLC, 타 체인 간 서로 다른 체인은 장부가 분리되어 단일 트랜잭션 원자성 적용 불가 Hash Time Locked Contract 사용 해시 값으로 잠금 설정, 사전 이미지 공개 시 수령 가능 타임락 만료 시 자산 반환 경로 확보 체인 간 동기화와 페널티 설계가 핵심이며, 실패 시 자산 회수 가능해야 함 적용 효과 사기 리스크 제거에 따른 CS 비용 감소 별도 중개자 없이 코드 기반 에스크로로 수수료 및 운영비 절감 신뢰 요구 없는 즉시 교환 UX 제공 간단 예시 상황 정리 A와 B가 각자 보유한 NFT를 교환하려는 경우 두 사용자가 컨트랙트에 승인 부여 완료 상태 swap 호출 시 소유권과 승인 검증 후 동시 이전 수행 한쪽이 교환 직전 NFT를 이동했다면 조건 불충족으로 Revert 발생, 자산 상태 원상 유지 한 줄 요약 서로 신뢰가 없어도 코드가 조건을 검증하고 하나의 트랜잭션에서 양방향 이전을 처리해 중간 상태 없이 맞교환을 보장하는 기술임\n참고자료 ERC 표준의 승인과 전송 semantics 참고 권장 참고자료 https://eips.ethereum.org/EIPS/eip-721 https://eips.ethereum.org/EIPS/eip-20 https://ethereum.org/en/developers/docs/transactions/ https://bitcoinops.org/en/topics/htlc/ https://en.bitcoin.it/wiki/Hashed_Timelock_Contracts ","permalink":"https://blog.jsontapose.com/posts/atomic-swap-smart-contract-3c92dc/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAtomic Swap 스마트 컨트랙트는 블록체인에서 두 당사자의 자산을 맞교환할 때 모든 동작이 한 번에 완료되거나 전혀 일어나지 않음을 보장하는 메커니즘을 제공함\n사용자 간 신뢰 없이도 안전하게 교환할 수 있게 만드는 자동화 에스크로 역할의 코드임\u003c/p\u003e\n\u003ch3 id=\"핵심-개념-원자성\"\u003e핵심 개념: 원자성\u003c/h3\u003e\n\u003cp\u003e원자성은 트랜잭션이 더 쪼갤 수 없는 단위로 실행됨을 의미함\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성공 시: A가 B에게 자산 X를 이전 AND B가 A에게 자산 Y를 이전, 두 동작이 한 묶음으로 처리됨\u003c/li\u003e\n\u003cli\u003e실패 시: 아무 변경 없음, 각자 자산 유지\n중간 상태가 발생하지 않도록 보장하는 것이 핵심임\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"왜-필요한가\"\u003e왜 필요한가\u003c/h3\u003e\n\u003cp\u003e서로 신뢰가 없을 때 누가 먼저 보낼지에 대한 교착 상태 발생함\u003c/p\u003e","title":"Atomic Swap 스마트 컨트랙트 개념과 설계 포인트"},{"content":"개요 NestJS에서 @Module은 기능 단위 의존성을 묶는 단위이자 DI 경계를 정의하는 컨테이너 개념임 핵심은 imports로 외부 의존성 수입, providers로 내부 의존성 등록, exports로 외부 공개 대상을 결정하는 흐름 이해가 전부임\nModule의 imports, providers, exports @Module 선언의 기본 형태\n@Module({ imports: [...], providers: [...], exports: [...] }) class SomeModule {} providers 이 모듈에서 새로 생성해 DI 컨테이너에 등록할 대상 목록 @Injectable 클래스들 중심 Service, Repository, Adapter 등 예시 providers: [BatchService, PortFetcher, StoreService, MergeService] imports 다른 모듈이 exports로 공개한 provider를 이 모듈에서 사용하겠다는 선언 예시 imports: [RepositoryModule, HttpModule, LoggerModule] exports 이 모듈 바깥에서도 사용 가능하도록 내보낼 provider 목록 예시 exports: [JSON_REPOSITORY, LogRepository]정리하면 providers는 내부 생성, imports는 외부 수입, exports는 외부 공개 대상 지정임\nScheduleModule.forRoot와 forRoot 패턴 ScheduleModule은 크론과 인터벌 같은 스케줄링 기능을 제공하는 외부 모듈임\nforRoot는 전역 설정을 포함한 DynamicModule을 반환하는 정적 메서드 패턴 앱 부트스트랩 시 한 번 호출해 필요한 레지스트리와 provider를 구성하는 용도 유사 패턴 예시 TypeOrmModule.forRoot, ConfigModule.forRoot 등 의미상 forRoot는 앱 레벨에서 한 번 설정하고 재사용하는 초기화 진입점 역할임\nSymbol 토큰으로 DI 안정화 Nest DI는 토큰 기반 주입 동작 기본은 클래스가 토큰이지만 클래스가 아닌 값 또는 여러 구현을 구분해야 할 때 커스텀 토큰 필요\nexport const JSON_REPOSITORY = Symbol(\u0026#39;JSON_REPOSITORY\u0026#39;) Symbol은 전역에서 유일한 값이라 이름 충돌 회피에 유리 provider 등록 시 커스텀 토큰과 매핑 { provide: JSON_REPOSITORY, useFactory: () =\u0026gt; /* 인스턴스 반환 */ } 주입 시 @Inject(JSON_REPOSITORY)로 명시적 의존성 선택 가능 constructor(@Inject(JSON_REPOSITORY) private readonly repo: JsonRepository\u0026lt;any\u0026gt;) {}클래스명으로는 구분이 어려운 경우 또는 인터페이스에 해당하는 구현을 주입해야 할 때 유효한 패턴임\nuseFactory를 쓰는 이유 기본 등록은 useClass 동작과 동일해 new SomeService(\u0026hellip;)로 생성됨 생성 과정이 비동기이거나 외부 설정 주입, 사전 로딩이 필요한 경우 useFactory가 적합\n요구 사항 예시 생성 자체가 async로 초기 데이터 로딩 필요 외부 라이브러리 설정값 주입 필요 완성된 인스턴스를 싱글톤으로 공유 필요 간단 예시\n{ provide: JSON_REPOSITORY, useFactory: async () =\u0026gt; { const db = new JsonDB(new Config(\u0026#39;path\u0026#39;, true)) await db.load() return JsonRepository.create(db) }, }포인트\nuseFactory 결과값이 토큰에 매핑되어 DI 대상이 됨 의존성이 있다면 inject 옵션으로 다른 provider를 안전하게 받아서 사용 권장 new로 직접 만드는 대신 주입 사용 권장 요약 imports 외부 모듈이 export한 provider 사용 선언 providers 이 모듈에서 생성해 등록하는 의존성 목록 exports 외부에서도 사용 가능하도록 공개할 provider 지정 forRoot 전역 설정을 수반하는 DynamicModule 초기화 패턴, 앱 부트스트랩에서 한 번 호출하는 용도 Symbol 토큰 클래스 이외의 토큰이 필요할 때 충돌 없는 식별자 제공, 다중 구현 구분에 유리 useFactory 비동기 초기화나 복잡한 생성 로직을 함수로 캡슐화해 주입, 설정 주입과 싱글톤 공유 시 적합 참고자료 https://docs.nestjs.com/modules https://docs.nestjs.com/fundamentals/custom-providers https://docs.nestjs.com/fundamentals/dynamic-modules https://docs.nestjs.com/techniques/task-scheduling ","permalink":"https://blog.jsontapose.com/posts/nestjs-module-imports-providers-exports-forroot-symbol-usefactory-025aae/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNestJS에서 @Module은 기능 단위 의존성을 묶는 단위이자 DI 경계를 정의하는 컨테이너 개념임\n핵심은 imports로 외부 의존성 수입, providers로 내부 의존성 등록, exports로 외부 공개 대상을 결정하는 흐름 이해가 전부임\u003c/p\u003e\n\u003ch3 id=\"module의-imports-providers-exports\"\u003eModule의 imports, providers, exports\u003c/h3\u003e\n\u003cp\u003e@Module 선언의 기본 형태\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@Module\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e imports\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[...],\u003c/span\u003e providers\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[...],\u003c/span\u003e exports\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[...]\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eclass\u003c/span\u003e SomeModule \u003cspan style=\"color:#eceff4\"\u003e{}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eproviders\n\u003cul\u003e\n\u003cli\u003e이 모듈에서 새로 생성해 DI 컨테이너에 등록할 대상 목록\u003c/li\u003e\n\u003cli\u003e@Injectable 클래스들 중심 Service, Repository, Adapter 등\u003c/li\u003e\n\u003cli\u003e예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eproviders\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003eBatchService\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e PortFetcher\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e StoreService\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e MergeService\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eimports\n\u003cul\u003e\n\u003cli\u003e다른 모듈이 exports로 공개한 provider를 이 모듈에서 사용하겠다는 선언\u003c/li\u003e\n\u003cli\u003e예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eimports\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003eRepositoryModule\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e HttpModule\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e LoggerModule\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eexports\n\u003cul\u003e\n\u003cli\u003e이 모듈 바깥에서도 사용 가능하도록 내보낼 provider 목록\u003c/li\u003e\n\u003cli\u003e예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexports\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003eJSON_REPOSITORY\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e LogRepository\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e정리하면 providers는 내부 생성, imports는 외부 수입, exports는 외부 공개 대상 지정임\u003c/p\u003e","title":"NestJS @Module 핵심 정리: imports, providers, exports, forRoot, Symbol 토큰, useFactory"},{"content":"개요 비동기는 강력한 도구임. 다만 배열과 스트림 같은 이터레이터와 결합되면 누가 무엇을 언제 기다리는지 불명확해지기 쉬움 핵심 포인트 세 가지 기억\n완료 보장 확보했는지 동시성 제어를 명시했는지 백프레셔로 생산 속도 ≤ 소비 속도 유지했는지 비동기가 의도대로 동작하지 않는 케이스 forEach + async 사용\n콜백이 반환한 프로미스를 외부가 수집하지 않음 → 완료 보장 깨짐, 레이스와 누락 가능성 증가 items.forEach(async (x) =\u0026gt; { await doAsync(x) // 외부에서 기다리지 않음 }) map + async 이후 기다리지 않음\nmap은 프로미스 배열을 반환함. 배열 자체를 await 불가, 반드시 모아서 기다려야 함 const promises = items.map((x) =\u0026gt; doAsync(x)) // await promises // X await Promise.all(promises) // O 무제한 병렬 처리\nPromise.all에 수천 개를 한 번에 던지면 API·DB·네트워크 폭주, 스로틀·쿼터 초과, 메모리 스파이크 유발 스트림 백프레셔 무시\n생산 속도가 소비 속도보다 빠르면 버퍼 적체로 메모리 터짐. 소비 측에서 처리 속도 제어 필요 에러 집계 전략 부재\nPromise.all은 하나라도 실패하면 전체 reject. 일부 실패를 허용하면서 진행하려면 allSettled 필요 순서 보장 착각\n병렬 처리에서는 완료 순서가 섞임. 순서 보장이 필요하면 순차 처리 또는 인덱스 기반 재정렬 필요 상황별 베스트 프랙티스 순차 처리 필요 시\n순서 중요, 레이트리밋, 트랜잭션, 멱등 요구 같은 조건에서 안정성과 백프레셔 확보 목적 for (const item of items) { await doAsync(item) // 하나 끝나야 다음으로 이동 } 최대 속도 필요 시\n순서 무관, 리소스 여유가 있을 때 전체 처리 시간 최소화 목적 await Promise.all(items.map((item) =\u0026gt; doAsync(item))) 병렬 + 동시성 제한 필요 시\n외부·내부 리소스 보호와 안정적 처리율 확보 목적 const K = 5 for (let i = 0; i \u0026lt; items.length; i += K) { await Promise.all(items.slice(i, i + K).map(doAsync)) } 일부 실패 허용·집계 필요 시\n성공과 실패를 분리해 보고 및 재시도 가능 상태로 유지 const results = await Promise.allSettled(items.map(doAsync)) const successes = results.filter(r =\u0026gt; r.status === \u0026#39;fulfilled\u0026#39;).map(r =\u0026gt; r.value) const failures = results.filter(r =\u0026gt; r.status === \u0026#39;rejected\u0026#39;).map(r =\u0026gt; r.reason) 스트리밍·비동기 소스 처리 시\n자연스러운 백프레셔와 메모리 효율 확보 목적 for await (const chunk of asyncIterable) { await handle(chunk) // 입력 속도에 맞춰 소비 } map에서의 비동기 처리 패턴\n올바른 패턴은 프로미스 배열 생성 후 모아서 기다림 const promises = items.map((x) =\u0026gt; doAsync(x)) await Promise.all(promises) 잘못된 패턴 예시 await items.map(\u0026hellip;) 사용 불가, 배열은 await 대상 아님 forEach + async 조합은 외부 대기 불가 타임아웃·취소·재시도 넣기\n외부 I/O 안정성 강화 목적. 행잉 방지와 회복 탄력성 확보 const controller = new AbortController() const timeout = setTimeout(() =\u0026gt; controller.abort(), 5_000) try { await fetch(url, { signal: controller.signal }) } finally { clearTimeout(timeout) } 맺음말 비동기와 이터레이터 조합에서의 실패 원인은 대개 기다림, 동시성, 백프레셔를 명시하지 않은 데서 옴 기억할 것\n순차는 for\u0026hellip;of + await 병렬은 Promise.all, 실패 집계는 Promise.allSettled 스트림은 for await\u0026hellip;of forEach + async는 금지, map은 반드시 Promise.all로 기다림 동시성 제한 필수. 배치나 세마포어로 시스템 보호 이 원칙을 지키면 의도대로 정확하고 빠른 비동기 처리가 가능함 참고자료 https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise/all https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for-await...of https://developer.mozilla.org/docs/Web/API/AbortController https://nodejs.org/api/stream.html#streams-compatibility-with-async-generators-and-async-iterators ","permalink":"https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e비동기는 강력한 도구임. 다만 배열과 스트림 같은 이터레이터와 결합되면 누가 무엇을 언제 기다리는지 불명확해지기 쉬움\n핵심 포인트 세 가지 기억\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e완료 보장 확보했는지\u003c/li\u003e\n\u003cli\u003e동시성 제어를 명시했는지\u003c/li\u003e\n\u003cli\u003e백프레셔로 생산 속도 ≤ 소비 속도 유지했는지\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"비동기가-의도대로-동작하지-않는-케이스\"\u003e비동기가 의도대로 동작하지 않는 케이스\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eforEach + async 사용\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e콜백이 반환한 프로미스를 외부가 수집하지 않음 → 완료 보장 깨짐, 레이스와 누락 가능성 증가\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eitems\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eforEach\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ex\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e doAsync\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ex\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 외부에서 기다리지 않음\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emap + async 이후 기다리지 않음\u003c/p\u003e","title":"자바스크립트 비동기와 이터레이터 정리 — 기다림, 동시성, 백프레셔"},{"content":"개요 TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름 객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐 핵심 차이 포인트 중심으로 정리\n핵심 개념 type\n타입 별칭 정의 수단 기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리 선언 병합 불가 interface\n객체의 구조 정의 수단 확장과 선언 병합 지원 주로 객체와 클래스와의 계약 정의에 사용 // type 별칭 최소 예시 type ID = number | string type Point = [number, number] type Person = { name: string } \u0026amp; { age: number } // interface 최소 예시 interface User { name: string; age: number } interface Employee extends User { employeeId: number }차이점과 동작 표현 범위\ntype은 유니언, 튜플, 조건부 타입, 매핑된 타입 등 고급 타입 구성 가능 interface는 객체 중심 표현에 최적화, 유니언/튜플 직접 표현 불가 확장 방식\ninterface는 extends로 계층 설계 용이 type은 교차 타입(\u0026amp;)으로 합성, 사실상 객체 타입 확장 대체 가능 interface는 객체 형태의 type 별칭을 extends할 수 있으나 유니언 등 비객체 타입은 확장 불가 선언 병합\ninterface는 같은 이름으로 재선언 시 자동 병합 지원 type은 동일 이름 중복 정의 불가, 병합 미지원 클래스와의 호환\n클래스 implements에는 interface뿐 아니라 객체 형태의 type 별칭도 사용 가능 차이는 선언 병합 가능 여부와 확장 구문 차이에서 발생 장단점 type 장점\n유니언, 튜플, 교차, 조건부, 매핑된 타입 등 복잡한 타입 모델링에 강함 별칭으로 복잡한 표현 캡슐화, 가독성 향상 type 단점\n선언 병합 미지원 확장은 교차 타입으로만 구성, 명시적 계층 표현은 제한적 interface 장점\nextends 기반 계층화 용이, 객체 모델 설계에 적합 선언 병합 지원으로 점진적 확장과 모듈 보강에 유리 클래스와의 계약 정의에 직관적 interface 단점\n유니언/튜플 등 비객체 타입 표현 한계 매우 복잡한 조합형 타입 표현에는 제약 사용 권장 interface 권장 상황\n도메인 객체 구조 정의 및 계층 확장 필요 라이브러리 타입 공개 시 선언 병합 또는 모듈 보강 가능성이 있음 클래스가 구현해야 할 계약을 명시하고자 함 type 권장 상황\n유니언, 교차, 튜플 등 복합 타입 모델링 필요 조건부/매핑된 타입 같은 고급 타입 구성 필요 인터페이스로 표현하기 어려운 조합형 타입 단순화 필요 // 인터페이스 계층 최소 예시 interface Shape { area(): number } interface Rectangle extends Shape { width: number; height: number } // 유니언 별칭 최소 예시 type Status = \u0026#39;success\u0026#39; | \u0026#39;error\u0026#39; | \u0026#39;loading\u0026#39;예시로 보는 핵심 포인트 선언 병합은 interface만 가능 interface Profile { name: string } interface Profile { age: number } // Profile은 { name: string; age: number }로 병합됨 type으로 객체 타입 확장하는 일반 패턴 type Base = { id: string } type WithTimestamps = Base \u0026amp; { createdAt: Date; updatedAt: Date }주의 사항 interface가 type보다 항상 우월하거나 그 반대는 아님, 모델링 목표에 따라 선택 interface는 비객체 타입 확장 불가, type은 선언 병합 불가 클래스 implements에는 객체 형태의 type도 사용 가능, 오해 주의 최신 TS에서 공통 기능이 늘었지만 핵심 차이는 선언 병합과 표현 범위에 남아 있음 요약 객체 구조 정의와 확장, 모듈 보강 필요 시 interface 우선 유니언, 튜플, 교차, 조건부 등 복합 타입 모델링 시 type 우선 팀 컨벤션에 따라 일관성 유지 권장, 특정 케이스에서는 혼용 실무적 선택 유효 참고자료 https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces https://www.typescriptlang.org/docs/handbook/declaration-merging.html https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types ","permalink":"https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름\n객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐\n핵심 차이 포인트 중심으로 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003etype\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e타입 별칭 정의 수단\u003c/li\u003e\n\u003cli\u003e기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리\u003c/li\u003e\n\u003cli\u003e선언 병합 불가\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003einterface\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 구조 정의 수단\u003c/li\u003e\n\u003cli\u003e확장과 선언 병합 지원\u003c/li\u003e\n\u003cli\u003e주로 객체와 클래스와의 계약 정의에 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// type 별칭 최소 예시\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e ID \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e Point \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e Person \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e age: \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// interface 최소 예시\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003einterface\u003c/span\u003e User \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e age: \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003einterface\u003c/span\u003e Employee \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eextends\u003c/span\u003e User \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e employeeId: \u003cspan style=\"color:#81a1c1\"\u003enumber\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"차이점과-동작\"\u003e차이점과 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e표현 범위\u003c/p\u003e","title":"TypeScript에서 type과 interface 차이와 선택 기준"},{"content":"개요 Collation은 문자열 정렬과 비교 규칙 정의 테이블에 저장되는 바이트 표현은 인코딩(character set)으로 결정되며, 정렬과 비교 결과는 Collation으로 결정됨 둘은 목적과 적용 지점이 다름\n핵심 개념 Character set은 문자 ↔ 바이트 매핑 Collation은 특정 문자 집합 위에서 정렬 순서와 동일성 판단 규칙 정의 대소문자 민감도(cs), 대소문자 비민감도(ci), 악센트 민감도(as), 악센트 비민감도(ai) 같은 속성으로 비교 엄격도 제어 언어별 규칙 존재하며 같은 인코딩이라도 Collation에 따라 결과 달라짐\n동작 원리와 적용 범위 적용 레벨 계층 구조: 서버 기본값 → 데이터베이스 → 테이블 → 컬럼 → 표현식 단위 오버라이드 가능 영향 받는 연산: ORDER BY, GROUP BY, DISTINCT, LIKE, = 등 문자열 비교 연산 전반 인덱스는 해당 컬럼의 Collation 기준으로 구성되며 정렬 규칙이 범위 검색과 정렬 최적화에 직접 영향 다국어 환경에선 ICU 기반 Collation이나 언어 특화 Collation 선택 필요\n주의와 베스트 프랙티스 인코딩과 Collation을 프로젝트 전반에 일관성 있게 설정 정렬과 검색의 기대 동작 정의 후 cs/ci, as/ai를 명시적으로 선택 다국어 문자 처리가 필요하면 유니코드 계열 인코딩 선택 후 언어 중립 또는 목표 언어에 맞는 Collation 매핑 마이그레이션 시 Collation 변경은 테이블 리빌드 및 인덱스 재생성 비용 발생 가능 바이너리 동일성 비교가 필요하면 BINARY 비교 또는 *_bin Collation 사용\n간단 예시 같은 인코딩에서 Collation만 다를 때 \u0026lsquo;a\u0026rsquo;와 \u0026lsquo;B\u0026rsquo;의 정렬과 비교 결과 달라짐 예시 개념\n대소문자 비민감도(ci): \u0026lsquo;a\u0026rsquo; = \u0026lsquo;A\u0026rsquo;로 간주, 정렬 시 같이 묶임 대소문자 민감도(cs): \u0026lsquo;A\u0026rsquo; \u0026lt; \u0026lsquo;a\u0026rsquo; 같은 규칙 적용 가능 MySQL 예시 개념 utf8mb4_0900_ai_ci는 대소문자/악센트 무시 utf8mb4_0900_as_cs는 악센트 구분 및 대소문자 구분 PostgreSQL 예시 개념 데이터베이스 생성 시 LC_COLLATE 지정 또는 CREATE COLLATION으로 사용자 정의 Collation 등록 표현식 단위 오버라이드 예시 ORDER BY name COLLATE some_collation 형태로 쿼리 레벨에서 지정 가능 정리 Collation은 정렬과 비교 규칙, 인코딩은 저장 형식 정렬과 검색 일관성을 위해 인코딩과 Collation을 분리해서 설계하고, 민감도 옵션을 요구사항에 맞게 선택 필요\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/charset-general.html https://www.postgresql.org/docs/current/collation.html https://unicode.org/reports/tr10/ ","permalink":"https://blog.jsontapose.com/posts/database-collation-and-character-set-320bf2/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eCollation은 문자열 정렬과 비교 규칙 정의\n테이블에 저장되는 바이트 표현은 인코딩(character set)으로 결정되며, 정렬과 비교 결과는 Collation으로 결정됨\n둘은 목적과 적용 지점이 다름\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003eCharacter set은 문자 ↔ 바이트 매핑\nCollation은 특정 문자 집합 위에서 정렬 순서와 동일성 판단 규칙 정의\n대소문자 민감도(cs), 대소문자 비민감도(ci), 악센트 민감도(as), 악센트 비민감도(ai) 같은 속성으로 비교 엄격도 제어\n언어별 규칙 존재하며 같은 인코딩이라도 Collation에 따라 결과 달라짐\u003c/p\u003e\n\u003ch3 id=\"동작-원리와-적용-범위\"\u003e동작 원리와 적용 범위\u003c/h3\u003e\n\u003cp\u003e적용 레벨 계층 구조: 서버 기본값 → 데이터베이스 → 테이블 → 컬럼 → 표현식 단위 오버라이드 가능\n영향 받는 연산: ORDER BY, GROUP BY, DISTINCT, LIKE, = 등 문자열 비교 연산 전반\n인덱스는 해당 컬럼의 Collation 기준으로 구성되며 정렬 규칙이 범위 검색과 정렬 최적화에 직접 영향\n다국어 환경에선 ICU 기반 Collation이나 언어 특화 Collation 선택 필요\u003c/p\u003e","title":"데이터베이스 Collation 정렬·비교 규칙과 인코딩 차이"},{"content":"개요 ERC-1155는 게임 아이템처럼 대량의 토큰을 효율적으로 관리하기 위해 등장한 멀티 토큰 표준으로, ERC-721의 전송·배포 측면 비효율을 줄이려는 목적을 가짐\n편의점 비유로 직관화 가능\nERC-721 개별 포장 모델, 물건 10개 결제에 결제 10번·영수증 10장 ERC-1155 장바구니 모델, 물건 10개를 한 번에 결제·영수증 1장 핵심 개념 ERC-721 단일 NFT 표준, 토큰 ID 하나가 유일한 자산을 대표 ERC-1155 멀티 토큰 표준, 하나의 컨트랙트에서 다수의 ID 발행과 각 ID별 수량 관리 동일 ID에 수량이 붙는 구조로 FT·NFT·SFT를 한 컨트랙트에서 혼합 가능 세미 펀지블 SFT, 같은 ID를 공유하는 동일 품질의 여러 개 토큰을 표현 동작과 구조 단일 컨트랙트에 다수의 tokenId와 balance 맵핑 보유 전송 함수 safeTransferFrom 단건, safeBatchTransferFrom 묶음 전송 지원 이벤트는 TransferSingle과 TransferBatch로 발행, 동일 ID 다건 이동에 최적화 메타데이터는 ID 기반 템플릿 URI 방식 활용이 일반적 {id} 플레이스홀더 패턴 사용 장점 비교 A. 가스비 및 처리량 개선\nERC-721 다수 전송 시 트랜잭션 N회 발생, 가스비·혼잡 증가 ERC-1155 배치 전송으로 서로 다른 ID와 수량을 한 번에 처리, 오버헤드 절감 및 네트워크 혼잡도 감소 B. 컨트랙트 통합 운영\nERC-721 컬렉션 단위로 별도 컨트랙트 배포하는 경우 다수 ERC-1155 한 컨트랙트에서 무한대 ID 발행 가능, 운영·배포 비용 단순화 ID 1 전설의 검, 공급량 1, NFT ID 2 체력 포션, 공급량 10,000, FT NFT와 FT 혼합 구성으로 인벤토리·아이템 카탈로그 모델에 적합 C. 세미 펀지블 모델 적합성\n같은 속성의 아이템 다량 보유 시 효율적 모델링 가능 ERC-721로는 동일한 속성의 개별 ID가 수천 개 필요해 스토리지·인덱싱 비효율 발생 ERC-1155는 하나의 ID에 balance로 표현, 데이터·이벤트 볼륨 절감 단점 및 고려사항 A. 개별 추적 프로비넌스 이슈\nERC-721은 토큰 ID가 유일해 소유 이력·이동 경로 추적 명확 ERC-1155는 동일 ID 내 개별 단위 구분이 어려워 특정 한 점만 떼어 추적하는 데 제약 존재 공급량 1로 설정 시 완화되나 구조적 차이는 남음 B. 도구·레거시 호환성 편차\n초기 생태계는 ERC-721 중심으로 구축된 사례 다수 현재는 대부분 1155 지원이나 일부 오래된 지갑·툴은 721만 지원하는 경우 존재 C. 시장 인식과 포지셔닝\n1/1 예술품·PFP 커뮤니티에서는 721의 유일성 상징성을 선호하는 경향 1155는 게임 아이템·티켓·멤버십 등 대량 발행 이미지가 강해 초고가 1/1 예술품에는 덜 쓰이는 편 한눈에 비교 특징 ERC-721 ERC-1155 주요 용도 디지털 아트, PFP, 1/1 수집품 게임 아이템, 멤버십, 티켓 토큰 유형 NFT 전용 NFT + FT + SFT 혼합 전송 효율 단건 전송 중심, 가스비 부담 배치 전송 지원, 가스비 절감 데이터 구조 ID = 고유 자산 1개 ID에 수량 개념 존재, 동일 자산 다량 표현 비유 미술관의 그림, 각각 고유 마트 진열대, 같은 물건 여러 개 선택 가이드 ERC-721 고유성·작가성 강조, 1/1 예술작품·고유 속성이 중요한 PFP에 적합 ERC-1155 인벤토리형 자산, 대량 발행과 묶음 전송이 필요한 게임 아이템·티켓·멤버십에 적합 핵심은 자산의 고유성 요구와 운영 효율성 간 균형점 찾기임 개별 추적과 상징성이 최우선이면 721, 대량 관리·비용 효율·혼합 자산 모델이 필요하면 1155 선택\n참고자료 https://eips.ethereum.org/EIPS/eip-1155 https://eips.ethereum.org/EIPS/eip-721 https://docs.openzeppelin.com/contracts/5.x/erc1155 https://docs.openzeppelin.com/contracts/5.x/erc721 ","permalink":"https://blog.jsontapose.com/posts/erc-1155-vs-erc-721-multi-token-standard-vs-single-nft-03f5a7/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eERC-1155는 게임 아이템처럼 대량의 토큰을 효율적으로 관리하기 위해 등장한 멀티 토큰 표준으로, ERC-721의 전송·배포 측면 비효율을 줄이려는 목적을 가짐\u003c/p\u003e\n\u003cp\u003e편의점 비유로 직관화 가능\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eERC-721 개별 포장 모델, 물건 10개 결제에 결제 10번·영수증 10장\u003c/li\u003e\n\u003cli\u003eERC-1155 장바구니 모델, 물건 10개를 한 번에 결제·영수증 1장\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eERC-721 단일 NFT 표준, 토큰 ID 하나가 유일한 자산을 대표\u003c/li\u003e\n\u003cli\u003eERC-1155 멀티 토큰 표준, 하나의 컨트랙트에서 다수의 ID 발행과 각 ID별 수량 관리\u003c/li\u003e\n\u003cli\u003e동일 ID에 수량이 붙는 구조로 FT·NFT·SFT를 한 컨트랙트에서 혼합 가능\u003c/li\u003e\n\u003cli\u003e세미 펀지블 SFT, 같은 ID를 공유하는 동일 품질의 여러 개 토큰을 표현\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작과-구조\"\u003e동작과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단일 컨트랙트에 다수의 tokenId와 balance 맵핑 보유\u003c/li\u003e\n\u003cli\u003e전송 함수 \u003ccode\u003esafeTransferFrom\u003c/code\u003e 단건, \u003ccode\u003esafeBatchTransferFrom\u003c/code\u003e 묶음 전송 지원\u003c/li\u003e\n\u003cli\u003e이벤트는 \u003ccode\u003eTransferSingle\u003c/code\u003e과 \u003ccode\u003eTransferBatch\u003c/code\u003e로 발행, 동일 ID 다건 이동에 최적화\u003c/li\u003e\n\u003cli\u003e메타데이터는 ID 기반 템플릿 URI 방식 활용이 일반적 \u003ccode\u003e{id}\u003c/code\u003e 플레이스홀더 패턴 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"장점-비교\"\u003e장점 비교\u003c/h3\u003e\n\u003cp\u003eA. 가스비 및 처리량 개선\u003c/p\u003e","title":"ERC-1155 vs ERC-721: 멀티 토큰 표준과 단일 NFT 표준의 차이와 선택 기준"},{"content":"개념/배경 마이크로서비스와 비동기 작업이 섞인 환경에서 요청의 전 흐름을 좇기 위한 상관 식별자 필요 일반적으로 trace id를 tid로 표기해 서비스 경계를 넘나들며 전파함 HTTP 같은 동기 호출과 메시지 큐 같은 비동기 처리의 전파 매체가 다르므로 매체별 규칙을 명확히 두는 것이 핵심 산업 표준은 W3C Trace Context와 OpenTelemetry가 사실상 기본값 프로세스 내부 전파에는 비동기 컨텍스트 저장소 사용 권장\n핵심 개념과 정의 TID(trace id)와 span id 구분, tid는 전체 요청 상관을 위한 루트 식별자 역할 W3C Trace Context의 traceparent와 tracestate 헤더로 표준 전파 OpenTelemetry는 위 표준을 구현하고 언어별 SDK 제공 프로세스 내 컨텍스트 전파는 AsyncLocalStorage 등 런타임 컨텍스트로 처리 표준 패턴 HTTP 및 gRPC 같은 동기 네트워크 통신은 헤더 사용이 기본 원칙 메시지 큐나 비동기 작업은 메시지 Body 또는 시스템이 제공하는 메시지 속성 사용 지원되는 경우 메시지 헤더를 우선 사용, 없으면 Payload에 포함 요약\nHTTP, gRPC 전파 수단: 헤더 Queue, Job 전파 수단: Payload 또는 메시지 속성 내부 함수 간 전파 수단: AsyncLocalStorage 같은 컨텍스트 저장소 산업 표준 OpenTelemetry의 대표 포맷 예시\ntraceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01 tracestate: vendor-specific data메시지 큐에 싣는 최소 컨텍스트 예시\n{\u0026#34;traceId\u0026#34;:\u0026#34;0af7651916cd43dd8448eb211c80319c\u0026#34;,\u0026#34;spanId\u0026#34;:\u0026#34;b7ad6b7169203331\u0026#34;,\u0026#34;data\u0026#34;:{}}권장 사항\n가능하면 W3C traceparent 사용, 불가 시 임시로 x-trace-id 같은 커스텀 헤더 사용 OTel SDK를 사용하면 생성과 전파, 추적 연계를 표준화 가능 매체별 권장 전파 방식 HTTP REST: traceparent 또는 x-trace-id 같은 커스텀 헤더 사용 gRPC: 메타데이터 사용, 키는 traceparent 또는 조직 표준 키 Kafka: Message Headers 사용 권장, traceId를 헤더 키로 저장 RabbitMQ: Message Properties의 headers 사용 권장 AWS SQS: MessageAttributes 사용, 제약 때문에 불가한 경우 Body에 포함 BullMQ 같은 Redis 기반 Job Queue: 헤더 개념 없음, Job Data에 포함 WebSocket: 최초 핸드셰이크에 헤더 사용, 이후 애플리케이션 메시지에 tid 필드 포함 간단 예시\n// HTTP 클라이언트 인터셉터 예시 client.interceptors.request.use((config) =\u0026gt; { const tid = contextStore.get(\u0026#39;tid\u0026#39;) if (tid) config.headers[\u0026#39;traceparent\u0026#39;] = toTraceparent(tid) return config })// Kafka 예시 producer.send({ topic: \u0026#39;t\u0026#39;, messages: [{ headers: { traceId: tid }, value: payload }] })// BullMQ 예시 await queue.add(\u0026#39;job\u0026#39;, { tid, ...data })// RabbitMQ 예시 channel.publish(\u0026#39;ex\u0026#39;, \u0026#39;rk\u0026#39;, Buffer.from(body), { headers: { traceId: tid } })동작 원리/흐름 HTTP는 요청과 응답이 한 쌍으로 묶이는 모델이라 헤더가 자연스러운 메타데이터 운송 수단 한 요청 체인의 다음 홉으로 갈 때 기존 헤더를 그대로 전달하거나 필요 시 변환함\n메시지 큐는 fire-and-forget 모델이라 메시지 자체가 컨텍스트의 단위가 됨 프로듀서는 메시지에 tid를 포함하고, 컨슈머는 수신 시 컨텍스트 저장소에 복원한 뒤 외부 호출에는 다시 헤더로 전파함\n실무 흐름\n수신 지점에서 tid 추출 또는 생성 프로세스 내부 컨텍스트에 주입 모든 로그와 외부 호출에 동일 tid를 포함 비동기 전환 시 메시지에 tid를 넣어 다음 단계로 전달 최소 예시 모음 HTTP 수신 지점에서 컨텍스트 초기화\napp.use((req, res, next) =\u0026gt; { const fromHeader = req.headers[\u0026#39;traceparent\u0026#39;] || req.headers[\u0026#39;x-trace-id\u0026#39;] const tid = parseOrCreateTid(fromHeader) contextStore.run({ tid }, () =\u0026gt; { res.setHeader(\u0026#39;traceparent\u0026#39;, toTraceparent(tid)) next() }) })비동기 Job 생성과 처리\n// enqueue const tid = contextStore.get(\u0026#39;tid\u0026#39;) await queue.add(\u0026#39;send-email\u0026#39;, { tid, orderId })// worker worker.process(async (job) =\u0026gt; { const tid = job.data.tid || createTid() contextStore.enterWith({ tid }) await http.post(\u0026#39;/email\u0026#39;, body, { headers: { traceparent: toTraceparent(tid) } }) })구조화 로그 예시\n{\u0026#34;tid\u0026#34;:\u0026#34;abc-123\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;order created\u0026#34;,\u0026#34;orderId\u0026#34;:5} {\u0026#34;tid\u0026#34;:\u0026#34;abc-123\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;email sent\u0026#34;,\u0026#34;jobId\u0026#34;:99}베스트 프랙티스 표준 우선 적용, traceparent와 tracestate 사용 가능한 한 동일 키를 계층 전반에 일관되게 사용 수신 시 tid 유효성 검증, 형식 불일치 시 새로 생성하고 원본은 별도 필드로 기록 모든 응답에 tid를 에코, 클라이언트 디버깅 비용 절감 로그는 JSON 구조화와 키 일관성 유지, tid 키를 최우선 컬럼으로 두기 메시지 큐는 시스템이 제공하는 헤더나 속성 기능이 있으면 이를 우선 사용 컨텍스트 저장소는 프레임워크와 런타임 특성에 맞춰 검증, 비동기 경계에서 누수 테스트 필수 샘플링을 사용하는 경우 로거, 트레이서, APM 간 상관 규칙을 문서화 게이트웨이와 프록시에서 trace 헤더가 보존되도록 allowlist 설정 헤더 크기와 메시지 속성 한도 고려, 최소 필드만 전송 tid에 개인정보나 의미 있는 비즈니스 값 포함 금지 외부 조직 간 연동 시 최소한 traceparent만 합의하고 벤더별 tracestate는 선택 적용 주의와 한계 일부 로드밸런서나 보안 프록시가 커스텀 헤더를 제거할 수 있음, traceparent 같은 표준 키 사용과 예외 설정 필요 SQS와 같은 서비스는 속성 크기 제한이 존재, 길이와 문자셋 검증 필요 배치 컨슈머는 단일 배치에 여러 tid가 섞일 수 있음, 레코드 단위로 컨텍스트 복원 필요 워커 풀이나 스레드 풀 전환 시 컨텍스트 전달 누락 가능, 프레임워크 수준 미들웨어로 강제 적용 권장 클라이언트가 임의로 tid를 주입하는 경우 추적 오염 가능, 화이트리스트 형식 검증과 재생성 정책 필요 간단 검증 체크리스트 HTTP 수신과 응답 모두에서 traceparent가 존재하는지 확인 내부 로그 전체에서 tid 검색 시 하나의 사용자 시나리오가 연결되는지 확인 동기 호출 체인과 비동기 메시지 체인 모두에서 tid 손실 구간이 없는지 확인 큐 컨슈머가 수신한 tid로 외부 호출 헤더를 세팅하는지 확인 프록시, 게이트웨이, 서비스 메시 구간에서 trace 헤더 보존 여부 확인 점검을 위한 최소 E2E 시나리오 권장\n클라이언트에서 요청 시작 시 tid 지정 또는 서버 생성 API 서버 로그, 외부 API 호출 로그, 큐에 적재된 메시지, 워커 로그를 단일 tid로 조회 가능해야 함 마무리 전파 매체에 맞춘 일관된 규칙이 관건 HTTP와 gRPC는 헤더, 메시지 큐는 메시지 속성 또는 Payload, 내부 호출은 컨텍스트 저장소라는 단순한 규칙을 지키면 됨 W3C Trace Context와 OpenTelemetry를 기본으로 두고, 지원이 부족한 구간만 최소한의 커스텀을 적용하는 전략이 유지 비용과 도입 비용을 동시에 낮춤 핵심은 유효성 검증, 일관된 로깅, 경계별 책임 분리 세 가지임\n참고 자료 W3C Trace Context OpenTelemetry Traces 개념 gRPC Metadata Kafka Message Format과 Headers RabbitMQ Message Properties AWS SQS Message Attributes BullMQ 문서 Node.js AsyncLocalStorage 참고자료 https://www.w3.org/TR/trace-context/ https://opentelemetry.io/docs/concepts/signals/traces/ https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/ https://grpc.io/docs/guides/metadata/ https://kafka.apache.org/documentation/#messageformat https://www.rabbitmq.com/publishers.html#message-properties https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-attributes.html https://docs.bullmq.io/ https://nodejs.org/api/async_context.html#class-asynclocalstorage ","permalink":"https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e마이크로서비스와 비동기 작업이 섞인 환경에서 요청의 전 흐름을 좇기 위한 상관 식별자 필요\n일반적으로 trace id를 tid로 표기해 서비스 경계를 넘나들며 전파함\nHTTP 같은 동기 호출과 메시지 큐 같은 비동기 처리의 전파 매체가 다르므로 매체별 규칙을 명확히 두는 것이 핵심\n산업 표준은 W3C Trace Context와 OpenTelemetry가 사실상 기본값\n프로세스 내부 전파에는 비동기 컨텍스트 저장소 사용 권장\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eTID(trace id)와 span id 구분, tid는 전체 요청 상관을 위한 루트 식별자 역할\u003c/li\u003e\n\u003cli\u003eW3C Trace Context의 traceparent와 tracestate 헤더로 표준 전파\u003c/li\u003e\n\u003cli\u003eOpenTelemetry는 위 표준을 구현하고 언어별 SDK 제공\u003c/li\u003e\n\u003cli\u003e프로세스 내 컨텍스트 전파는 AsyncLocalStorage 등 런타임 컨텍스트로 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"표준-패턴\"\u003e표준 패턴\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP 및 gRPC 같은 동기 네트워크 통신은 헤더 사용이 기본 원칙\u003c/li\u003e\n\u003cli\u003e메시지 큐나 비동기 작업은 메시지 Body 또는 시스템이 제공하는 메시지 속성 사용\u003c/li\u003e\n\u003cli\u003e지원되는 경우 메시지 헤더를 우선 사용, 없으면 Payload에 포함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e요약\u003c/p\u003e","title":"TID 전파 베스트 프랙티스: HTTP 헤더와 메시지 큐 Payload 기준"},{"content":"개요 인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움 MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨 또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함\n디스크 I/O가 성능을 좌우하는 이유 CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림 DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨\nI/O는 컴퓨터와 주변 장치 간 데이터 전송 전반을 의미하며 파일 시스템 접근, 디스크 읽기·쓰기, 컨트롤러 캐시 플러시 등 시스템 전반의 입출력 행위를 포함함\n저장 매체 개요 서버 환경에서 흔히 쓰는 저장 매체 구분\n내장 디스크 내부 장착형 디스크 드라이브 DAS Direct Attached Storage, 본체에 직접 연결하는 디스크 확장 장치 NAS Network Attached Storage, 네트워크를 통해 공유되는 파일 스토리지 SAN Storage Area Network, 전용 네트워크로 연결되는 블록 스토리지 내장 디스크는 서버 섀시 공간 제약으로 장착 수량과 용량 확장이 제한됨 DAS는 본체에 직결되어 내장 디스크와 유사한 방식으로 동작하며 대용량 확장에 유리하나 하나의 호스트에 귀속되므로 다중 서버 공유 불가 NAS는 TCP/IP 기반 공유 스토리지로 여러 서버에서 동시에 접근 가능하나 직접 연결 대비 지연과 처리량 손실 발생 SAN은 광케이블 등 전용 인터커넥트를 사용해 대용량과 높은 성능, 안정성을 제공하나 구축 비용이 큼\n일반적인 성능과 비용 특성은 내장 디스크 → DAS → SAN 순으로 고성능·고비용 경향을 가짐 모든 매체 내부에는 하나 이상의 디스크 드라이브가 존재한다는 공통점이 있음\nHDD와 SSD의 차이 전통적인 HDD는 플래터와 디스크 헤드를 움직여 데이터를 읽고 쓰는 기계식 구조를 가짐 SSD는 플래시 메모리를 사용해 기계적 움직임 없이 접근하므로 지연이 낮고 랜덤 I/O가 월등히 빠름 인터페이스는 SATA, SAS 등 기존 채널을 그대로 활용 가능하며 서버 스토리지 구성에 바로 적용 가능함\n왜 HDD는 SSD보다 느린가\nHDD는 플래터로 물리적 위치를 탐색해야 해 접근 지연이 필연적으로 큼 SSD는 셀에 전자적으로 접근하므로 위치 탐색 지연이 현저히 낮음 순차 I/O에서는 SSD가 HDD와 유사하거나 다소 빠른 수준을 보이기도 하나 데이터베이스는 작은 블록의 랜덤 접근 비중이 높아 SSD의 이점이 크게 드러남\n랜덤 I/O와 순차 I/O 두 방식 모두 결국 디스크 헤드를 적절한 위치로 이동해 데이터를 읽고 쓰는 동작을 수반함 차이는 접근 패턴에 있음\n순차 I/O 연속된 페이지를 한 번의 흐름으로 접근 랜덤 I/O 불연속 페이지를 여러 번 나눠 접근 예시로 3개의 페이지를 기록하는 경우\n순차 I/O 시스템 콜 1회, 헤드 이동 1회로 연속 기록 랜덤 I/O 시스템 콜 3회, 헤드 이동 3회로 분산 기록 디스크 접근 시간은 헤드 이동과 회전 지연에서 대부분 결정됨 따라서 같은 양의 데이터를 다룰 때 순차 I/O가 랜덤 I/O보다 유리함 DBMS에서는 작은 단위의 랜덤 I/O가 빈번하므로 이를 완화하기 위해 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등 완충 메커니즘을 제공함\n쓰기 작업은 fsync와 같은 동기화가 필요하며 순차 I/O라 해도 동기화 호출이 잦으면 랜덤 I/O처럼 비효율이 발생 가능함 RAID 컨트롤러의 캐시 메모리는 빈번한 동기화 호출을 병합해 순차 쓰기 형태로 변환하는 데 기여함\n실무 쿼리 튜닝에서 랜덤 I/O를 순차 I/O로 전환하는 전략은 제한적임 목표는 랜덤 I/O 자체를 줄이는 것, 즉 쿼리가 필요한 데이터만 읽도록 만드는 것에 초점\n인덱스 레인지 스캔은 주로 랜덤 I/O를 유발하고 풀 테이블 스캔은 순차 I/O를 활용함 큰 테이블에서 대부분의 레코드를 읽는 경우에는 인덱스를 배제하고 풀 스캔을 유도하는 편이 더 빠를 수 있음 이는 OLAP나 대용량 통계 처리에서 종종 채택되는 전략이며 OLTP 특성의 워크로드에서는 신중한 적용이 필요함\nOLTP On-Line Transaction Processing, 데이터 갱신 중심의 다중 동시 트랜잭션 처리 방식 OLAP On-Line Analytic Processing, 대화형 분석 질의와 집계 중심의 정보 처리 방식\n인덱스의 기본 개념 인덱스는 컬럼 값과 해당 레코드의 저장 위치를 키-값 쌍으로 보관하는 구조를 가짐 책의 찾아보기 색인처럼 정렬된 상태로 유지되어 원하는 값을 빠르게 찾을 수 있음\n자료구조 비유\nSortedList 정렬 유지, 조회 빠름, 삽입·갱신 비용 큼 → DB 인덱스에 대응 ArrayList 저장 순서 유지, 별도 정렬 없음 → 데이터 파일에 대응 인덱스는 읽기 성능을 높이는 대신 쓰기 비용을 증가시킴 INSERT, UPDATE, DELETE 시 인덱스 구조를 유지하기 위한 추가 작업이 발생함 따라서 WHERE 절에 등장한다고 모두 인덱스로 만드는 것은 역효과를 초래할 수 있음 인덱스 추가 여부는 쓰기 성능 희생 가능한 범위와 읽기 가속 기대치를 기준으로 판단해야 함\n역할 관점 분류\nPrimary Key 테이블의 대표 키, 고유성과 식별성 보장 Secondary Key 보조 인덱스, 검색 가속 목적 알고리즘 관점 분류\nB-Tree 가장 범용적, 원본 값을 정렬해 보관 Hash 해시 값으로 인덱싱, 동등 비교에 매우 빠름, 전방 일치 등 범위 검색 부적합, 주로 메모리 기반 엔진에서 활용 Fractal-Tree B-Tree의 쓰기 비용을 낮추기 위한 변형, 범용 사용 가능성을 지향하나 성숙도는 상대적으로 낮음 고유성 관점 분류\nUnique 같은 키 값 1개만 허용 Non-Unique 같은 키 값 여러 개 허용 유니크 여부는 옵티마이저의 실행 계획 선택에 중요한 신호로 작용함\nB-Tree 인덱스 이해 B-Tree는 DB 인덱싱에서 가장 널리 쓰이는 기본 알고리즘이며 B+-Tree 또는 B*-Tree 형태가 일반적 여기서 B는 Binary가 아닌 Balanced를 의미함\nB-Tree는 컬럼의 원래 값을 기반으로 정렬 상태를 유지함 일부 엔진은 프리픽스 길이로 앞부분만 보관해 공간을 절약하기도 함 특수 요구사항을 제외하면 범용 검색에 가장 적합함\n구조\n루트 노드 트리 최상단, 탐색 시작점 브랜치 노드 중간 계층, 하위 노드로 경로 분기 리프 노드 최하단, 실제 인덱스 키와 레코드 주소 보관 인덱스 키는 정렬돼 있으나 데이터 파일의 레코드는 일반적으로 임의 순서로 저장됨 삭제 공간 재활용과 페이지 분할 등으로 물리 저장 순서는 삽입 순서와 달라질 수 있음\n예외적으로 InnoDB는 클러스터형 저장 방식을 사용함\n클러스터링 기본 프라이머리 키 순서로 레코드가 물리적으로 모여 저장됨 오라클의 IOT, MS SQL의 클러스터 테이블과 유사 개념 InnoDB는 기본값으로 클러스터링 테이블을 생성함 리프 노드의 레코드 주소 의미\n일부 시스템은 물리적 주소를 직접 가리킴 MyISAM은 내부 레코드 ID 형태로 참조 InnoDB는 프라이머리 키가 클러스터 키이므로 프라이머리 키 자체가 주소 역할을 수행 결과적으로 인덱스 레코드는 인덱스 키와 주소 성분의 조합으로 이뤄짐 인덱스 설계와 I/O 관점 팁 큰 범위를 읽는 질의는 인덱스 레인지 스캔보다 풀 스캔이 더 빠를 수 있음 순차 I/O 활용 선택도가 높은 조건을 선행 컬럼으로 배치해 랜덤 I/O 횟수 최소화 커버링 인덱스 활용으로 테이블 접근을 회피하면 랜덤 I/O를 크게 절감 가능 불필요한 보조 인덱스는 쓰기 비용과 공간만 증가시키므로 주기적 점검 필요 유니크 인덱스는 탐색을 빠르게 하고 불필요한 추가 탐색을 줄여 옵티마이저 결정에 긍정적 신호 제공 간단 예시로 보는 선택 전략 조건이 전체의 80% 이상을 포함하는 집계 질의 → 인덱스보다 풀 스캔이 유리할 가능성 큼 조건이 1% 미만으로 매우 선별적이고 필요한 컬럼이 인덱스에 모두 포함됨 → 커버링 인덱스로 랜덤 I/O 최소화 조인에서 드라이빙 테이블을 고선택도 조건으로 줄인 뒤 조인 실행 → 조인 전체 랜덤 I/O 감소 마무리 인덱스는 읽기 효율을 위해 쓰기 비용을 감수하는 장치라는 본질을 잊지 말아야 함 MySQL에서는 스토리지 엔진 특성과 I/O 패턴 이해가 실행 계획과 성능 결과를 가르는 핵심 요소가 됨 튜닝의 목표는 랜덤 I/O를 순차 I/O로 바꾸는 것이 아니라 불필요한 랜덤 I/O 자체를 줄이는 것임 B-Tree의 구조와 InnoDB의 클러스터링 특성을 이해하고, 선택도와 커버링 여부를 기준으로 인덱스를 설계하면 실무에서 체감 성능 향상을 얻을 수 있음\n참고자료 https://velog.io/@keywookim/MySQL-Index-%EC%BF%BC%EB%A6%AC%ED%8A%9C%EB%8B%9D%EC%9D%98-%EA%B8%B0%EB%B3%B8-1 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html https://12bme.tistory.com/138 ","permalink":"https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움\nMySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨\n또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함\u003c/p\u003e\n\u003ch3 id=\"디스크-io가-성능을-좌우하는-이유\"\u003e디스크 I/O가 성능을 좌우하는 이유\u003c/h3\u003e\n\u003cp\u003eCPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림\nDB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨\u003c/p\u003e","title":"MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본"},{"content":"유한 상태 머신(FSM, Finite State Machine)은 시스템이 가질 수 있는 상태와 그 사이 전이를 명확히 정의하는 모델 복잡한 비즈니스 로직을 단순화하고 예측 가능하게 만들어 결제나 주문처럼 순서와 무결성이 중요한 도메인에 적합\n개념/배경 상태와 규칙을 명시적으로 모델링해 허용되지 않은 동작을 구조적으로 차단하는 접근 요구사항이 늘어도 상태 전이 규칙을 중심으로 변경 범위를 제한해 안정성 확보에 유리\n핵심 개념 상태 State 시스템이 존재할 수 있는 유한한 조건 집합 예 로그인 전, 로그인 후, 결제 대기, 결제 완료 이벤트 또는 입력 Event/Input 상태 변화를 유발하는 외부 행위나 신호 예 버튼 클릭, 네트워크 끊김, 시간 초과 전이 또는 규칙 Transition/Rule 어떤 상태에서 어떤 이벤트가 발생하면 다음 상태로 이동한다는 정의 규칙에 없는 전이는 거부 또는 무시 동작 원리 현재 상태와 입력을 받아 다음 상태를 결정하는 전이 함수 관점으로 해석 가능 f(state, event) -\u0026gt; nextState 형태 전이에는 가드 조건과 부수효과가 수반될 수 있음 가드는 전이 허용 여부 판단, 부수효과는 알림 전송이나 로그 기록 등 외부 행동을 명시적으로 수행 정의되지 않은 전이를 막아 비정상 흐름 차단 재진입이나 중복 이벤트 처리 시에도 일관된 행동을 보장 예시 자판기 모델 상태 대기 중, 이벤트 동전 투입 -\u0026gt; 다음 상태 금액 충족 돈이 들어와야만 다음 상태로 이동 상태 금액 충족, 이벤트 상품 버튼 누름 -\u0026gt; 다음 상태 상품 배출 중 상품 선택 가능 상태 상품 배출 중, 이벤트 배출 완료 -\u0026gt; 다음 상태 대기 중 초기 상태로 복귀 상태 대기 중, 이벤트 상품 버튼 누름 -\u0026gt; 상태 변화 없음 금액 미충족 시 입력 무시 장점과 효과 정합성 보장 정의된 전이 외 동작 불가하므로 데이터 꼬임 예방 결제가 완료 상태에서 결제 요청 이벤트가 다시 들어오면 규칙에 없는 전이로 처리되어 거부 또는 무시되어 중복 결제 차단에 기여 멱등 처리 전략과 결합 시 효과적 예측 가능성 향상 몇 개의 상태와 전이 규칙으로 복잡도를 축소해 로직 이해와 디버깅 용이 테스트 용이성 상태 x 이벤트 조합별로 기대 결과가 명확해 단위 테스트 케이스 설계가 단순 주의와 베스트 프랙티스 상태 폭발 주의 의미 있는 상태만 유지하고 파생 속성은 별도 데이터로 관리 전이 정의의 단일 소스 유지 가드와 부수효과를 전이 정의 근처에 모아 산재된 분기 로직을 제거 잘못된 전이 로깅과 모니터링 활성화 무시된 입력을 계측해 모델 누락이나 외부 시스템 이상 조기 탐지 멱등성 고려 중복 이벤트 재수신 가능 환경에서는 전이와 부수효과를 멱등하게 설계 분산 환경에서는 상태 영속화와 재시도 정책을 명시 크래시 후 재기동 시 일관성 있는 상태 복원 필요 마무리 FSM은 상태와 전이를 중심으로 시스템 동작을 제한하고 드러내며, 규칙 밖 동작을 원천 차단해 안정성을 끌어올림 결제나 주문 같은 순서 기반 도메인에 특히 유용하며, 상태 정의와 전이 규칙만 명확히 유지하면 변경에도 견고하게 대응 가능\n참고자료 https://en.wikipedia.org/wiki/Finite-state_machine https://en.wikipedia.org/wiki/State_diagram ","permalink":"https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/","summary":"\u003cp\u003e유한 상태 머신(FSM, Finite State Machine)은 시스템이 가질 수 있는 상태와 그 사이 전이를 명확히 정의하는 모델\n복잡한 비즈니스 로직을 단순화하고 예측 가능하게 만들어 결제나 주문처럼 순서와 무결성이 중요한 도메인에 적합\u003c/p\u003e\n\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e상태와 규칙을 명시적으로 모델링해 허용되지 않은 동작을 구조적으로 차단하는 접근\n요구사항이 늘어도 상태 전이 규칙을 중심으로 변경 범위를 제한해 안정성 확보에 유리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e상태 State\n시스템이 존재할 수 있는 유한한 조건 집합\n예 로그인 전, 로그인 후, 결제 대기, 결제 완료\u003c/li\u003e\n\u003cli\u003e이벤트 또는 입력 Event/Input\n상태 변화를 유발하는 외부 행위나 신호\n예 버튼 클릭, 네트워크 끊김, 시간 초과\u003c/li\u003e\n\u003cli\u003e전이 또는 규칙 Transition/Rule\n어떤 상태에서 어떤 이벤트가 발생하면 다음 상태로 이동한다는 정의\n규칙에 없는 전이는 거부 또는 무시\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e현재 상태와 입력을 받아 다음 상태를 결정하는 전이 함수 관점으로 해석 가능 f(state, event) -\u0026gt; nextState 형태\u003c/li\u003e\n\u003cli\u003e전이에는 가드 조건과 부수효과가 수반될 수 있음\n가드는 전이 허용 여부 판단, 부수효과는 알림 전송이나 로그 기록 등 외부 행동을 명시적으로 수행\u003c/li\u003e\n\u003cli\u003e정의되지 않은 전이를 막아 비정상 흐름 차단\n재진입이나 중복 이벤트 처리 시에도 일관된 행동을 보장\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"예시-자판기-모델\"\u003e예시 자판기 모델\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e상태 대기 중, 이벤트 동전 투입 -\u0026gt; 다음 상태 금액 충족\n돈이 들어와야만 다음 상태로 이동\u003c/li\u003e\n\u003cli\u003e상태 금액 충족, 이벤트 상품 버튼 누름 -\u0026gt; 다음 상태 상품 배출 중\n상품 선택 가능\u003c/li\u003e\n\u003cli\u003e상태 상품 배출 중, 이벤트 배출 완료 -\u0026gt; 다음 상태 대기 중\n초기 상태로 복귀\u003c/li\u003e\n\u003cli\u003e상태 대기 중, 이벤트 상품 버튼 누름 -\u0026gt; 상태 변화 없음\n금액 미충족 시 입력 무시\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"장점과-효과\"\u003e장점과 효과\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e정합성 보장\n정의된 전이 외 동작 불가하므로 데이터 꼬임 예방\n결제가 완료 상태에서 결제 요청 이벤트가 다시 들어오면 규칙에 없는 전이로 처리되어 거부 또는 무시되어 중복 결제 차단에 기여 멱등 처리 전략과 결합 시 효과적\u003c/li\u003e\n\u003cli\u003e예측 가능성 향상\n몇 개의 상태와 전이 규칙으로 복잡도를 축소해 로직 이해와 디버깅 용이\u003c/li\u003e\n\u003cli\u003e테스트 용이성\n상태 x 이벤트 조합별로 기대 결과가 명확해 단위 테스트 케이스 설계가 단순\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의와-베스트-프랙티스\"\u003e주의와 베스트 프랙티스\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e상태 폭발 주의\n의미 있는 상태만 유지하고 파생 속성은 별도 데이터로 관리\u003c/li\u003e\n\u003cli\u003e전이 정의의 단일 소스 유지\n가드와 부수효과를 전이 정의 근처에 모아 산재된 분기 로직을 제거\u003c/li\u003e\n\u003cli\u003e잘못된 전이 로깅과 모니터링 활성화\n무시된 입력을 계측해 모델 누락이나 외부 시스템 이상 조기 탐지\u003c/li\u003e\n\u003cli\u003e멱등성 고려\n중복 이벤트 재수신 가능 환경에서는 전이와 부수효과를 멱등하게 설계\u003c/li\u003e\n\u003cli\u003e분산 환경에서는 상태 영속화와 재시도 정책을 명시\n크래시 후 재기동 시 일관성 있는 상태 복원 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eFSM은 상태와 전이를 중심으로 시스템 동작을 제한하고 드러내며, 규칙 밖 동작을 원천 차단해 안정성을 끌어올림\n결제나 주문 같은 순서 기반 도메인에 특히 유용하며, 상태 정의와 전이 규칙만 명확히 유지하면 변경에도 견고하게 대응 가능\u003c/p\u003e","title":"유한 상태 머신(FSM) 기본 개념과 적용 포인트"},{"content":"개요 분산 추적 컨텍스트를 어디에 어떻게 실어 나를지에 대한 표준 패턴 정리. HTTP 같은 동기식 통신과 메시지 큐 같은 비동기식 통신은 전달 수단이 다름. 업계 표준은 W3C Trace Context와 이를 구현한 OpenTelemetry를 따르는 흐름임\n핵심 개념 trace-id, span-id, sampling 플래그 등 추적 컨텍스트 전달 필요 동기식 요청/응답 채널은 헤더 기반 메타데이터 전달이 자연스러움 비동기 메시징은 메시지 자체가 전달 단위이므로 페이로드 또는 메시지 속성 이용 채널이 헤더 개념을 지원하면 헤더 우선, 없으면 페이로드에 포함 통신별 패턴 HTTP/REST 통신: 요청/응답 헤더에 trace 컨텍스트 실어 전달 gRPC: 메타데이터(헤더 개념)로 전달 Kafka: 메시지 헤더 지원. 가능하면 헤더 사용 권장 RabbitMQ: 메시지 프로퍼티의 headers 사용 가능 AWS SQS: Message Attributes 사용 가능. 미지원 시 Body에 포함 BullMQ/Redis 기반 잡 큐: 헤더 개념 없음. Job data에 포함 WebSocket: 초기 핸드셰이크 단계에서 허용된 메타데이터 채널 또는 쿼리로 전달, 이후 각 메시지 페이로드에 포함. 환경 제약으로 커스텀 헤더 불가한 경우 존재 산업 표준 OpenTelemetry는 W3C Trace Context를 구현하는 업계 표준 스택 HTTP는 W3C traceparent, tracestate 헤더 사용 비동기 메시징은 채널이 헤더를 지원하면 헤더 사용, 아니면 데이터에 포함하는 전략 일반화 예시\ntraceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01 └─ trace-id ────────────┘ └─ span-id ──┘비동기 메시지에 컨텍스트 포함 예시\n{ \u0026#34;traceId\u0026#34;: \u0026#34;0af7651916cd43dd8448eb211c80319c\u0026#34;, \u0026#34;spanId\u0026#34;: \u0026#34;b7ad6b7169203331\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;...\u0026#34;: true } }왜 채널별로 다르게 전파하나 HTTP는 요청-응답 모델. 헤더가 양방향 메타데이터 전달의 표준 수단이라 헤더 사용이 자연스러움 메시지 큐는 fire-and-forget 모델. 메시지가 독립적 단위라 메시지 헤더 또는 페이로드에 컨텍스트를 포함하는 편이 합리적임 채널별 구현 힌트 HTTP/REST: W3C traceparent, tracestate 사용. 레거시 시스템은 x-trace-id, x-request-id 같이 커스텀 헤더를 병행하기도 함 gRPC: 메타데이터에 traceparent 전파 Kafka: headers에 trace-id 등 삽입. 헤더 미사용 시 value에 포함 RabbitMQ: properties.headers.trace-id 형태 권장 AWS SQS: MessageAttributes에 trace 관련 키 삽입. 컨수머에서 Attributes 추출 실패 시 Body fallback 고려 BullMQ: job.data에 tid 포함 외 대안 없음 WebSocket: 초기 연결 시 허용된 채널(프로토콜 네고, 쿼리, 쿠키 등)로 컨텍스트 전달. 이후 애플리케이션 메시지에 tid 필드 포함 베스트 프랙티스 가능한 표준 헤더 사용 우선. 지원하지 않는 채널에서만 페이로드 포함 전략 채택 traceparent의 sampling 플래그와 tracestate를 보존. 재발급이 아닌 전파를 기본으로 함 컨텍스트 키는 케이스와 하이픈 규칙 일관성 유지. 채널 제약에 맞춰 스네이크/카멜케이스 변환 필요 시 매핑 테이블 유지 메시지 크기와 헤더 용량 제한 고려. 대형 오브젝트를 컨텍스트에 넣지 않음 보안 민감 정보는 컨텍스트에 포함 금지. 추적용 상관관계 식별자만 전파 수신 측에서 유효성 검증. 잘못된 형식이면 새 트레이스 시작 또는 드롭 정책 정의 최소 예시 스니펫 HTTP 요청에 traceparent 주입과 추출\nGET /api HTTP/1.1 traceparent: 00-\u0026lt;trace-id\u0026gt;-\u0026lt;span-id\u0026gt;-01Kafka 메시지에 헤더로 전파\nproducer.send({ topic: \u0026#39;t\u0026#39;, messages: [{ headers: { \u0026#39;trace-id\u0026#39;: tid }, value: payload }] }) // consumer 측에서 message.headers[\u0026#39;trace-id\u0026#39;] 추출 BullMQ 잡 데이터에 포함\nqueue.add(\u0026#39;job\u0026#39;, { tid, payload })마무리 원칙은 단순함. 채널이 헤더 기반 메타데이터를 지원하면 헤더 사용, 아니면 메시지 데이터에 포함. W3C Trace Context와 OpenTelemetry를 기본으로 삼고, 각 통신 채널의 제약에 맞춰 일관된 전파 전략 수립이 핵심임\n참고자료 https://www.w3.org/TR/trace-context/ https://opentelemetry.io/docs/concepts/signals/traces/ https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/trace/semantic_conventions https://grpc.io/docs/guides/concepts/#metadata https://kafka.apache.org/documentation/#record ","permalink":"https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e분산 추적 컨텍스트를 어디에 어떻게 실어 나를지에 대한 표준 패턴 정리. HTTP 같은 동기식 통신과 메시지 큐 같은 비동기식 통신은 전달 수단이 다름. 업계 표준은 W3C Trace Context와 이를 구현한 OpenTelemetry를 따르는 흐름임\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003etrace-id, span-id, sampling 플래그 등 추적 컨텍스트 전달 필요\u003c/li\u003e\n\u003cli\u003e동기식 요청/응답 채널은 헤더 기반 메타데이터 전달이 자연스러움\u003c/li\u003e\n\u003cli\u003e비동기 메시징은 메시지 자체가 전달 단위이므로 페이로드 또는 메시지 속성 이용\u003c/li\u003e\n\u003cli\u003e채널이 헤더 개념을 지원하면 헤더 우선, 없으면 페이로드에 포함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"통신별-패턴\"\u003e통신별 패턴\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP/REST 통신: 요청/응답 헤더에 trace 컨텍스트 실어 전달\u003c/li\u003e\n\u003cli\u003egRPC: 메타데이터(헤더 개념)로 전달\u003c/li\u003e\n\u003cli\u003eKafka: 메시지 헤더 지원. 가능하면 헤더 사용 권장\u003c/li\u003e\n\u003cli\u003eRabbitMQ: 메시지 프로퍼티의 headers 사용 가능\u003c/li\u003e\n\u003cli\u003eAWS SQS: Message Attributes 사용 가능. 미지원 시 Body에 포함\u003c/li\u003e\n\u003cli\u003eBullMQ/Redis 기반 잡 큐: 헤더 개념 없음. Job data에 포함\u003c/li\u003e\n\u003cli\u003eWebSocket: 초기 핸드셰이크 단계에서 허용된 메타데이터 채널 또는 쿼리로 전달, 이후 각 메시지 페이로드에 포함. 환경 제약으로 커스텀 헤더 불가한 경우 존재\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"산업-표준\"\u003e산업 표준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eOpenTelemetry는 W3C Trace Context를 구현하는 업계 표준 스택\u003c/li\u003e\n\u003cli\u003eHTTP는 W3C traceparent, tracestate 헤더 사용\u003c/li\u003e\n\u003cli\u003e비동기 메시징은 채널이 헤더를 지원하면 헤더 사용, 아니면 데이터에 포함하는 전략 일반화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e","title":"분산 추적 표준 패턴 정리: HTTP 헤더와 메시지 페이로드, OpenTelemetry와 W3C Trace Context"},{"content":"개념/배경 Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함 핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함 원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함\n왜 필요한가 데이터 불일치 발생 위험 증가 위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황 유지보수 비용 급증 수정 시 흩어진 모든 복제본을 찾아 변경해야 함 일부 누락 시 버그와 장애로 연결됨 변경 전파가 느림 캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐 실생활 비유 주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재 은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음 스마트폰 연락처가 전화번호의 원본 역할을 수행 연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함 개발 적용 예시 프론트엔드 상태 관리 Bad 부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리 부모 변경이 자식에 반영되지 않을 수 있음 SSOT 상위 컴포넌트 또는 중앙 스토어에만 userData 보관 자식은 props나 selector로 읽기 전용 접근 데이터베이스 모델링 Bad 주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장 SSOT 회원 테이블에만 주소 저장 주문 테이블은 회원 ID를 참조해 조인으로 조회 타입 정의 공유(TypeScript) Bad 동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의 SSOT types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용 베스트 프랙티스와 주의 쓰기 경로 단일화 원본에 대한 쓰기는 반드시 한 경로로만 수행 읽기 복제본과 캐시 관리 캐시는 파생물로 취급 만료 정책, 동기화 주기, 재검증 전략을 명시 식별자 기반 참조 우선 파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석 양방향 복제와 수동 동기화 지양 충돌 해결 복잡도와 데이터 드리프트 위험 상승 마이그레이션 단계 관리 이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용 요약 원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부 이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음 프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장\n필요하다면 리액트 상태 관리에서 SSOT를 어떻게 구현하는지 간단한 예시로 확장 가능\n참고자료 https://en.wikipedia.org/wiki/Single_source_of_truth https://redux.js.org/understanding/thinking-in-redux/three-principles https://en.wikipedia.org/wiki/Database_normalization ","permalink":"https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eSingle Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함\n핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함\n원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함\u003c/p\u003e\n\u003ch3 id=\"왜-필요한가\"\u003e왜 필요한가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 불일치 발생 위험 증가\n\u003cul\u003e\n\u003cli\u003e위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e유지보수 비용 급증\n\u003cul\u003e\n\u003cli\u003e수정 시 흩어진 모든 복제본을 찾아 변경해야 함\u003c/li\u003e\n\u003cli\u003e일부 누락 시 버그와 장애로 연결됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e변경 전파가 느림\n\u003cul\u003e\n\u003cli\u003e캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실생활-비유\"\u003e실생활 비유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재\n은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음\u003c/li\u003e\n\u003cli\u003e스마트폰 연락처가 전화번호의 원본 역할을 수행\n연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"개발-적용-예시\"\u003e개발 적용 예시\u003c/h3\u003e\n\u003ch4 id=\"프론트엔드-상태-관리\"\u003e프론트엔드 상태 관리\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eBad\n\u003cul\u003e\n\u003cli\u003e부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리\u003c/li\u003e\n\u003cli\u003e부모 변경이 자식에 반영되지 않을 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSSOT\n\u003cul\u003e\n\u003cli\u003e상위 컴포넌트 또는 중앙 스토어에만 userData 보관\u003c/li\u003e\n\u003cli\u003e자식은 props나 selector로 읽기 전용 접근\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"데이터베이스-모델링\"\u003e데이터베이스 모델링\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eBad\n\u003cul\u003e\n\u003cli\u003e주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSSOT\n\u003cul\u003e\n\u003cli\u003e회원 테이블에만 주소 저장\u003c/li\u003e\n\u003cli\u003e주문 테이블은 회원 ID를 참조해 조인으로 조회\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"타입-정의-공유typescript\"\u003e타입 정의 공유(TypeScript)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eBad\n\u003cul\u003e\n\u003cli\u003e동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSSOT\n\u003cul\u003e\n\u003cli\u003etypes/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"베스트-프랙티스와-주의\"\u003e베스트 프랙티스와 주의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e쓰기 경로 단일화\n\u003cul\u003e\n\u003cli\u003e원본에 대한 쓰기는 반드시 한 경로로만 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e읽기 복제본과 캐시 관리\n\u003cul\u003e\n\u003cli\u003e캐시는 파생물로 취급\u003c/li\u003e\n\u003cli\u003e만료 정책, 동기화 주기, 재검증 전략을 명시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e식별자 기반 참조 우선\n\u003cul\u003e\n\u003cli\u003e파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e양방향 복제와 수동 동기화 지양\n\u003cul\u003e\n\u003cli\u003e충돌 해결 복잡도와 데이터 드리프트 위험 상승\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e마이그레이션 단계 관리\n\u003cul\u003e\n\u003cli\u003e이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"요약\"\u003e요약\u003c/h3\u003e\n\u003cp\u003e원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부\n이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음\n프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장\u003c/p\u003e","title":"Single Source of Truth(SSOT)의 의미와 적용 예시"},{"content":"개요 좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함 핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향 과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향 최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장\n시스템 설계의 정의와 접근 소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점 주요 구성 요소 팔레트\n앱 서버 데이터베이스 캐시 큐와 잡 러너 이벤트 버스 프록시와 게이트웨이 좋은 설계의 징후\n특별히 문제 삼을 부분 없음 생각보다 쉽게 끝남 신경 쓸 필요가 없는 영역이 존재함 복잡함 그 자체는 신호가 아님\n근본 문제를 가리는 장식일 수 있음 초기부터 복잡한 분산 구조 도입 지양 단순한 구성으로 작동을 보장한 뒤 단계적 확장 상태와 무상태 가장 어려운 지점은 상태 관리\n상태 저장 컴포넌트 수를 줄일수록 복잡도와 장애 가능성 하락 상태는 가능한 한 한 곳에서만 관리 나머지는 무상태 API 호출이나 이벤트 발행 역할에 집중 무상태 예시\n입력을 받아 즉시 결과만 반환하는 렌더링 서비스 같은 경량 계산 경로 상태 예시\n데이터베이스에 쓰기 트랜잭션 수행 데이터베이스 설계와 병목 데이터베이스는 상태의 중심이므로 스키마와 인덱스 설계, 병목 해소 전략이 핵심\n스키마와 인덱스\n사람 읽기 쉬운 스키마 선호 전체를 JSON 컬럼에 몰아넣는 과유연 스키마는 애플리케이션 복잡도와 성능 리스크 상승 자주 질의되는 컬럼 기준의 선택적 인덱스 설계 모든 컬럼 인덱싱은 쓰기 오버헤드와 공간 낭비 유발 병목 해소 패턴\nDB 접근이 병목의 상수항이 되는 경우 많음 가능하면 조인 같은 데이터 결합은 DB에서 처리하는 편이 유리 ORM 사용 시 루프 내 쿼리 발생 등 N+1 주의 필요 시 쿼리 분할로 복잡도와 부하 분산 읽기 부하는 복제본으로 분산해 쓰기 노드 보호 트랜잭션과 대량 쓰기 폭주 시 쿼리 스로틀링 고려 느린 작업과 빠른 작업 분리 사용자 인터랙션 경로는 수백 ms 내 응답 목표 오래 걸리는 작업은 최소 확인만 동기 처리하고 백그라운드로 위임하는 패턴 추천 백그라운드 실행 구조의 일반형\n큐에 작업 적재 잡 러너가 소비 장기 예약 작업은 별도 DB 테이블과 스케줄러 조합이 실용적일 때 많음\n캐싱 캐시는 동일 계산 반복이나 고비용 연산의 비용 절감에 유효 그러나 캐시는 새로운 상태를 도입하므로 동기화 이슈와 스테일 데이터 리스크 존재 원칙\n먼저 쿼리 최적화와 인덱싱으로 기본기 강화 후 캐시 도입 검토 대용량 결과물은 Redis/Memcached 대신 문서 저장소에 주기 스냅샷 저장 전략도 옵션 캐시 무효화 규칙과 만료 정책의 단순화 우선 이벤트 처리 이벤트 허브 기반 분산 처리는 고용량과 지연 허용 케이스에서 적합 단순 요청–응답 API가 로깅과 문제 해결에 유리한 경우가 많음 발신자가 수신자 내부 동작을 몰라도 되는 독립성이 필요할 때 이벤트 채택 고려\n데이터 전달 방식 Pull vs Push Pull\n요청 후 응답 모델 단순하지만 폴링 오버헤드와 과부하 가능성 존재 Push\n데이터 변경 시 즉시 전달 효율적이며 최신성 유지에 유리 대량 클라이언트 처리 시 각 방식에 맞춘 인프라 증설 필요\n이벤트 큐, 팬아웃, 캐시 계층, 연결 수 관리 등 핫패스 집중 핫패스는 시스템 내 데이터가 많이 흐르고 사업 임팩트가 큰 경로를 의미 선택지가 적고 실패 영향이 크므로 신중한 설계와 집중 테스트 필요 마이너 기능의 옵션 다양화보다 핫패스 최적화에 자원 우선 배분\n로깅, 메트릭, 추적 비정상 경로 로깅 강화\n에러 원인과 컨텍스트 수집 관측성 기초 지표 수집\nCPU와 메모리 큐 길이 요청 지연과 작업 소요 시간 평균값 대신 분포 지표 관찰\np95, p99 지연에 주목 상위 소수의 느린 요청이 핵심 사용자 문제일 수 있음 분산 추적으로 경계 간 지연과 재시도 파악\n킬스위치, 재시도, 장애 복구 킬스위치로 기능 단위 차단 가능 상태 유지 무작정 재시도는 장애 전파와 증폭 위험\n회로 차단기로 하류 서비스 보호 지수 백오프와 재시도 예산 관리 멱등키로 중복 처리 방지 장애 모드 선택\nfail open이 사용자 영향이 적은 경로 예시로 Rate Limiting 인증과 결제는 fail closed 필수 DB 조인 vs 애플리케이션 조인 논의 요약 관점 A\n복잡한 데이터 결합은 DB가 담당하는 게 성능과 단순성에서 유리 뷰와 저장 프로시저는 데이터 추상화 계층으로 유효 관점 B\n확장성 요구가 큰 구조에서는 DB는 단순 인덱스 조회 역할에 집중 조인과 집계는 수평 확장 쉬운 백엔드에서 처리해 자원 증설로 스케일링 대역폭 관점에서 필요한 데이터만 가져와 애플리케이션에서 결합이 유리한 케이스 존재 실무 결론\n기본값은 DB에 맡기되 데이터 폭발, 팬아웃, 대역폭 병목, 캐시 전략과 결합 등 조건에서 예외 설계 고려 관측 지표와 비용 곡선으로 선택 검증 스키마 설계와 유연성 스키마의 과유연은 앱 복잡도와 성능 문제 야기\n모든 것을 JSON 컬럼이나 EAV로 수용하는 설계는 가독성과 최적화 모두에 독 정규화 가능한 경우엔 정규화 선호 사람이 봐도 용도가 직관적인 테이블 구조 우선 단, 임시 수용을 위한 제한적 JSONB 같은 완충은 특정 상황에서 유용할 수 있으나 기본 규칙은 아님\nORM 사용 시 주의 단일 오브젝트 모델 강제는 복잡한 조회 시 유연성 저하 위험 N+1, 비효율 조인, 불필요 데이터 로딩 주의 필요 시 뷰나 핸드크래프트 쿼리로 경로 단순화\n여러 서비스의 DB 공유 vs API 단일 쓰기 경로 권장 기본값\n한 서비스만 테이블에 쓰기 책임 부여 나머지는 API 호출 또는 이벤트 발행으로 상호작용 반론과 현실 제약\n여러 서비스가 DB를 직접 접근하면 권한과 트랜잭션, 커스텀 쿼리 활용이 쉬움 그러나 스키마 변경 시 영향 반경이 커지고 마이그레이션 제약 증가 실무 결론\n변화 적응성과 조정 범위 최소화를 우선시하면 API가 유리 공유 DB 구조는 소규모·단기에는 빠를 수 있으나 규모 확대 시 실패 사례가 다수 보고됨 구조 변경 시 영향을 받는 팀 수를 지표로 삼아 결정 데이터 전달 인터페이스 우선순위 시스템 설계의 핵심은 사용자가 맞닥뜨리는 인터페이스 설계\n기능 제공과 교환비용의 명확화가 본질 내부 구조는 인터페이스 안정성을 지키며 후속 교체 가능 설계 논의 시간의 다수를 인터페이스 정의와 버전 전략에 투자 권장\n상태와 운영 책임의 분리 무상태 컨테이너 경로는 배포와 롤백으로 복구 쉬움 상태가 붙는 DB와 파일 스토리지는 전담 운영 책임 필요\n백업과 복구 전략 부재는 정상 운영 중에도 잠재 리스크 사고 대응은 수 분 내 배포로 해결되지 않는 영역 존재 캐시와 문서 저장소 선택지 키값 캐시가 아닌 문서 저장소에 주기적 결과 저장 전략\n대용량 결과물 재사용 시 비용 절감 효과 만료와 불일치 관리 단순화 가능 Pull과 Push 확장 전략 Pull 고도화\n조건부 요청과 캐시 검증 헤더 활용 백오프와 지능형 폴링 간격 조절 Push 고도화\n팬아웃을 큐로 비동기화 연결 수 관리와 샤딩으로 수평 확장 관측과 핫패스 최적화 체크리스트 핫패스 정의와 경로 단순화 p95, p99 지연 모니터링과 예산 설정 실패 로그의 샘플링과 컨텍스트 상관ID 부여 큐 적체 알람과 처리율 자동 확장 스로틀링과 회로 차단기 정책 점검 멱등키 적용 범위 정의 HN에서 나온 면접과 복잡도 논의 요약 현실의 좋은 설계는 단순함이 미덕이지만 면접 신호로는 복잡한 다이어그램이 과대평가되는 경향 존재 면접에서는 결정을 내린 이유와 고려 요소를 구조화해 설명하는 능력이 중요하다는 반론 다수 SQL과 NoSQL 선택은 팀 친숙도만이 아니라 작업 부하 특성과 데이터 모델 차이가 중요하다는 의견 존재 복잡함 숭배가 과설계를 장려한다는 비판과, 그래도 면접은 양방향이므로 의도한 평가 포인트에 맞춰 소통해야 한다는 조언 공존 DB 공유와 서비스 경계에 대한 HN 논의 요약 여러 서비스가 한 DB를 공유하면 분산 시스템이 이미 형성된 셈이라 관리 복잡도 상승 가능 반대로 서비스 API가 높은 수준의 인터페이스가 되면 인증과 트랜잭션, 예외처리를 직접 구현해야 하는 부담 발생 장기 유지보수성과 변경 용이성 관점에서 공유 DB보다 API 경계가 유리하다는 경험담 다수 DB 분리 시 가용성 계산과 운영 복잡도 증가도 현실 제약으로 고려 필요 저장 프로시저와 SQL 추상화에 대한 HN 논의 요약 뷰와 저장 프로시저는 데이터 추상화에 유효하다는 견해와, 팀 언어와 도구 표준화 관점에서 유지보수 난이도가 높다는 반론 공존 ORM은 큰 서비스에서 유연성을 제한하고 성능 문제 유발 가능성이 있어 뷰와 핸드크래프트 쿼리 병행 제안 다수 boolean vs timestamp 논의 요약 단순 boolean은 상태 확장 시 필드 난립으로 이어지므로 timestamp나 enum으로 진화 가능성 확보가 낫다는 주장 존재 반론으로 논리적 boolean이 의미상 더 적합하고 데이터 크기와 분석 효율 측면에서 유리한 케이스도 있음 실무 결론은 도메인 변화 방향과 감사 요구에 따라 선택하며, 변경 시점이 중요한 경우 별도 감사 테이블 도입이 더 적합 느린 작업 처리와 인프라 선택 단기 대기열은 인메모리 큐로 충분 장기 스케줄은 DB 기반 스케줄 테이블과 워커 조합이 단순하고 운영이 쉬움 마무리 좋은 시스템 설계의 기본값은 단순함과 상태 최소화 데이터베이스 중심의 스키마와 인덱스, 핫패스 최적화, 관측 가능성 확보가 토대 캐시와 이벤트, 백그라운드 처리, 복잡한 분산 구성은 필요한 순간에만 단계적으로 도입 기술적으로 특별한 설계는 드물고, 지루할 정도로 단순한 구성의 안정적 운영이 장기적으로 가장 강함\n참고자료 https://www.seangoedecke.com/good-system-design/ https://news.ycombinator.com/item?id=44921137 https://en.wikipedia.org/wiki/Systemantics https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model https://pragprog.com/titles/bksqla/sql-antipatterns/ ","permalink":"https://blog.jsontapose.com/posts/good-system-design-guide-484b40/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함\n핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향\n과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향\n최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장\u003c/p\u003e\n\u003ch3 id=\"시스템-설계의-정의와-접근\"\u003e시스템 설계의 정의와 접근\u003c/h3\u003e\n\u003cp\u003e소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점\n주요 구성 요소 팔레트\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e앱 서버\u003c/li\u003e\n\u003cli\u003e데이터베이스\u003c/li\u003e\n\u003cli\u003e캐시\u003c/li\u003e\n\u003cli\u003e큐와 잡 러너\u003c/li\u003e\n\u003cli\u003e이벤트 버스\u003c/li\u003e\n\u003cli\u003e프록시와 게이트웨이\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e좋은 설계의 징후\u003c/p\u003e","title":"좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙"},{"content":"개요 HTTP Status Code만으로는 서비스 로직의 원인을 전달하기 부족함 400대와 500대는 네트워크 관점의 대분류 신호에 가깝고 실제로 필요한 것은 비즈니스 맥락의 구체적 사유임 결론은 단순함 HTTP Status는 대분류 신호로 두고 실제 의미와 추가 컨텍스트는 Response Body에 싣는 구조가 현실적 해법임\n핵심 원칙 HTTP Status는 큰 범주 신호등 역할 2xx 성공 4xx 클라이언트 오류 5xx 서버 오류 비즈니스 의미는 Response Body의 커스텀 에러 구조로 표현 클라이언트가 코드 기반으로 분기하고 UI를 결정할 수 있어야 함 운영 관측을 위해 traceId 제공 업계에서 검증된 기본 구조 아래 형태가 가장 보편적으로 쓰이는 패턴임\n// HTTP 400 { \u0026#34;success\u0026#34;: false, \u0026#34;code\u0026#34;: \u0026#34;USER_ALREADY_EXISTS\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;이미 가입된 이메일입니다.\u0026#34;, \u0026#34;traceId\u0026#34;: \u0026#34;a1b2c3d4\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-05-21T10:00:00Z\u0026#34; }이점\nstatus는 대분류, code는 비즈니스 소분류 사람이 읽기 쉬운 문자열 코드가 숫자보다 디버깅 친화적임 traceId로 로그 상관관계 추적 가능 Validation 에러는 배열로 구조화 여러 필드가 동시에 실패할 수 있으므로 필드 단위로 묶어 제공\n// HTTP 400 { \u0026#34;code\u0026#34;: \u0026#34;INVALID_INPUT\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;입력값이 올바르지 않음\u0026#34;, \u0026#34;errors\u0026#34;: [ { \u0026#34;field\u0026#34;: \u0026#34;email\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;abc@\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;이메일 형식 아님\u0026#34; }, { \u0026#34;field\u0026#34;: \u0026#34;age\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;-5\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;0보다 커야 함\u0026#34; } ] }프론트엔드가 각 필드에 에러를 매핑하기 쉬움\nRFC 7807 요약 Problem Details for HTTP APIs 표준 스펙으로 에러 응답을 정형화하는 방법 제공 Spring Boot 3 계열은 ProblemDetail을 기본 제공하며 적용이 용이함 필수는 아니나 상호운용성과 문서화를 원활하게 해줌\n// HTTP 403 { \u0026#34;type\u0026#34;: \u0026#34;https://api.example.com/errors/not-enough-credit\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Not Enough Credit\u0026#34;, \u0026#34;status\u0026#34;: 403, \u0026#34;detail\u0026#34;: \u0026#34;Current balance is 30, item costs 50\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/account/12345/tx/abc\u0026#34; }실무에서는 필드를 축약하거나 내부 코드 체계와 혼합 사용하는 경우가 많음\n빅테크 사례 관찰 Google Cloud API는 status와 message, 세부 정보 배열로 구조화 Meta Graph API는 type, code, subcode, trace id를 포함해 디버깅 친화성 확보 국내 주요 서비스들도 대체로 자체 에러 코드와 message 조합 사용 베스트 프랙티스 정리 HTTP Status는 대분류로 통일 400 잘못된 요청 401 인증 필요 403 권한 없음 404 리소스 없음 409 상태 충돌 422 의미적 검증 실패 500 서버 오류 Response Body 필드 권장 { \u0026#34;success\u0026#34;: false, \u0026#34;code\u0026#34;: \u0026#34;COUPON_ALREADY_USED\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;이미 사용한 쿠폰임\u0026#34;, \u0026#34;details\u0026#34;: [], \u0026#34;traceId\u0026#34;: \u0026#34;xyz123\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2025-01-01T00:00:00Z\u0026#34; } 서버에 ErrorCode Enum 정의 export enum ErrorCode { COMMON_INVALID_PARAMETER = \u0026#34;COMMON_INVALID_PARAMETER\u0026#34;, USER_ALREADY_EXISTS = \u0026#34;USER_ALREADY_EXISTS\u0026#34;, COUPON_EXPIRED = \u0026#34;COUPON_EXPIRED\u0026#34;, PERMISSION_DENIED = \u0026#34;PERMISSION_DENIED\u0026#34;, }효과\n프론트 분기 단순화 디버깅과 핫픽스 속도 향상 조직 전반 에러 표현 일관성 유지 i18n 처리 전략 두 가지 중 하나로 결정하고 일관성 유지\n서버가 Accept-Language 기반으로 message 현지화 클라이언트가 code를 로컬 메시지로 매핑해 렌더링 서버 현지화는 중앙집중 제어 용이, 클라이언트 매핑은 번역 배포 독립성 높음 팀의 배포 파이프라인과 책임 분리에 맞춰 선택\n보안과 운영 관점 주의사항 내부 스택 트레이스, DB 원문 오류 메시지 노출 금지 클라이언트에는 안전한 수준의 요약 메시지 제공 traceId로만 서버 로그와 상관관계 연결하도록 설계 실제 예외 상세는 서버 로그와 관측 시스템에서만 확인 마무리 HTTP Status만으로 비즈니스 맥락의 에러를 충분히 설명하기 어려움 대분류는 Status, 실제 의미는 Body의 코드와 메시지, 추가 컨텍스트는 details 또는 errors, 운영 추적은 traceId로 분리 설계 권장 이 패턴은 REST, GraphQL, gRPC 등 전송 방식과 무관하게 적용 가능하며 규모가 커질수록 가치가 커짐\n참고자료 https://www.rfc-editor.org/rfc/rfc7807 https://cloud.google.com/apis/design/errors https://developers.facebook.com/docs/graph-api/using-graph-api/error-handling/ https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/responseentity.html#page-title https://datatracker.ietf.org/doc/html/rfc9110#name-status-codes ","permalink":"https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eHTTP Status Code만으로는 서비스 로직의 원인을 전달하기 부족함\n400대와 500대는 네트워크 관점의 대분류 신호에 가깝고 실제로 필요한 것은 비즈니스 맥락의 구체적 사유임\n결론은 단순함\nHTTP Status는 대분류 신호로 두고 실제 의미와 추가 컨텍스트는 Response Body에 싣는 구조가 현실적 해법임\u003c/p\u003e\n\u003ch3 id=\"핵심-원칙\"\u003e핵심 원칙\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP Status는 큰 범주 신호등 역할\n\u003cul\u003e\n\u003cli\u003e2xx 성공\u003c/li\u003e\n\u003cli\u003e4xx 클라이언트 오류\u003c/li\u003e\n\u003cli\u003e5xx 서버 오류\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e비즈니스 의미는 Response Body의 커스텀 에러 구조로 표현\u003c/li\u003e\n\u003cli\u003e클라이언트가 코드 기반으로 분기하고 UI를 결정할 수 있어야 함\u003c/li\u003e\n\u003cli\u003e운영 관측을 위해 traceId 제공\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"업계에서-검증된-기본-구조\"\u003e업계에서 검증된 기본 구조\u003c/h3\u003e\n\u003cp\u003e아래 형태가 가장 보편적으로 쓰이는 패턴임\u003c/p\u003e","title":"API 에러 응답 설계 가이드 — HTTP Status는 대분류, 비즈니스 의미는 바디"},{"content":"개념/배경 객체 구조 분해 할당에서 프로퍼티 이름을 바꾸는 기본형은 { 기존프로퍼티명: 새변수명 } 형태임\n사용법/예시 아래는 request 프로퍼티를 revealRequest라는 이름으로 받는 예시\nconst { request: revealRequest } = await client.doSomething({...})의미는 다음과 같음\ndoSomething이 반환하는 객체에서 request 프로퍼티 추출 추출한 값을 revealRequest 변수에 바인딩 아래 전개 코드와 동일함\nconst result = await client.doSomething({...}) const revealRequest = result.request왜 쓰는가 코드 간결화 필요한 프로퍼티만 선택 추출 문맥에 맞게 변수명 명확화, 의도 드러남 참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment ","permalink":"https://blog.jsontapose.com/posts/typescript-object-destructuring-rename-property-ba20ff/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e객체 구조 분해 할당에서 프로퍼티 이름을 바꾸는 기본형은 { 기존프로퍼티명: 새변수명 } 형태임\u003c/p\u003e\n\u003ch3 id=\"사용법예시\"\u003e사용법/예시\u003c/h3\u003e\n\u003cp\u003e아래는 request 프로퍼티를 revealRequest라는 이름으로 받는 예시\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e request: \u003cspan style=\"color:#81a1c1\"\u003erevealRequest\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e client\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003edoSomething\u003cspan style=\"color:#eceff4\"\u003e({...})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e의미는 다음과 같음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edoSomething이 반환하는 객체에서 request 프로퍼티 추출\u003c/li\u003e\n\u003cli\u003e추출한 값을 revealRequest 변수에 바인딩\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 전개 코드와 동일함\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e result \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e client\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003edoSomething\u003cspan style=\"color:#eceff4\"\u003e({...})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e revealRequest \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e result\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003erequest\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"왜-쓰는가\"\u003e왜 쓰는가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e코드 간결화\u003c/li\u003e\n\u003cli\u003e필요한 프로퍼티만 선택 추출\u003c/li\u003e\n\u003cli\u003e문맥에 맞게 변수명 명확화, 의도 드러남\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"TypeScript 객체 구조 분해 할당으로 프로퍼티 이름 변경하기"},{"content":"개요 운영 중인 서비스에서 전체 트래픽을 한 번에 신규 기능이나 신규 인프라로 전환하지 않고, 일정 비율만 점진적으로 이동하는 전략이 필요함\n주요 활용 맥락\nA/B 테스트로 실험군과 통제군 분리 카나리 배포로 신규 버전을 소수 사용자에게만 적용 신규 데이터베이스, 캐시, 인덱스 전환 검증 신규 알고리즘, 추천 엔진, 정책 점진 적용 서버 비용 최적화를 위한 점진적 트래픽 이동 아래는 대부분의 시나리오에 적용 가능한 일반화된 트래픽 분배 기법 정리\n요구 조건 Deterministic — 같은 사용자나 리소스는 항상 같은 그룹에 속해야 함 요청마다 그룹이 바뀌면 실험 신뢰성이 떨어지고 디버깅이 어려움 안정적 해시 기반 결정 방식 필요\nConfig-driven — 배포 없이 실시간 비율 조절 가능해야 함 1% → 5% → 10%처럼 점진 조절 가능해야 함 이상 감지 시 즉시 0%로 롤백 가능해야 함\nObservability — 그룹별 지표 수집 가능해야 함 모든 요청에 식별 가능한 태그 부여 권장\nvariant=control|treatment cohort=new_db|old_db traffic_group=A|B 그룹 단위 결과 분석과 장애 구간 추적이 쉬워짐 Single routing decision point — 애플리케이션 곳곳에 if 분기 남발 금지 Repository, Gateway, Middleware 등 한 지점에서 라우팅 결정을 수행하여 일관성 확보\n핵심 기법 해시 기반 코호트 라우팅 (Hash-based Cohort Routing) A/B 테스트, 카나리 배포, 신규 DB 점진 전환까지 포괄하는 업계 표준 기법\n원리\n사용자나 리소스의 고유 키를 안정적 해시 함수에 입력 해시 값을 퍼센트 버킷으로 매핑 버킷 범위에 따라 그룹 결정 간단 스니펫\nfunction selectCohort(key: string, rolloutPercent: number): \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; { const hash = stableHash(key) // 예: murmurhash3 계열 const bucket = hash % 100 // 0~99 return bucket \u0026lt; rolloutPercent ? \u0026#39;B\u0026#39; : \u0026#39;A\u0026#39; }장점\n결정적 분배로 재현성 보장 균일한 트래픽 분포 기대 배포 없이 비율 조절 가능 사용자 단위 일관성 유지 장애 시 즉시 롤백 용이 주의\n키 선택 중요. 사용자 ID가 없으면 세션 ID나 영속 쿠키 등 안정적 대체키 필요 해시 함수는 충돌 특성과 분포가 검증된 안정적 구현 사용 권장 버킷 경계 변경 시 코호트 이동 최소화를 고려. 다중 코호트가 필요한 경우 키+실험명 조합으로 네임스페이스 분리 권장 기능 플래그 기반 분배 (Feature Flags) 런타임 구성으로 기능 on/off 및 비율 롤아웃을 제어하는 방식 상용 서비스나 자체 구성 서비스로 운영 가능\n장점\nUI나 API로 롤아웃 비율, 타깃팅 조건을 안전하게 조절 지역, 디바이스, 사용자 속성 기반 등 다양한 조건 분배 지원 릴리즈와 활성화를 분리해 리스크 완화 단점\n외부 의존 비용 또는 운영 비용 존재 네트워크 지연 및 실패 처리에 대한 폴백 로직 필요 세그먼트 기반 라우팅 (Segmentation-based Routing) 특정 사용자 집단을 기준으로 우선 전환하는 방식\n예시\n내부 계정부터 전환 베타 사용자 그룹만 신규 기능 활성화 특정 국가나 특정 고객만 신규 버전 적용 장점\n매우 안정적이며 단계적 검증에 유리 운영 및 QA 시나리오에 적합 단점\n퍼센트 기반의 균일 분배를 얻기 어려움 헤더·오버라이드 기반 라우팅 (Header/Override) 특정 요청을 강제로 새로운 경로로 전환하는 보조 전략\n예시\nX-Use-NewDB: true 같은 헤더로 강제 전환 운영 도구에서 신규 코드 경로 강제 실행 장점\n디버깅과 테스트에 유용 점진 전환 전략과 함께 보조적으로 사용 베스트 프랙티스 아키텍처 단일 결정 지점에서 라우팅 수행 Repository 또는 Service Layer에서 매 요청마다 동일한 결정 로직 실행\ncohort = determineCohort(key, rolloutPercent) if (cohort == NEW) { read/write new DB } else { read/write old DB }애플리케이션 전역에 흩어진 분기 제거로 복잡도와 리스크 축소 결정 결과를 요청 컨텍스트에 태그로 첨부하여 하위 레이어와 로깅·모니터링에 전달 권장\n구성 가능한 롤아웃 플랜 운영이 제어 가능한 매개변수 예\nrolloutPercentRead rolloutPercentWrite rolloutPercentUIExperimental 읽기와 쓰기를 분리해 점진적 마이그레이션 수행 가능. 예를 들어 읽기는 50%부터 시작, 쓰기는 1%로 보수적으로 시작 모니터링과 알람 체계 실험이나 전환에는 반드시 다음 포함\n그룹별 오류율 그룹별 지연시간 그룹별 핵심 지표. 예: 구매율, 전환율 자동 롤백 또는 빠른 수동 롤백 수단 지표 집계는 그룹 태그 기준으로 분리. 알람은 베이스라인 대비 상대 변화율 기반 설정 권장 전체 진행 예시 rolloutPercent = 1 설정 핵심 경로 정상 동작 확인 rolloutPercent = 5 확대 지표와 로그 모니터링 rolloutPercent = 20 확대 문제 발생 시 즉시 0으로 롤백 안정화 후 50 → 100 단계적 확대 A/B 테스트, 신규 DB 전환, 신규 API나 알고리즘 도입에도 동일 패턴 적용 가능 요약 기법 목적 장점 Hash-based Routing 균일하고 결정적인 퍼센트 분배 A/B, 카나리, 무중단 전환까지 범용 대응 Feature Flags 런타임 구성 제어 운영 친화적, 조건 기반 분배 용이 Segmentation 안전한 초기 전환 QA와 제한적 사용자 테스트에 적합 Header Override 디버깅·강제 테스트 실험 보조 도구로 유용 가장 범용적인 조합은 해시 기반 코호트 라우팅과 구성 기반 퍼센트 조정 트래픽 전환 시나리오에서 이 조합이 베스트 프랙티스로 널리 사용됨\n참고자료 https://martinfowler.com/bliki/CanaryRelease.html https://martinfowler.com/articles/feature-toggles.html https://sre.google/workbook/canarying-releases/ https://en.wikipedia.org/wiki/MurmurHash ","permalink":"https://blog.jsontapose.com/posts/safe-traffic-splitting-with-hash-cohorts-and-config-rollout-f5b03f/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e운영 중인 서비스에서 전체 트래픽을 한 번에 신규 기능이나 신규 인프라로 전환하지 않고, 일정 비율만 점진적으로 이동하는 전략이 필요함\u003c/p\u003e\n\u003cp\u003e주요 활용 맥락\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA/B 테스트로 실험군과 통제군 분리\u003c/li\u003e\n\u003cli\u003e카나리 배포로 신규 버전을 소수 사용자에게만 적용\u003c/li\u003e\n\u003cli\u003e신규 데이터베이스, 캐시, 인덱스 전환 검증\u003c/li\u003e\n\u003cli\u003e신규 알고리즘, 추천 엔진, 정책 점진 적용\u003c/li\u003e\n\u003cli\u003e서버 비용 최적화를 위한 점진적 트래픽 이동\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래는 대부분의 시나리오에 적용 가능한 일반화된 트래픽 분배 기법 정리\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"요구-조건\"\u003e요구 조건\u003c/h3\u003e\n\u003ch4 id=\"deterministic--같은-사용자나-리소스는-항상-같은-그룹에-속해야-함\"\u003eDeterministic — 같은 사용자나 리소스는 항상 같은 그룹에 속해야 함\u003c/h4\u003e\n\u003cp\u003e요청마다 그룹이 바뀌면 실험 신뢰성이 떨어지고 디버깅이 어려움\n안정적 해시 기반 결정 방식 필요\u003c/p\u003e","title":"트래픽을 일정 비율로 안전하게 나누는 방법: 해시 코호트와 구성 기반 롤아웃"},{"content":"개념/배경 한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름 발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름 핵심은 느슨한 결합과 자동 알림 흐름 유지\n핵심 개념과 구성요소 Subject 또는 Observable 이벤트를 발생시키는 주체 Observer 목록을 관리 상태가 변하면 observers에 알림 전파 Observer 상태 변화를 알고 싶은 소비자 update 같은 콜백 보유 notify Subject가 모든 Observer에게 브로드캐스트하는 동작 동작 원리 Observer가 Subject에 구독 등록 Subject 상태 변화 발생 Subject가 notify 실행, 등록된 Observer의 콜백 호출 Observer는 전달된 값에 따라 자체 로직 수행 필수 인터페이스의 최소 형태는 아래와 같음\n// 핵심 메서드 형태만 발췌 interface Observer { update(value: unknown): void } // Subject는 내부에 observers 보유 // subscribe, unsubscribe, notify 동작 제공 // notify(value) -\u0026gt; 모든 observer.update(value) 왜 쓰는가 하나의 변화에 여러 객체가 반응해야 하는 요구 충족 예: 버튼 클릭 한 번에 여러 UI 혹은 모듈 업데이트 필요 느슨한 결합 유지 Subject는 Observer의 구체 타입이나 구현을 모를 수 있음 이벤트 기반 비동기 흐름 표현에 적합 UI 이벤트, 도메인 이벤트, 시스템 시그널 등 다양한 케이스에 적용 가능 RxJS와의 관계 RxJS는 Observer 패턴을 비동기 스트림 개념으로 확장한 라이브러리\nObserver는 next, error, complete 세 가지 콜백으로 구성 Subject는 내부적으로 Observer 목록을 관리하고 next 호출 시 모든 구독자에 브로드캐스트 구독과 해제, 리소스 정리와 같은 수명주기 관리 포함 요소 매핑 관점에서 보면 다음과 같은 대응 관계를 가짐\nSubject ↔ Observable 또는 Subject Observer ↔ next/error/complete 콜백을 가진 객체 notify ↔ next 호출 구독 관계 ↔ subscribe 호출 즉, RxJS는 기본 Observer 패턴에 연속 데이터 스트림, 비동기 처리, 구독 해제와 정리 같은 운영 요소를 더해 실무 활용도를 높인 형태\n주의와 한계 메모리 누수 리스크 구독 해제 누락 시 Observer가 참조 유지되어 GC가 불가해질 수 있음. unsubscribe 또는 구독 관리 유틸 사용 권장 호출 순서와 동기성 단순 구현은 동기 브로드캐스트가 기본. 비동기 순서 보장은 별도 설계 필요 에러 처리와 전파 기본 Observer 패턴에는 표준화된 에러 전파 방식 부재. RxJS는 error, complete로 보완 Pub/Sub와의 관계 개념적으로 유사. Observer는 객체 간 직접 참조가 전제되는 경우가 많고, Pub/Sub는 브로커를 두어 간접 라우팅하는 경우가 많음. 구현 선택은 시스템 결합도와 배포 토폴로지에 따라 결정 간단 예시 // 최소한의 흐름만 표현 subject.subscribe(observer) subject.notify(10) // 내부적으로 observer.update(10) 마무리 Observer 패턴은 한 객체의 이벤트를 여러 객체가 자동으로 구독하고 반응하는 구조 제공 RxJS는 이를 비동기 스트림으로 확장해 연속 데이터, 에러 처리, 구독 해제까지 포함하는 실용적 모델 제공\n참고자료 https://en.wikipedia.org/wiki/Observer_pattern https://rxjs.dev/guide/observer https://rxjs.dev/guide/subject ","permalink":"https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름\n발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름\n핵심은 느슨한 결합과 자동 알림 흐름 유지\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-구성요소\"\u003e핵심 개념과 구성요소\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSubject 또는 Observable\n\u003cul\u003e\n\u003cli\u003e이벤트를 발생시키는 주체\u003c/li\u003e\n\u003cli\u003eObserver 목록을 관리\u003c/li\u003e\n\u003cli\u003e상태가 변하면 observers에 알림 전파\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eObserver\n\u003cul\u003e\n\u003cli\u003e상태 변화를 알고 싶은 소비자\u003c/li\u003e\n\u003cli\u003eupdate 같은 콜백 보유\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003enotify\n\u003cul\u003e\n\u003cli\u003eSubject가 모든 Observer에게 브로드캐스트하는 동작\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eObserver가 Subject에 구독 등록\u003c/li\u003e\n\u003cli\u003eSubject 상태 변화 발생\u003c/li\u003e\n\u003cli\u003eSubject가 notify 실행, 등록된 Observer의 콜백 호출\u003c/li\u003e\n\u003cli\u003eObserver는 전달된 값에 따라 자체 로직 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e필수 인터페이스의 최소 형태는 아래와 같음\u003c/p\u003e","title":"Observer 패턴 제대로 이해하기 — 동작 원리와 RxJS 확장"},{"content":"개요 Object.entries는 객체의 키-값 쌍을 [key, value] 형태의 배열 리스트로 반환하는 표준 메서드임. 객체를 배열로 바꿔 순회, 변환, 자료구조 간 변환 같은 작업을 단순화하는 데 유용함\n문법 Object.entries(obj) 매개변수 obj: 키-값 쌍을 가진 객체 값 반환값: [key, value] 쌍의 2차원 배열 기본 예시 const user = { name: \u0026#39;Alice\u0026#39;, age: 25 } Object.entries(user) // [[\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;], [\u0026#39;age\u0026#39;, 25]] 배열로 변환되므로 for\u0026hellip;of, map 같은 배열 API에 바로 연결 가능\n순회와 변환 for\u0026hellip;of로 키와 값을 동시에 순회 가능\nfor (const [key, value] of Object.entries({ name: \u0026#39;Alice\u0026#39;, age: 25 })) { console.log(`${key}: ${value}`) }map으로 사람이 읽기 좋은 문자열 배열로 가공 가능\nObject.entries({ name: \u0026#39;Alice\u0026#39;, age: 25 }).map(([k, v]) =\u0026gt; `${k}: ${v}`) // [\u0026#39;name: Alice\u0026#39;, \u0026#39;age: 25\u0026#39;] Map으로 변환 키-값 페어를 유지한 채로 Map으로 손쉽게 변환 가능\nconst map = new Map(Object.entries({ name: \u0026#39;Alice\u0026#39;, age: 25 }))null 및 빈 객체 처리 빈 객체는 빈 배열 반환 null 또는 undefined에 대해 호출 시 TypeError 발생 Object.entries({}) // [] // Object.entries(null) -\u0026gt; 예외 발생 안전한 접근 예\nconst obj = null const entries = obj ? Object.entries(obj) : []TypeScript에서의 타입 기본적으로 Object.entries는 [string, any][] 또는 [string, unknown][]로 추론되는 경우가 많음. TS 버전과 대상 타입에 따라 달라질 수 있어 과신 금지 정확한 키와 값 타입을 유지하려면 얇은 헬퍼로 단언 처리\nfunction typedEntries\u0026lt;T extends object\u0026gt;(o: T) { return Object.entries(o) as [keyof T, T[keyof T]][] } type User = { name: string; age: number } const entries = typedEntries\u0026lt;User\u0026gt;({ name: \u0026#39;Alice\u0026#39;, age: 25 })또는 Record를 명시해 값 타입 범위를 제한하는 방법 사용\nconst user: Record\u0026lt;string, string | number\u0026gt; = { name: \u0026#39;Alice\u0026#39;, age: 25 } const entries = Object.entries(user) // [string, string | number][] 동작 특성 및 주의 own enumerable 프로퍼티만 대상. 프로토타입 체인의 프로퍼티는 제외됨 심볼 키는 무시됨. 필요 시 Object.getOwnPropertySymbols와 병행 고려 프로퍼티 열거 순서는 표준 규칙을 따름. 정수형 키 → 문자열 키 → 심볼 키 순서. 단, entries는 심볼 키 제외 키는 문자열로 반환됨. 숫자 키도 문자열화되어 반환됨 마무리 Object.entries는 객체 데이터를 배열 중심의 도구 체인으로 끌어오는 관문 역할을 함. 순회, 변환, Map 변환 같은 작업을 간결하게 만들며, TypeScript에서는 상황에 따라 보조 타이핑으로 안전성을 보완하는 전략이 유효함\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries https://tc39.es/ecma262/#sec-object.entries https://caniuse.com/mdn-javascript_builtins_object_entries https://www.typescriptlang.org/docs/handbook/2/objects.html https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html ","permalink":"https://blog.jsontapose.com/posts/object-entries-usage-and-notes-329c74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eObject.entries는 객체의 키-값 쌍을 [key, value] 형태의 배열 리스트로 반환하는 표준 메서드임. 객체를 배열로 바꿔 순회, 변환, 자료구조 간 변환 같은 작업을 단순화하는 데 유용함\u003c/p\u003e\n\u003ch3 id=\"문법\"\u003e문법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003eObject\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eentries\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003eobj\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e매개변수 obj: 키-값 쌍을 가진 객체 값\u003c/li\u003e\n\u003cli\u003e반환값: [key, value] 쌍의 2차원 배열\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"기본-예시\"\u003e기본 예시\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e user \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;Alice\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e age\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e25\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003eObject\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eentries\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// [[\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;], [\u0026#39;age\u0026#39;, 25]]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e배열로 변환되므로 for\u0026hellip;of, map 같은 배열 API에 바로 연결 가능\u003c/p\u003e\n\u003ch3 id=\"순회와-변환\"\u003e순회와 변환\u003c/h3\u003e\n\u003cp\u003efor\u0026hellip;of로 키와 값을 동시에 순회 가능\u003c/p\u003e","title":"Object.entries 사용법과 주의사항"},{"content":"개념/배경 백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함 직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함\n왜 중요한가 처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐\n생산자 1000 req/s, 소비자 100 req/s 가정 매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험 큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능 백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함 핵심 개념과 정의 Producer: 데이터를 생성·전송하는 주체 Consumer: 데이터를 수신·처리하는 주체 Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위 전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping 동작 원리/전략 A. 조절 Control/Throttling\n소비자가 당분간 수신 중단 또는 속도 저하 요구 Node.js Stream: stream.write가 false 반환 시 drain까지 쓰기 중단 TCP: 윈도우 사이즈 축소로 전송량 감소 B. 버퍼링 Buffering\n큐로 일시적 완충 메모리·스토리지 한계 존재, 포화 시 조절 또는 드롭과 병행 필요 C. 드롭 Dropping/Sampling\n최신성 우선 시 과거 데이터 폐기 영상 스트리밍에서 느린 네트워크 구간의 과거 프레임 건너뛰기 RxJS 연산자 throttleTime, debounceTime, sample을 통한 이벤트 솎아내기 기술별 적용 예시 RxJS debounceTime(1000)으로 1초 내 다수 입력을 마지막 1건만 처리해 드롭 구현 큐 시스템 Redis 기반 워커가 바쁠 때 작업을 가져오지 않고 큐에 대기시켜 버퍼링 수행, 소비자 확장으로 처리량 증가 가능 Node.js Streams readable.pipe(writable) 구성 시 런타임이 자동 백프레셔 수행, writable이 밀리면 readable 읽기 속도 조절됨 간단 예시 읽기와 쓰기 스트림을 수동으로 연결할 때의 최소 패턴 예시\nif (!writable.write(chunk)) { readable.pause() writable.once(\u0026#39;drain\u0026#39;, () =\u0026gt; readable.resume()) } write가 false면 쓰기 버퍼 포화 상태, drain 이후 재개 자동 pipe를 쓰면 동일 패턴이 내부 처리됨 주의와 베스트 프랙티스 버퍼는 유한, 포화 전제 하에 드롭 또는 조절 정책 설계 필요 드롭 기준은 도메인 의존, 최신성 vs 완전성 트레이드오프 명시 네트워크 경계와 서비스 경계를 넘는 파이프라인에서는 백프레셔 신호가 단절되지 않도록 프로토콜·큐 정책 정합성 확보 필요 모니터링 지표 권장: 큐 길이, 처리 지연 percentile, 메모리 사용량, 드롭율, 재시도율 요약 정의: 느린 소비자가 빠른 생산자에 속도 제한을 요구하는 흐름 제어 메커니즘 목적: OOM 방지, 지연 통제, 시스템 안정성 확보 방법: 조절 Control, 버퍼링 Buffer, 드롭 Drop의 조합으로 파이프라인 균형 유지 참고자료 https://nodejs.org/api/stream.html#streambackpressuregivesyouthepower https://rxjs.dev/guide/operators https://www.reactive-streams.org/ https://www.rfc-editor.org/rfc/rfc5681 https://docs.bullmq.io/ ","permalink":"https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003e백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함\n직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함\u003c/p\u003e\n\u003ch3 id=\"왜-중요한가\"\u003e왜 중요한가\u003c/h3\u003e\n\u003cp\u003e처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e생산자 1000 req/s, 소비자 100 req/s 가정\u003c/li\u003e\n\u003cli\u003e매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험\u003c/li\u003e\n\u003cli\u003e큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능\n백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eProducer: 데이터를 생성·전송하는 주체\u003c/li\u003e\n\u003cli\u003eConsumer: 데이터를 수신·처리하는 주체\u003c/li\u003e\n\u003cli\u003eBackpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위\u003c/li\u003e\n\u003cli\u003e전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리전략\"\u003e동작 원리/전략\u003c/h3\u003e\n\u003cp\u003eA. 조절 Control/Throttling\u003c/p\u003e","title":"백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴"},{"content":"개요 API 에러 규격의 핵심은 에러를 안정적으로 식별할 수 있는 Code 체계 확보임 HTTP Status만으로는 부족하고 메시지는 언어·맥락에 따라 바뀔 수 있음 실제로 계약으로서 신뢰할 수 있는 값은 error.code 임 아래는 다수의 글로벌 서비스에서 공통적으로 쓰는 Error Code 설계 원칙 정리\n설계 원칙 error.code 는 서비스 전반의 안정적인 식별자여야 함 메시지나 HTTP Status는 변경 가능하지만 error.code 는 변경 불가 구버전 클라이언트도 동일 코드를 신뢰해야 하므로 호환성 보장 필수 숫자형 대신 의미가 드러나는 문자열 기반 Enum 권장 숫자형은 의미 파악 어려움, 매뉴얼 의존, 협업 비용 증가 문자열 Enum은 가독성, 검색성, 커뮤니케이션 효율 우수 예시\n\u0026#34;USER_ALREADY_EXISTS\u0026#34; \u0026#34;INVALID_COUPON\u0026#34; \u0026#34;PAYMENT_INSUFFICIENT_BALANCE\u0026#34;네이밍 규칙 대문자 + 언더스코어 형태 CONSTANT_CASE 권장 언어/플랫폼 비종속, 문서화 시 표현 깔끔함 도메인 + 문제 유형 조합 권장 패턴: {DOMAIN}_{CONDITION} 예시\nUSER_NOT_FOUND 해당 유저를 찾을 수 없음 USER_ALREADY_EXISTS 이미 가입된 유저 AUTH_TOKEN_EXPIRED 인증 토큰 만료 ORDER_NOT_CANCELABLE 현재 상태에서는 주문 취소 불가 PAYMENT_INSUFFICIENT_BALANCE 잔액 부족 FILE_TOO_LARGE 허용 파일 크기 초과 카테고리 분리 전략 A. Prefix로 도메인 구분 권장\nAUTH_, USER_, ORDER_, PAYMENT_, COMMON_, FILE_ 등으로 그룹화 코드만 보고도 영역 식별 가능, 문서 구조화 용이 B. HTTP Status와 비즈니스 코드는 분리\n400_USER_INVALID_EMAIL 같은 결합은 지양 HTTP Status는 정책·맥락에 따라 변할 수 있으나 code는 절대 불변이어야 함 원칙 HTTP Status와 Error Code는 결합하지 않음 ErrorCode Enum 예시 NestJS/TypeScript 기준 예시\nexport enum ErrorCode { // ===== 공통 ===== INTERNAL_SERVER_ERROR = \u0026#39;INTERNAL_SERVER_ERROR\u0026#39;, INVALID_INPUT = \u0026#39;INVALID_INPUT\u0026#39;, VALIDATION_FAILED = \u0026#39;VALIDATION_FAILED\u0026#39;, RESOURCE_NOT_FOUND = \u0026#39;RESOURCE_NOT_FOUND\u0026#39;, // ===== Auth ===== AUTH_REQUIRED = \u0026#39;AUTH_REQUIRED\u0026#39;, AUTH_TOKEN_EXPIRED = \u0026#39;AUTH_TOKEN_EXPIRED\u0026#39;, AUTH_INVALID_TOKEN = \u0026#39;AUTH_INVALID_TOKEN\u0026#39;, // ===== User ===== USER_NOT_FOUND = \u0026#39;USER_NOT_FOUND\u0026#39;, USER_ALREADY_EXISTS = \u0026#39;USER_ALREADY_EXISTS\u0026#39;, USER_EMAIL_NOT_VERIFIED = \u0026#39;USER_EMAIL_NOT_VERIFIED\u0026#39;, // ===== Order ===== ORDER_NOT_FOUND = \u0026#39;ORDER_NOT_FOUND\u0026#39;, ORDER_NOT_CANCELABLE = \u0026#39;ORDER_NOT_CANCELABLE\u0026#39;, // ===== Payment ===== PAYMENT_INSUFFICIENT_BALANCE = \u0026#39;PAYMENT_INSUFFICIENT_BALANCE\u0026#39;, PAYMENT_METHOD_INVALID = \u0026#39;PAYMENT_METHOD_INVALID\u0026#39;, // ===== File Upload ===== FILE_TOO_LARGE = \u0026#39;FILE_TOO_LARGE\u0026#39;, FILE_UNSUPPORTED_TYPE = \u0026#39;FILE_UNSUPPORTED_TYPE\u0026#39;, }이 구성의 효과\n프론트·앱에서 조건 분기 용이 의미 중심 네이밍으로 직관성 확보 도메인 확장에 따른 추가가 간단 유지보수 비용 낮음 안티 패턴 숫자 코드만 사용 예시 \u0026ldquo;E4302\u0026rdquo; 의미 불명확, 협업 비용 증가 HTTP Status를 code에 포함 예시 \u0026ldquo;400_INVALID_EMAIL\u0026rdquo; Status 변경 시 code 불변 원칙과 충돌 지나치게 포괄적 네이밍 BAD_REQUEST, CONFLICT 등은 비즈니스 의미 전달 부족 전역 중복 이름 NOT_FOUND 단일 정의는 도메인 식별 불가 메시지 문구를 code에 포함 예시 \u0026ldquo;EMAIL_HAS_INVALID_FORMAT\u0026rdquo; 미묘한 정책 변경 시 관리 비용 증가, 번역·UX 변경 어려움 코드·메시지·HTTP Status 매핑 명확한 맵핑 구조를 두면 운영과 문서화가 단순해짐\nexport const ErrorMeta: Record\u0026lt;ErrorCode, { httpStatus: number; message: string }\u0026gt; = { INTERNAL_SERVER_ERROR: { httpStatus: 500, message: \u0026#39;서버 내부 오류가 발생했습니다.\u0026#39; }, INVALID_INPUT: { httpStatus: 400, message: \u0026#39;입력값이 잘못되었습니다.\u0026#39; }, VALIDATION_FAILED: { httpStatus: 400, message: \u0026#39;입력값 검증에 실패했습니다.\u0026#39; }, RESOURCE_NOT_FOUND: { httpStatus: 404, message: \u0026#39;리소스를 찾을 수 없습니다.\u0026#39; }, AUTH_REQUIRED: { httpStatus: 401, message: \u0026#39;인증이 필요합니다.\u0026#39; }, AUTH_TOKEN_EXPIRED: { httpStatus: 401, message: \u0026#39;인증 토큰이 만료되었습니다.\u0026#39; }, AUTH_INVALID_TOKEN: { httpStatus: 401, message: \u0026#39;잘못된 인증 토큰입니다.\u0026#39; }, USER_NOT_FOUND: { httpStatus: 404, message: \u0026#39;사용자를 찾을 수 없습니다.\u0026#39; }, USER_ALREADY_EXISTS: { httpStatus: 409, message: \u0026#39;이미 가입된 유저입니다.\u0026#39; }, USER_EMAIL_NOT_VERIFIED: { httpStatus: 403, message: \u0026#39;이메일 인증이 필요합니다.\u0026#39; }, ORDER_NOT_FOUND: { httpStatus: 404, message: \u0026#39;주문을 찾을 수 없습니다.\u0026#39; }, ORDER_NOT_CANCELABLE: { httpStatus: 409, message: \u0026#39;현재 주문은 취소할 수 없습니다.\u0026#39; }, PAYMENT_INSUFFICIENT_BALANCE: { httpStatus: 402, message: \u0026#39;잔액이 부족합니다.\u0026#39;, }, PAYMENT_METHOD_INVALID: { httpStatus: 400, message: \u0026#39;결제 수단이 유효하지 않습니다.\u0026#39;, }, FILE_TOO_LARGE: { httpStatus: 400, message: \u0026#39;파일이 너무 큽니다.\u0026#39; }, FILE_UNSUPPORTED_TYPE: { httpStatus: 400, message: \u0026#39;지원하지 않는 파일 형식입니다.\u0026#39; }, };전역 예외 필터 예시 사용법\nconst meta = ErrorMeta[exception.code]; return res.status(meta.httpStatus).json({ error: { code: exception.code, httpStatus: meta.httpStatus, message: meta.message, details: exception.details ?? null, traceId, timestamp, } });요점\nErrorCode는 비즈니스 의미 유지 HTTP Status, 메시지는 환경·정책에 맞게 별도 관리 관측성 지표로 traceId 등 메타데이터 포함 권장 도입 체크리스트 Code가 불변 계약인지 확인 API 계약 준수 Code만 보고 의미 파악 가능한지 확인 YES 기준 모든 코드에 고유 도메인 접두가 있는지 확인 USER, AUTH 등 HTTP Status와 code 결합 금지 여부 확인 결합 금지 메시지와 code의 독립성 확인 번역·UX 변경 용이성 Validation 오류 코드 일관성 확인 VALIDATION_FAILED 등 공용 코드 사용 로그에서 traceId 기반 추적 가능 여부 확인 운영 디버깅 용이성 마무리 좋은 Error Code 체계는 프론트·앱·백엔드 간 계약이자 디버깅·모니터링·UX 일관성을 좌우하는 핵심 설계 요소\ncode의 안정성 확보 비즈니스 의미 중심의 도메인 기반 네이밍 Status와 메시지의 분리된 관리 팀 합의 컨벤션으로 문서화와 운영 일관성 유지 이 네 가지를 충족하면 확장성과 유지보수성이 뛰어난 API 에러 설계로 평가 가능 참고자료 https://datatracker.ietf.org/doc/html/rfc7807 https://jsonapi.org/format/#errors ","permalink":"https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAPI 에러 규격의 핵심은 에러를 안정적으로 식별할 수 있는 Code 체계 확보임\nHTTP Status만으로는 부족하고 메시지는 언어·맥락에 따라 바뀔 수 있음\n실제로 계약으로서 신뢰할 수 있는 값은 error.code 임\n아래는 다수의 글로벌 서비스에서 공통적으로 쓰는 Error Code 설계 원칙 정리\u003c/p\u003e\n\u003ch3 id=\"설계-원칙\"\u003e설계 원칙\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eerror.code 는 서비스 전반의 안정적인 식별자여야 함\u003c/li\u003e\n\u003cli\u003e메시지나 HTTP Status는 변경 가능하지만 error.code 는 변경 불가\u003c/li\u003e\n\u003cli\u003e구버전 클라이언트도 동일 코드를 신뢰해야 하므로 호환성 보장 필수\u003c/li\u003e\n\u003cli\u003e숫자형 대신 의미가 드러나는 문자열 기반 Enum 권장\n\u003cul\u003e\n\u003cli\u003e숫자형은 의미 파악 어려움, 매뉴얼 의존, 협업 비용 증가\u003c/li\u003e\n\u003cli\u003e문자열 Enum은 가독성, 검색성, 커뮤니케이션 효율 우수\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e","title":"API ErrorCode Enum 설계 베스트 프랙티스"},{"content":"개요 Kubernetes에서 Taints는 노드에 거는 출입 제한 설정이고 Tolerations는 파드가 가진 출입 허용 키에 해당함 이 조합으로 스케줄러가 특정 파드를 특정 노드에서 배제하거나 허용하도록 제어 가능 비용이 높은 노드 보호, 장애 노드 격리, 점검 중 노드 비우기 같은 운영 시나리오에서 효과적임\n비유로 이해하기 노드가 VIP 라운지, Taint는 라운지 입구의 안내 표지, 파드는 손님, Toleration은 출입증에 해당함 Taint가 있는 노드에는 아무 파드나 배치되지 않음 해당 Taint를 허용하는 Toleration을 가진 파드만 스케줄링 가능\nTaint의 효과 종류 NoSchedule 해당 Toleration이 없으면 새 파드 스케줄링 금지 이미 노드에 있는 파드는 유지 특수 목적 노드에 일반 워크로드가 올라오는 것 방지에 가장 흔히 사용 PreferNoSchedule 가능하면 스케줄링하지 않도록 시도 여유 자원이 부족한 등 불가피하면 배치될 수 있음 유연한 격리가 필요할 때 선택 NoExecute 해당 Toleration이 없으면 새 파드 스케줄링 금지 이미 있는 파드도 퇴거 처리 노드 점검이나 문제 발생 시 파드를 신속히 비워야 할 때 사용 실제 사용 방법 단계 1 노드에 Taint 설정 kubectl로 직접 적용 가능\nkubectl taint nodes node-1 gpu=true:NoSchedule노드 그룹이 오토스케일링으로 증감하는 환경에서는 관리형 노드 그룹 수준에서 Taint를 선언해 두는 편이 안전함 이렇게 하면 새로 생성되는 노드에도 동일한 Taint가 자동 적용됨\n단계 2 파드에 Toleration 추가 해당 노드로 갈 수 있는 파드에 최소한의 Toleration만 추가 Deployment 등의 전체 매니페스트는 생략하고 핵심 블록만 예시로 표기함\nspec: tolerations: - key: \u0026#34;gpu\u0026#34; operator: \u0026#34;Equal\u0026#34; value: \u0026#34;true\u0026#34; effect: \u0026#34;NoSchedule\u0026#34;위 설정은 gpu=true NoSchedule Taint가 있는 노드에서도 이 파드가 스케줄링될 수 있음을 의미함\n함께 알아둘 점 Taints는 밀어내는 메커니즘이고 Tolerations는 그 배제를 무력화하는 출입 허용 키 역할임 특정 파드를 특정 노드로 반드시 보내고 싶다면 Node Affinity와 함께 사용 권장\nTaint로 일반 파드가 특수 노드에 올라오는 것을 차단 Node Affinity로 해당 파드가 그 노드를 선호하도록 선언 두 개를 동시에 써야 전용 노드 보장과 의도된 배치가 함께 충족됨\n운영 팁 GPU나 고성능 CPU 노드를 전용으로 보호하고 싶을 때 NoSchedule을 기본값으로 두고 필요한 워크로드에만 Toleration을 부여 장애나 점검으로 노드를 비워야 할 때 NoExecute 사용 검토 노드 자동 증설 환경에서는 노드 그룹 템플릿에 Taint를 선언해 누락을 방지 Toleration은 최소한으로 유지해 의도치 않은 노드 유입을 줄임 요약 목적 특정 노드에 일반 워크로드가 배치되지 않도록 차단하고 필요한 파드만 허용하기 위함 방법 노드에 Taint로 제한을 걸고 파드에 필요한 Toleration만 부여 주의 Taints는 배제를, Affinity는 선호를 표현하므로 전용 노드 보장은 두 기능을 함께 사용 특정 노드 그룹을 전용 용도로 쓰고 싶다면 지금 바로 Taint를 적용하고 필요한 파드에만 Toleration을 부여할 것\n참고자료 https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/ https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html ","permalink":"https://blog.jsontapose.com/posts/kubernetes-taints-tolerations-c1d4eb/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eKubernetes에서 Taints는 노드에 거는 출입 제한 설정이고 Tolerations는 파드가 가진 출입 허용 키에 해당함\n이 조합으로 스케줄러가 특정 파드를 특정 노드에서 배제하거나 허용하도록 제어 가능\n비용이 높은 노드 보호, 장애 노드 격리, 점검 중 노드 비우기 같은 운영 시나리오에서 효과적임\u003c/p\u003e\n\u003ch3 id=\"비유로-이해하기\"\u003e비유로 이해하기\u003c/h3\u003e\n\u003cp\u003e노드가 VIP 라운지, Taint는 라운지 입구의 안내 표지, 파드는 손님, Toleration은 출입증에 해당함\nTaint가 있는 노드에는 아무 파드나 배치되지 않음\n해당 Taint를 허용하는 Toleration을 가진 파드만 스케줄링 가능\u003c/p\u003e","title":"Kubernetes 스케줄링 제어를 위한 Taints와 Tolerations 개념과 사용법"},{"content":"개념과 배경 배열을 무작위로 섞을 때 Array.prototype.sort와 Math.random을 조합한 패턴이 흔히 보임\narray.sort(() =\u0026gt; Math.random() - 0.5) 형태는 간단해 보이지만 결과 분포가 한쪽으로 치우치는 편향이 발생함\n간단한 실험으로 [1, 2, 3]을 백만 회 섞어 빈도를 집계해 보면 특정 순열이 과도하게 많이 나오거나 적게 나오는 경향 관찰됨\n핵심은 Math.random 자체보다 sort에 전달된 비교 함수가 랜덤하게 일관성 없이 값을 내놓는 구조라는 점임\n왜 sort + random이 편향되는가 정렬 알고리즘은 비교 함수가 다음 성질을 만족한다고 가정함\n반대칭과 추이성 보장 같은 두 원소 비교 시 항상 같은 결과 반환 하지만 () =\u0026gt; Math.random() - 0.5는 같은 두 원소 쌍이라도 호출할 때마다 결과가 달라짐\n비교 결과의 비일관성으로 인해 정렬 알고리즘 동작이 정의에 가까운 보장 범위를 벗어남 엔진별 정렬 구현과 안정성 여부, 피벗 선택 전략 등에 따라 특정 패턴이 더 자주 발생하는 편향이 생김 즉 문제의 주된 원인은 비교 함수의 무작위성으로 인한 추이성 붕괴와 구현 의존성임\n참고로 Math.random은 자바스크립트 표준상 균등 분포의 유사난수를 제공하는 것이 목적이며 암호학적 보안은 보장하지 않음 보안 목적에는 window.crypto.getRandomValues 사용 권장\n올바른 해결책 피셔‑예이츠 셔플 피셔‑예이츠 셔플은 모든 순열을 동일 확률로 생성하는 균등 셔플 알고리즘임 배열의 끝에서 시작해 i 인덱스를 0 이상 i 이하에서 균일하게 고른 j와 교환하는 과정을 반복함\ni를 n-1에서 1까지 감소시키며 한 번씩 정확히 교환 수행 각 단계에서 선택 범위를 점차 줄이므로 중복 선택 없이 균등한 순열 공간을 탐색 간단 구현 예시\nfunction shuffle(array) { for (let i = array.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)) ;[array[i], array[j]] = [array[j], array[i]] } }위 구현은 i 단계에서 j를 0 이상 i 이하로 균일 추출해야 함 Math.floor(Math.random() * (i + 1)) 형태가 이 조건을 충족함\n검증 관찰 동일한 실험으로 [1, 2, 3]을 백만 회 셔플해 순열 빈도를 집계하면 모든 순열의 발생 비율이 거의 동일하게 수렴하는 패턴 관찰됨 샘플링 오차 범위 내에서 균등 분포 근사 확인 가능\n주의사항과 베스트 프랙티스 sort에 랜덤 비교 함수를 넘겨 셔플 구현하지 말 것 피셔‑예이츠에서 j 범위는 0 이상 i 이하가 되어야 하며 오프바이원 주의 Math.random은 보안용 아님, 게임 보상이나 추첨 등 금전적 가치가 걸린 시나리오에서는 암호학적 난원 필요 보안 민감 시 Web Crypto 기반으로 무작위 정수를 만들고 같은 알고리즘에 주입 암호학적 난수로 정수를 얻는 최소 스니펫 예시\nfunction cryptoRandomInt(maxExclusive) { const buf = new Uint32Array(1) window.crypto.getRandomValues(buf) return buf[0] % maxExclusive }실무에서는 모듈러 편향을 피하려면 거부 샘플링 등 추가 처리가 필요할 수 있음\n정리 sort + Math.random 패턴은 비교 함수의 비일관성 때문에 구현 의존적 편향 발생 가능성이 큼 균등한 셔플이 필요하면 피셔‑예이츠 셔플 사용 보안 요구가 있으면 난수 소스를 Web Crypto로 교체하고 동일 알고리즘을 적용 이 조합이 단순하며 빠르고 분포 품질도 신뢰 가능\n참고자료 https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/random https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort https://developer.mozilla.org/docs/Web/API/Crypto/getRandomValues https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle https://yceffort.kr/2021/09/javascript-random-number ","permalink":"https://blog.jsontapose.com/posts/javascript-fisher-yates-shuffle-and-sort-random-bias-96c3c0/","summary":"\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003e배열을 무작위로 섞을 때 Array.prototype.sort와 Math.random을 조합한 패턴이 흔히 보임\u003c/p\u003e\n\u003cp\u003earray.sort(() =\u0026gt; Math.random() - 0.5) 형태는 간단해 보이지만 결과 분포가 한쪽으로 치우치는 편향이 발생함\u003c/p\u003e\n\u003cp\u003e간단한 실험으로 [1, 2, 3]을 백만 회 섞어 빈도를 집계해 보면 특정 순열이 과도하게 많이 나오거나 적게 나오는 경향 관찰됨\u003c/p\u003e\n\u003cp\u003e핵심은 Math.random 자체보다 sort에 전달된 비교 함수가 랜덤하게 일관성 없이 값을 내놓는 구조라는 점임\u003c/p\u003e\n\u003ch3 id=\"왜-sort--random이-편향되는가\"\u003e왜 sort + random이 편향되는가\u003c/h3\u003e\n\u003cp\u003e정렬 알고리즘은 비교 함수가 다음 성질을 만족한다고 가정함\u003c/p\u003e","title":"자바스크립트에서 균등한 배열 셔플 구현 피셔‑예이츠와 sort+random 편향 이슈"},{"content":"개요 쿠버네티스는 명령을 조율하는 Control Plane과 실제 워크로드가 실행되는 Data Plane으로 구성됨 각 컴포넌트의 역할과 흐름을 이해하면 트러블슈팅, 성능 최적화, 보안 구성에 필요한 기준이 생김 클라우드 매니지드 쿠버네티스의 경우 Control Plane은 보통 제공자가 관리하지만 동작 원리 이해는 필수\nControl Plane API Server\n클러스터 유일 진입점 모든 컴포넌트와 사용자는 API Server를 통해 통신 인증과 권한 확인 수행 etcd\n클러스터 상태와 스펙을 보관하는 분산 키밸류 저장소 API Server만 직접 접근 가능 상태 복구의 근간이 되는 데이터 원장 Scheduler\n스케줄링 되지 않은 파드를 관찰하고 적합한 노드를 선택 리소스 사용량, 어피니티와 테인트, 스케줄링 정책 등을 고려 노드 선택만 담당하며 파드 생성은 수행하지 않음 Controller Manager\n다양한 컨트롤러의 이벤트 루프 집합 현재 상태를 관찰하고 선언적 원하는 상태를 유지하도록 조정 Cloud Controller Manager\n클라우드 공급자 API 연계 담당 예시 구성에서는 외부 로드밸런서 생성, 노드 라우팅 정보 동기화 등을 위임 Data Plane Kubelet\n노드별 에이전트 파드 스펙을 감시하고 컨테이너 런타임에 생명주기 명령 전달 파드 상태를 주기적으로 보고 kube-proxy\n서비스 네트워킹 데이터플레인 규칙 구현 iptables 또는 IPVS로 서비스, 엔드포인트 룰 관리 일부 CNI 구현은 eBPF 등으로 프록시 없이 동작 가능하나 일반적 구성에서는 규칙 기반 전송 사용 Container Runtime\n컨테이너 실행 엔진 역할 containerd가 현재 표준으로 널리 사용, 기타 CRI 호환 런타임 존재 Controllers 상세 Workload\nDeployment 웹앱 등 무상태 워크로드 롤링 업데이트와 롤백 관리 ReplicaSet 지정된 수의 파드 복제 개수 보장 DaemonSet 모든 노드 또는 선택된 노드에 1개씩 파드 배치, 로그나 모니터링 에이전트에 적합 StatefulSet 순서와 영속 스토리지 정체성이 필요한 워크로드에 적합 Job/CronJob 일회성 배치 또는 스케줄 주기 작업 Scaling\nHPA 메트릭 기반 파드 수 자동 조정 파드 생성 흐름 사용자가 스펙을 적용하면 API Server가 요청을 검증하고 etcd에 파드가 Pending으로 기록됨 Scheduler가 스케줄링 되지 않은 파드를 감지해 목표 노드를 결정함 해당 노드의 Kubelet이 할당 사실을 감지하고 컨테이너 런타임에 실행을 지시함 런타임이 컨테이너를 기동하면 Kubelet이 상태를 API Server에 보고하고 Running으로 갱신됨 Pod Deep Dive 논리적 위치\n파드는 컨테이너 런타임이 관리하는 격리된 실행 단위 내부에 존재 노드 \u0026gt; Kubelet \u0026gt; 런타임 \u0026gt; 파드 \u0026gt; 컨테이너 구조로 관리됨 기술적 원리\n네임스페이스로 격리, cgroup으로 자원 제한 적용 동일 파드 내 컨테이너는 네트워크 네임스페이스를 공유하므로 같은 IP 사용 디스크 경로 예시\n컨테이너 이미지와 레이어 배포판에 따라 /var/lib/containerd 등 런타임 디렉터리 사용 파드 로그 /var/log/pods 경로 활용하는 배포판 다수 존재 볼륨 마운트 /var/lib/kubelet/pods/[pod-uuid]/volumes 구조가 일반적 Pause 컨테이너\n파드 네임스페이스 소유자 역할을 하는 최소 컨테이너가 먼저 생성됨 나머지 컨테이너는 이 네임스페이스에 합류하여 동일 네트워크와 IPC, PID 환경을 공유 Networking Service\n변하는 파드 IP 위에 고정 진입점을 제공하는 가상 IP ClusterIP 클러스터 내부 통신용 LoadBalancer 외부 노출을 위한 L4 엔드포인트 Ingress\nL7 라우팅 구성으로 호스트와 경로 기반 분기 제공 매니지드 환경에서는 Ingress 컨트롤러가 외부 로드밸런서를 생성하고 규칙을 동기화 DNS\nCoreDNS가 서비스와 파드 이름을 IP로 해석해 통신 단순화 Storage 파드는 일시적 존재이므로 데이터 영속화를 위해 볼륨 필요 PV 클러스터에 프로비저닝된 실제 스토리지 추상화 PVC 워크로드가 요청하는 스토리지 스펙과 바인딩 요구사항 선언 동적 프로비저닝 StorageClass에 따라 CSI 드라이버가 자동으로 볼륨 생성과 바인딩 수행 가용영역 종속 스토리지의 이동 제약 존재, 다중 가용영역 공유가 필요하면 네트워크 파일시스템 계열 선택 고려 Configuration과 보안 Configuration\nConfigMap 비민감 설정 분리 보관 Secret 민감 정보 저장, 전송과 저장 시 보호 구성 필요 보안 경계와 권한\nNamespace로 워크로드와 리소스의 논리적 격리 구성 ServiceAccount는 파드의 신원 주체로 사용, RBAC로 권한 최소화 적용 클라우드 연계 환경에서는 서비스계정 기반 IAM 연동 기능이 제공되며, 파드 단위 외부 리소스 접근 권한을 세분화 가능 컨테이너 레벨 보안은 이미지 서명 검증, 런타임 권한 축소, PSP 대체 정책이나 정책 엔진 사용 등으로 보완 운영과 확장 생태계 Helm\n다수의 매니페스트를 차트로 패키징하여 템플릿 기반 배포와 버전 관리에 활용 Operators\n도메인 특화 운영을 자동화하는 커스텀 컨트롤러, 백업과 클러스터링 등 고급 시나리오 관리에 적합 노드 오토스케일링\n워크로드 대기로 인한 스케줄 실패 시 요구 리소스에 맞춘 노드 증설을 자동화하는 구성 사용 GitOps\n선언적 설정을 저장소에 보관하고 컨트롤러가 변경을 지속 동기화 배포와 롤백 이력이 명확하며 재현 가능성 확보에 유리 Service Mesh\n사이드카 프록시를 통해 mTLS, 라우팅 제어, 관측성 기능을 표준화하고 애플리케이션 수정 없이 적용 Observability\nPrometheus 계열로 메트릭 수집과 경보 구성 Grafana로 대시보드 시각화 Loki 등 로그 수집 스택으로 텍스트 로그 질의와 보관 수행 핵심 요약 Control Plane은 API Server, etcd, Scheduler, Controller Manager, 클라우드 연계 모듈로 구성 Data Plane은 노드 위 Kubelet, kube-proxy, 컨테이너 런타임과 파드로 구성 파드는 네임스페이스와 cgroup으로 격리되고 동일 파드 내 네트워크 공유 Service와 Ingress로 안정적 엔드포인트와 L7 라우팅 구성 PV와 PVC, StorageClass로 영속 스토리지 동적 프로비저닝 ConfigMap과 Secret으로 설정과 비밀 분리, ServiceAccount와 RBAC로 최소 권한 적용 Helm, Operators, 오토스케일러, GitOps, Mesh, 관측성 스택으로 운영 자동화와 가시성 강화 참고자료 https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/ https://kubernetes.io/docs/concepts/workloads/pods/ https://kubernetes.io/docs/concepts/services-networking/service/ https://kubernetes.io/docs/concepts/services-networking/ingress/ https://kubernetes.io/docs/concepts/storage/persistent-volumes/ https://kubernetes.io/docs/concepts/configuration/configmap/ https://kubernetes.io/docs/concepts/configuration/secret/ https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/ https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/ https://kubernetes.io/docs/concepts/extend-kubernetes/operator/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e쿠버네티스는 명령을 조율하는 Control Plane과 실제 워크로드가 실행되는 Data Plane으로 구성됨\n각 컴포넌트의 역할과 흐름을 이해하면 트러블슈팅, 성능 최적화, 보안 구성에 필요한 기준이 생김\n클라우드 매니지드 쿠버네티스의 경우 Control Plane은 보통 제공자가 관리하지만 동작 원리 이해는 필수\u003c/p\u003e\n\u003ch3 id=\"control-plane\"\u003eControl Plane\u003c/h3\u003e\n\u003cp\u003eAPI Server\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클러스터 유일 진입점\u003c/li\u003e\n\u003cli\u003e모든 컴포넌트와 사용자는 API Server를 통해 통신\u003c/li\u003e\n\u003cli\u003e인증과 권한 확인 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eetcd\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클러스터 상태와 스펙을 보관하는 분산 키밸류 저장소\u003c/li\u003e\n\u003cli\u003eAPI Server만 직접 접근 가능\u003c/li\u003e\n\u003cli\u003e상태 복구의 근간이 되는 데이터 원장\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eScheduler\u003c/p\u003e","title":"Kubernetes 아키텍처와 핵심 컴포넌트 정리"},{"content":"개요 객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님 키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함 중복 없는 집합 연산에는 Set이 자연스러운 선택지\n언제 객체 대신 Map을 고려할까 키를 자주 추가·삭제하는 동적 해시맵 패턴 안전한 반복과 구조 분해가 필요한 경우 키의 삽입 순서 유지가 중요한 경우 비문자열 키가 필요한 경우 // 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음 const mapOfThingsObj = {}; mapOfThingsObj[thing.id] = thing; delete mapOfThingsObj[thing.id]; // Map은 동적 추가·삭제에 최적화 const mapOfThings = new Map(); mapOfThings.set(thing.id, thing); mapOfThings.delete(thing.id);성능 배경 객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재 Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨 마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능\n참고 개념\n객체 셰이프 변화는 모노모픽 → 폴리모픽 전이 유발 가능 Map은 내부적으로 동적 키 공간에 최적화된 경로 제공 내장 키 오염 문제 객체는 프로토타입 체인에 의해 비어 있어도 여러 키가 이미 존재함\nconst myMapLikeObj = {}; myMapLikeObj.valueOf; myMapLikeObj.toString; myMapLikeObj.hasOwnProperty;임의 키-값 저장에서 우연히 충돌하거나 방어 코드가 필요해짐\n반복의 일관성 for..in은 상속된 키까지 순회 가능해 방어 코드 필요해짐\nfor (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { // 안전하지만 장황함 } } Object.keys(obj).forEach((key) =\u0026gt; { // 키만 순회 });Map은 표준 이터레이터를 제공하며 키와 값을 구조 분해로 즉시 획득 가능\nfor (const [key, value] of myMap) { // 깔끔한 순회 }키 순서 유지 Map은 삽입 순서를 보존함 정확한 순서로 구조 분해 가능\nconst [[firstKey, firstValue]] = myMap;LRU 캐시 같은 순서 기반 전략 구현에 유리함\n복사 객체는 전개나 assign으로 얕은 복사 쉬움\nconst copyObj = { ...obj }; const copyObj2 = Object.assign({}, obj);Map도 생성자에 이터러블을 넘겨 간단히 복사 가능\nconst copyMap = new Map(myMap);깊은 복사는 structuredClone 사용 가능\nconst deepCopyMap = structuredClone(myMap);Map ↔ 객체 상호 변환 Map → 객체\nconst objFromMap = Object.fromEntries(myMap);객체 → Map\nconst mapFromObj = new Map(Object.entries(obj));선언 시 객체 리터럴을 이용해 가독성 개선 가능\nconst myMap = new Map( Object.entries({ key: \u0026#34;value\u0026#34;, keyTwo: \u0026#34;valueTwo\u0026#34;, }) ); // 간단 헬퍼 const makeMap = (o) =\u0026gt; new Map(Object.entries(o)); const m = makeMap({ key: \u0026#34;value\u0026#34; });TypeScript 제네릭 형태\nconst makeMap = \u0026lt;V = unknown\u0026gt;(o: Record\u0026lt;string, V\u0026gt;) =\u0026gt; new Map\u0026lt;string, V\u0026gt;(Object.entries(o));키 타입 유연성과 WeakMap 객체 키는 문자열 또는 심볼로 제한됨 Map은 임의 객체를 키로 사용 가능\nmyMap.set({}, value); myMap.set([], value); myMap.set(document.body, value); myMap.set(() =\u0026gt; {}, value); myMap.set(myObj, value);메타데이터를 원본 객체에 오염 없이 부착하는 패턴에 유용함\nconst metadata = new Map(); metadata.set(myDomNode, { internalId: \u0026#34;...\u0026#34; }); metadata.get(myDomNode);단점은 참조를 보유하면 가비지 컬렉션이 지연되어 메모리 누수 위험 존재 이 경우 WeakMap 사용\nconst metadata = new WeakMap(); metadata.set(myTodo, { focused: true }); // 다른 강한 참조가 사라지면 자동으로 수거됨 Map 유틸리티 메서드 요약 map.clear() 전체 비우기 map.size 크기 조회 map.keys() 키 이터레이터 map.values() 값 이터레이터 Set과 WeakSet Set은 고유 요소 집합 표현에 적합하며 추가·삭제·조회가 단순하고 종종 배열 대비 성능상 유리\nconst set = new Set([1, 2, 3]); set.add(3); set.delete(4); set.has(5);객체 참조 집합에 대해 GC 친화성을 원하면 WeakSet 사용\nconst checked = new WeakSet([todo1, todo2]);직렬화 전략 JSON은 Map/Set을 직접 직렬화하지 않음 replacer와 reviver를 이용해 직렬화 규칙을 커스터마이즈 가능\nMap/Set을 직렬화를 위해 객체/배열로 변환\nfunction replacer(key, value) { if (value instanceof Map) return Object.fromEntries(value); if (value instanceof Set) return Array.from(value); return value; } const payload = { set: new Set([1, 2, 3]), map: new Map([[\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;]]) }; const json = JSON.stringify(payload, replacer);역직렬화 시 객체와 배열을 무조건 Map/Set으로 바꾸면 구분 불가 이슈 발생 타입 태그를 추가해 손실 없이 왕복 가능\nfunction taggedReplacer(key, value) { if (value instanceof Map) return { __type: \u0026#34;Map\u0026#34;, value: Object.fromEntries(value) }; if (value instanceof Set) return { __type: \u0026#34;Set\u0026#34;, value: Array.from(value) }; return value; } function taggedReviver(key, value) { if (value?.__type === \u0026#34;Map\u0026#34;) return new Map(Object.entries(value.value)); if (value?.__type === \u0026#34;Set\u0026#34;) return new Set(value.value); return value; } const obj = { set: new Set([1, 2]), map: new Map([[\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;]]) }; const str = JSON.stringify(obj, taggedReplacer); const roundTripped = JSON.parse(str, taggedReviver);언제 무엇을 쓸까 요약 구조가 고정된 도메인 객체는 객체 사용, 예 title, date 같은 명확한 스키마 const event = { title: \u0026#34;Conf\u0026#34;, date: new Date() }; 동적 키-값 저장과 빈번한 추가·삭제는 Map 사용 const events = new Map(); events.set(event.id, event); events.delete(event.id); 순서가 중요하고 중복 허용 목록은 배열 const list = [1, 2, 3, 2]; 중복 없는 집합이고 순서 중요하지 않으면 Set const uniq = new Set([1, 2, 3]);정리 객체는 구조화된 데이터 모델에, Map은 동적 해시맵 패턴에, Set은 고유 집합에 최적 성능은 실제 시나리오에서 검증하되, 키 추가·삭제와 반복·키타입 유연성 측면에서 Map이 갖는 일관된 장점이 큼 메모리 안전성이 필요한 참조 기반 메타데이터에는 WeakMap과 WeakSet 고려 권장\n참고자료 https://www.builder.io/blog/maps https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects https://developer.mozilla.org/en-US/docs/Web/API/structuredClone https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza ","permalink":"https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님\n키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함\n중복 없는 집합 연산에는 Set이 자연스러운 선택지\u003c/p\u003e\n\u003ch3 id=\"언제-객체-대신-map을-고려할까\"\u003e언제 객체 대신 Map을 고려할까\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e키를 자주 추가·삭제하는 동적 해시맵 패턴\u003c/li\u003e\n\u003cli\u003e안전한 반복과 구조 분해가 필요한 경우\u003c/li\u003e\n\u003cli\u003e키의 삽입 순서 유지가 중요한 경우\u003c/li\u003e\n\u003cli\u003e비문자열 키가 필요한 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e mapOfThingsObj \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emapOfThingsObj\u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003ething\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eid\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e thing\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003edelete\u003c/span\u003e mapOfThingsObj\u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003ething\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eid\u003cspan style=\"color:#eceff4\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// Map은 동적 추가·삭제에 최적화\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e mapOfThings \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e Map\u003cspan style=\"color:#eceff4\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emapOfThings\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eset\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ething\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eid\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e thing\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emapOfThings\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003edelete\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ething\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eid\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"성능-배경\"\u003e성능 배경\u003c/h3\u003e\n\u003cp\u003e객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재\nMap은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨\n마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능\u003c/p\u003e","title":"JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유"},{"content":"개요 signTypedData는 EIP-712 표준을 구현한 서명 메서드로 구조화된 데이터에 서명하기 위한 표준 인터페이스를 제공함 지갑은 사람이 읽을 수 있는 형태로 서명 내용을 표시하고, 서명은 특정 도메인과 체인에 귀속되어 재사용 공격을 줄임\nsignTypedData와 EIP-712의 관계 정의 signTypedData는 EIP-712 규격을 따르는 구조화 데이터 서명 메서드 이더리움 지갑 및 제공자에서 eth_signTypedData, eth_signTypedData_v3, eth_signTypedData_v4 형태로 노출 버전 signTypedData 최초 버전 signTypedData_v3 signTypedData_v4 가장 널리 사용되는 최신 버전 라이브러리 사용 ethers에서는 _signTypedData로 제공 const signature = await signer._signTypedData(domain, types, value) 지갑 연동은 일반적으로 provider에 직접 요청하는 방식 사용 const signature = await ethereum.request({ method: \u0026#39;eth_signTypedData_v4\u0026#39;, params: [account, JSON.stringify({ domain, types, message: value })], })동작 원리 요약 타입화된 구조체 정의 예시 구조체와 필드 타입을 정형화해 명세 도메인 분리자 사용 이름, 버전, 체인 ID, 검증 컨트랙트 주소를 포함해 서명 범위 고정 타입 해시와 데이터 해시 생성 타입 정의를 keccak256으로 해싱 후 데이터 인코딩 해시 생성 최종 해시에 서명 및 검증 지갑에서 서명 생성, 컨트랙트에서 도메인과 타입을 동일하게 재현해 검증 사용 예시 간단한 도메인, 타입, 메시지 구성 예시 const domain = { name: \u0026#39;MyApp\u0026#39;, version: \u0026#39;1\u0026#39;, chainId, verifyingContract } const types = { Action: [ { name: \u0026#39;user\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;amount\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] } const value = { user: userAddress, amount } // ethers 서명 const sig = await signer._signTypedData(domain, types, value) // 지갑 요청 v4 서명 const sig2 = await ethereum.request({ method: \u0026#39;eth_signTypedData_v4\u0026#39;, params: [account, JSON.stringify({ domain, types, message: value })], }) 컨트랙트 검증 예시 요약 // OpenZeppelin EIP712, ECDSA 사용 가정 bytes32 digest = _hashTypedDataV4( keccak256(abi.encode( keccak256(\u0026#34;Action(address user,uint256 amount)\u0026#34;), user, amount )) ) require(ECDSA.recover(digest, signature) == signer, \u0026#34;Invalid signature\u0026#34;)EIP-712 핵심 개념 정리 목적 사람이 읽을 수 있는 서명 메시지 제공 도메인에 귀속된 서명으로 리플레이 공격 저감 구조 타입화된 데이터 스키마와 도메인 분리자 타입 해시와 데이터 해시를 조합한 최종 해시 장점 지갑 UI에서 의미 있는 정보 노출로 UX 개선 다른 dApp이나 체인에서 재사용 어려움으로 보안 강화 주의사항과 팁 v4 사용 권장 v4는 가장 널리 지원되고 구조체 및 배열 표현이 안정적임 provider 요청 방식 web3 라이브러리 함수보다 ethereum.request의 eth_signTypedData_v4 사용이 호환성 측면에서 안전함 타입 정의 일치 컨트랙트와 클라이언트의 타입 이름, 필드 순서, 정수 크기 등 완전 일치 필요 도메인 정합성 chainId와 verifyingContract가 실제 네트워크와 배포 주소와 일치해야 검증 성공 데이터 인코딩 JS 측 정수값은 문자열 또는 BigNumber 형태 사용 권장, 오버플로와 반올림 이슈 회피 ethers 사용 시 types에 EIP712Domain을 포함하지 않음, _signTypedData가 도메인을 별도로 처리함 v4 메시지 포맷 params에 JSON.stringify로 { domain, types, message } 형태 전달 필요 마무리 signTypedData는 곧 EIP-712 사용을 의미하며 구조화된 데이터에 대한 안전한 서명을 가능하게 함 ethers의 _signTypedData 또는 지갑의 eth_signTypedData_v4를 사용해 서명하고, 컨트랙트에서는 동일한 도메인과 타입으로 해시를 재현해 검증하면 됨 명세 일치와 도메인 정합성만 확보하면 안전하고 예측 가능한 서명 흐름을 구현 가능\n참고자료 https://eips.ethereum.org/EIPS/eip-712 https://docs.ethers.org/v5/api/signer/#Signer-_signTypedData https://docs.metamask.io/wallet/how-to/sign-data/#sign-typed-data-v4 https://docs.openzeppelin.com/contracts/4.x/api/utils#EIP712 ","permalink":"https://blog.jsontapose.com/posts/eip-712-signtypeddata-guide-29efde/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003esignTypedData는 EIP-712 표준을 구현한 서명 메서드로 구조화된 데이터에 서명하기 위한 표준 인터페이스를 제공함\n지갑은 사람이 읽을 수 있는 형태로 서명 내용을 표시하고, 서명은 특정 도메인과 체인에 귀속되어 재사용 공격을 줄임\u003c/p\u003e\n\u003ch3 id=\"signtypeddata와-eip-712의-관계\"\u003esignTypedData와 EIP-712의 관계\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e정의\n\u003cul\u003e\n\u003cli\u003esignTypedData는 EIP-712 규격을 따르는 구조화 데이터 서명 메서드\u003c/li\u003e\n\u003cli\u003e이더리움 지갑 및 제공자에서 eth_signTypedData, eth_signTypedData_v3, eth_signTypedData_v4 형태로 노출\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e버전\n\u003cul\u003e\n\u003cli\u003esignTypedData 최초 버전\u003c/li\u003e\n\u003cli\u003esignTypedData_v3\u003c/li\u003e\n\u003cli\u003esignTypedData_v4 가장 널리 사용되는 최신 버전\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e라이브러리 사용\n\u003cul\u003e\n\u003cli\u003eethers에서는 _signTypedData로 제공\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e signature \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e signer\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e_signTypedData\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003edomain\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e types\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e value\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e지갑 연동은 일반적으로 provider에 직접 요청하는 방식 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e signature \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e ethereum\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003erequest\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  method\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;eth_signTypedData_v4\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  params\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003eaccount\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e JSON\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003estringify\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e domain\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e types\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e message\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e value \u003cspan style=\"color:#eceff4\"\u003e})],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"동작-원리-요약\"\u003e동작 원리 요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e타입화된 구조체 정의\n\u003cul\u003e\n\u003cli\u003e예시 구조체와 필드 타입을 정형화해 명세\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e도메인 분리자 사용\n\u003cul\u003e\n\u003cli\u003e이름, 버전, 체인 ID, 검증 컨트랙트 주소를 포함해 서명 범위 고정\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e타입 해시와 데이터 해시 생성\n\u003cul\u003e\n\u003cli\u003e타입 정의를 keccak256으로 해싱 후 데이터 인코딩 해시 생성\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e최종 해시에 서명 및 검증\n\u003cul\u003e\n\u003cli\u003e지갑에서 서명 생성, 컨트랙트에서 도메인과 타입을 동일하게 재현해 검증\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e간단한 도메인, 타입, 메시지 구성 예시\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e domain \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;MyApp\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e version\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;1\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e chainId\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e verifyingContract \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e types \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e Action\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;user\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e type\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;address\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e name\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;amount\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e type\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;uint256\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e value \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e user\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e userAddress\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e amount \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// ethers 서명\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e sig \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e signer\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e_signTypedData\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003edomain\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e types\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e value\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 지갑 요청 v4 서명\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e sig2 \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e ethereum\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003erequest\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  method\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;eth_signTypedData_v4\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  params\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003eaccount\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e JSON\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003estringify\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e domain\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e types\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e message\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e value \u003cspan style=\"color:#eceff4\"\u003e})],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e컨트랙트 검증 예시 요약\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-solidity\" data-lang=\"solidity\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// OpenZeppelin EIP712, ECDSA 사용 가정\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003ebytes32\u003c/span\u003e digest \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e _hashTypedDataV4\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1\"\u003ekeccak256\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eabi\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eencode\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#81a1c1\"\u003ekeccak256\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;Action(address user,uint256 amount)\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    user\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    amount\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1\"\u003erequire\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003eECDSA\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003erecover\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003edigest\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e signature\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e==\u003c/span\u003e signer\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;Invalid signature\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"eip-712-핵심-개념-정리\"\u003eEIP-712 핵심 개념 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e목적\n\u003cul\u003e\n\u003cli\u003e사람이 읽을 수 있는 서명 메시지 제공\u003c/li\u003e\n\u003cli\u003e도메인에 귀속된 서명으로 리플레이 공격 저감\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e구조\n\u003cul\u003e\n\u003cli\u003e타입화된 데이터 스키마와 도메인 분리자\u003c/li\u003e\n\u003cli\u003e타입 해시와 데이터 해시를 조합한 최종 해시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e장점\n\u003cul\u003e\n\u003cli\u003e지갑 UI에서 의미 있는 정보 노출로 UX 개선\u003c/li\u003e\n\u003cli\u003e다른 dApp이나 체인에서 재사용 어려움으로 보안 강화\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의사항과-팁\"\u003e주의사항과 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ev4 사용 권장\n\u003cul\u003e\n\u003cli\u003ev4는 가장 널리 지원되고 구조체 및 배열 표현이 안정적임\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eprovider 요청 방식\n\u003cul\u003e\n\u003cli\u003eweb3 라이브러리 함수보다 ethereum.request의 eth_signTypedData_v4 사용이 호환성 측면에서 안전함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e타입 정의 일치\n\u003cul\u003e\n\u003cli\u003e컨트랙트와 클라이언트의 타입 이름, 필드 순서, 정수 크기 등 완전 일치 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e도메인 정합성\n\u003cul\u003e\n\u003cli\u003echainId와 verifyingContract가 실제 네트워크와 배포 주소와 일치해야 검증 성공\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e데이터 인코딩\n\u003cul\u003e\n\u003cli\u003eJS 측 정수값은 문자열 또는 BigNumber 형태 사용 권장, 오버플로와 반올림 이슈 회피\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eethers 사용 시\n\u003cul\u003e\n\u003cli\u003etypes에 EIP712Domain을 포함하지 않음, _signTypedData가 도메인을 별도로 처리함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ev4 메시지 포맷\n\u003cul\u003e\n\u003cli\u003eparams에 JSON.stringify로 { domain, types, message } 형태 전달 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003esignTypedData는 곧 EIP-712 사용을 의미하며 구조화된 데이터에 대한 안전한 서명을 가능하게 함\nethers의 _signTypedData 또는 지갑의 eth_signTypedData_v4를 사용해 서명하고, 컨트랙트에서는 동일한 도메인과 타입으로 해시를 재현해 검증하면 됨\n명세 일치와 도메인 정합성만 확보하면 안전하고 예측 가능한 서명 흐름을 구현 가능\u003c/p\u003e","title":"EIP-712 기반 signTypedData 가이드와 지갑 연동 핵심"},{"content":"개요 NestJS는 대규모 서버 애플리케이션을 위한 구조화된 Node.js 프레임워크임 핵심은 Angular 스타일의 아키텍처, 강력한 의존성 주입 컨테이너, 데코레이터 기반 메타프로그래밍 조합 팀 규모가 커질수록 일관성과 유지보수성이 살아나는 타입스크립트 퍼스트 선택지임\n구조적 강제의 이점 Nest는 모듈 Module, 컨트롤러 Controller, 서비스 Service 구조를 강제함 계층 분리 패턴 BLL, DAL, 도메인 레이어 등 적용 용이 아키텍처가 일관되게 유지되어 4~10명 규모 팀에서 코드 스타일과 책임 경계가 흐트러지지 않음\nFastify, Express 같은 미니멀 프레임워크 대비 생산성과 일관성 측면에서 팀 단위 효율 우위\nDI 컨테이너 대부분의 Node 생태계 프레임워크는 DI가 없거나 약함 Nest는 DI를 코어에 두어 객체 간 결합도 낮춤 Mocking, 테스트, 레이어드 아키텍처 구성에 유리함 모듈 경계와 프로바이더 스코프가 명확해 대형 코드베이스에서 의존성 추적 비용 감소\n데코레이터 기반 선언적 API 클래스와 메타데이터 중심으로 라우팅과 바인딩을 선언적으로 기술 가능 스프링과 유사한 개발 경험 제공\n@Controller(\u0026#34;users\u0026#34;) export class UserController { @Get() findAll() {} }데코레이터는 의도를 드러내고 런타임 메타데이터 조회 경로를 단순화하여 가독성과 유지보수성에 기여\nCross‑cutting 도구 집합 Nest는 미들웨어만으로 처리하기 애매한 횡단 관심사를 1급 추상화로 제공함\nPipes 입력값 검증과 변환 책임 분리 Guards 인증과 인가 관문 정의 Interceptors 로깅, 응답 래핑, AOP 패턴 적용 Filters 예외 처리 경로 일원화 엔터프라이즈 백엔드에서 반복되는 보일러플레이트 축소 및 정책 일괄 적용에 적합 다양한 플랫폼 어댑터 HTTP 서버 외 다양한 프로토콜을 동일한 아키텍처로 운용 가능\nFastify Express GraphQL Apollo, Federation WebSocket 마이크로서비스 Kafka, RabbitMQ, Redis 등 하나의 구조로 멀티 프로토콜 애플리케이션 설계 가능 TypeScript 친화적 DX 타입 메타데이터 적극 활용 DTO와 class‑validator 조합으로 유효성 검증 일괄 적용 용이 Swagger 기반 API 문서화 자동화 쉬움 타입 안정성과 도구 체인이 맞물려 대규모 코드베이스에서 회귀를 줄임\n대형 서비스에서 유리한 이유 아키텍처 강제 덕분에 신규 인력 온보딩 속도 향상 기능을 모듈 단위로 분리해 독립적 개발과 배포 파이프라인 구성 용이 모노레포와 멀티 모듈 구조에 적합하여 레포 규모가 커져도 빌드와 테스트 전략 수립이 명확함\nNestJS 11.x 핵심 변화 Nest 11은 내부 아키텍처 리팩토링을 통해 더 빠르고 가벼운 동작을 목표로 함 사용법은 그대로 유지되며 성능과 DX가 개선됨\n메타데이터 처리 경로 최적화 Reflector 기반 조회 성능 향상, 데코레이터 처리 비용 감소 Fastify 4 정식 지원 HTTP 처리 성능과 플러그인 호환성 개선, Node 18/20 환경에서 최적화 표준 Node.js Fetch API 지원 강화 Axios 강제 아님, edge 런타임 연동 자연스러움, HTTP 모듈 경량화 경향 DI 엔진 최적화 프로바이더 해석과 스코프 계산 속도 향상, 모듈 수가 많을수록 체감 증가 Standalone 앱 구성 강화 모듈 없이도 안정적으로 애플리케이션 구성이 가능해 유틸리티성 워커나 CLI와 궁합 좋음 const app = await NestFactory.createApplicationContext({ providers: [...] }) SWC 기반 빌드 지원 강화 ts‑node 대비 빠른 컴파일과 낮은 메모리 사용, 대형 모노레포에서 빌드 시간 단축 체감 GraphQL 연동 개선 Apollo Federation v2 등 최신 기능과 정합성 향상, 스키마 생성 경로 최적화 테스트 환경 개선 TestingModule 초기화와 E2E 부트 속도 단축 동작 원리 요약 모듈이 애플리케이션의 경계를 정의하고 프로바이더가 의존성으로 주입됨 컨트롤러는 요청 엔드포인트를 노출하고 파이프와 가드, 인터셉터가 요청 라우팅 전후 파이프라인을 구성함 필터가 예외를 수집해 일관된 에러 응답을 생성함 플랫폼 어댑터는 HTTP, GraphQL, WebSocket, 마이크로서비스 등 전송 레이어 차이를 추상화함\n마무리 Nest는 구조적 강제와 DI를 바탕으로 팀 단위 생산성과 코드 일관성에 초점을 둔 프레임워크임 11.x에서는 내부 엔진 최적화와 현대적 런타임 지원이 강화되어 기존 코드베이스를 크게 흔들지 않고 성능과 DX를 동시에 끌어올릴 수 있음 필요하면 버전 9 → 10 → 11 변화 요약, 11의 성능 지표, Nest와 Fastify 또는 Express 생산성 비교, 팀 규모 4명 기준 선택 근거도 정리 가능함\n참고자료 https://docs.nestjs.com https://github.com/nestjs/nest/releases/tag/v11.0.0 https://github.com/nestjs/nest/releases/tag/v11.1.0 https://docs.nestjs.com/graphql/quick-start https://nodejs.org/api/globals.html#fetch https://www.fastify.io/docs/latest/Guides/Getting-Started/ ","permalink":"https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNestJS는 대규모 서버 애플리케이션을 위한 구조화된 Node.js 프레임워크임\n핵심은 Angular 스타일의 아키텍처, 강력한 의존성 주입 컨테이너, 데코레이터 기반 메타프로그래밍 조합\n팀 규모가 커질수록 일관성과 유지보수성이 살아나는 타입스크립트 퍼스트 선택지임\u003c/p\u003e\n\u003ch3 id=\"구조적-강제의-이점\"\u003e구조적 강제의 이점\u003c/h3\u003e\n\u003cp\u003eNest는 모듈 Module, 컨트롤러 Controller, 서비스 Service 구조를 강제함\n계층 분리 패턴 BLL, DAL, 도메인 레이어 등 적용 용이\n아키텍처가 일관되게 유지되어 4~10명 규모 팀에서 코드 스타일과 책임 경계가 흐트러지지 않음\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFastify, Express 같은 미니멀 프레임워크 대비 생산성과 일관성 측면에서 팀 단위 효율 우위\u003c/p\u003e","title":"NestJS 핵심 개념과 11.x 변화 정리 — 구조, DI, 데코레이터, 성능 업데이트"},{"content":"개요 개발 현장은 기술 변화가 빠르고 학습 범위가 넓음 이 환경에서 임포스터 증후군과 우월감 증후군은 자주 관찰되는 심리 상태이며, 같은 사람이 커리어 단계에 따라 두 상태를 오가기도 함 핵심 개념과 개발자 맥락에서의 징후, 발생 배경, 성장 곡선 상의 위치, 건강한 마인드셋을 정리함\n핵심 개념 임포스터 증후군\n스스로 실력을 과소평가하고 운이나 타인의 공 덕분에 현재 위치에 있다고 여기는 불안 심리 들킬 것 같은 두려움이 동반됨 개발자 맥락에서 보이는 징후\n구글링 의존을 부끄러워하며 자신을 가짜 개발자로 규정함 성과를 팀 운이나 외부 요인으로만 해석함 질문을 회피하고 비난을 두려워해 홀로 고립됨 더 알수록 모르는 영역이 보이며 시니어가 되어도 불안 증가 우월감 증후군\n자신이 타인보다 뛰어나고 자신의 방식만 정답이라고 믿는 태도 타인의 코드와 선택을 비하하는 경향 개발자 맥락에서 보이는 징후\n도구와 스택으로 급을 나누는 발언 빈발 문맥 파악 전 타인의 코드를 먼저 폄하함 설명을 생략하고 커뮤니케이션을 단절함 동작하는 코드를 스타일 이유로 과도하게 리팩터링하려는 강박 왜 생기는가 임포스터 증후군의 배경\nIT 도메인이 방대해 개인이 전부 알 수 없다는 구조적 한계 동료와 온라인 커뮤니티에서의 선택적 노출로 모두가 잘 아는 듯 보이는 착시 우월감 증후군의 배경\n더닝 크루거 효과로 지식이 얕을 때 자신감이 과도하게 상승하는 구간 존재 자신의 불안을 감추기 위한 방어 기제로 공격성이 표출될 수 있음 성장 곡선에서의 위치 입문 단계 코딩이 쉬워 보이고 자신감 급상승 우월감 증후군이 나타나기 쉬운 구간 성장 단계 깊이 들어갈수록 모르는 영역이 급증 임포스터 증후군으로 자신을 과소평가하기 쉬움 숙련 단계 모르는 것을 인정하고 검증 가능한 태도로 전환 필요 시 찾아보고 답하겠다는 합리적 대응 건강한 마인드셋 임포스터 다루기\n모르는 것은 결함이 아니라 학습 우선순위 신호로 보기 검색과 레퍼런스 활용은 프로페셔널의 표준 워크플로우로 인정 자신을 문제 해결 능력과 학습 속도로 정의하기 우월감 경계하기\n코드 품질은 문맥과 제약 조건 위에서 평가되어야 함을 상기 기술은 도구일 뿐 위계 수단 아님 나의 과거 코드도 시간이 지나면 개선 여지가 많음을 전제 실무적 체크리스트\n비판 전 배경 지식과 제약 조건 확인 의견 제시는 사실과 데이터, 재현 가능한 근거 중심으로 표현 리뷰는 문제 진단과 개선 제안 분리, 인신 비판 금지 학습 계획은 범위 축소와 단계적 확장 전략으로 설계\n마무리 두 증후군은 개발자라면 흔히 겪는 심리 패턴 증상 자체를 문제로 낙인찍기보다 신호로 해석하고 학습과 협업 방식을 조정하는 계기로 삼기 과도한 자기 비하와 근거 없는 우월감 모두 팀 생산성과 개인 성장에 비용을 유발하므로, 데이터 기반 피드백과 겸손한 탐구 태도로 균형 맞추기\n참고자료 https://en.wikipedia.org/wiki/Impostor_syndrome https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect https://psycnet.apa.org/record/1978-07774-001 ","permalink":"https://blog.jsontapose.com/posts/imposter-and-superiority-syndrome-in-developer-careers-81a0d5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e개발 현장은 기술 변화가 빠르고 학습 범위가 넓음\n이 환경에서 임포스터 증후군과 우월감 증후군은 자주 관찰되는 심리 상태이며, 같은 사람이 커리어 단계에 따라 두 상태를 오가기도 함\n핵심 개념과 개발자 맥락에서의 징후, 발생 배경, 성장 곡선 상의 위치, 건강한 마인드셋을 정리함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e임포스터 증후군\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스스로 실력을 과소평가하고 운이나 타인의 공 덕분에 현재 위치에 있다고 여기는 불안 심리\u003c/li\u003e\n\u003cli\u003e들킬 것 같은 두려움이 동반됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e개발자 맥락에서 보이는 징후\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구글링 의존을 부끄러워하며 자신을 가짜 개발자로 규정함\u003c/li\u003e\n\u003cli\u003e성과를 팀 운이나 외부 요인으로만 해석함\u003c/li\u003e\n\u003cli\u003e질문을 회피하고 비난을 두려워해 홀로 고립됨\u003c/li\u003e\n\u003cli\u003e더 알수록 모르는 영역이 보이며 시니어가 되어도 불안 증가\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e우월감 증후군\u003c/p\u003e","title":"개발자 커리어에서 마주치는 임포스터와 우월감 증후군 정리"},{"content":"개요 자바스크립트에서 날짜·시간을 다루는 일은 사소해 보이지만 버그가 가장 잦은 영역 중 하나임 day.js, moment.js, luxon 등 대안 존재하나 date-fns는 모듈화, 작은 크기, 불변성 중심 설계로 프런트엔드와 백엔드 모두에 적합함 아래는 date-fns와 date-fns-tz를 활용해 바로 써먹을 수 있는 23가지 패턴 정리\n핵심 개념 Date 객체는 타임존이 아닌 UTC 타임스탬프를 보유하는 값이라는 점이 핵심 date-fns 함수는 대부분 불변 동작, 인자로 받은 Date를 변경하지 않음 포맷팅은 format, 상대 표기는 formatDistance 계열, 구간 계산은 differenceIn*, intervalToDuration 등 사용 파싱은 parseISO 또는 parse로 명시적 포맷 지정 권장 타임존 변환은 date-fns-tz의 utcToZonedTime, zonedTimeToUtc, formatInTimeZone 사용 실전 패턴 현재 날짜와 시간 가져오기 const now = new Date() 특정 날짜·시간 설정 import { setMinutes, setHours } from \u0026#39;date-fns\u0026#39; const specific = setHours(setMinutes(new Date(), 30), 17) // 17:30 날짜 포맷팅 import { format } from \u0026#39;date-fns\u0026#39; const ymd = format(new Date(), \u0026#39;yyyy-MM-dd\u0026#39;) 기간 더하기·빼기 import { addDays, subMonths } from \u0026#39;date-fns\u0026#39; const inAWeek = addDays(new Date(), 7) const aMonthAgo = subMonths(new Date(), 1) 특정 요일까지 남은 일수 import { nextDay, differenceInDays } from \u0026#39;date-fns\u0026#39; const nextMon = nextDay(new Date(), 1) // 0 일요일, 1 월요일 const d = differenceInDays(nextMon, new Date()) 두 날짜 차이 계산 import { differenceInDays } from \u0026#39;date-fns\u0026#39; const diff = differenceInDays(new Date(2023, 11, 31), new Date(2023, 0, 1)) 동일한 날짜 비교 import { isSameDay } from \u0026#39;date-fns\u0026#39; const same = isSameDay(new Date(2023, 0, 1), new Date(\u0026#39;2023-01-01T05:00:00Z\u0026#39;)) 윤년 확인 import { isLeapYear } from \u0026#39;date-fns\u0026#39; const isLeap = isLeapYear(new Date(2024, 0, 1)) 날짜 유효성 검사 import { isValid } from \u0026#39;date-fns\u0026#39; const ok = isValid(new Date(\u0026#39;2023-02-30\u0026#39;)) // false 로컬과 특정 타임존 간 변환 import { utcToZonedTime, zonedTimeToUtc, formatInTimeZone } from \u0026#39;date-fns-tz\u0026#39; const tz = \u0026#39;America/New_York\u0026#39; const utc = zonedTimeToUtc(new Date(), tz) const inNY = utcToZonedTime(new Date(), tz) const shown = formatInTimeZone(new Date(), tz, \u0026#39;yyyy-MM-dd HH:mm:ssXXX\u0026#39;) 문자열 파싱 import { parseISO, parse } from \u0026#39;date-fns\u0026#39; const a = parseISO(\u0026#39;2023-01-01\u0026#39;) const b = parse(\u0026#39;01/02/2023 17:30\u0026#39;, \u0026#39;MM/dd/yyyy HH:mm\u0026#39;, new Date()) 상대 시간 표현 import { formatDistanceToNow } from \u0026#39;date-fns\u0026#39; import { ko } from \u0026#39;date-fns/locale\u0026#39; const rel = formatDistanceToNow(new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), { addSuffix: true, locale: ko }) 과거·미래 판별 import { isPast, isFuture } from \u0026#39;date-fns\u0026#39; const past = isPast(new Date(\u0026#39;2023-01-01\u0026#39;)) const future = isFuture(new Date(Date.now() + 60_000)) 특정 기간의 날짜 배열 생성 루프 대신 eachDayOfInterval 사용 권장\nimport { startOfMonth, endOfMonth, eachDayOfInterval } from \u0026#39;date-fns\u0026#39; const days = eachDayOfInterval({ start: startOfMonth(new Date(2023, 0)), end: endOfMonth(new Date(2023, 0)) }) 연도의 첫날·마지막 날 import { startOfYear, endOfYear } from \u0026#39;date-fns\u0026#39; const yStart = startOfYear(new Date()) const yEnd = endOfYear(new Date()) 간격을 사람이 읽는 문자열로 표현 import { intervalToDuration, formatDuration } from \u0026#39;date-fns\u0026#39; const dur = intervalToDuration({ start: new Date(2023, 0, 1), end: new Date(2023, 1, 1) }) const txt = formatDuration(dur) 타임존을 고려한 계산과 표시 계산은 UTC 기준, 표시만 타임존 적용 권장\nimport { addHours } from \u0026#39;date-fns\u0026#39; import { formatInTimeZone } from \u0026#39;date-fns-tz\u0026#39; const shippedAtUtc = addHours(new Date(), 5) const view = formatInTimeZone(shippedAtUtc, \u0026#39;Asia/Seoul\u0026#39;, \u0026#39;yyyy-MM-dd HH:mm\u0026#39;) 특정 날짜의 시작·끝 import { startOfDay, endOfDay } from \u0026#39;date-fns\u0026#39; const s = startOfDay(new Date()) const e = endOfDay(new Date()) 국제화 포맷팅 import { format } from \u0026#39;date-fns\u0026#39; import { ko, es } from \u0026#39;date-fns/locale\u0026#39; const d = new Date(2023, 0, 1) const koFmt = format(d, \u0026#39;PPP\u0026#39;, { locale: ko }) const esFmt = format(d, \u0026#39;PPP\u0026#39;, { locale: es }) 날짜 데이터 유효성 검증 심화 import { parseISO, isValid } from \u0026#39;date-fns\u0026#39; const input = \u0026#39;2023-01-01\u0026#39; const parsed = parseISO(input) const safe = isValid(parsed) 기간 내 특정 요일 모두 구하기 주 단위 앵커를 eachWeekOfInterval로 만들고 원하는 요일로 오프셋, 주 시작 요일 옵션 주의\nimport { eachWeekOfInterval, startOfYear, endOfYear, addDays } from \u0026#39;date-fns\u0026#39; const mondaysOfYear = (date) =\u0026gt; { const weeks = eachWeekOfInterval({ start: startOfYear(date), end: endOfYear(date) }, { weekStartsOn: 0 }) return weeks.map(w =\u0026gt; addDays(w, 1)) // 일요일 시작 기준 +1일 → 월요일 } 오늘로부터 N일 후 import { addDays } from \u0026#39;date-fns\u0026#39; const afterN = (n) =\u0026gt; addDays(new Date(), n) 분기 계산 import { getQuarter } from \u0026#39;date-fns\u0026#39; const q = getQuarter(new Date(2023, 5))주의사항 타임존 라벨은 반드시 IANA 이름 사용 예시 \u0026lsquo;Asia/Seoul\u0026rsquo;, \u0026lsquo;America/New_York\u0026rsquo; 등, \u0026lsquo;Local\u0026rsquo; 같은 임의 문자열 사용 불가 date-fns-tz에서 format 함수가 아닌 formatInTimeZone 사용 권장, 일반 포맷은 date-fns의 format 사용 포맷 토큰 주의 yyyy와 YYYY는 다름, 주차 기반 연도는 YYYY가 아닌 경우가 많음, date-fns는 소문자 yyyy 권장 formatDistanceToNow 결과 언어는 locale 옵션 없으면 영어, 한국어 표시는 locale: ko 필요 반복 계산 시 불변성 유지되어 안전하지만 Date 객체 생성 비용 존재, 대량 처리 시 배치 처리 또는 캐싱 고려 DST 전환 구간은 날짜 계산이 직관과 다를 수 있음, 타임존 표시만 바꾸고 계산은 UTC 기준으로 수행 권장 트리 셰이킹을 위해 필요한 함수만 개별 import 권장 마무리 date-fns는 작은 단위 함수들의 조합으로 날짜·시간 문제를 안정적으로 해결하게 해줌 포맷팅, 파싱, 구간 계산, 타임존과 국제화까지 대부분의 요구를 커버하며 불변성과 모듈성 덕에 유지보수에 유리함 위 패턴들을 팀 기준 유틸로 정리해두면 제품 전반의 시간 처리 일관성과 품질을 빠르게 끌어올릴 수 있음\n참고자료 https://date-fns.org/docs/Getting-Started https://date-fns.org/docs/format https://date-fns.org/docs/parse https://date-fns.org/docs/formatDistanceToNow https://github.com/marnusw/date-fns-tz https://date-fns.org/v3.6.0/docs/I18n-Examples ","permalink":"https://blog.jsontapose.com/posts/date-fns-javascript-date-time-23-patterns-d70145/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e자바스크립트에서 날짜·시간을 다루는 일은 사소해 보이지만 버그가 가장 잦은 영역 중 하나임\nday.js, moment.js, luxon 등 대안 존재하나 date-fns는 모듈화, 작은 크기, 불변성 중심 설계로 프런트엔드와 백엔드 모두에 적합함\n아래는 date-fns와 date-fns-tz를 활용해 바로 써먹을 수 있는 23가지 패턴 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDate 객체는 타임존이 아닌 UTC 타임스탬프를 보유하는 값이라는 점이 핵심\u003c/li\u003e\n\u003cli\u003edate-fns 함수는 대부분 불변 동작, 인자로 받은 Date를 변경하지 않음\u003c/li\u003e\n\u003cli\u003e포맷팅은 format, 상대 표기는 formatDistance 계열, 구간 계산은 differenceIn*, intervalToDuration 등 사용\u003c/li\u003e\n\u003cli\u003e파싱은 parseISO 또는 parse로 명시적 포맷 지정 권장\u003c/li\u003e\n\u003cli\u003e타임존 변환은 date-fns-tz의 utcToZonedTime, zonedTimeToUtc, formatInTimeZone 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실전-패턴\"\u003e실전 패턴\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e현재 날짜와 시간 가져오기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e now \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e특정 날짜·시간 설정\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e setMinutes\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e setHours \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e specific \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e setHours\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003esetMinutes\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e30\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e17\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 17:30\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e날짜 포맷팅\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e format \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e ymd \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e format\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;yyyy-MM-dd\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"4\"\u003e\n\u003cli\u003e기간 더하기·빼기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e addDays\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e subMonths \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e inAWeek \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e addDays\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e7\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e aMonthAgo \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e subMonths\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"5\"\u003e\n\u003cli\u003e특정 요일까지 남은 일수\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e nextDay\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e differenceInDays \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e nextMon \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e nextDay\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 0 일요일, 1 월요일\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e d \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e differenceInDays\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003enextMon\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e())\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"6\"\u003e\n\u003cli\u003e두 날짜 차이 계산\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e differenceInDays \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e diff \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e differenceInDays\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2023\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e11\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e31\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2023\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"7\"\u003e\n\u003cli\u003e동일한 날짜 비교\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e isSameDay \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e same \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e isSameDay\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2023\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;2023-01-01T05:00:00Z\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"8\"\u003e\n\u003cli\u003e윤년 확인\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e isLeapYear \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e isLeap \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e isLeapYear\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2024\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"9\"\u003e\n\u003cli\u003e날짜 유효성 검사\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e isValid \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e ok \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e isValid\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;2023-02-30\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// false\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"10\"\u003e\n\u003cli\u003e로컬과 특정 타임존 간 변환\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e utcToZonedTime\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e zonedTimeToUtc\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e formatInTimeZone \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns-tz\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e tz \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;America/New_York\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e utc \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e zonedTimeToUtc\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e tz\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e inNY \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e utcToZonedTime\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e tz\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e shown \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e formatInTimeZone\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(),\u003c/span\u003e tz\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;yyyy-MM-dd HH:mm:ssXXX\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"11\"\u003e\n\u003cli\u003e문자열 파싱\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e parseISO\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e parse \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e a \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e parseISO\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;2023-01-01\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e b \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e parse\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;01/02/2023 17:30\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;MM/dd/yyyy HH:mm\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e())\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"12\"\u003e\n\u003cli\u003e상대 시간 표현\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e formatDistanceToNow \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e ko \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns/locale\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e rel \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e formatDistanceToNow\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003enow\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e24\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e60\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e60\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1000\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e addSuffix\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etrue\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e locale\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e ko \u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"13\"\u003e\n\u003cli\u003e과거·미래 판별\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-js\" data-lang=\"js\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e isPast\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e isFuture \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e from \u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;date-fns\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e past \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e isPast\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;2023-01-01\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e future \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e isFuture\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eDate\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003enow\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e60_000\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"14\"\u003e\n\u003cli\u003e특정 기간의 날짜 배열 생성\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e루프 대신 eachDayOfInterval 사용 권장\u003c/p\u003e","title":"date-fns로 자바스크립트 날짜·시간 처리 23가지 실전 패턴"},{"content":"개요 Node.js에서 CommonJS(CJS)와 ESM(ES Modules)은 공존 상태이며, 신규 프로젝트는 ESM으로 전환되는 추세임. 두 시스템의 차이를 이해하면 번들 크기, 로딩 성능, 정적 분석, 생태계 호환에서 불필요한 시행착오 감소 가능\n배경 2009년 Node.js는 표준 모듈 시스템이 없던 시기라 CommonJS 채택 2015년 ES6에서 ESM이 언어 차원의 공식 표준으로 확정 2020년대 들어 Node.js가 ESM을 정식 지원, 브라우저와 규약 수렴 진행 CommonJS 요약 // export module.exports = { foo: 1 } exports.bar = 2 // import const { foo, bar } = require(\u0026#39;./utils\u0026#39;)특성\nrequire와 module.exports 사용 동기 로딩, 호출 시점에 블로킹 발생 런타임 해석 기반, 동적 require 가능 상대 경로에서 확장자 생략 가능 ESM 요약 // export export const foo = 1 export default function main() {} // import import { foo } from \u0026#39;./utils.js\u0026#39; import lodash from \u0026#39;lodash\u0026#39;특성\nimport와 export 사용 비동기 로딩, 병렬 가능 정적 분석 가능, tree-shaking 전제 충족 Node.js에서 상대 경로 사용 시 확장자 명시 필요 Tree-shaking 핵심 요지 사용하지 않는 export를 번들 단계에서 제거하는 최적화 기법 ESM의 정적 import 그래프가 전제 조건 CommonJS는 require가 동적이어서 안전한 제거가 어려움 간단 예시\n// utils.js export function add(a, b) { return a + b } export function sub(a, b) { return a - b } // main.js import { add } from \u0026#39;./utils.js\u0026#39; console.log(add(1, 2))번들러는 add만 포함 가능. sub는 제거 대상\n잘 동작하려면\n패키지와 앱 코드 ESM 사용 권장 사이드 이펙트 없는 모듈 구성 라이브러리는 package.json에 sideEffects: false 명시 또는 예외 파일만 whitelisting lodash 사례 요지\nimport _ from \u0026rsquo;lodash\u0026rsquo;는 전체 포함 위험 import { get } from \u0026rsquo;lodash-es\u0026rsquo;는 필요한 함수만 포함 유리 핵심 차이점 정리 문법\nCJS: module.exports, require ESM: export, export default, import 로딩 방식\nCJS: 동기 로딩, require 호출 지점 블로킹 ESM: 비동기 로딩, 브라우저 네이티브에서 병렬 요청 정합 정적 vs 동적 분석\nCJS: 런타임 결정, require(변수) 등 동적 패턴 허용, 사전 분석 어려움 ESM: 컴파일 타임 확정, import는 정적 문자열과 파일 상단 배치 요구, 미사용 코드 제거 가능 this 바인딩\nCJS: 최상위 this는 module.exports와 동일 ESM: 최상위 this는 undefined __dirname, __filename\nCJS: 기본 제공 ESM: 직접 생성 필요 import { fileURLToPath } from \u0026#39;url\u0026#39; import { dirname } from \u0026#39;path\u0026#39; const __filename = fileURLToPath(import.meta.url) const __dirname = dirname(__filename)JSON import\nCJS: require(\u0026rsquo;./config.json\u0026rsquo;) 가능 ESM: Node 18+에서 import assertions 사용 권장 import config from \u0026#39;./config.json\u0026#39; assert { type: \u0026#39;json\u0026#39; }또는 fs로 읽어 파싱\n브라우저 호환성\nCJS: 번들러 필요 ESM: 네이티브 지원, 동일 문법 사용 Top-level await\nCJS: 미지원 ESM: 지원 Node.js에서 ESM 사용하기 방법 1, package.json에 type 지정\n{ \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; }이 경우 .js는 ESM으로 해석, .cjs는 CJS로 강제 해석\n방법 2, 확장자로 구분\n.mjs는 ESM .cjs는 CJS .js는 package.json의 type 규칙을 따름 상대 경로 import 시 확장자 또는 exports 매핑 필요. 브라우저와 규칙을 맞추려면 확장자 명시 권장\n상호 운용성 ESM에서 CJS 가져오기\nimport lodash from \u0026#39;lodash\u0026#39;일반적으로 기본 내보내기 형태로 동작. 일부 라이브러리는 네임드 내보내기 호환성 제한 존재\nCJS에서 ESM 가져오기\n// require로 직접 로딩 불가 // 필요 시 동적 import 사용 const esm = await import(\u0026#39;./esm-module.mjs\u0026#39;)트레이드오프\nCJS 프로젝트에서 ESM 모듈을 섞을 때 비동기 경계 발생 초기화 순서와 로딩 타이밍에 주의 필요 번들링과 성능 관점 ESM은 정적 분석 기반으로 dead code 제거, 코드 스플리팅 최적화에 유리 CJS 패키지를 번들링할 때는 번들러가 안전을 위해 전체 포함하는 경우 빈번 라이브러리 선택 시 ESM 제공 여부와 sideEffects 메타데이터 확인 권장 현재 생태계 상황 신규 프로젝트는 ESM 권장 흐름 기존 라이브러리 상당수가 여전히 CJS를 배포하나, 점진적으로 dual package 또는 ESM 우선 제공으로 이동 중 Node.js는 CJS와 ESM 모두 지원. 브라우저와 번들러는 ESM 우선 설계가 보편 실무 선택 가이드 새 프로젝트는 ESM 우선. 브라우저와 서버 모두에서 일관된 모듈 해석 확보 기존 CJS 코드베이스는 점진 전환 전략 적용. 외부 의존성 호환성, 빌드 파이프라인 영향, 배포 타깃 고려 번들러 사용 환경에서는 ESM 의존성 채택이 번들 크기와 트리쉐이킹 품질에 유리 상대 경로 import에는 확장자 명시. 경로 해석 차이로 인한 런타임 오류 방지 JSON, __dirname 등 CJS 편의 기능은 ESM 전환 시 대체 패턴을 사전에 확보 TypeScript에서 nodenext의 의미 tsconfig 예시\n{ \u0026#34;module\u0026#34;: \u0026#34;nodenext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;nodenext\u0026#34; }의미\nNode.js의 최신 ESM 해석 규칙을 따르는 모듈 시스템 적용 import, export 문법과 package.json의 exports, type에 맞춘 해석 수행 상대 경로에는 확장자 요구. CJS와 ESM의 혼합 구성에 대한 Node 규칙을 TS 레벨에서 일치시킴 한 줄 요약\nnodenext는 타입스크립트의 모듈 시스템과 해석을 Node ESM 규칙에 정합시키는 설정 마무리 요약\nCommonJS는 역사적 배경과 생태계 호환에서 여전히 유효하나, 동기 로딩과 동적 해석으로 인해 정적 최적화에 불리 ESM은 언어 표준, 정적 분석, 브라우저 네이티브, top‑level await 등 현대적 요구에 부합 신규 개발은 ESM을 기본값으로 두고, CJS 상호 운용은 경계 최소화와 비동기 초기화 관리에 집중 권장 번들 크기와 로딩 성능이 중요하면 ESM과 sideEffects 메타데이터를 우선 고려 참고자료 https://nodejs.org/api/esm.html https://nodejs.org/api/modules.html https://nodejs.org/api/packages.html#type https://nodejs.org/api/esm.html#json-modules https://webpack.js.org/guides/tree-shaking/ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules https://www.typescriptlang.org/tsconfig#moduleResolution https://nodejs.org/api/esm.html#import-assertions ","permalink":"https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js에서 CommonJS(CJS)와 ESM(ES Modules)은 공존 상태이며, 신규 프로젝트는 ESM으로 전환되는 추세임. 두 시스템의 차이를 이해하면 번들 크기, 로딩 성능, 정적 분석, 생태계 호환에서 불필요한 시행착오 감소 가능\u003c/p\u003e\n\u003ch3 id=\"배경\"\u003e배경\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e2009년 Node.js는 표준 모듈 시스템이 없던 시기라 CommonJS 채택\u003c/li\u003e\n\u003cli\u003e2015년 ES6에서 ESM이 언어 차원의 공식 표준으로 확정\u003c/li\u003e\n\u003cli\u003e2020년대 들어 Node.js가 ESM을 정식 지원, 브라우저와 규약 수렴 진행\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"commonjs-요약\"\u003eCommonJS 요약\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// export\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003emodule\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eexports \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e foo\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexports\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003ebar \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// import\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e foo\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e bar \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e require\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;./utils\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e특성\u003c/p\u003e","title":"Node.js 모듈 시스템 정리: CommonJS와 ESM의 차이, 선택 기준, 상호 운용"},{"content":"개요 EVM 트랜잭션 수수료 모델은 자동차 연료 비유가 직관적임 Gas는 연료, 트랜잭션 수행은 목적지까지 주행이라는 맥락으로 이해하면 됨 핵심은 두 파라미터, Gas Limit와 Gas Price이며 EIP-1559 이후에는 Base Fee와 Priority Fee로 세분됨\n핵심 개념 Gas Limit\n이 트랜잭션이 최대 얼마만큼의 연산을 사용할 수 있는지에 대한 상한 단순 ETH 송금은 21,000 가스 고정값 수준 컨트랙트 실행은 로직 복잡도, 저장소 접근, 반복 등에 비례해 증가 사용하지 않은 가스는 환불, 부족하면 Out of Gas로 실패 후 사용한 가스 비용만큼 청구 Gas Price\n가스 1단위당 지불 단가, 단위는 Gwei (1 Gwei = 0.000000001 ETH) 네트워크 혼잡도에 따라 경쟁적으로 책정하는 입찰값 성격 높으면 포함 우선순위 상승, 낮으면 대기 또는 드롭 가능성 동작 원리 블록 프로듀서는 더 높은 보상을 주는 트랜잭션부터 포함하려는 경향 가스가 실행 중 소진되면 즉시 중단하고 상태 변경은 리버트 처리, 이미 사용된 가스 비용은 청구됨 가스 단가가 지나치게 낮으면 멤풀에서 장시간 대기하거나 노드 정책에 따라 제거될 수 있음 블록체인에 포함되지 않은 트랜잭션은 수수료 지불도 발생하지 않음 EIP-1559 이후의 구조 Base Fee 네트워크 혼잡도에 따라 프로토콜이 자동 조정하는 최소 수수료 성분 블록에 포함되면 소각됨 Priority Fee 블록 프로듀서에게 주는 팁 빠른 포함을 원할 때 상향 트랜잭션 필드 maxFeePerGas, maxPriorityFeePerGas 지정 실제 지불 단가인 effectiveGasPrice는 min(maxFeePerGas, baseFee + priorityFee)에 의해 결정됨 기존 gasPrice 단일 필드는 레거시 호환 목적, 현재는 타입2 트랜잭션 사용 권장 수수료 계산 기본식 총 수수료 = Gas Used × 단가 레거시 가정 단가 = Gas Price EIP-1559 가정 단가 = effectiveGasPrice = min(maxFeePerGas, baseFee + priorityFee) 총 수수료는 Gas Used × effectiveGasPrice이며, baseFee는 소각, priorityFee는 블록 프로듀서에게 전달 예시 단순 송금 케이스 Gas Used 21,000, Gas Price 20 Gwei 가정 총 수수료 = 21,000 × 20 Gwei = 420,000 Gwei = 0.00042 ETH EIP-1559 케이스 baseFee 15 Gwei, priorityFee 2 Gwei, maxFeePerGas 30 Gwei, Gas Used 21,000 effectiveGasPrice = min(30, 15 + 2) = 17 Gwei 총 수수료 = 21,000 × 17 Gwei = 357,000 Gwei = 0.000357 ETH 실패와 대기 시나리오 Gas Limit이 너무 낮은 경우 실행 도중 가스 소진으로 즉시 중단, 상태 리버트 사용한 가스 비용은 청구 블록에는 실패 상태로 기록 Gas Price가 너무 낮은 경우 멤풀 대기 또는 노드 정책에 따라 드롭 블록 미포함, 비용 지불 없음 익스플로러에서 pending으로 보일 수 있으나 확정 아님 한눈에 비교 상황 부족한 것 블록 포함 비용 상태 Out of Gas Gas Limit(연산량 상한) 포함됨 사용된 가스만큼 지불 Fail 및 Revert Underpriced Gas Price 또는 effectiveGasPrice 포함 안 됨 0 Pending → Drop 주의와 베스트 프랙티스 Gas Limit는 노드의 estimateGas 결과를 기본으로, 약간의 마진 추가 권장 반복적 저장소 쓰기나 루프가 있는 컨트랙트는 가스 변동성 큼, 경계 케이스에 대한 사전 시뮬레이션 필요 EIP-1559 사용 시 maxFeePerGas는 baseFee 변동을 흡수할 수 있도록 여유 있게, maxPriorityFeePerGas는 시장 상황에 맞춰 설정 멤풀 장기 대기 시 동일 nonce로 수수료를 상향해 트랜잭션 교체하는 전략 유효 실패 트랜잭션도 가스 비용 발생 가능, 리트라이 시 원인 분석 후 수정 재전송 권장 요약 Gas Limit은 작업량 상한, 부족하면 Out of Gas로 실패하며 이미 사용한 가스 비용 청구 Gas Price는 단가, 낮으면 대기 또는 드롭으로 블록 미포함 EIP-1559 이후 수수료는 baseFee 소각 + priorityFee 보상 구조이며, effectiveGasPrice에 의해 실제 지불 단가 결정 참고자료 https://ethereum.org/en/developers/docs/gas/ https://ethereum.org/en/developers/docs/transactions/ https://eips.ethereum.org/EIPS/eip-1559 ","permalink":"https://blog.jsontapose.com/posts/ethereum-gas-gas-limit-gas-price-eip-1559-157947/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eEVM 트랜잭션 수수료 모델은 자동차 연료 비유가 직관적임\nGas는 연료, 트랜잭션 수행은 목적지까지 주행이라는 맥락으로 이해하면 됨\n핵심은 두 파라미터, Gas Limit와 Gas Price이며 EIP-1559 이후에는 Base Fee와 Priority Fee로 세분됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGas Limit\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 트랜잭션이 최대 얼마만큼의 연산을 사용할 수 있는지에 대한 상한\u003c/li\u003e\n\u003cli\u003e단순 ETH 송금은 21,000 가스 고정값 수준\u003c/li\u003e\n\u003cli\u003e컨트랙트 실행은 로직 복잡도, 저장소 접근, 반복 등에 비례해 증가\u003c/li\u003e\n\u003cli\u003e사용하지 않은 가스는 환불, 부족하면 Out of Gas로 실패 후 사용한 가스 비용만큼 청구\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGas Price\u003c/p\u003e","title":"이더리움 가스 이해하기: Gas Limit, Gas Price, EIP-1559 정리"},{"content":"개요 테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임 인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함\nPrimary Key 지정 시 클러스터드 인덱스 생성 Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성 MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함\n핵심 개념 정리 클러스터드 인덱스\n테이블 데이터가 인덱스 키 순서로 정리되는 구조 테이블당 하나만 존재 리프 노드가 실제 레코드(전체 컬럼)를 보유 InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨 PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용 논클러스터드 인덱스(보조 인덱스, Secondary Index)\n테이블에 여러 개 생성 가능 리프 노드가 인덱스 키와 함께 클러스터드 인덱스 키(PK 또는 내부 Row ID)를 보유 보조 인덱스로 찾은 키로 다시 클러스터드 인덱스를 탐색하는 백투테이블 단계 발생 인덱스는 조회 성능 향상을 위해 쓰되, 인덱스가 늘어날수록 CUD 비용과 저장 공간이 증가하는 트레이드오프 존재\n동작 원리와 구조 B+Tree 탐색 흐름\n수직 탐색에서 루트 → 브랜치 → 리프 순으로 키 범위를 좁힘 보조 인덱스 사용 시 리프에서 얻은 클러스터드 키로 한 번 더 수직 탐색 수행 수평 탐색으로 리프 레벨에서 연속 키 스캔 가능 커버링 인덱스\n쿼리에 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 없이 인덱스만으로 결과 생성 추가 I/O 회피로 레이턴시 절감 접근 패턴과 I/O 특성\n시퀀셜 액세스: 물리적으로 인접한 페이지를 연속 읽기, 멀티 블록 I/O 활용, 대량 읽기에 유리 랜덤 액세스: 물리적으로 떨어진 페이지에 임의 접근, 단일 블록 I/O 빈번, 보조 인덱스 사용 시 다수 발생 SSD 환경에서도 무작위 접근 비용은 존재, 범위 스캔 대량 발생 시 체감 가능 InnoDB에서의 물리 정렬에 대한 오해 정리\n클러스터드 인덱스는 페이지 단위로 키 순서를 유지하도록 관리되지만, 디스크 상에서 완전한 순차 배치가 되는 것은 아님 랜덤 삽입이나 페이지 분할이 반복되면 물리적 연속성이 낮아질 수 있음 단조 증가 PK(auto increment 등) 사용 시 페이지 분할과 랜덤 쓰기 감소 효과 기대 MySQL 실행 흐름과 옵티마이저 관점 쿼리 캐시\nMySQL 8.0에서 제거됨 파싱과 전처리\n문법 검증 및 의미 분석 수행 최적화 단계\n실행계획 생성 조건 절 분류, 인덱스 선택, 조인 순서 결정 통계 정보와 비용 모델 기반으로 테이블 풀 스캔과 인덱스 스캔 중 비용이 낮은 경로 선택 스토리지 엔진 핸들러\nInnoDB가 페이지 읽기와 버퍼풀 관리를 담당 MySQL 엔진은 반환된 레코드로 조인, 정렬, 집계를 수행 실행 계획 확인\nEXPLAIN으로 실제 접근 경로 점검 권장 테이블 풀 스캔 vs 인덱스 레인지 스캔 Table Full Scan\n테이블 전체를 시퀀셜 액세스로 읽으며 멀티 블록 I/O 활용 큰 테이블에서 대량 결과 반환 시 효율적 Index Range Scan\n인덱스 트리에서 범위 탐색 후 필요 시 백투테이블 단계 수행 랜덤 액세스와 단일 블록 I/O가 많아지는 경향 작은 결과 집합을 빠르게 찾는 데 유리 손익분기점 관찰치\n데이터 규모와 하드웨어, 버퍼풀 히트율에 따라 달라짐 업무 환경에서 5~20% 선택도 구간에서 테이블 풀 스캔이 더 빠르게 전환되는 사례 빈번 빅테이블에서 결과 비율이 높아질수록 인덱스 경로는 점진적으로 불리 인덱스 설계 시 주의와 베스트 프랙티스 모든 WHERE 조건에 인덱스 남발 금지\n각 인덱스는 쓰기 비용과 저장 공간 증가를 동반 다수 인덱스는 옵티마이저 선택 혼선을 키울 수 있음 PK 설계\n짧고 단조 증가하는 키 선호 무작위 UUID v4는 페이지 분할과 랜덤 쓰기 유발 위험, 시간순 UUID 대안 고려 보조 인덱스 구성\n선택도 높은 컬럼 우선 결합 인덱스는 좌측 접두사 규칙 고려, 자주 결합되는 조건 묶기 커버링 인덱스가 큰 이득을 주는 빈도 높은 쿼리에 한정 적용 SARGable 조건 유지\n인덱스 컬럼에 함수 적용, 계산, 캐스팅이 있으면 인덱스 사용 저해 가능성 가능한 원형 비교 유지, 필요한 경우 생성 칼럼과 인덱스 조합 검토 통계와 실행 계획 점검\nANALYZE TABLE로 통계 최신화 EXPLAIN, 실행 프로파일링으로 계획 검증 저장 공간과 CUD 비용 이해\n추가 인덱스마다 페이지 유지와 분할, 리밸런싱 비용 증가 저장 공간 증가는 인덱스 키 길이와 카디널리티에 의존, 대략 테이블 크기의 두 자릿수 퍼센트까지 늘어날 수 있음 간단 예시 인덱스 생성 예\n단일 컬럼 ALTER TABLE UserTable ADD INDEX idx_closed_at (closed_at) 다중 컬럼 ALTER TABLE UserTable ADD INDEX idx_created_lastmod (created_at, last_modified_at) 조회 예\n전체 조회는 테이블 풀 스캔 경로 선택 가능성 높음 SELECT * FROM EmployeeTable PK로 단건 조회는 클러스터드 인덱스 탐색 경로 SELECT * FROM EmployeeTable WHERE employee_id = 1 보조 인덱스 컬럼 조회는 인덱스 레인지 스캔 후 백투테이블 SELECT * FROM EmployeeTable WHERE name = 'Kim' 커버링 인덱스 예\nINDEX(name, created_at)가 있고 SELECT name, created_at FROM EmployeeTable WHERE name = 'Kim' 처럼 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 생략 가능 언제 풀 스캔이 더 나은가 결과 비율이 높아 랜덤 액세스가 폭증하는 경우 조건이 낮은 선택도로 인덱스 이득이 미미한 경우 정렬이나 조인 전략 관점에서 풀 스캔이 총비용이 낮게 추정되는 경우 경계값은 시스템마다 상이하므로 실제 데이터로 벤치마킹하여 결정하는 것이 안전\n요약과 결론 클러스터드 인덱스는 테이블 자체의 정렬 구조, 보조 인덱스는 검색 보조 구조 소량 결과를 빠르게 찾을 때는 보조 인덱스 경로, 대량 읽기에는 풀 스캔이 유리한 구간 존재 인덱스는 비용이 있는 도구, 자주 쓰이는 고선택도 조건과 커버링 효과가 큰 쿼리에 집중 투자 PK는 짧고 단조 증가하는 키가 안전, 보조 인덱스는 쿼리 패턴 기반으로 최소 집합 유지 EXPLAIN과 통계 최신화를 통해 계획을 검증하고, 쿼리와 데이터 특성에 맞춰 지속 조정 참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html https://dev.mysql.com/doc/refman/8.0/en/query-cache.html https://www.sqlservercentral.com/articles/nonclustered-index-structure https://sihyung92.oopy.io/database/mysql-index ","permalink":"https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임\n인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary Key 지정 시 클러스터드 인덱스 생성\u003c/li\u003e\n\u003cli\u003eUnique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념-정리\"\u003e핵심 개념 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e클러스터드 인덱스\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e테이블 데이터가 인덱스 키 순서로 정리되는 구조\u003c/li\u003e\n\u003cli\u003e테이블당 하나만 존재\u003c/li\u003e\n\u003cli\u003e리프 노드가 실제 레코드(전체 컬럼)를 보유\u003c/li\u003e\n\u003cli\u003eInnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨\u003c/li\u003e\n\u003cli\u003ePK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e논클러스터드 인덱스(보조 인덱스, Secondary Index)\u003c/p\u003e","title":"MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준"},{"content":"개념과 배경 마이크로서비스로 분산이 심화되면 로깅, 모니터링, 보안, 네트워킹 같은 공통 기능을 어디에 둘지 결정이 어려워짐 애플리케이션 코드에 공통 기능을 계속 끼워 넣으면 침투와 중복 증가, 배포와 버전 관리 복잡도 상승 사이드카 패턴은 공통 기능을 별도 컨테이너로 분리해 메인 서비스는 비즈니스 로직에 집중하게 하는 접근법 컨테이너 오케스트레이션 환경에서 일관된 운영 모델을 제공한다는 점이 실무적 장점\n핵심 개념 사이드카 패턴의 구성 요소\n메인 컨테이너: 비즈니스 로직 담당, 웹 서비스나 API 서버 등 사이드카 컨테이너: 횡단 관심사 처리, 로그 수집, 모니터링 에이전트, 프록시, 보안 검사 등 같은 파드 내 배치로 네트워크 네임스페이스와 볼륨 공유 가능, 표준 출력/공유 볼륨 등을 통해 데이터 연계 업데이트와 배포를 컨테이너 단위로 분리해 독립적 버전 관리 가능 동작 원리 하나의 파드에 메인 컨테이너와 사이드카 컨테이너를 함께 배치\n트래픽 프록시형 사이드카: 인바운드/아웃바운드 트래픽 프록시, 정책 집행과 텔레메트리 수집 수행 로그/메트릭형 사이드카: 애플리케이션은 표준 출력 또는 파일에 기록, 사이드카가 수집 후 중앙 시스템으로 전달 보안형 사이드카: 인증서 갱신, 토큰 주입, 요청 검증 같은 보조 기능 처리 파드 라이프사이클이 공유되어 함께 스케줄링되며, 준비성 프로브와 헬스 체크로 상호 의존성 관리 필요 장점 코드 침투 최소화 및 모듈 경계 명확화 공통 기능 표준화와 재사용성 확보 독립적 릴리스와 롤백 용이성 확보 환경 간 일관성 강화 및 운영 자동화 적합 단점 파드당 컨테이너 증가로 CPU·메모리 오버헤드 발생 가능 빌드·배포 파이프라인과 템플릿 복잡도 상승 사이드카 장애가 메인 경로에 간접 영향 줄 수 있음, 감시와 격리 전략 필요 간단한 요구에 적용하면 오버엔지니어링 리스크 존재 도입 시 고려사항 필요성 판단\n공통 기능의 복잡도 높음, 정책 변화 잦음, 서비스 다수에 일관 적용 필요할 때 적합 단순 기능은 라이브러리 또는 애플리케이션 내 구현이 비용 대비 효율적일 수 있음 리소스와 스케일링\n컨테이너별 요청·제한 자원 설정 필수 HPA 등 스케일 정책 수립, 사이드카 메트릭 기반 병목 모니터링 필요 운영 성숙도\n쿠버네티스, 프록시, 서비스 메시 개념 이해 요구 템플릿화와 정책 관리 체계 필요, DevOps 운영 역량 전제 장애 대응\n사이드카 비정상 시 알람, 자동 복구, 격리 전략 수립 준비성/활성 프로브 정교화, 백프레셔와 재시도 정책 명시 간단 예시 로그 수집 사이드카 적용\n메인 애플리케이션은 로그를 표준 출력으로 남김 사이드카 에이전트가 파드 내 로그를 수집해 중앙 로깅으로 전송 애플리케이션 코드는 로깅 라이브러리와 출력만 책임, 전송·포맷·재시도 정책은 사이드카가 담당 마무리 사이드카 패턴은 메인 서비스의 독립성을 유지하면서 횡단 관심사를 일관되게 적용할 수 있는 실용적 선택지 분명한 이점이 있으나 자원 오버헤드, 배포 복잡도, 장애 전파 가능성 등의 트레이드오프 존재 업무 요구와 운영 역량, 인프라 여건을 모아 비용 대비 효과가 명확한 경우에만 도입하는 것이 안전 적절한 프로브·알람·표준 템플릿과 함께 설계하면 장애 상황에서도 예측 가능한 동작을 보장하기 쉬움\n참고자료 https://learn.microsoft.com/en-us/azure/architecture/patterns/sidecar https://www.ibm.com/think/topics/service-mesh ","permalink":"https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/","summary":"\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003e마이크로서비스로 분산이 심화되면 로깅, 모니터링, 보안, 네트워킹 같은 공통 기능을 어디에 둘지 결정이 어려워짐\n애플리케이션 코드에 공통 기능을 계속 끼워 넣으면 침투와 중복 증가, 배포와 버전 관리 복잡도 상승\n사이드카 패턴은 공통 기능을 별도 컨테이너로 분리해 메인 서비스는 비즈니스 로직에 집중하게 하는 접근법\n컨테이너 오케스트레이션 환경에서 일관된 운영 모델을 제공한다는 점이 실무적 장점\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cp\u003e사이드카 패턴의 구성 요소\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메인 컨테이너: 비즈니스 로직 담당, 웹 서비스나 API 서버 등\u003c/li\u003e\n\u003cli\u003e사이드카 컨테이너: 횡단 관심사 처리, 로그 수집, 모니터링 에이전트, 프록시, 보안 검사 등\n같은 파드 내 배치로 네트워크 네임스페이스와 볼륨 공유 가능, 표준 출력/공유 볼륨 등을 통해 데이터 연계\n업데이트와 배포를 컨테이너 단위로 분리해 독립적 버전 관리 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cp\u003e하나의 파드에 메인 컨테이너와 사이드카 컨테이너를 함께 배치\u003c/p\u003e","title":"사이드카 패턴 이해와 도입 판단 가이드: 마이크로서비스·쿠버네티스에서의 활용"},{"content":"개념/배경 Node.js 프로세스 레벨에서 잡히지 않은 에러를 마지막으로 처리하는 안전망을 두는 목적 정리 애플리케이션 어디에서도 처리되지 못한 오류를 기록하고 종료 경로를 일관되게 관리하기 위함 프로덕션 환경에서 원인 파악과 사후 조치 자동화를 위한 최소 장치로 간주\n핵심 이벤트 두 가지 이벤트가 글로벌 핸들러의 대상\nuncaughtException try-catch로 포착되지 않은 동기 오류가 호출 스택 끝까지 전파될 때 발생 핸들러가 없으면 프로세스가 비정상 종료됨 // 동기 에러가 상위에서 잡히지 않은 경우 function boom() { throw new Error(\u0026#39;폭발\u0026#39;) } boom() unhandledRejection Promise가 reject되었으나 await 혹은 .catch로 처리되지 않은 경우 발생 Node.js 15+ 기본 동작은 핸들러가 없을 때 프로세스 종료 // reject가 소비되지 않은 경우 async function asyncBoom() { throw new Error(\u0026#39;비동기 폭발\u0026#39;) } asyncBoom()왜 글로벌 핸들러인가 코드 최상위에서 아무도 잡지 못한 에러에 대한 마지막 안전망 역할\n통일된 포맷으로 치명적 오류 로깅 시간, 환경, 실행 컨텍스트 등 추가 맥락 기록 용이 알림 전송, 임시 리소스 정리 같은 최소 후처리 수행 종료 코드 일관화 및 관찰성 강화 예시 핸들러가 없을 때의 기본 동작은 스택트레이스 출력 후 종료\n// main.ts async function bootstrap() { throw new Error(\u0026#39;부트스트랩 실패\u0026#39;) } bootstrap()출력 예\n/Users/.../main.ts:2 throw new Error(\u0026#39;부트스트랩 실패\u0026#39;) ^ Error: 부트스트랩 실패 at bootstrap (/Users/.../main.ts:2:9) ...핸들러를 둘 경우 포맷을 통일해 기록 후 종료 가능\nprocess.on(\u0026#39;uncaughtException\u0026#39;, (error) =\u0026gt; { console.log(\u0026#39;=\u0026#39;.repeat(50)) console.log(\u0026#39;[FATAL] 작업이 비정상 종료 예정\u0026#39;) console.log(\u0026#39;[FATAL] Error:\u0026#39;, error \u0026amp;\u0026amp; error.message) console.log(\u0026#39;[FATAL] Stack:\u0026#39;, error \u0026amp;\u0026amp; error.stack) console.log(\u0026#39;[FATAL] 시간:\u0026#39;, new Date().toISOString()) console.log(\u0026#39;=\u0026#39;.repeat(50)) process.exit(1) }) async function bootstrap() { throw new Error(\u0026#39;부트스트랩 실패\u0026#39;) } bootstrap()출력 예\n================================================== [FATAL] 작업이 비정상 종료 예정 [FATAL] Error: 부트스트랩 실패 [FATAL] Stack: Error: 부트스트랩 실패 at bootstrap (...) [FATAL] 시간: 2025-12-03T14:30:00.000Z ==================================================동작 원리 요약 uncaughtException\n에러 발생 → 호출 스택 전파 → 어느 곳에서도 catch되지 않으면 이벤트 발생 핸들러 없으면 종료, 핸들러 있으면 개발자 로직 실행 후 보통 종료 선택 unhandledRejection\nPromise reject → 소비되지 않음 → 이벤트 발생 Node.js 15+에서 핸들러 없으면 기본적으로 종료 주의사항 복구 시도 금지 프로세스가 불안정 상태일 수 있으므로 로깅 후 종료 권장 process.exit 호출 누락 금지 종료하지 않으면 누수와 이상 상태 지속 위험 최소 작업만 수행 동기 로깅, 메트릭 전송 시 타임아웃 짧게, 복잡한 비동기 작업 지양 unhandledRejection 처리 시 주의 reason이 Error가 아닐 수 있음 → 안전하게 문자열화하여 로깅 정책 일관화를 위해 핸들러에서 에러를 throw하거나 process.exit로 종료 권장 핸들러 중복 등록 방지 초기화 구간에서 process.once 사용 고려 종료 코드 일관화 치명적 오류는 1 같은 비영 0 종료 코드 사용 간단 스니펫\nprocess.once(\u0026#39;unhandledRejection\u0026#39;, (reason) =\u0026gt; { const msg = reason instanceof Error ? reason.stack : String(reason) console.error(\u0026#39;[FATAL] Unhandled Rejection\\n\u0026#39;, msg) process.exit(1) }) process.once(\u0026#39;uncaughtException\u0026#39;, (err) =\u0026gt; { console.error(\u0026#39;[FATAL] Uncaught Exception\\n\u0026#39;, err \u0026amp;\u0026amp; err.stack) process.exit(1) })베스트 프랙티스 애플리케이션 레벨에서 먼저 잡는다 각 경계에서 try-catch, Promise 체인에 .catch, 최상위 await에 try-catch 배치 글로벌 핸들러는 마지막 안전망으로만 사용 로깅 포맷을 고정하고 관찰성 도구와 연동 시간, 서비스명, 버전, 요청 식별자 등 가능하면 포함 종료 전 단명 정리만 수행 열려 있는 로그 버퍼 flush 시도, 임시 파일 제거 정도로 한정 요약 정의: 프로세스 레벨의 마지막 에러 핸들러 대상: uncaughtException, unhandledRejection 필요성: 원인 추적과 후처리 일원화, 프로덕션 안정성 확보 운영 원칙: 로깅하고 빠르게 종료, 복구 시도하지 않음 비유\ntry-catch = 각 방의 소화기 글로벌 핸들러 = 건물 스프링클러, 최종 안전망참고자료 https://nodejs.org/api/process.html#event-uncaughtexception https://nodejs.org/api/process.html#event-unhandledrejection https://nodejs.org/en/blog/release/v15.0.0/ ","permalink":"https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eNode.js 프로세스 레벨에서 잡히지 않은 에러를 마지막으로 처리하는 안전망을 두는 목적 정리\n애플리케이션 어디에서도 처리되지 못한 오류를 기록하고 종료 경로를 일관되게 관리하기 위함\n프로덕션 환경에서 원인 파악과 사후 조치 자동화를 위한 최소 장치로 간주\u003c/p\u003e\n\u003ch3 id=\"핵심-이벤트\"\u003e핵심 이벤트\u003c/h3\u003e\n\u003cp\u003e두 가지 이벤트가 글로벌 핸들러의 대상\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euncaughtException\n\u003cul\u003e\n\u003cli\u003etry-catch로 포착되지 않은 동기 오류가 호출 스택 끝까지 전파될 때 발생\u003c/li\u003e\n\u003cli\u003e핸들러가 없으면 프로세스가 비정상 종료됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 동기 에러가 상위에서 잡히지 않은 경우\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e boom\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ethrow\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eError\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;폭발\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eboom\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eunhandledRejection\n\u003cul\u003e\n\u003cli\u003ePromise가 reject되었으나 await 혹은 .catch로 처리되지 않은 경우 발생\u003c/li\u003e\n\u003cli\u003eNode.js 15+ 기본 동작은 핸들러가 없을 때 프로세스 종료\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// reject가 소비되지 않은 경우\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003efunction\u003c/span\u003e asyncBoom\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ethrow\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eError\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#39;비동기 폭발\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003easyncBoom\u003cspan style=\"color:#eceff4\"\u003e()\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"왜-글로벌-핸들러인가\"\u003e왜 글로벌 핸들러인가\u003c/h3\u003e\n\u003cp\u003e코드 최상위에서 아무도 잡지 못한 에러에 대한 마지막 안전망 역할\u003c/p\u003e","title":"Node.js 글로벌 에러 핸들러 가이드"},{"content":"개요 Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행 Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침\n핵심 차이 Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행 Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행 본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨 Node.js 맥락 Liveness Probe 대상 상황 이벤트 루프 블로킹으로 요청 처리 불가 상태 무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능 메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태 Readiness Probe 대상 상황 프로세스는 떠 있으나 초기화 작업 진행 중인 상태 DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태 유의점 Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험 Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함 구현 스니펫 Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장\n간단한 Express 핸들러 예시\nlet isReady = false // Liveness app.get(\u0026#39;/health/live\u0026#39;, (_req, res) =\u0026gt; res.status(200).send(\u0026#39;OK\u0026#39;)) // Readiness app.get(\u0026#39;/health/ready\u0026#39;, (_req, res) =\u0026gt; { if (isReady) return res.status(200).send(\u0026#39;OK\u0026#39;) return res.status(503).send(\u0026#39;Not Ready\u0026#39;) })준비 플래그는 DB 연결 완료 시점 등에서 true로 전환하는 방식 권장\nKubernetes 프로브 최소 설정 예시\nlivenessProbe: httpGet: path: /health/live port: 3000 initialDelaySeconds: 5 periodSeconds: 10 readinessProbe: httpGet: path: /health/ready port: 3000 initialDelaySeconds: 5 periodSeconds: 10앱 기동 시간이 긴 경우 startupProbe 사용 고려\nstartupProbe: httpGet: path: /health/live port: 3000 periodSeconds: 5 failureThreshold: 12주의와 베스트 프랙티스 Liveness에 DB 체크 넣지 않기 DB 일시 지연으로 Liveness 실패 시 컨테이너 재시작 폭주 발생 가능 재접속 과부하로 DB 상태 악화, 전체 장애로 확산되는 연쇄 실패 위험 Readiness에는 실제 서비스 처리 가능 상태를 반영 DB 연결 불가, 핵심 캐시 미구축 시 503 반환으로 트래픽 유입 차단 초기 지연 대응 initialDelaySeconds를 앱 기동 시간보다 여유 있게 설정 또는 startupProbe로 초기 부트 구간 명시 과한 작업 금지 Liveness 핸들러에 무거운 로직, 외부 네트워크 호출, 파일 IO 등 포함 금지 Readiness도 불필요한 비용 최소화, 필요한 의존성 상태만 점검 프로브 타이밍 파라미터 조정 periodSeconds, timeoutSeconds, failureThreshold를 워크로드 특성에 맞춰 튜닝 일시적 네트워크 지연에 과민하지 않도록 실패 임계값 완충 적용 엔드포인트 분리 /health/live와 /health/ready는 별도 라우트로 유지, 공용 미들웨어에서 불필요한 비용 유입 방지 운영 시 고려사항 배포 중 Readiness가 OK가 될 때까지 로드밸런서가 신규 파드로 트래픽을 라우팅하지 않음 롤링 업데이트 시 502와 같은 전이적 오류 방지에 효과적 장애 상황 가시화 Liveness 재시작 이벤트와 Readiness 변화를 모니터링 지표로 수집하면 회귀나 성능 저하 조기 탐지에 유용 Node.js 특성 반영 이벤트 루프 블로킹은 Liveness로 조기 감지 가능 메모리 누수로 인한 GC 압박과 응답 지연은 Readiness 변동과 함께 관찰 시 원인 추적에 도움 요약 Liveness Probe는 죽었으면 살려내라, 실패 시 재시작 수행 Readiness Probe는 준비 안 됐으면 손님 받지 마라, 실패 시 트래픽 차단 수행 Node.js에서는 Liveness를 가볍게, Readiness로 의존성 준비 상태를 엄밀히 반영 초기 부트 지연 구간은 startupProbe로 구분해 재시작 루프 예방 권장 참고자료 https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/ https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eKubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행\nNode.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침\u003c/p\u003e\n\u003ch3 id=\"핵심-차이\"\u003e핵심 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLiveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행\u003c/li\u003e\n\u003cli\u003eReadiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행\u003c/li\u003e\n\u003cli\u003e본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"nodejs-맥락\"\u003eNode.js 맥락\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLiveness Probe 대상 상황\n\u003cul\u003e\n\u003cli\u003e이벤트 루프 블로킹으로 요청 처리 불가 상태\u003c/li\u003e\n\u003cli\u003e무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능\u003c/li\u003e\n\u003cli\u003e메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eReadiness Probe 대상 상황\n\u003cul\u003e\n\u003cli\u003e프로세스는 떠 있으나 초기화 작업 진행 중인 상태\u003c/li\u003e\n\u003cli\u003eDB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e유의점\n\u003cul\u003e\n\u003cli\u003eLiveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험\u003c/li\u003e\n\u003cli\u003eReadiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"구현-스니펫\"\u003e구현 스니펫\u003c/h3\u003e\n\u003cp\u003eNode.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장\u003c/p\u003e","title":"Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드"},{"content":"개념 flatMap은 각 요소를 매핑한 결과를 한 단계만 평탄화하는 배열 메서드 arr.map(fn).flat(1)과 동등\n동작 콜백 시그니처 (value, index, array) 콜백이 배열을 반환하면 concat 후 depth 1 평탄화 더 깊은 중첩은 유지됨 희소 배열의 빈 슬롯은 평탄화 과정에서 제거됨 ES2019 이후 표준 지원 범위 넓음 예시 const arr = [1, 2, 3, 4] arr.flatMap(x =\u0026gt; [x * 2]) // =\u0026gt; [2, 4, 6, 8] arr.flatMap(x =\u0026gt; [[x * 2]]) // =\u0026gt; [[2], [4], [6], [8]] const s = [\u0026#34;it\u0026#39;s Sunny in\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;California\u0026#34;] s.flatMap(x =\u0026gt; x.split(\u0026#34; \u0026#34;)) // =\u0026gt; [\u0026#34;it\u0026#39;s\u0026#34;,\u0026#34;Sunny\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;California\u0026#34;] 주의와 팁 깊이 2 이상 평탄화 필요 시 flat(depth) 사용 또는 map + flat 조합 고려 콜백은 배열을 반환하는 패턴 권장, 스칼라를 섞으면 의도치 않은 구조 발생 가능 희소 배열 처리 시 구멍이 사라지는 특성 주의 성능상 불필요한 중첩 생성은 피하고 필요한 경우에만 flatMap 사용 권장 참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap ","permalink":"https://blog.jsontapose.com/posts/javascript-array-flatmap-22e1f3/","summary":"\u003ch3 id=\"개념\"\u003e개념\u003c/h3\u003e\n\u003cp\u003eflatMap은 각 요소를 매핑한 결과를 한 단계만 평탄화하는 배열 메서드\narr.map(fn).flat(1)과 동등\u003c/p\u003e\n\u003ch3 id=\"동작\"\u003e동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e콜백 시그니처 (value, index, array)\u003c/li\u003e\n\u003cli\u003e콜백이 배열을 반환하면 concat 후 depth 1 평탄화\u003c/li\u003e\n\u003cli\u003e더 깊은 중첩은 유지됨\u003c/li\u003e\n\u003cli\u003e희소 배열의 빈 슬롯은 평탄화 과정에서 제거됨\u003c/li\u003e\n\u003cli\u003eES2019 이후 표준 지원 범위 넓음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"예시\"\u003e예시\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e arr \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003earr\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eflatMap\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ex \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003ex \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e])\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// =\u0026gt; [2, 4, 6, 8]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003earr\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eflatMap\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ex \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[[\u003c/span\u003ex \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]])\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// =\u0026gt; [[2], [4], [6], [8]]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e s \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;it\u0026#39;s Sunny in\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;California\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003es\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003eflatMap\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ex \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e x\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003esplit\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e))\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// =\u0026gt; [\u0026#34;it\u0026#39;s\u0026#34;,\u0026#34;Sunny\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;California\u0026#34;]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"주의와-팁\"\u003e주의와 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e깊이 2 이상 평탄화 필요 시 flat(depth) 사용 또는 map + flat 조합 고려\u003c/li\u003e\n\u003cli\u003e콜백은 배열을 반환하는 패턴 권장, 스칼라를 섞으면 의도치 않은 구조 발생 가능\u003c/li\u003e\n\u003cli\u003e희소 배열 처리 시 구멍이 사라지는 특성 주의\u003c/li\u003e\n\u003cli\u003e성능상 불필요한 중첩 생성은 피하고 필요한 경우에만 flatMap 사용 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"JavaScript Array.prototype.flatMap 개념과 사용 예시"},{"content":"개요 NestJS을 다루다 보면 ConfigModule.forRoot(), TypeOrmModule.forRoot() 같은 코드를 보게 됨 보통 \u0026ldquo;이건 전역 설정이니까 한 번만 하면 끝이고 알아서 싱글톤 유지되겠지?\u0026ldquo;라고 생각하기 쉬움\n하지만 forRoot()를 호출한다고 프레임워크가 알아서 물리적인 싱글톤 인스턴스를 강제하는 건 아님 특히 ScheduleModule처럼 사이드 이펙트(이벤트 리스너, 타이머 등)를 유발하는 모듈을 잘못 다루면, 기능이 중복 실행되는 심각한 버그가 터질 수 있음\n이 글에서는 forRoot()의 진짜 의미와 내부 동작, 그리고 ScheduleModule 중복 실행 문제가 왜 생기는지 코드로 뜯어보겠음\nforRoot()란 무엇인가 forRoot()는 NestJS의 동적 모듈(Dynamic Module)을 생성하기 위해 관례적으로 쓰는 메서드 이름임\n정적 모듈 vs 동적 모듈 정적 모듈 (일반적인 import) 메타데이터(설정)가 바뀔 일 없는 모듈임. 그냥 imports 배열에 클래스 이름만 넣으면 끝남\n동적 모듈 (forRoot) 모듈을 쓰는 쪽에서 설정을 주입해줘야 할 때 씀 DB 접속 정보, API 키, 전역 옵션 같은 걸 인자로 넘겨주면, 그에 맞춰 모듈 정의를 동적으로 만들어서 반환함\nforRoot()와 forFeature()의 차이 forRoot() 앱 전체에서 단 한 번만 설정해야 하는 전역 설정용임 주로 루트 모듈(AppModule)에서 호출하고 내부적으로 DB 커넥션 풀을 만들거나 스케줄러를 초기화함 forFeature() 이미 forRoot로 설정된 모듈의 기능을 특정 도메인(Feature)에서 갖다 쓸 때 씀 엔티티 등록이나 리포지토리 주입을 위해 여러 번 호출해도 됨 문제 상황: forRoot()는 싱글톤 보장 안 함 제일 큰 오해가 \u0026ldquo;forRoot()는 전역 설정이니까 여러 번 불러도 NestJS가 알아서 합쳐주겠지\u0026quot;라고 믿는 거임 하지만 NestJS 모듈 시스템에서 forRoot()는 호출할 때마다 새로운 동적 모듈 객체를 반환함\n만약 ScheduleModule.forRoot()를 루트 모듈에서도 부르고 자식 모듈에서도 부르면, NestJS는 이걸 서로 다른 두 개의 모듈로 인식하고 로딩해버림\n예제 코드 (잘못된 사용) // AppModule (루트) @Module({ imports: [ ScheduleModule.forRoot(), // 1. 여기서 한 번 생성됨 BatchModule, ], }) export class AppModule {} // BatchModule (자식) @Module({ imports: [ ScheduleModule.forRoot(), // 2. 여기서 또 생성됨 (중복!) ], }) export class BatchModule {}이렇게 짜면 스케줄러가 2개 돔. @Cron 붙은 작업이 1초에 2번씩 실행되는 대참사가 일어남\n심층 분석: 왜 중복 실행되는가 이걸 이해하려면 @nestjs/schedule 패키지 내부를 봐야 함\nScheduleModule 소스 코드 분석 // @nestjs/schedule/lib/schedule.module.ts (단순화됨) @Module({ imports: [DiscoveryModule], providers: [SchedulerMetadataAccessor, SchedulerOrchestrator], }) export class ScheduleModule { static forRoot(options?: ScheduleModuleOptions): DynamicModule { return { global: true, // 전역 모듈로 선언 module: ScheduleModule, providers: [ ScheduleExplorer, // 핵심: 스케줄링 탐색기 SchedulerRegistry, { provide: SCHEDULE_MODULE_OPTIONS, useValue: options, }, ], exports: [SchedulerRegistry], }; } }여기서 눈여겨볼 건 딱 두 가지임\nglobal: true 이건 이 모듈이 제공하는 프로바이더(providers)를 다른 모듈에서 imports 없이도 쓸 수 있게 해준다는 뜻임. 모듈 인스턴스를 딱 하나만 만들겠다는 뜻이 아님\nScheduleExplorer 프로바이더 providers에 있는 ScheduleExplorer는 OnModuleInit 생명주기를 가짐. 앱 켜질 때 전체를 스캔해서 @Cron 데코레이터를 찾고 작업을 등록하는 놈임\n중복 호출 시 일어나는 일 AppModule에서 forRoot() 호출 → DynamicModule A 생성 내부의 ScheduleExplorer A가 생성됨 A가 @Cron 메서드 싹 긁어서 스케줄러에 등록함 BatchModule에서 forRoot() 호출 → DynamicModule B 생성 forRoot()는 팩토리 메서드라 그냥 새 객체를 뱉음 내부의 ScheduleExplorer B가 또 생성됨 B가 다시 @Cron 메서드 싹 긁어서 스케줄러에 또 등록함 결과적으로 탐색기가 2명이라 일도 2배로 함. global: true가 있어도 모듈 객체 참조값이 다르니 NestJS는 별개로 처리함\n올바른 사용 패턴 forRoot() 쓰는 모듈은 무조건 루트 모듈(AppModule)이나 CoreModule에서 딱 한 번만 호출한다는 관례를 지켜야 함\n예제 코드 (올바른 구조) // app.module.ts @Module({ imports: [ // 1. 루트에서 한 번만 설정 및 초기화 ScheduleModule.forRoot(), BatchModule, HttpModule, ], }) export class AppModule {} // batch.module.ts @Module({ imports: [ // 2. ScheduleModule을 다시 import 하지 않음! // global: true 덕분에 SchedulerRegistry 같은 건 그냥 주입받아 쓸 수 있음 ], providers: [BatchService], }) export class BatchModule {} 요약 forRoot()는 단순 팩토리 메서드임 부를 때마다 새 설정 객체 뱉음. 프레임워크가 알아서 중복 막아주지 않음 global: true는 싱글톤 보장이 아님 프로바이더를 전역 공유하게 해줄 뿐, 모듈 초기화 로직이 두 번 도는 걸 막지는 못함 결국 개발자 책임임 ScheduleModule, TypeOrmModule 같은 건 앱의 최상위 진입점(AppModule)에서만 명시적으로 부르자. 하위에서 필요하면 forFeature를 쓰거나 그냥 주입받아 쓰면 됨 참고자료 https://docs.nestjs.com/modules#dynamic-modules https://docs.nestjs.com/techniques/configuration https://docs.nestjs.com/techniques/database https://docs.nestjs.com/techniques/task-scheduling ","permalink":"https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNestJS을 다루다 보면 \u003ccode\u003eConfigModule.forRoot()\u003c/code\u003e, \u003ccode\u003eTypeOrmModule.forRoot()\u003c/code\u003e 같은 코드를 보게 됨\n보통 \u0026ldquo;이건 전역 설정이니까 한 번만 하면 끝이고 알아서 싱글톤 유지되겠지?\u0026ldquo;라고 생각하기 쉬움\u003c/p\u003e\n\u003cp\u003e하지만 \u003ccode\u003eforRoot()\u003c/code\u003e를 호출한다고 프레임워크가 알아서 물리적인 싱글톤 인스턴스를 강제하는 건 아님\n특히 \u003ccode\u003eScheduleModule\u003c/code\u003e처럼 사이드 이펙트(이벤트 리스너, 타이머 등)를 유발하는 모듈을 잘못 다루면, 기능이 중복 실행되는 심각한 버그가 터질 수 있음\u003c/p\u003e\n\u003cp\u003e이 글에서는 \u003ccode\u003eforRoot()\u003c/code\u003e의 진짜 의미와 내부 동작, 그리고 \u003ccode\u003eScheduleModule\u003c/code\u003e 중복 실행 문제가 왜 생기는지 코드로 뜯어보겠음\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"forroot란-무엇인가\"\u003eforRoot()란 무엇인가\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eforRoot()\u003c/code\u003e는 NestJS의 \u003cstrong\u003e동적 모듈\u003c/strong\u003e(Dynamic Module)을 생성하기 위해 관례적으로 쓰는 메서드 이름임\u003c/p\u003e","title":"NestJS forRoot()의 동작 원리와 싱글톤에 대한 오해"},{"content":"전략 패턴이란? 객체의 특정 행동(알고리즘)을 직접 구현하지 않고, 외부에서 \u0026lsquo;전략\u0026rsquo;을 주입받아 갈아 끼우는 방식임\n쉽게 말해 \u0026ldquo;본체는 그대로 두고, 부품만 바꿔서 기능을 바꾸는 것\u0026quot;이라 보면 됨\n전략 패턴이 적용되지 않은 코드 전략 패턴을 쓰지 않으면 보통 이렇게 구현하게 됨\nclass Vehicle { constructor(private type: \u0026#34;road\u0026#34; | \u0026#34;rail\u0026#34;) {} move() { if (this.type === \u0026#34;road\u0026#34;) { console.log(\u0026#34;부릉부릉 도로로 감 🚌\u0026#34;); } else if (this.type === \u0026#34;rail\u0026#34;) { console.log(\u0026#34;칙칙폭폭 선로로 감 🚂\u0026#34;); } } }이 방식이 가지는 문제는 다음과 같음\n조건문이 계속 늘어남 새로운 이동 방식이 생길 때마다 move()를 수정해야 함 → OCP(Open-Closed Principle) 위반\nVehicle 클래스가 알고리즘에 강하게 결합됨 → 이동 로직이 Vehicle 내부에 박혀 있음\n유닛 테스트 어려움 Vehicle을 테스트하려면 항상 type 조건을 따라가야 함\n코드 재사용성 낮음 “선로 전략”을 다른 곳에서 재사용할 수도 없고, 로직 분리가 안 됨\n그러면 이 문제를 전략 패턴은 어떻게 해결할 수 있을까?\n구조 설계 Vehicle(본체)은 MoveStrategy(부품)를 가지고 있고, 필요할 때 이 부품만 바꿈\nclassDiagram class MoveStrategy { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; \u0026#43;move() } class RailStrategy { \u0026#43;move() } class RoadStrategy { \u0026#43;move() } class Vehicle { -strategy: MoveStrategy \u0026#43;setStrategy() \u0026#43;move() } MoveStrategy \u0026lt;|.. RailStrategy MoveStrategy \u0026lt;|.. RoadStrategy Vehicle o-- MoveStrategyTypeScript 구현 1. 전략(Strategy) 정의 \u0026ldquo;어떻게 움직일지\u0026quot;에 대한 부품들임\n// 행동의 규격 (인터페이스) interface MoveStrategy { move(): void; } // 부품 1: 도로용 class RoadStrategy implements MoveStrategy { move() { console.log(\u0026#34;부릉부릉 도로로 감 🚌\u0026#34;); } } // 부품 2: 선로용 class RailStrategy implements MoveStrategy { move() { console.log(\u0026#34;칙칙폭폭 선로로 감 🚂\u0026#34;); } }2. 컨텍스트(Context) 정의 전략을 사용하는 본체임. setStrategy로 부품만 갈아 끼우면 됨\nclass Vehicle { // 생성할 때 초기 전략(부품)을 낌 constructor(private strategy: MoveStrategy) {} // 핵심: 실행 중에 부품 교체 가능! setStrategy(strategy: MoveStrategy) { this.strategy = strategy; } // 본체는 그냥 부품한테 일을 시킴 (위임) move() { this.strategy.move(); } }3. 사용 예시 Vehicle 코드를 뜯어고칠 필요 없이, 주입하는 객체만 바꾸면 행동이 변함\n// 1. 처음엔 도로 전략으로 생성 const bus = new Vehicle(new RoadStrategy()); bus.move(); // 결과: 부릉부릉 도로로 감 🚌 // 2. 갑자기 선로로 가야 함? 전략만 교체! bus.setStrategy(new RailStrategy()); bus.move(); // 결과: 칙칙폭폭 선로로 감 🚂 핵심 요약 코드 수정 없음 (OCP): 새로운 이동 방식(예: FlyStrategy)이 생겨도 Vehicle 클래스는 수정할 필요가 없음. 그냥 새 전략 만들어서 끼우면 됨 유연성: 실행 중(Runtime)에 setStrategy로 즉시 행동을 바꿀 수 있음 상속보단 합성: 복잡하게 클래스 상속(extends) 하지 말고, 기능을 부품처럼 인터페이스로 받아서 쓰는 게 훨씬 유연함 참고자료 https://en.wikipedia.org/wiki/Strategy_pattern https://refactoring.guru/design-patterns/strategy https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T- https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html https://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain- ","permalink":"https://blog.jsontapose.com/posts/strategy-pattern-with-typescript-mermaid-6618f4/","summary":"\u003ch3 id=\"전략-패턴이란\"\u003e전략 패턴이란?\u003c/h3\u003e\n\u003cp\u003e객체의 특정 행동(알고리즘)을 직접 구현하지 않고, \u003cstrong\u003e외부에서 \u0026lsquo;전략\u0026rsquo;을 주입받아 갈아 끼우는 방식\u003c/strong\u003e임\u003c/p\u003e\n\u003cp\u003e쉽게 말해 \u0026ldquo;본체는 그대로 두고, 부품만 바꿔서 기능을 바꾸는 것\u0026quot;이라 보면 됨\u003c/p\u003e\n\u003ch3 id=\"전략-패턴이-적용되지-않은-코드\"\u003e전략 패턴이 적용되지 않은 코드\u003c/h3\u003e\n\u003cp\u003e전략 패턴을 쓰지 않으면 보통 이렇게 구현하게 됨\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eclass\u003c/span\u003e Vehicle \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econstructor\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eprivate\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;road\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e|\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;rail\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  move() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;road\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      console\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;부릉부릉 도로로 감 🚌\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ethis\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e===\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;rail\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      console\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;칙칙폭폭 선로로 감 🚂\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e이 방식이 가지는 문제는 다음과 같음\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e조건문이 계속 늘어남\n새로운 이동 방식이 생길 때마다 move()를 수정해야 함\n→ OCP(Open-Closed Principle) 위반\u003c/p\u003e","title":"전략 패턴 (Strategy Pattern) - 유연한 코드 만들기"},{"content":"개념/배경 VARCHAR(n)에서 n을 글자 수로 볼지 바이트 수로 볼지 혼동 많음 표준 SQL의 character varying(n)은 최대 글자 수 의미이나, 실제 구현은 DBMS와 문자셋 설정에 따라 달라짐 멀티바이트 문자셋에서는 저장 바이트 수와 글자 수가 다름. 길이 제한은 글자 수 기준일 수 있으나 내부 저장은 바이트 단위로 이뤄짐\nDBMS별 동작 MySQL VARCHAR(n)에서 n은 글자 수 의미 utf8mb4 사용 시 글자 하나가 최대 4바이트까지 소요. 행 크기 제한 등으로 인해 저장 가능 여부는 바이트 한계에도 영향 받음 PostgreSQL character varying(n)에서 n은 글자 수 의미 저장은 바이트 단위이나 제약은 글자 수 기준으로 평가 SQL Server varchar(n)은 n이 바이트 수. 멀티바이트 문자 사용 시 같은 n이라도 담을 수 있는 글자 수 감소 nvarchar(n)은 n이 글자 수. 유니코드 2바이트 단위 저장. 글자 수 기준 제약 필요 시 nvarchar 사용 권장 Oracle VARCHAR2(n)은 기본이 바이트 기준. 세션/시스템에서 CHAR semantics 또는 컬럼 정의 시 VARCHAR2(n CHAR)로 명시하면 글자 수 기준 실무 팁 한글 100자, 영어 100자 모두 허용 기대라면 글자 수 기준 타입 필요 MySQL VARCHAR(100), PostgreSQL varchar(100), SQL Server에서는 nvarchar(100), Oracle에서는 VARCHAR2(100 CHAR) 선택 저장 바이트 한계 고려 필요. MySQL은 행 크기 한계, Oracle/SQL Server도 페이지 크기 등 제약 존재 길이 함수 차이 주의. 바이트 길이와 글자 길이 함수가 다른 경우 존재. 예를 들어 글자 길이 검증은 문자 길이 함수 사용 권장 이모지, 결합 문자 등 특수 유니코드 조합은 사용자 체감 글자 수와 코드 포인트 수가 다를 수 있음. 제품 요구사항에 맞는 길이 기준 정의 필요 정리 VARCHAR(n)이 항상 바이트 무관이라는 주장은 오해 많은 DBMS에서 n은 글자 수지만, SQL Server의 varchar처럼 바이트 기준인 구현 존재 문자셋과 저장 한계를 함께 고려해야 안정적인 길이 설계 가능 한글도 100글자, 영어도 100글자라는 기대를 보장하려면 글자 수 기준 타입과 설정을 명시적으로 선택할 것 참고자료 https://dev.mysql.com/doc/refman/8.0/en/char.html https://www.postgresql.org/docs/current/datatype-character.html https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673 ","permalink":"https://blog.jsontapose.com/posts/varchar-n-length-characters-vs-bytes-99b017/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eVARCHAR(n)에서 n을 글자 수로 볼지 바이트 수로 볼지 혼동 많음\n표준 SQL의 character varying(n)은 최대 글자 수 의미이나, 실제 구현은 DBMS와 문자셋 설정에 따라 달라짐\n멀티바이트 문자셋에서는 저장 바이트 수와 글자 수가 다름. 길이 제한은 글자 수 기준일 수 있으나 내부 저장은 바이트 단위로 이뤄짐\u003c/p\u003e\n\u003ch3 id=\"dbms별-동작\"\u003eDBMS별 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMySQL\n\u003cul\u003e\n\u003cli\u003eVARCHAR(n)에서 n은 글자 수 의미\u003c/li\u003e\n\u003cli\u003eutf8mb4 사용 시 글자 하나가 최대 4바이트까지 소요. 행 크기 제한 등으로 인해 저장 가능 여부는 바이트 한계에도 영향 받음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePostgreSQL\n\u003cul\u003e\n\u003cli\u003echaracter varying(n)에서 n은 글자 수 의미\u003c/li\u003e\n\u003cli\u003e저장은 바이트 단위이나 제약은 글자 수 기준으로 평가\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSQL Server\n\u003cul\u003e\n\u003cli\u003evarchar(n)은 n이 바이트 수. 멀티바이트 문자 사용 시 같은 n이라도 담을 수 있는 글자 수 감소\u003c/li\u003e\n\u003cli\u003envarchar(n)은 n이 글자 수. 유니코드 2바이트 단위 저장. 글자 수 기준 제약 필요 시 nvarchar 사용 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eOracle\n\u003cul\u003e\n\u003cli\u003eVARCHAR2(n)은 기본이 바이트 기준. 세션/시스템에서 CHAR semantics 또는 컬럼 정의 시 VARCHAR2(n CHAR)로 명시하면 글자 수 기준\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실무-팁\"\u003e실무 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e한글 100자, 영어 100자 모두 허용 기대라면 글자 수 기준 타입 필요\n\u003cul\u003e\n\u003cli\u003eMySQL VARCHAR(100), PostgreSQL varchar(100), SQL Server에서는 nvarchar(100), Oracle에서는 VARCHAR2(100 CHAR) 선택\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e저장 바이트 한계 고려 필요. MySQL은 행 크기 한계, Oracle/SQL Server도 페이지 크기 등 제약 존재\u003c/li\u003e\n\u003cli\u003e길이 함수 차이 주의. 바이트 길이와 글자 길이 함수가 다른 경우 존재. 예를 들어 글자 길이 검증은 문자 길이 함수 사용 권장\u003c/li\u003e\n\u003cli\u003e이모지, 결합 문자 등 특수 유니코드 조합은 사용자 체감 글자 수와 코드 포인트 수가 다를 수 있음. 제품 요구사항에 맞는 길이 기준 정의 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"정리\"\u003e정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVARCHAR(n)이 항상 바이트 무관이라는 주장은 오해\u003c/li\u003e\n\u003cli\u003e많은 DBMS에서 n은 글자 수지만, SQL Server의 varchar처럼 바이트 기준인 구현 존재\u003c/li\u003e\n\u003cli\u003e문자셋과 저장 한계를 함께 고려해야 안정적인 길이 설계 가능\u003c/li\u003e\n\u003cli\u003e한글도 100글자, 영어도 100글자라는 기대를 보장하려면 글자 수 기준 타입과 설정을 명시적으로 선택할 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/char.html\"\u003ehttps://dev.mysql.com/doc/refman/8.0/en/char.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.postgresql.org/docs/current/datatype-character.html\"\u003ehttps://www.postgresql.org/docs/current/datatype-character.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql\"\u003ehttps://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673\"\u003ehttps://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"VARCHAR(n) 길이 기준 정리 — 글자 수인가 바이트 수인가"},{"content":"개요 쿠버네티스에서 컨트롤러는 제어 루프를 통해 원하는 상태와 현재 상태를 맞추는 두뇌 역할 수행 사용자가 선언한 스펙을 지속 관찰하고 차이를 줄이기 위해 리소스를 생성·수정·삭제하는 자동화 구성 요소 이 문서는 주요 컨트롤러를 실무 맥락과 비유를 곁들여 정리하며, 디버깅 관점에서의 관계와 주의점을 함께 정리\n워크로드 컨트롤러 Deployment\n역할: 상태 비저장 앱의 표준 배포 단위, 버전 관리와 롤링 업데이트 담당 특기: 롤링 업데이트로 무중단에 가까운 배포, 이슈 시 손쉬운 롤백 관계: 파드 직접 관리 대신 ReplicaSet을 통해 간접 관리 ReplicaSet\n역할: 지정된 파드 수를 유지하는 계수 담당 특기: 파드가 부족하면 빠르게 신규 생성, 과하면 정리 관계: 일반적으로 사용자가 직접 생성하지 않음, Deployment가 생성한 하위 리소스인 경우가 표준 DaemonSet\n역할: 모든 노드마다 파드 1개씩 보장 용도: 로그 수집기, 모니터링 에이전트, CNI 등 노드 단위로 필요한 에이전트 배치 특기: 노드 증감에 따라 자동으로 파드 배치와 정리 수행 StatefulSet\n역할: 아이덴티티와 순서가 중요한 워크로드 관리 용도: DB, Redis, Kafka 등 스토리지 연결과 고정 네이밍이 필요한 경우 특기: 파드 이름 고정, 재시작 시 기존 PVC와 재결합 Job\n역할: 단발성 작업을 보장하고 성공 시 종료 용도: 데이터 마이그레이션, 일회성 배치, 학습 파이프라인의 단건 태스크 특기: 성공 시 Completed 상태로 종료되어 자원 반환 시간과 네트워크 컨트롤러 CronJob\n역할: 스케줄에 따라 Job을 생성하는 상위 컨트롤러 용도: 정기 백업, 리포트 생성, 주기적 데이터 집계 특징: 리눅스 crontab 표현식 기반 스케줄링 Ingress Controller\n역할: 외부 트래픽을 L7 기준으로 라우팅하여 내부 서비스로 전달 용도: nginx-ingress, aws-load-balancer-controller 등 환경에 맞는 컨트롤러 사용 특징: 호스트와 경로 기반 라우팅 구성, 클라우드 환경에서는 매칭되는 L7 로드밸런서와 연동되는 경우가 일반적 스케일링 컨트롤러 HPA (Horizontal Pod Autoscaler)\n역할: 파드 개수 수평 확장과 축소 자동화 방식: CPU 사용률, 사용자 정의 메트릭 등을 감시하여 Deployment의 replicas 조정 특징: 가장 널리 쓰이는 오토스케일링 방식 VPA (Vertical Pod Autoscaler)\n역할: 파드 리소스 요청과 제한을 상향 또는 하향 조정하는 수직 확장 방식: 관측된 사용량 기반 권고 또는 업데이트를 통해 더 큰 사양으로 재시작 주의: 파드 재시작이 수반될 수 있어 서비스 영향 가능, HPA와 병행 시 정책 충돌 주의 Cluster Autoscaler / Karpenter\n역할: 스케줄 불가 파드가 대기 중일 때 노드 규모 자동 조정 방식: Pending 파드 수요를 기반으로 노드 추가, 유휴 리소스가 충분하면 축소 참고: Karpenter는 신속한 프로비저닝과 비용 최적화에 초점, 기존 Cluster Autoscaler 대비 다양한 프로비저닝 전략 제공 커스텀 컨트롤러와 오퍼레이터 Operators\n역할: 복잡한 애플리케이션의 운영 지식을 코드화한 커스텀 컨트롤러 예시: Prometheus Operator, Elasticsearch Operator 등 특징: CRD 기반으로 백업, 업그레이드, 샤딩 등 도메인 특화 작업을 자동화 한눈에 보는 요약표 종류 컨트롤러 이름 핵심 역할 비유 작업반장 Deployment 웹 및 API 배포와 버전 관리 프로젝트 팀장 ReplicaSet 파드 개수 유지, Deployment 하위 리소스 인원 점검 반장 DaemonSet 모든 노드에 1개씩 에이전트 배치 층별 경비원 StatefulSet 순서와 정체성이 중요한 상태 저장 워크로드 지정석 전문가 Job 1회성 작업 완료 후 종료 일용직 알바 시간/네트워크 CronJob 스케줄 기반 Job 생성 정기 청소 Ingress Controller 외부 트래픽 L7 라우팅 안내 데스크 스케일링 HPA 파드 수 자동 조절 인사팀 채용 VPA 파드 사양 자동 조절 헬스 트레이너 Karpenter 노드 자동 증설 및 축소 건물 증축 담당 계층 구조 관계 파악은 원인 분석과 디버깅 시간을 줄이는 지름길 사용자 정의 리소스가 어떤 컨트롤러를 통해 어느 하위 리소스로 이어지는지 확인할 것\ngraph TD User[사용자/개발자] --\u0026gt;|YAML 정의| Deployment User --\u0026gt;|YAML 정의| HPA User --\u0026gt;|YAML 정의| Service HPA[HPA] --\u0026gt;|replicas 조정| Deployment[Deployment] Deployment --\u0026gt;|관리| ReplicaSet[ReplicaSet] ReplicaSet --\u0026gt;|생성/삭제| Pod[Pod] Service[Service] --\u0026gt;|라벨 셀렉터| Pod Ingress[Ingress Controller] --\u0026gt;|외부 라우팅| Service Karpenter[Karpenter/CA] --\u0026gt;|노드 증설| Node[Node] Node --\u0026gt;|스케줄링 대상| Pod핵심 포인트\n파드가 생성되지 않으면 Deployment와 ReplicaSet 이벤트부터 확인 파드 개수 변동이 의도와 다르면 HPA 정책과 메트릭 확인 스케줄 불가가 지속되면 Karpenter 또는 Cluster Autoscaler 상태와 제약 조건 점검 외부 접속 이슈는 Ingress Controller와 Service, 엔드포인트 셋의 연계를 순서대로 확인 마무리 컨트롤러는 선언적 상태를 실현하는 자동화 엔진 디버깅은 관계 그래프를 따라 상위에서 하위로 내려가며 이벤트와 조건을 확인하는 절차로 단순화 가능 운영 환경에서는 스케일링 정책 충돌과 스토리지 바인딩, 네트워크 라우팅 규칙의 일관성에 특히 유의할 것\n참고자료 https://kubernetes.io/docs/concepts/architecture/controller/ https://kubernetes.io/docs/concepts/workloads/controllers/deployment/ https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/ https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/ https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/ https://kubernetes.io/docs/concepts/workloads/controllers/job/ https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/ https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/ https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler https://kubernetes.io/docs/tasks/run-application/vertical-pod-autoscale/ https://kubernetes.io/docs/concepts/services-networking/ingress/ https://karpenter.sh/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-controllers-core-practical-guide-ecd5cd/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e쿠버네티스에서 컨트롤러는 제어 루프를 통해 원하는 상태와 현재 상태를 맞추는 두뇌 역할 수행\n사용자가 선언한 스펙을 지속 관찰하고 차이를 줄이기 위해 리소스를 생성·수정·삭제하는 자동화 구성 요소\n이 문서는 주요 컨트롤러를 실무 맥락과 비유를 곁들여 정리하며, 디버깅 관점에서의 관계와 주의점을 함께 정리\u003c/p\u003e\n\u003ch3 id=\"워크로드-컨트롤러\"\u003e워크로드 컨트롤러\u003c/h3\u003e\n\u003cp\u003eDeployment\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e역할: 상태 비저장 앱의 표준 배포 단위, 버전 관리와 롤링 업데이트 담당\u003c/li\u003e\n\u003cli\u003e특기: 롤링 업데이트로 무중단에 가까운 배포, 이슈 시 손쉬운 롤백\u003c/li\u003e\n\u003cli\u003e관계: 파드 직접 관리 대신 ReplicaSet을 통해 간접 관리\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReplicaSet\u003c/p\u003e","title":"Kubernetes Controllers 핵심 개념과 실전 가이드"},{"content":" Node.js 기본 구조 graph TB subgraph STACK[Call Stack] S1[현재 실행 중인 함수] end subgraph LOOP[Event Loop] EL[Call Stack 비었나?\u0026lt;br/\u0026gt;→ Queue에서 가져오기] end subgraph QUEUES[Queues] MQ[Microtask Queue\u0026lt;br/\u0026gt;Promise, await 완료] TQ[Task Queue\u0026lt;br/\u0026gt;setTimeout, I/O, Cron] end STACK --\u0026gt; |비어있을 때만| LOOP LOOP --\u0026gt; MQ MQ --\u0026gt; |비었으면| TQ TQ --\u0026gt; STACK style STACK fill:#ff6b6b style MQ fill:#4ecdc4 style TQ fill:#45b7d1핵심 규칙: Call Stack이 비어야만 다음 작업 실행\n오해 1: \u0026ldquo;setTimeout(0)은 즉시 실행된다\u0026rdquo; 코드 console.log(\u0026#34;1\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;2\u0026#34;), 0); console.log(\u0026#34;3\u0026#34;);실행 흐름 sequenceDiagram participant CS as Call Stack participant TQ as Task Queue participant OUT as 출력 Note over CS: console.log(\u0026#39;1\u0026#39;) CS-\u0026gt;\u0026gt;OUT: \u0026#34;1\u0026#34; Note over CS: setTimeout 등록 CS-\u0026gt;\u0026gt;TQ: 콜백 등록 (0ms여도!) Note over CS: console.log(\u0026#39;3\u0026#39;) CS-\u0026gt;\u0026gt;OUT: \u0026#34;3\u0026#34; Note over CS: Call Stack 비었음! TQ-\u0026gt;\u0026gt;CS: 콜백 가져오기 Note over CS: 콜백 실행 CS-\u0026gt;\u0026gt;OUT: \u0026#34;2\u0026#34;출력: 1 → 3 → 2 setTimeout(0)은 \u0026ldquo;다음 Event Loop에 실행\u0026quot;이라는 뜻!\n오해 2: \u0026ldquo;await은 프로그램을 멈춘다\u0026rdquo; 코드 async function fetchData() { console.log(\u0026#34;fetch 시작\u0026#34;); await sleep(3000); console.log(\u0026#34;fetch 끝\u0026#34;); } fetchData(); console.log(\u0026#34;다음 코드\u0026#34;);실행 흐름 sequenceDiagram participant CS as Call Stack participant MQ as Microtask Queue participant OUT as 출력 Note over CS: fetchData() 실행 CS-\u0026gt;\u0026gt;OUT: \u0026#34;fetch 시작\u0026#34; Note over CS: await 만남! CS--\u0026gt;\u0026gt;MQ: Promise 등록, 제어권 반환 Note over CS: fetchData 일시 중단 Note over CS: 다음 코드 실행 가능! CS-\u0026gt;\u0026gt;OUT: \u0026#34;다음 코드\u0026#34; Note over CS: Call Stack 비었음 Note over MQ: 3초 후 Promise 완료 MQ-\u0026gt;\u0026gt;CS: fetchData 재개 CS-\u0026gt;\u0026gt;OUT: \u0026#34;fetch 끝\u0026#34;출력: fetch 시작 → 다음 코드 → (3초 후) fetch 끝 오해 3: \u0026ldquo;Promise와 setTimeout은 같은 우선순위\u0026rdquo; 코드 console.log(\u0026#34;1\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;timeout\u0026#34;), 0); Promise.resolve().then(() =\u0026gt; console.log(\u0026#34;promise\u0026#34;)); console.log(\u0026#34;2\u0026#34;);실행 흐름 sequenceDiagram participant CS as Call Stack participant MQ as Microtask Queue participant TQ as Task Queue participant OUT as 출력 Note over CS: 동기 코드 실행 CS-\u0026gt;\u0026gt;OUT: \u0026#34;1\u0026#34; CS-\u0026gt;\u0026gt;TQ: setTimeout 콜백 등록 CS-\u0026gt;\u0026gt;MQ: Promise.then 등록 CS-\u0026gt;\u0026gt;OUT: \u0026#34;2\u0026#34; Note over CS: Call Stack 비었음! Note over MQ: Microtask 먼저! MQ-\u0026gt;\u0026gt;CS: Promise 콜백 CS-\u0026gt;\u0026gt;OUT: \u0026#34;promise\u0026#34; Note over TQ: 그 다음 Task TQ-\u0026gt;\u0026gt;CS: setTimeout 콜백 CS-\u0026gt;\u0026gt;OUT: \u0026#34;timeout\u0026#34;출력: 1 → 2 → promise → timeout 오해 4: \u0026ldquo;await은 동기처럼 동작한다\u0026rdquo; 비교 graph LR subgraph SYNC[진짜 동기 대기] A1[while로 CPU 점유] --\u0026gt; A2[전체 프로그램 블록] A2 --\u0026gt; A3[아무것도 못함] end subgraph AWAIT[await 대기] B1[Promise 등록] --\u0026gt; B2[제어권 반환] B2 --\u0026gt; B3[다른 코드 실행 가능!] end style A3 fill:#ff6b6b style B3 fill:#4ecdc4// ❌ 진짜 동기 (전체 블록) function syncWait(ms) { const end = Date.now() + ms; while (Date.now() \u0026lt; end) {} // CPU 점유! } // ✅ await (해당 함수만 중단) await new Promise((r) =\u0026gt; setTimeout(r, 3000)); 오해 5: \u0026ldquo;for 안의 await은 병렬\u0026rdquo; 순차 실행 (기본) gantt title for-await 순차 실행 dateFormat X axisFormat %s초 section 처리 item 1 :0, 1 item 2 :1, 2 item 3 :2, 3for (const item of items) { await processItem(item); // 하나씩 순차! } // 총 3초병렬 실행 (Promise.all) gantt title Promise.all 병렬 실행 dateFormat X axisFormat %s초 section 처리 item 1 :0, 1 item 2 :0, 1 item 3 :0, 1await Promise.all(items.map((item) =\u0026gt; processItem(item))); // 총 1초! Event Loop 흐름도 (핵심!) flowchart TD START([시작]) --\u0026gt; CS{Call Stack에\u0026lt;br/\u0026gt;동기 코드 있음?} CS --\u0026gt;|예| EXEC[실행!\u0026lt;br/\u0026gt;끝날 때까지 독점] EXEC --\u0026gt; POP[Call Stack에서 제거] POP --\u0026gt; CS CS --\u0026gt;|아니오| MQ{Microtask Queue에\u0026lt;br/\u0026gt;작업 있음?} MQ --\u0026gt;|예| MICRO[모든 Microtask 실행\u0026lt;br/\u0026gt;Promise.then, await 완료] MICRO --\u0026gt; MQ MQ --\u0026gt;|아니오| TQ{Task Queue에\u0026lt;br/\u0026gt;작업 있음?} TQ --\u0026gt;|예| TASK[하나만 Call Stack에\u0026lt;br/\u0026gt;올려서 실행] TASK --\u0026gt; CS TQ --\u0026gt;|아니오| IDLE[대기 idle] IDLE --\u0026gt; CS style EXEC fill:#ff6b6b style MICRO fill:#4ecdc4 style TASK fill:#45b7d1우선순위 graph LR A[1️⃣ Call Stack\u0026lt;br/\u0026gt;동기 코드] --\u0026gt; B[2️⃣ Microtask Queue\u0026lt;br/\u0026gt;Promise, await] B --\u0026gt; C[3️⃣ Task Queue\u0026lt;br/\u0026gt;setTimeout, I/O] style A fill:#ff6b6b,color:#fff style B fill:#4ecdc4,color:#fff style C fill:#45b7d1,color:#fff 핵심 요약 오해 실제 setTimeout(0)은 즉시 실행 ❌ Task Queue 경유 후 실행 await은 프로그램을 멈춤 ❌ 해당 함수만 중단, 다른 코드 실행 가능 Promise와 setTimeout 우선순위 같음 ❌ Microtask(Promise)가 먼저 await은 동기 코드 ❌ 비동기, Event Loop에 제어권 반환 for-await은 병렬 ❌ 순차 실행, 병렬은 Promise.all 한 줄 정리 await = \u0026ldquo;나(이 함수)는 여기서 기다릴게, Event Loop는 그 동안 다른 일 해!\u0026rdquo;\n","permalink":"https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/","summary":"\u003chr\u003e\n\u003ch2 id=\"nodejs-기본-구조\"\u003eNode.js 기본 구조\u003c/h2\u003e\n\u003cpre class=\"mermaid\"\u003egraph TB\n    subgraph STACK[Call Stack]\n        S1[현재 실행 중인 함수]\n    end\n\n    subgraph LOOP[Event Loop]\n        EL[Call Stack 비었나?\u0026lt;br/\u0026gt;→ Queue에서 가져오기]\n    end\n\n    subgraph QUEUES[Queues]\n        MQ[Microtask Queue\u0026lt;br/\u0026gt;Promise, await 완료]\n        TQ[Task Queue\u0026lt;br/\u0026gt;setTimeout, I/O, Cron]\n    end\n\n    STACK --\u0026gt; |비어있을 때만| LOOP\n    LOOP --\u0026gt; MQ\n    MQ --\u0026gt; |비었으면| TQ\n    TQ --\u0026gt; STACK\n\n    style STACK fill:#ff6b6b\n    style MQ fill:#4ecdc4\n    style TQ fill:#45b7d1\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e핵심 규칙: Call Stack이 비어야만 다음 작업 실행\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"오해-1-settimeout0은-즉시-실행된다\"\u003e오해 1: \u0026ldquo;setTimeout(0)은 즉시 실행된다\u0026rdquo;\u003c/h2\u003e\n\u003ch3 id=\"코드\"\u003e코드\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-jsx\" data-lang=\"jsx\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econsole\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetTimeout\u003cspan style=\"color:#eceff4\"\u003e(()\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e console\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;2\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e),\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econsole\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;3\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"실행-흐름\"\u003e실행 흐름\u003c/h3\u003e\n\u003cpre class=\"mermaid\"\u003esequenceDiagram\n    participant CS as Call Stack\n    participant TQ as Task Queue\n    participant OUT as 출력\n\n    Note over CS: console.log(\u0026#39;1\u0026#39;)\n    CS-\u0026gt;\u0026gt;OUT: \u0026#34;1\u0026#34;\n\n    Note over CS: setTimeout 등록\n    CS-\u0026gt;\u0026gt;TQ: 콜백 등록 (0ms여도!)\n\n    Note over CS: console.log(\u0026#39;3\u0026#39;)\n    CS-\u0026gt;\u0026gt;OUT: \u0026#34;3\u0026#34;\n\n    Note over CS: Call Stack 비었음!\n    TQ-\u0026gt;\u0026gt;CS: 콜백 가져오기\n\n    Note over CS: 콜백 실행\n    CS-\u0026gt;\u0026gt;OUT: \u0026#34;2\u0026#34;\u003c/pre\u003e\u003ch3 id=\"출력-1--3--2\"\u003e출력: \u003ccode\u003e1 → 3 → 2\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003esetTimeout(0)은 \u0026ldquo;다음 Event Loop에 실행\u0026quot;이라는 뜻!\u003c/strong\u003e\u003c/p\u003e","title":"이벤트 루프와 비동기, await에 대한 오해"},{"content":"개요 Record\u0026lt;Key, Value\u0026gt;는 키와 값 타입을 고정해 객체 형태를 만드는 타입스크립트 유틸리티 타입임 인덱스 시그니처와 유사하지만 문자열 리터럴 유니온을 키로 직접 사용할 수 있고, 맵드 타입으로도 같은 효과를 낼 수 있음\n핵심 개념과 정의 Record\u0026lt;Key, Value\u0026gt; 키 타입 Key, 값 타입 Value를 갖는 객체 타입 생성 인덱스 시그니처와의 차이 [key: string]: T 형태는 키 집합을 특정 리터럴 유니온으로 제한 불가 Record는 \u0026lsquo;A\u0026rsquo; | \u0026lsquo;B\u0026rsquo; 같은 리터럴 유니온을 키로 직접 지정 가능 맵드 타입과의 관계 { [K in Keys]: V }와 Record\u0026lt;Keys, V\u0026gt;는 구조적으로 동일한 결과를 만들 수 있음 간단 스니펫\ntype Names = \u0026#39;치즈볼\u0026#39; | \u0026#39;초코볼\u0026#39; // 인덱스 시그니처는 리터럴 유니온으로 키 제한 불가 // type Score = { [name: \u0026#39;치즈볼\u0026#39; | \u0026#39;초코볼\u0026#39;]: number } // 불가 // 맵드 타입 type Score = { [K in Names]: number } // Record type ScoreRecord = Record\u0026lt;Names, number\u0026gt;동작 원리와 구조 키 집합 정의 리터럴 유니온을 직접 지정하거나 keyof T로 도출 옵셔널 전파 여부 맵드 타입 { [K in keyof T]: V }는 기본적으로 T의 속성 옵셔널 여부를 전파함 Record\u0026lt;keyof T, V\u0026gt;는 원본 T의 옵셔널 여부를 전파하지 않고 모든 키를 필수로 간주함 옵셔널 차이 스니펫\ninterface CountType { views?: number likes?: number } // 맵드 타입은 옵셔널 전파 가능성 존재 const a: { [K in keyof CountType]: number[] } = { views: [], likes: [] } // a.views 사용 시 possibly \u0026#39;undefined\u0026#39; 경고 가능 // Record는 모든 키를 필수로 간주 const b: Record\u0026lt;keyof CountType, number[]\u0026gt; = { views: [], likes: [] } // b.views 접근 시 undefined 경고 없음 적용기 요약 프론트 개발에서 한 인터페이스의 키 집합을 다른 타입에도 그대로 재사용할 일이 많았음 초기에는 다음처럼 맵드 타입을 인라인으로 사용\nconst chartData: { [K in keyof CountType]: ChartType[] } = { /* ... */ }이 타입을 별도로 분리하려 했으나 인터페이스로는 맵드 타입만으로 정의 불가\n// interface X { [K in Keys]: V } 형태로 순수 맵드 타입만으로 인터페이스 선언 불가 대안\n속성을 한 번 감싸 인터페이스 내부에 맵드 타입을 둠 단, 실제 사용 시 X[\u0026lsquo;data\u0026rsquo;]처럼 내부 프로퍼티로 접근해야 하는 번거로움 발생 type 별칭으로 맵드 타입 선언 팀 규칙상 interface 중심 사용 시 도입이 어려울 수 있음 실전 선택은 Record 활용\nconst chartData: Record\u0026lt;keyof CountType, ChartType[]\u0026gt; = { /* ... */ }타입을 완전히 분리하지는 않지만 선언이 짧아지고 가독성이 좋아짐 필요하면 type 별칭으로 Record를 감싸 재사용 가능\ntype ChartDataType = Record\u0026lt;keyof CountType, ChartType[]\u0026gt;언제 무엇을 쓸까 리터럴 유니온 키를 간단히 객체 타입으로 만들고 싶음 Record 선호 기존 타입 T의 키 집합에 값을 매핑하고, 옵셔널이나 readonly 같은 수정자 전파가 필요함 맵드 타입 선호 팀 컨벤션이 interface 중심이고 맵드 타입을 인터페이스로 직접 선언해야 한다는 요구가 있음 불가하므로 Record 인라인 사용 또는 type 별칭 최소 도입 고려 키 집합이 바뀔 때 컴파일 타임에 누락을 잡고 싶음 Record와 맵드 타입 모두 keyof를 사용하면 누락 감지 가능 간단 예시 리터럴 유니온 키를 가진 점수판 타입 정의\ntype Names = \u0026#39;치즈볼\u0026#39; | \u0026#39;초코볼\u0026#39; type Scores = Record\u0026lt;Names, number\u0026gt;주의 사항 맵드 타입은 기본적으로 원본의 옵셔널 여부를 전파하므로 접근 시 undefined 가드 필요 가능 Record\u0026lt;keyof T, V\u0026gt;는 모든 키를 필수로 보고 생성하므로 값 초기화 전략을 먼저 정리할 것 interface로는 순수 맵드 타입을 직접 선언할 수 없음 공용 타입을 재사용한다면 이름 있는 type 별칭으로 감싸 관리하는 편이 안전 마무리 Record는 인덱스 시그니처보다 명시적 키 집합을 다루기 쉽고, 맵드 타입보다 선언을 짧게 유지하기 좋음 옵셔널 전파 여부와 팀 컨벤션을 고려해 Record와 맵드 타입을 상황에 맞게 선택하는 것이 핵심임 유틸리티 타입 전반을 익혀두면 리팩터링과 타입 재사용성 모두에서 이점을 얻을 수 있음\n참고자료 https://cheeseb.github.io/typescript/typescript-record/ https://www.typescriptlang.org/docs/handbook/utility-types.html https://cheeseb.github.io/typescript/typescript-utility-omit/ https://developer-talk.tistory.com/296 ","permalink":"https://blog.jsontapose.com/posts/typescript-record-mapped-type-index-signature-d67f80/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eRecord\u0026lt;Key, Value\u0026gt;는 키와 값 타입을 고정해 객체 형태를 만드는 타입스크립트 유틸리티 타입임\n인덱스 시그니처와 유사하지만 문자열 리터럴 유니온을 키로 직접 사용할 수 있고, 맵드 타입으로도 같은 효과를 낼 수 있음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRecord\u0026lt;Key, Value\u0026gt;\n\u003cul\u003e\n\u003cli\u003e키 타입 Key, 값 타입 Value를 갖는 객체 타입 생성\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e인덱스 시그니처와의 차이\n\u003cul\u003e\n\u003cli\u003e[key: string]: T 형태는 키 집합을 특정 리터럴 유니온으로 제한 불가\u003c/li\u003e\n\u003cli\u003eRecord는 \u0026lsquo;A\u0026rsquo; | \u0026lsquo;B\u0026rsquo; 같은 리터럴 유니온을 키로 직접 지정 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e맵드 타입과의 관계\n\u003cul\u003e\n\u003cli\u003e{ [K in Keys]: V }와 Record\u0026lt;Keys, V\u0026gt;는 구조적으로 동일한 결과를 만들 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e간단 스니펫\u003c/p\u003e","title":"TypeScript Record 제대로 이해하기 — 인덱스 시그니처와 맵드 타입 비교, 선택 기준"},{"content":"개요 리터럴 선언 시 조건에 따라 요소나 속성을 넣었다 뺄 수 있는 패턴 정리 분기문 없이 스프레드 연산자만으로 가독성 유지\n사용법/예시 배열은 피연산자가 이터러블이어야 하므로 삼항 연산자 사용\nconst arr = [ ...(cond ? [1, 2, 3] : []), 4, 5, 6, ] // cond === true =\u0026gt; [1, 2, 3, 4, 5, 6] // cond === false =\u0026gt; [4, 5, 6] 객체는 원시값을 스프레드해도 자체 속성이 없어 무시됨 불리언화로 안전성 확보\nconst obj = { ...(!!cond \u0026amp;\u0026amp; { a: 1, b: 2 }), c: 3, d: 4, } // cond === true =\u0026gt; { a: 1, b: 2, c: 3, d: 4 } // cond === false =\u0026gt; { c: 3, d: 4 } 주의 사항 배열에서 \u0026hellip;(cond \u0026amp;\u0026amp; [1,2,3]) 사용 금지, cond가 false면 이터러블 아님 오류 발생 객체에서 null이나 undefined를 그대로 스프레드하면 오류 가능, !!cond로 불리언화하거나 cond ? {..} : {} 형태 권장 타입스크립트에서는 \u0026amp;\u0026amp; 패턴이 타입 좁히기 미흡할 수 있음, 삼항으로 빈 객체 반환 또는 적절한 타입 주석 권장\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND ","permalink":"https://blog.jsontapose.com/posts/conditional-add-with-spread-array-object-940699/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e리터럴 선언 시 조건에 따라 요소나 속성을 넣었다 뺄 수 있는 패턴 정리\n분기문 없이 스프레드 연산자만으로 가독성 유지\u003c/p\u003e\n\u003ch3 id=\"사용법예시\"\u003e사용법/예시\u003c/h3\u003e\n\u003cp\u003e배열은 피연산자가 이터러블이어야 하므로 삼항 연산자 사용\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e arr \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e...(\u003c/span\u003econd \u003cspan style=\"color:#81a1c1\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[]),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#b48ead\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e6\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// cond === true =\u0026gt; [1, 2, 3, 4, 5, 6]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// cond === false =\u0026gt; [4, 5, 6]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e객체는 원시값을 스프레드해도 자체 속성이 없어 무시됨\n불리언화로 안전성 확보\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e obj \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e...(\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e!!\u003c/span\u003econd \u003cspan style=\"color:#81a1c1\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e a\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e b\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  c\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  d\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// cond === true =\u0026gt; { a: 1, b: 2, c: 3, d: 4 }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// cond === false =\u0026gt; { c: 3, d: 4 }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"주의-사항\"\u003e주의 사항\u003c/h3\u003e\n\u003cp\u003e배열에서 \u0026hellip;(cond \u0026amp;\u0026amp; [1,2,3]) 사용 금지, cond가 false면 이터러블 아님 오류 발생\n객체에서 null이나 undefined를 그대로 스프레드하면 오류 가능, !!cond로 불리언화하거나 cond ? {..} : {} 형태 권장\n타입스크립트에서는 \u0026amp;\u0026amp; 패턴이 타입 좁히기 미흡할 수 있음, 삼항으로 빈 객체 반환 또는 적절한 타입 주석 권장\u003c/p\u003e","title":"스프레드 연산자로 배열 요소와 객체 속성 조건부 추가"},{"content":"InnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 (colA, colB, colC) 인덱스면 colA 기준으로 정렬되고 같은 colA 그룹 내에서 colB, 이어서 colC 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐\n개념과 배경 복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장 InnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향 left-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦 동작 방식 예시 (colA, colB) 인덱스 구조 정렬 키 순서: colA → colB → 내부적으로 PK 참조 왼쪽 컬럼 우선 필터링 WHERE colA = ? 또는 WHERE colA = ? AND colB = ? 형태는 인덱스를 온전히 사용 가능 WHERE colB = ?처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움 왼쪽 접두사 부분 사용 (colA, colB)에서 colA만 조건으로 사용해도 인덱스 사용 가능 colA와 colB를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐 colB만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음 정렬과 결합 사용의 기본 인덱스 키 순서와 같은 ORDER BY colA, colB는 추가 정렬 비용 감소에 도움 WHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦 여러 컬럼을 묶는 이유 다중 조건 검색 성능 향상. 예: WHERE colA = ? AND colB BETWEEN ? AND ?는 (colA, colB)로 빠른 범위 스캔 가능 커버링 인덱스 활용. 예: SELECT colA, colB FROM T WHERE colA = ? AND colB = ?에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능 쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가 주의할 점 인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장 너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한 (A, B, C)일 때 WHERE B = ?처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 (B, A) 같은 보완 인덱스 검토 InnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리 ORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락 범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 colA BETWEEN ...가 선두에 오면 그 뒤 colB는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음 마무리 복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨 다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음 불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심 참고자료 https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html ","permalink":"https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/","summary":"\u003cp\u003eInnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 \u003ccode\u003e(colA, colB, colC)\u003c/code\u003e 인덱스면 \u003ccode\u003ecolA\u003c/code\u003e 기준으로 정렬되고 같은 \u003ccode\u003ecolA\u003c/code\u003e 그룹 내에서 \u003ccode\u003ecolB\u003c/code\u003e, 이어서 \u003ccode\u003ecolC\u003c/code\u003e 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐\u003c/p\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장\u003c/li\u003e\n\u003cli\u003eInnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향\u003c/li\u003e\n\u003cli\u003eleft-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-방식-예시-cola-colb\"\u003e동작 방식 예시 \u003ccode\u003e(colA, colB)\u003c/code\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e인덱스 구조\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e정렬 키 순서: \u003ccode\u003ecolA\u003c/code\u003e → \u003ccode\u003ecolB\u003c/code\u003e → 내부적으로 PK 참조\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e왼쪽 컬럼 우선 필터링\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eWHERE colA = ?\u003c/code\u003e 또는 \u003ccode\u003eWHERE colA = ? AND colB = ?\u003c/code\u003e 형태는 인덱스를 온전히 사용 가능\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWHERE colB = ?\u003c/code\u003e처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e왼쪽 접두사 부분 사용\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e(colA, colB)\u003c/code\u003e에서 \u003ccode\u003ecolA\u003c/code\u003e만 조건으로 사용해도 인덱스 사용 가능\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecolA\u003c/code\u003e와 \u003ccode\u003ecolB\u003c/code\u003e를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecolB\u003c/code\u003e만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e정렬과 결합 사용의 기본\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e인덱스 키 순서와 같은 \u003ccode\u003eORDER BY colA, colB\u003c/code\u003e는 추가 정렬 비용 감소에 도움\u003c/li\u003e\n\u003cli\u003eWHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"여러-컬럼을-묶는-이유\"\u003e여러 컬럼을 묶는 이유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e다중 조건 검색 성능 향상. 예: \u003ccode\u003eWHERE colA = ? AND colB BETWEEN ? AND ?\u003c/code\u003e는 \u003ccode\u003e(colA, colB)\u003c/code\u003e로 빠른 범위 스캔 가능\u003c/li\u003e\n\u003cli\u003e커버링 인덱스 활용. 예: \u003ccode\u003eSELECT colA, colB FROM T WHERE colA = ? AND colB = ?\u003c/code\u003e에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능\u003c/li\u003e\n\u003cli\u003e쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의할-점\"\u003e주의할 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장\u003c/li\u003e\n\u003cli\u003e너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e(A, B, C)\u003c/code\u003e일 때 \u003ccode\u003eWHERE B = ?\u003c/code\u003e처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 \u003ccode\u003e(B, A)\u003c/code\u003e 같은 보완 인덱스 검토\u003c/li\u003e\n\u003cli\u003eInnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리\u003c/li\u003e\n\u003cli\u003eORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락\u003c/li\u003e\n\u003cli\u003e범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 \u003ccode\u003ecolA BETWEEN ...\u003c/code\u003e가 선두에 오면 그 뒤 \u003ccode\u003ecolB\u003c/code\u003e는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨\u003c/li\u003e\n\u003cli\u003e다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음\u003c/li\u003e\n\u003cli\u003e불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html\"\u003ehttps://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html\"\u003ehttps://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html\"\u003ehttps://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html\"\u003ehttps://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"InnoDB 복합 인덱스와 Left-most Prefix 원칙 정리"},{"content":"개념/배경 JavaScript에서 조건식은 내부적으로 ToBoolean 연산을 거쳐 참거짓을 판정함 이때 객체 타입은 모두 truthy로 간주되며 배열도 객체에 해당함 따라서 빈 배열 []과 빈 객체 {} 역시 조건문에서 true로 평가됨 반대로 falsy는 정해진 값만 해당됨 false, 0, -0, 0n, \u0026ldquo;\u0026rdquo;, null, undefined, NaN\n예시 다음은 빈 배열이 조건문에서 어떻게 평가되는지 확인하는 간단한 코드\nif ([]) { console.log(\u0026#34;빈 배열은 truthy입니다!\u0026#34;) } else { console.log(\u0026#34;빈 배열은 falsy입니다!\u0026#34;) } // 출력: \u0026#34;빈 배열은 truthy입니다!\u0026#34; 배열이 비어 있는지를 논리적으로 구분하려면 길이를 확인해야 함\nconst myArray = [] if (myArray.length === 0) { console.log(\u0026#34;빈 배열입니다! (falsy처럼 취급)\u0026#34;) } else { console.log(\u0026#34;배열에 요소가 있습니다! (truthy)\u0026#34;) }주의할 점 빈 배열은 truthy이지만 느슨한 동등 비교는 다른 규칙이 개입할 수 있음\n[] == false // true Boolean([]) // true 조건식은 ToBoolean으로 배열을 truthy로 처리하지만, == 비교는 타입 변환 과정에서 숫자 0과 false가 같게 평가되는 등 예외적 동작이 발생함 조건식 판단은 Boolean 변환 또는 길이 검사 사용 권장\n정리 []와 {}는 조건문에서 truthy로 평가됨 \u0026ldquo;비어 있음\u0026quot;을 판단하려면 배열은 length === 0 확인 느슨한 동등 비교 == 는 혼동 유발 가능성 높음, 조건 판단에는 명시적 검사 권장 참고자료 https://developer.mozilla.org/en-US/docs/Glossary/Truthy https://developer.mozilla.org/en-US/docs/Glossary/Falsy https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else ","permalink":"https://blog.jsontapose.com/posts/javascript-empty-array-truthy-falsy-32e6fe/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eJavaScript에서 조건식은 내부적으로 ToBoolean 연산을 거쳐 참거짓을 판정함\n이때 객체 타입은 모두 truthy로 간주되며 배열도 객체에 해당함\n따라서 빈 배열 []과 빈 객체 {} 역시 조건문에서 true로 평가됨\n반대로 falsy는 정해진 값만 해당됨 false, 0, -0, 0n, \u0026ldquo;\u0026rdquo;, null, undefined, NaN\u003c/p\u003e\n\u003ch3 id=\"예시\"\u003e예시\u003c/h3\u003e\n\u003cp\u003e다음은 빈 배열이 조건문에서 어떻게 평가되는지 확인하는 간단한 코드\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e([])\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  console\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;빈 배열은 truthy입니다!\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eelse\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  console\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003elog\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;빈 배열은 falsy입니다!\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 출력: \u0026#34;빈 배열은 truthy입니다!\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e배열이 비어 있는지를 논리적으로 구분하려면 길이를 확인해야 함\u003c/p\u003e","title":"JavaScript에서 빈 배열은 truthy인가 falsy인가"},{"content":"개요 백오프는 실패한 작업을 즉시 재시도하지 않고 일정 시간 대기 후 다시 시도하는 전략을 말함 연속 실패 시 대기 시간을 점진적으로 늘려 서비스와 네트워크에 가해지는 부하를 낮추는 목적 RPC, 데이터베이스, 외부 API 호출, 트랜잭션 재시도 등에서 일반적으로 사용\n왜 쓰는가 과부하 방지 실패 직후 동시 재시도를 막아 서버와 네트워크 폭주를 예방 일시적 장애 흡수 순간적인 지연이나 혼잡이 해소될 시간을 벌어 성공 확률을 높임 비용 절감 불필요한 재시도 횟수와 리소스 낭비 감소 대표 백오프 패턴 고정 백오프 Fixed 매번 동일 대기 시간 사용 예) 1초 → 1초 → 1초 선형 백오프 Linear 시도할 때마다 일정 간격으로 증가 예) 1초 → 2초 → 3초 → 4초 지수 백오프 Exponential 보통 2배로 증가하는 지수 증가 사용, 실무에서 기본값으로 가장 흔함 예) 1초 → 2초 → 4초 → 8초 → 16초 지수 백오프 + 지터 Jitter 지수 증가에 무작위성을 섞어 동시 재시도 동기화를 깨뜨림 예) 1초 → 2.3초 → 4.1초 → 8.6초 실전 포인트 동시성 환경에서는 지터 필수 동일한 주기 백오프만으로는 다수 클라이언트가 같은 타이밍에 몰려 서버를 다시 두들김 상한 설정 최대 대기 시간과 최대 재시도 횟수 캡을 두어 꼬리 길어짐 방지 실패 예산과 타임아웃 연계 전체 호출 타임아웃 내에서 재시도 예산을 배분, 1회 호출과 재시도들이 전체 SLA를 초과하지 않도록 관리 멱등성 보장 재시도 가능한 작업은 멱등성을 만족해야 안전, 아니면 보상 로직 필요 서버 힌트 활용 Retry-After 등 서버가 제시하는 대기 힌트가 있으면 우선 적용 지터 방식 선택 전체 구간 무작위 분포 Full jitter가 단순하고 효과적이라는 보고가 많음 간단 예시 아래는 지수 백오프의 최소 구현 예시이며, 지터와 최대 대기 시간 제한은 상황에 맞게 추가 권장\nasync function retryWithBackoff(fn) { let delay = 1000 // 1초 for (let i = 0; i \u0026lt; 5; i++) { try { return await fn() } catch (e) { await new Promise(r =\u0026gt; setTimeout(r, delay)) delay *= 2 // 지수 증가 } } }한 줄 요약 백오프는 실패 직후 재시도를 지연시키고 연속 실패 시 대기 시간을 늘리는 전략이며, 실전에서는 지수 백오프에 지터를 더해 동시 폭주를 피하는 구성이 표준적 선택\n참고자료 https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter/ https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/ https://cloud.google.com/storage/docs/retry-strategy ","permalink":"https://blog.jsontapose.com/posts/backoff-retry-strategy-fixed-linear-exponential-jitter-6d23a5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e백오프는 실패한 작업을 즉시 재시도하지 않고 일정 시간 대기 후 다시 시도하는 전략을 말함\n연속 실패 시 대기 시간을 점진적으로 늘려 서비스와 네트워크에 가해지는 부하를 낮추는 목적\nRPC, 데이터베이스, 외부 API 호출, 트랜잭션 재시도 등에서 일반적으로 사용\u003c/p\u003e\n\u003ch3 id=\"왜-쓰는가\"\u003e왜 쓰는가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e과부하 방지\n실패 직후 동시 재시도를 막아 서버와 네트워크 폭주를 예방\u003c/li\u003e\n\u003cli\u003e일시적 장애 흡수\n순간적인 지연이나 혼잡이 해소될 시간을 벌어 성공 확률을 높임\u003c/li\u003e\n\u003cli\u003e비용 절감\n불필요한 재시도 횟수와 리소스 낭비 감소\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"대표-백오프-패턴\"\u003e대표 백오프 패턴\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e고정 백오프 Fixed\n매번 동일 대기 시간 사용\n예) 1초 → 1초 → 1초\u003c/li\u003e\n\u003cli\u003e선형 백오프 Linear\n시도할 때마다 일정 간격으로 증가\n예) 1초 → 2초 → 3초 → 4초\u003c/li\u003e\n\u003cli\u003e지수 백오프 Exponential\n보통 2배로 증가하는 지수 증가 사용, 실무에서 기본값으로 가장 흔함\n예) 1초 → 2초 → 4초 → 8초 → 16초\u003c/li\u003e\n\u003cli\u003e지수 백오프 + 지터 Jitter\n지수 증가에 무작위성을 섞어 동시 재시도 동기화를 깨뜨림\n예) 1초 → 2.3초 → 4.1초 → 8.6초\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실전-포인트\"\u003e실전 포인트\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e동시성 환경에서는 지터 필수\n동일한 주기 백오프만으로는 다수 클라이언트가 같은 타이밍에 몰려 서버를 다시 두들김\u003c/li\u003e\n\u003cli\u003e상한 설정\n최대 대기 시간과 최대 재시도 횟수 캡을 두어 꼬리 길어짐 방지\u003c/li\u003e\n\u003cli\u003e실패 예산과 타임아웃 연계\n전체 호출 타임아웃 내에서 재시도 예산을 배분, 1회 호출과 재시도들이 전체 SLA를 초과하지 않도록 관리\u003c/li\u003e\n\u003cli\u003e멱등성 보장\n재시도 가능한 작업은 멱등성을 만족해야 안전, 아니면 보상 로직 필요\u003c/li\u003e\n\u003cli\u003e서버 힌트 활용\nRetry-After 등 서버가 제시하는 대기 힌트가 있으면 우선 적용\u003c/li\u003e\n\u003cli\u003e지터 방식 선택\n전체 구간 무작위 분포 Full jitter가 단순하고 효과적이라는 보고가 많음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e아래는 지수 백오프의 최소 구현 예시이며, 지터와 최대 대기 시간 제한은 상황에 맞게 추가 권장\u003c/p\u003e","title":"백오프 Backoff 재시도 전략 정리 고정·선형·지수·지터"},{"content":"개요 슬리피지(slippage)는 내가 예상한 가격과 실제 체결 가격의 차이를 의미함 분산형 거래소 환경에서는 블록 포함 지연과 유동성 구조 때문에 발생 빈도가 높음\n슬리피지가 발생하는 이유 유동성 부족 특정 토큰 페어의 유동성 풀이 얕으면 작은 주문에도 가격 영향 커짐 대량 주문 시장 규모 대비 큰 금액을 한 번에 실행 시 풀 내 토큰 비율이 급격히 변해 체결 평균가가 악화됨 시장 변동성 트랜잭션 제출 시점과 블록에 포함되는 시점 사이 외부 가격 급변으로 기대 가격과 괴리 발생 AMM에서의 동작 대부분의 DEX는 AMM을 사용하며 풀 내 두 토큰의 비율로 가격이 정해짐. 단순화된 상수곱 x·y=k 모델 기준으로 설명함\n예시 ETH 100, USDC 10,000이 있는 풀 가정 초기 k는 1,000,000이며 표시 가격은 1 ETH당 100 USDC에 근사 사용자가 ETH 10개를 풀에 판매하면 x는 110으로 증가하고 y는 k/x로 재계산되어 약 9,090.909로 감소함 사용자가 수취하는 USDC는 10,000에서 9,090.909를 뺀 약 909.091로, 평균 체결가는 약 90.909 USDC/ETH가 됨 초기 표시 가격 100 대비 낮은 평균가가 바로 슬리피지로 인한 가격 영향이며, 수수료와는 별개 항목임 슬리피지 허용치 대부분의 DEX는 사용자가 슬리피지 허용치(slippage tolerance)를 설정하도록 함\n허용치 1% 예시 예상 가격 대비 최대 1% 불리해져도 체결 진행 의미 허용치를 초과하면 트랜잭션은 되돌림 발생, 사용자는 가스비만 지출함 주의와 간단 팁 주문 분할로 단일 거래의 가격 충격 완화 유동성이 깊은 풀 선택으로 체결 안정성 확보 변동성 구간에서는 허용치 과도 확대 지양, 실패 시 가스 손실 감수 필요 가능하다면 제한가 형태의 라우팅 기능 활용 검토 참고자료 https://docs.uniswap.org/concepts/protocol/overview https://en.wikipedia.org/wiki/Slippage https://www.investopedia.com/terms/s/slippage.asp ","permalink":"https://blog.jsontapose.com/posts/amm-dex-slippage-4c7cd0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e슬리피지(slippage)는 내가 예상한 가격과 실제 체결 가격의 차이를 의미함\n분산형 거래소 환경에서는 블록 포함 지연과 유동성 구조 때문에 발생 빈도가 높음\u003c/p\u003e\n\u003ch3 id=\"슬리피지가-발생하는-이유\"\u003e슬리피지가 발생하는 이유\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e유동성 부족\n특정 토큰 페어의 유동성 풀이 얕으면 작은 주문에도 가격 영향 커짐\u003c/li\u003e\n\u003cli\u003e대량 주문\n시장 규모 대비 큰 금액을 한 번에 실행 시 풀 내 토큰 비율이 급격히 변해 체결 평균가가 악화됨\u003c/li\u003e\n\u003cli\u003e시장 변동성\n트랜잭션 제출 시점과 블록에 포함되는 시점 사이 외부 가격 급변으로 기대 가격과 괴리 발생\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"amm에서의-동작\"\u003eAMM에서의 동작\u003c/h3\u003e\n\u003cp\u003e대부분의 DEX는 AMM을 사용하며 풀 내 두 토큰의 비율로 가격이 정해짐. 단순화된 상수곱 x·y=k 모델 기준으로 설명함\u003c/p\u003e","title":"AMM DEX에서 슬리피지 이해와 허용치 설정"},{"content":"개요 테이블 이름 변경은 ALTER TABLE로도 가능하지만, RENAME TABLE을 쓰면 다수 테이블을 한 번에 처리 가능하며 같은 서버 내 다른 데이터베이스로 이동까지 가능함\n핵심 차이 ALTER TABLE RENAME은 단일 테이블 대상 RENAME TABLE은 여러 테이블을 한 문장으로 변경 가능 스키마 간 이동 지원 current_db.table에서 other_db.table로 변경 가능 동일 트랜잭션처럼 동작하는 원자성 제공, 다중 변경 중 하나라도 실패 시 전체 미적용 권한 요구 사항 존재, 원본 테이블에 ALTER와 DROP, 대상 스키마에 CREATE 권한 필요 트리거와 외래키 메타데이터는 함께 유지되나, 뷰나 저장 프로시저의 하드코딩된 참조는 자동 갱신되지 않음 사용법 단일 테이블 이름 변경 RENAME TABLE old_table TO new_table; 단일 테이블 이름 변경 ALTER 사용 ALTER TABLE old_table RENAME new_table; 다수 테이블 이름 일괄 변경 RENAME TABLE old_table1 TO new_table1, old_table2 TO new_table2, old_table3 TO new_table3; 다른 데이터베이스로 이동 같은 서버 내 RENAME TABLE current_db.table_name TO other_db.table_name;주의 사항 대상 이름이 이미 존재하면 실패 교차 서버 이동 불가, 같은 서버 인스턴스 내 스키마 간 이동만 가능 실행 시 메타데이터 락 획득, 짧은 구간 동안 읽기나 쓰기 대기 가능 배치 변경 전 사전 검증 권장, 이름 충돌 여부와 권한 확인 뷰나 프로시저 참조는 수동 점검 필요, 린트나 간단한 탐색 쿼리로 영향 범위 확인 권장 정리 단일 변경만 필요하면 ALTER로 충분하나, 다수 변경이나 스키마 이동까지 고려하면 RENAME TABLE이 더 실용적 선택 원자적 일괄 변경과 스키마 간 이동을 활용하되, 권한과 의존성 영향 검증을 선행할 것\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/rename-table.html https://dev.mysql.com/doc/refman/8.0/en/alter-table.html ","permalink":"https://blog.jsontapose.com/posts/mysql-rename-table-vs-alter-table-470e90/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e테이블 이름 변경은 ALTER TABLE로도 가능하지만, RENAME TABLE을 쓰면 다수 테이블을 한 번에 처리 가능하며 같은 서버 내 다른 데이터베이스로 이동까지 가능함\u003c/p\u003e\n\u003ch3 id=\"핵심-차이\"\u003e핵심 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eALTER TABLE RENAME은 단일 테이블 대상\u003c/li\u003e\n\u003cli\u003eRENAME TABLE은 여러 테이블을 한 문장으로 변경 가능\u003c/li\u003e\n\u003cli\u003e스키마 간 이동 지원 current_db.table에서 other_db.table로 변경 가능\u003c/li\u003e\n\u003cli\u003e동일 트랜잭션처럼 동작하는 원자성 제공, 다중 변경 중 하나라도 실패 시 전체 미적용\u003c/li\u003e\n\u003cli\u003e권한 요구 사항 존재, 원본 테이블에 ALTER와 DROP, 대상 스키마에 CREATE 권한 필요\u003c/li\u003e\n\u003cli\u003e트리거와 외래키 메타데이터는 함께 유지되나, 뷰나 저장 프로시저의 하드코딩된 참조는 자동 갱신되지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용법\"\u003e사용법\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단일 테이블 이름 변경\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eRENAME\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTABLE\u003c/span\u003e old_table \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTO\u003c/span\u003e new_table\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e단일 테이블 이름 변경 ALTER 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eALTER\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTABLE\u003c/span\u003e old_table \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eRENAME\u003c/span\u003e new_table\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e다수 테이블 이름 일괄 변경\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eRENAME\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTABLE\u003c/span\u003e old_table1 \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTO\u003c/span\u003e new_table1\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             old_table2 \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTO\u003c/span\u003e new_table2\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e             old_table3 \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTO\u003c/span\u003e new_table3\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e다른 데이터베이스로 이동 같은 서버 내\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eRENAME\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTABLE\u003c/span\u003e current_db\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etable_name\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eTO\u003c/span\u003e other_db\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etable_name\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"주의-사항\"\u003e주의 사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e대상 이름이 이미 존재하면 실패\u003c/li\u003e\n\u003cli\u003e교차 서버 이동 불가, 같은 서버 인스턴스 내 스키마 간 이동만 가능\u003c/li\u003e\n\u003cli\u003e실행 시 메타데이터 락 획득, 짧은 구간 동안 읽기나 쓰기 대기 가능\u003c/li\u003e\n\u003cli\u003e배치 변경 전 사전 검증 권장, 이름 충돌 여부와 권한 확인\u003c/li\u003e\n\u003cli\u003e뷰나 프로시저 참조는 수동 점검 필요, 린트나 간단한 탐색 쿼리로 영향 범위 확인 권장\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"정리\"\u003e정리\u003c/h3\u003e\n\u003cp\u003e단일 변경만 필요하면 ALTER로 충분하나, 다수 변경이나 스키마 이동까지 고려하면 RENAME TABLE이 더 실용적 선택\n원자적 일괄 변경과 스키마 간 이동을 활용하되, 권한과 의존성 영향 검증을 선행할 것\u003c/p\u003e","title":"MySQL 테이블 이름 변경 RENAME TABLE vs ALTER TABLE 정리"},{"content":"개요 Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음 Prisma에서는 JOIN이 어디로 갔나 하는 질문임 개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음 정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함\nORM이란 무엇인가 ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함 애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공 SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능 데이터베이스 의존성 완화 효과 기대\nActive Record vs Data Mapper ORM 구현 패턴은 크게 두 가지로 요약됨\nActive Record 패턴\n클래스와 테이블의 동치에 가까운 모델링 필드가 컬럼, 인스턴스가 레코드에 대응 접근·조작 로직이 모델에 함께 존재 데이터베이스 스키마 변화에 코드가 민감하게 결합되는 단점 Data Mapper 패턴\n모델과 데이터베이스를 분리하는 매핑 계층 존재 엔티티 클래스와 매퍼 클래스를 분리 정의 유연성 증가 대신 클래스 수 증가와 변화 추적 복잡도 상승 가능 일반적으로 ORM은 공통 CRUD와 쿼리 API를 제공하고, 세부 패턴은 프레임워크가 선택하거나 혼합 지원함\nPrisma와 스키마 중심 모델링 Prisma는 Data Mapper 계열이지만, 자체 스키마를 중심으로 모델·마이그레이션·Client를 모두 생성하는 점이 특징임 단일 스키마 파일에서 데이터베이스 스키마와 Prisma Client가 동시에 파생됨 @map()을 통해 애플리케이션의 명명 규칙과 데이터베이스 물리명 분리 가능\n예시 스키마 최소 발췌\nmodel Notice { id Int @id @default(autoincrement()) createdBy User @relation(fields: [createdById], references: [id]) createdById Int @map(\u0026#34;created_by_id\u0026#34;) group Group @relation(fields: [groupId], references: [id]) groupId Int @map(\u0026#34;group_id\u0026#34;) title String }Prisma Client는 이 스키마를 근거로 타입 안정성이 확보된 쿼리 API를 제공함\nPrisma에는 JOIN이 없나 Prisma Client 메소드 목록에는 JOIN이 존재하지 않음 서브쿼리도 직접 제공되지 않음 그렇다면 관계형 조회는 어떻게 수행되는가가 핵심 포인트임\n기본적인 include 사용 예시\nawait prisma.notice.findMany({ include: { group: true, }, })특정 컬럼만 선택하고 싶다면 select 사용\nconst notices: Array\u0026lt;{ id: number title: string group: { groupName: string } }\u0026gt; = await prisma.notice.findMany({ select: { id: true, title: true, group: { select: { groupName: true }, }, }, })내부적으로 JOIN을 쓰는가 직관적으로는 JOIN 또는 서브쿼리로 변환될 것 같지만, Prisma는 관계 쿼리를 다중 SELECT로 분해해 전송함 일반적인 패턴은 부모 테이블 조회 후 자식 테이블을 IN 절로 한 번 더 조회하는 형태임\n예시 로그 형태 요약\nSELECT Notice.id, Notice.title, Notice.groupId FROM Notice ... SELECT Group.id, Group.groupName FROM Group WHERE Group.id IN (...) ...코어 엔진이 이 결과들을 클라이언트 메모리에서 합성하고, include 또는 select로 요청한 nested 구조를 만들어 반환함 스키마의 @relation 정보는 실제 데이터베이스 컬럼으로 생기지 않지만, 타입 안전성과 결과 합성에 필요한 메타로 쓰임\n성능과 트레이드오프 JOIN이 없는 전략은 범용성 측면에서 장점이 있음\n다중 데이터베이스 지원 용이 커넥터 구현 부담 감소 쿼리 엔진이 공통 로직을 재사용하기 쉬움 반면 성능 리스크 존재\n다중 SELECT에 따른 왕복 비용 증가 가능 넓은 테이블 스캔 또는 부적절한 WHERE 인덱스 사용 시 비용 급증 대용량 데이터셋에서 JOIN 대비 비효율 가능성 높음 결론적으로 관계형 데이터베이스에서 최적화된 조인 실행 계획을 활용하지 못할 수 있음 크리티컬 경로에서는 성능 검증 필요\n필요한 경우 JOIN을 쓰는 방법 ORM 순수 사용 원칙에서는 벗어나지만, Prisma에서는 raw query로 JOIN 사용 가능 핫패스나 리포트성 대용량 집계처럼 조인이 본질적인 영역에서는 고려 가치 있음 프로그래밍 모델은 Prisma Client를 유지하되 특정 쿼리만 raw로 대체하는 하이브리드 전략 권장\n단일 책임 함수로 캡슐화 입력 검증과 SQL 인젝션 방지 매개 API 사용 스키마 변경 시 회귀 테스트로 커버 참고 문서 확인 권장\n왜 처음부터 JOIN을 쓰지 않았나 역사적 배경상 Prisma의 목표는 전통적 ORM 최적화가 아니라 다중 데이터베이스를 아우르는 가상 데이터베이스 레이어에 가까웠음\n코어 엔진에 공통 로직 집중, 커넥터는 최소한의 변환만 수행하는 구조 지향 MongoDB처럼 JOIN이 없는 시스템도 지원해야 했음 따라서 쿼리를 가장 단순한 형태로 쪼개어 처리하는 전략이 합리적 선택이었음 현 시점에서는 사용자 기반이 커지며 전통적 ORM 기대치도 함께 커짐 Prisma 팀 역시 크리티컬 케이스에서 JOIN 기반 생성 지원을 추진 중이라고 알려짐 과거의 범용성 우선 전략에서, 실용적 성능과 개발 경험을 균형 있게 보완하는 과도기로 보는 편이 타당함\n마무리 Prisma에는 개발자 API 차원에서 JOIN이 없음 실행 단계에서도 기본적으로 다중 SELECT 후 결과 합성 전략을 사용함 다만 실무에서는 핫패스에 한해 raw JOIN을 병행해 성능 보완 가능 장기적으로 Prisma가 선택적 JOIN 생성 옵션을 제공하면, 현재 전략과의 성능 차이를 정량적으로 검증하는 것이 합리적임 현재도 Prisma의 타입 안전성, 스키마 중심 워크플로우, 범용성은 충분히 매력적임 팀의 쿼리 특성과 트래픽 패턴을 기준으로 선택과 집중이 필요함\n참고자료 https://www.prisma.io/ https://typeorm.io/active-record-data-mapper https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access https://github.com/prisma/prisma/issues/5184 https://codedamn.com/news/product/dont-use-prisma https://www.prisma.io/day-2019 https://www.youtube.com/watch?v=RAoXdyI_PH4 ","permalink":"https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003ePrisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음\nPrisma에서는 JOIN이 어디로 갔나 하는 질문임\n개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음\n정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함\u003c/p\u003e\n\u003ch3 id=\"orm이란-무엇인가\"\u003eORM이란 무엇인가\u003c/h3\u003e\n\u003cp\u003eORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함\n애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공\nSQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능\n데이터베이스 의존성 완화 효과 기대\u003c/p\u003e","title":"Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리"},{"content":"개요 여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음 키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함 이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함\nPromise.all 개념과 정의 여러 Promise를 단일 Promise로 집계하는 유틸리티 모든 입력이 이행되면 결과를 같은 순서의 배열로 반환 하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유 입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨\nPromise.all 동작 원리와 특징 집계 대상 생성 시점에 작업이 시작됨 Promise.all 자체가 작업을 시작시키는 것은 아니고, 보통 배열에 담는 과정에서 각 Promise의 executor가 실행됨 모든 입력이 이행되면 동일한 인덱스 순서로 결과 배열 반환 하나라도 거부되면 첫 번째 거부 이유로 즉시 종료 종료 이후에도 이미 시작된 다른 작업의 부수효과는 계속 진행될 수 있음 빈 배열을 넘기면 즉시 이행하며 결과는 빈 배열 이터러블이면 배열이 아니어도 처리 가능\n간단 문법 Promise.all(iterable) iterable에 Promise 또는 값 나열 반환은 단일 Promise 하나 사용 예시 최소 스니펫 const a = Promise.resolve(3) const b = new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; resolve(\u0026#39;foo\u0026#39;), 1000)) Promise.all([a, b]) .then(([x, y]) =\u0026gt; { console.log(x, y) // 3 \u0026#39;foo\u0026#39; }) .catch(err =\u0026gt; { console.error(\u0026#39;error\u0026#39;, err) })거부가 포함된 경우의 동작\nconst ok = Promise.resolve(1) const fail = new Promise((_, reject) =\u0026gt; reject(new Error(\u0026#39;boom\u0026#39;))) Promise.all([ok, fail]) .then(() =\u0026gt; {}) .catch(err =\u0026gt; { console.error(err.message) // boom })주의와 한계 fail fast 특성으로 하나가 거부되면 즉시 거부하여 나머지 결과는 수집되지 않음 부분 성공과 실패를 모두 보고 싶다면 Promise.allSettled 선택 이미 실행된 비동기 작업의 취소는 기본적으로 지원하지 않음 AbortController 같은 별도 취소 메커니즘 연동 필요 동시성 제어 기능 없음 필요하면 큐나 제한 도구를 별도로 구성하여 배치 크기 제한 네트워크나 스토리지처럼 외부 리소스를 다루는 경우, 실패 시 이미 진행된 요청의 부수효과를 고려한 롤백 전략 필요\nTypeScript에서의 반환 타입 추론 배열 리터럴을 전달하면 튜플 기반으로 각 요소 타입을 추론\nconst p1: Promise\u0026lt;number\u0026gt; = Promise.resolve(5) const p2: Promise\u0026lt;string\u0026gt; = Promise.resolve(\u0026#39;hi\u0026#39;) Promise.all([p1, p2]).then(([n, s]) =\u0026gt; { // n: number, s: string })infer가 흐려지는 경우는 가변 배열이나 넓은 타입으로 수집할 때 발생 가능 필요 시 as const 또는 명시적 제네릭 타입 힌트로 튜플화\nPromise.all과 Promise.allSettled 비교 Promise.all 하나라도 거부되면 즉시 거부 모든 결과가 필요하고 어느 하나의 실패 시 전체 흐름을 중단해야 할 때 적합 Promise.allSettled 모든 입력의 상태와 값을 끝까지 수집 일부 실패를 허용하고 결과를 종합 평가할 때 적합 Promise.allSettled([a, b]).then(results =\u0026gt; { for (const r of results) { if (r.status === \u0026#39;fulfilled\u0026#39;) console.log(r.value) else console.warn(r.reason) } })현실적인 사용 맥락과 팁 여러 독립 API 요청을 동시에 보내고 전부 필요할 때 사용 각 요청은 미리 생성 후 한 번에 Promise.all로 합치기 개별 실패가 전체를 망치면 안 되는 경우에는 allSettled로 전환 후 실패만 필터링해 재시도 빈 입력은 즉시 이행되므로 조건 분기 간소화 가능 입력 순서가 결과 순서를 보장하므로 호출 순서와 매핑 로직을 단순화\nMap 개념과 정의 키-값 쌍을 저장하는 표준 컬렉션 모든 타입을 키로 사용 가능하며 삽입 순서 유지 키 중복 불가이며 동일 키 설정 시 마지막 값이 유지\nMap의 핵심 특징 모든 자료형 키 지원, 객체와 함수 포함 삽입 순서 기반 순회 보장 size 프로퍼티로 요소 개수 조회 직렬화 내장 지원 없음, 직렬화 시 변환 로직 필요 객체 키는 참조 동일성 기준 비교 사용\n기본 사용법 최소 스니펫 생성과 추가\nconst m = new Map() m.set(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;) m.set(\u0026#39;age\u0026#39;, 25)조회와 존재 확인\nm.get(\u0026#39;name\u0026#39;) // \u0026#39;Alice\u0026#39; m.has(\u0026#39;age\u0026#39;) // true 삭제와 크기\nm.delete(\u0026#39;age\u0026#39;) m.size // 1 순회\nfor (const [k, v] of m) { console.log(k, v) }객체와 Map 비교 포인트 키 타입 객체는 문자열과 심벌 중심 Map은 모든 데이터 타입을 키로 허용 순서와 순회 객체는 속성 열거 순서가 상황에 따라 달라질 수 있음 Map은 삽입 순서 보장으로 일관 순회 가능 크기 계산 객체는 Object.keys().length 필요 Map은 size 즉시 제공 성능과 용도 다량의 삽입·삭제·순회에서 Map이 일관된 특성을 제공 단순 구조, 직렬화 중심 데이터는 객체가 편의성 높음 실제 사용 예시와 팁 간단 캐시 패턴\nconst cache = new Map() async function getUser(userId) { if (cache.has(userId)) return cache.get(userId) const data = await doFetchUser(userId) // 외부 호출 추상화 cache.set(userId, data) return data }주의사항\n객체를 키로 쓸 때는 같은 모양의 다른 객체는 다른 키로 취급됨 캐시로 사용할 때는 만료 정책, 약참조 사용 가능성, 메모리 누수 방지 전략 필요 직렬화가 필요하면 배열이나 객체로 변환해 저장 형식에 맞추는 전처리 필요 마무리 여러 비동기 작업을 동시에 묶고 모두의 성공이 필요하면 Promise.all 선택 부분 실패를 용인하고 결과를 종합하려면 Promise.allSettled 고려 키-값 컬렉션이 필요하고 키 타입의 제약 없이 일관 순회가 중요하면 Map 선택 객체는 단순 데이터 구조와 직렬화 중심 시나리오에서 여전히 유효 용도와 제약을 기준으로 도구를 고르는 것이 유지보수와 성능 모두에 이득임\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map ","permalink":"https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음\n키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함\n이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함\u003c/p\u003e\n\u003ch3 id=\"promiseall-개념과-정의\"\u003ePromise.all 개념과 정의\u003c/h3\u003e\n\u003cp\u003e여러 Promise를 단일 Promise로 집계하는 유틸리티\n모든 입력이 이행되면 결과를 같은 순서의 배열로 반환\n하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유\n입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨\u003c/p\u003e","title":"JavaScript Promise.all과 Map 정리 – 동시 비동기 처리와 키-값 컬렉션 기본"},{"content":"개요 MECE는 Mutually Exclusive Collectively Exhaustive의 약자이며 상호배제와 전체포괄을 뜻함 겹치지 않게 나누되 합치면 전체가 되는 분류 원칙을 말함 영어권에서는 미씨로 읽고, 한국어로는 엠이씨이 또는 미시로 불림 컨설팅 실무에서 대중화된 사고 틀로 문제 분해, 요건 정의, 케이스 분류에 자주 사용됨\n개념과 정의 상호배제는 요소들이 서로 겹치지 않는 상태를 의미함 중복 없이 하나의 요소가 정확히 하나의 범주에만 속함 전체포괄은 분류된 요소들을 모두 합치면 전체 모수를 빠짐없이 덮는 상태를 의미함 누락 없이 전체 공간을 커버하는 분할이 목표임\n원칙 나열된 요소는 서로 배타적이어야 함 나열된 요소의 합은 전체와 같아야 함 중복된 특성이나 정의가 존재하지 않아야 함 목적 상호배제로 중복 제거, 혼동과 불필요한 자원 낭비 예방 전체포괄로 누락 방지, 기회 손실과 가능성 축소 예방 결과적으로 의사결정 단순화와 커뮤니케이션 명확화 달성\n동작 방식과 구조 MECE는 본질적으로 집합의 분할 문제에 해당함 하나의 기준 축을 선정한 뒤 서로 겹치지 않는 부분집합으로 전체를 나눔 경계값과 애매한 사례를 먼저 정의해 모호성을 제거함 분할 결과가 전체 공간을 덮는지 샘플과 로그로 검증함 정기적으로 도메인 변경 사항을 반영해 분류 체계를 보정함\n간단 예시 API 응답 상태 분류\n2xx 성공, 4xx 클라이언트 오류, 5xx 서버 오류로 나누면 상호배제 충족 리다이렉션 3xx와 정보 1xx를 누락하면 전체포괄 위배 발생 필요 범위를 명시해 1xx 2xx 3xx 4xx 5xx로 정의하거나 미사용 구간을 의도적으로 배제 처리 필요 로그 레벨 분류\ntrace debug info warn error fatal 같은 단일 축으로 분류 시 상호배제 충족 일부 시스템에서 error와 fatal의 경계가 정의되지 않으면 중복과 모호성 발생 각 레벨의 의미와 사용 기준을 문서화해 경계값 불일치 제거 필요 사용자 세그먼트 분류\n과금 여부로 free paid 분리 시 간결하지만 trial 상태 누락 가능 축을 혼합해 지역과 요금제를 동시에 쓰면 겹침 발생 위험 커짐 단일 기준 축 선택 후 하위 축을 별도 차원으로 관리하는 다차원 모델 권장 주의사항과 한계 완전한 MECE는 비용이 큼, 과도한 분류는 운영 복잡도 증가 위험 존재 도메인이 변하는 환경에서는 분류가 빠르게 낡음, 주기적 검토 필요 서로 다른 기준 축을 섞으면 즉시 상호배제 깨짐, 축 혼합 금지 기본값 기타 등으로 누락을 덮으면 전체포괄 착시 발생, 반드시 명시적 케이스 관리 필요\n실무 베스트프랙티스 분류 기준 축을 한 문장으로 선언하고 금지된 축 혼합을 명시 경계값 표를 먼저 만들고 애매한 사례를 강제 배치 샘플 데이터 커버리지 체크로 전체포괄 검증, 미매핑 데이터 알림 설정 분기문에서 기본값 허용 금지, 새 케이스 추가 시 빌드 타임에 누락 탐지하도록 정책화 용어 사전으로 각 범주의 정의와 사용 예를 관리, 리뷰 체크리스트 운영 마무리 MECE는 분류와 집합의 원리에 기반한 사고 틀임 겹치지 않게 나누고 빠짐없이 덮는다는 두 가지 조건을 동시에 만족시킬 때 분석과 커뮤니케이션이 선명해짐 완벽함을 강박으로 삼기보다 기준 축 명시와 경계값 관리, 검증 자동화를 통해 실무적 균형을 맞추는 것이 핵심임\n참고자료 https://oriyong.tistory.com/109 https://en.wikipedia.org/wiki/MECE_principle ","permalink":"https://blog.jsontapose.com/posts/mece-structured-classification-principle-c7252d/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eMECE는 Mutually Exclusive Collectively Exhaustive의 약자이며 상호배제와 전체포괄을 뜻함\n겹치지 않게 나누되 합치면 전체가 되는 분류 원칙을 말함\n영어권에서는 미씨로 읽고, 한국어로는 엠이씨이 또는 미시로 불림\n컨설팅 실무에서 대중화된 사고 틀로 문제 분해, 요건 정의, 케이스 분류에 자주 사용됨\u003c/p\u003e\n\u003ch3 id=\"개념과-정의\"\u003e개념과 정의\u003c/h3\u003e\n\u003cp\u003e상호배제는 요소들이 서로 겹치지 않는 상태를 의미함\n중복 없이 하나의 요소가 정확히 하나의 범주에만 속함\n전체포괄은 분류된 요소들을 모두 합치면 전체 모수를 빠짐없이 덮는 상태를 의미함\n누락 없이 전체 공간을 커버하는 분할이 목표임\u003c/p\u003e","title":"MECE 개념 정리: 상호배제와 전체포괄로 구조화하는 분류 원칙"},{"content":"관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요\n개념 some 관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함 존재성 검사에 해당, 하나라도 매칭되면 true every 모든 관계된 레코드가 조건을 만족해야 부모 포함 단 하나라도 위배되면 제외됨 관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨 동작 원리 some은 존재량화, every는 전칭량화에 해당함 차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음 특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요 간단 예시 model Post { id Int @id @default(autoincrement()) title String comments Comment[] } model Comment { id Int @id @default(autoincrement()) text String postId Int post Post @relation(fields: [postId], references: [id]) }댓글 text가 \u0026lsquo;interesting\u0026rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정\nsome 사용\nconst posts = await prisma.post.findMany({ where: { comments: { some: { text: \u0026#34;interesting\u0026#34; }, }, }, }); 댓글 중 하나라도 텍스트가 \u0026lsquo;interesting\u0026rsquo;이면 포함됨 every 사용\nconst posts = await prisma.post.findMany({ where: { comments: { every: { text: \u0026#34;interesting\u0026#34; }, }, }, }); 모든 댓글의 텍스트가 \u0026lsquo;interesting\u0026rsquo;이어야 포함됨 댓글이 하나도 없는 게시글도 조건을 만족한 것으로 간주됨 단일 필드 기준 필터링 시 차이 같은 필드 한 개로 필터링해도 결과가 달라질 수 있음 some은 조건을 만족하는 자식이 하나라도 있으면 부모 포함 every는 모든 자식이 조건을 만족해야 부모 포함, 자식이 없으면 포함됨 자식이 정확히 한 개이고 그 필드만 본다면 두 연산자가 같은 결과를 낼 수 있음. 그러나 자식이 여러 개이거나 없는 경우에는 달라짐 빈 관계를 결과에서 제외하고 싶을 때의 안전한 패턴\nconst posts = await prisma.post.findMany({ where: { AND: [ { comments: { every: { text: \u0026#34;interesting\u0026#34; } } }, { comments: { some: {} } }, // 최소 1개 존재 보장 ], }, }); every의 의도를 유지하면서 빈 관계가 포함되는 부작용 제거 가능 베스트 프랙티스 의도가 존재성 검사면 some, 전부 일치 검사면 every 선택 every 사용 시 빈 관계가 포함되는 특성을 인지하고 필요 시 some과 조합하여 최소 존재 보장 테스트 데이터에 빈 관계, 혼합된 관계, 전부 일치 관계를 포함해 결과 검증 권장 마무리 some은 하나라도 매칭되면 포함, every는 모두 매칭되어야 포함이라는 원칙. 차이는 자식이 0개 또는 다수일 때 크게 나타남. 단일 필드 기준이라도 항상 동일하지 않음. 관계 특성과 조건 의미를 명확히 정의하고, 빈 관계 처리 여부를 설계 단계에서 결정할 것\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries https://www.prisma.io/docs/orm/prisma-client/queries/filtering-and-sorting https://www.prisma.io/docs/orm/reference/prisma-client-reference#filter-conditions ","permalink":"https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/","summary":"\u003cp\u003e관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요\u003c/p\u003e\n\u003ch3 id=\"개념\"\u003e개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003esome\n\u003cul\u003e\n\u003cli\u003e관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함\u003c/li\u003e\n\u003cli\u003e존재성 검사에 해당, 하나라도 매칭되면 true\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eevery\n\u003cul\u003e\n\u003cli\u003e모든 관계된 레코드가 조건을 만족해야 부모 포함\u003c/li\u003e\n\u003cli\u003e단 하나라도 위배되면 제외됨\u003c/li\u003e\n\u003cli\u003e관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003esome은 존재량화, every는 전칭량화에 해당함\u003c/li\u003e\n\u003cli\u003e차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음\u003c/li\u003e\n\u003cli\u003e특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel Post {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  id       Int       @id @default(autoincrement())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  title    String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  comments Comment[]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel Comment {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  id     Int    @id @default(autoincrement())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  text   String\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  postId Int\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  post   Post   @relation(fields: [postId], references: [id])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e댓글 text가 \u0026lsquo;interesting\u0026rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정\u003c/p\u003e","title":"Prisma where 관계 필터 some vs every 동작 차이와 주의점"},{"content":"개념/배경 Array.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임 원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임\n기본 문법 const newArray = array.map((element, index, array) =\u0026gt; { return element; }); element 현재 요소 index 현재 인덱스 array 원본 배열 참조 콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨\n사용 예시 숫자 배열 변환\nconst numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map((n) =\u0026gt; n * 2); // [2, 4, 6, 8, 10] 객체 배열에서 특정 속성 추출\nconst users = [{ name: \u0026#34;Alice\u0026#34; }, { name: \u0026#34;Bob\u0026#34; }]; const names = users.map((u) =\u0026gt; u.name); // [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;] 인덱스 활용\nconst arr = [10, 20, 30]; const result = arr.map((n, i) =\u0026gt; n + i); // [10, 21, 32] 중첩 배열 변환\nconst nested = [ [1, 2], [3, 4], ]; const sums = nested.map((a) =\u0026gt; a.reduce((x, y) =\u0026gt; x + y, 0)); // [3, 7] 원본 배열과 불변성 map은 원본 배열을 수정하지 않음\nconst numbers = [1, 2, 3]; const squared = numbers.map((n) =\u0026gt; n ** 2); // numbers -\u0026gt; [1, 2, 3] // squared -\u0026gt; [1, 4, 9] null/undefined와 빈 슬롯 처리 주의 명시적 undefined 값이나 null 값은 콜백이 호출됨 반면, 배열의 빈 슬롯(hole)은 콜백이 호출되지 않음. 새 배열에도 동일한 위치의 빈 슬롯이 유지됨 // 명시적 undefined는 콜백 호출됨 const a = [1, undefined, 3]; const r1 = a.map((x) =\u0026gt; (x === undefined ? \u0026#34;empty\u0026#34; : x * 2)); // [2, \u0026#39;empty\u0026#39;, 6] // 빈 슬롯은 콜백 미호출, 그대로 빈 슬롯 유지됨 const b = [1, , 3]; // sparse array const r2 = b.map((x) =\u0026gt; \u0026#34;seen\u0026#34;); // r2는 [\u0026#39;seen\u0026#39;, , \u0026#39;seen\u0026#39;] 형태. 가운데는 여전히 빈 슬롯 이 차이를 혼동하면 데이터 품질 이슈 발생 가능. sparse array를 다루는 경우 사전에 채우기 또는 filter와의 조합 고려 권장\nforEach와의 차이 map 새 배열 반환, 변환 목적 forEach 반환값 없음, 부수 효과 목적 const nums = [1, 2, 3]; nums.forEach((n) =\u0026gt; console.log(n * 2)); // 출력만 수행 const doubled = nums.map((n) =\u0026gt; n * 2); // [2, 4, 6] 장점 불변성 유지 선언적 데이터 변환 체이닝에 유리, 가독성 향상 주의와 팁 콜백은 순수 함수 지향. 부수 효과는 forEach 사용 권장 map은 배열 길이를 기준으로 동작. 순회 중 새 요소를 push해도 방문하지 않음, 삭제된 요소는 방문되지 않음 배열 요소가 배열을 반환하는 변환이 많다면 flatMap 고려. map 후 flat보다 간결한 선택지 성능 민감 구간에서는 불필요한 중간 배열 생성을 피하도록 파이프라인 재검토 권장 정리 map은 각 요소를 변환해 동일 길이의 새 배열을 만드는 표준 도구 원본 불변, 명시적 undefined와 빈 슬롯 처리 차이, forEach와의 역할 분리가 핵심 포인트 데이터 변환 중심 로직에서 선언적이고 예측 가능한 코드 작성에 적합함\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map ","permalink":"https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eArray.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임\n원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임\u003c/p\u003e\n\u003ch3 id=\"기본-문법\"\u003e기본 문법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e newArray \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e array\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003emap\u003cspan style=\"color:#eceff4\"\u003e((\u003c/span\u003eelement\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e index\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e array\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003ereturn\u003c/span\u003e element\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eelement 현재 요소\u003c/li\u003e\n\u003cli\u003eindex 현재 인덱스\u003c/li\u003e\n\u003cli\u003earray 원본 배열 참조\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨\u003c/p\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cp\u003e숫자 배열 변환\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e numbers \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e[\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e4\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e doubled \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e numbers\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003emap\u003cspan style=\"color:#eceff4\"\u003e((\u003c/span\u003en\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e n \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// [2, 4, 6, 8, 10]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e객체 배열에서 특정 속성 추출\u003c/p\u003e","title":"JavaScript Array.prototype.map 개념과 사용법 정리"},{"content":"개요 커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법 n개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해 함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적\n핵심 개념 커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환 부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법 관계: 커링된 함수는 부분 적용을 자연스럽게 지원함 동작 원리와 간단 예시 일반 함수\nfunction add(a: number, b: number): number { return a + b; } add(1, 2); // 3 커링 적용\nfunction curriedAdd(a: number) { return (b: number): number =\u0026gt; a + b; } const addOne = curriedAdd(1); addOne(2); // 3 addOne(5); // 6 첫 번째 인자 고정 후 나머지 인자를 나중에 적용 가능\nRamda로 보는 자동 커링 Ramda의 함수는 기본적으로 자동 커링 동작 부분 적용이 일관되게 가능\nimport * as R from \u0026#34;ramda\u0026#34;; const add = R.add(1); // 첫 번째 인자 1 고정 add(2); // 3 함수 조합 파이프라인과 결합 시 표현 간결\n커링과 부분 적용의 차이 커링: 다인자 함수를 단일 인자 함수들의 연속으로 변환하는 과정 부분 적용: 전체 인자 중 일부만 먼저 채워 새 함수를 만드는 기법 간단 예시\nconst multiply = (a: number, b: number) =\u0026gt; a * b; const double = multiply.bind(null, 2); // 첫 인자 2 고정 double(5); // 10 커링은 구조 변환, 부분 적용은 사용 패턴에 초점\n함수 조합과의 궁합 커링된 함수는 합성 함수와 결합 시 장점 큼\nimport * as R from \u0026#34;ramda\u0026#34;; const increment = (x: number) =\u0026gt; x + 1; const double = (x: number) =\u0026gt; x * 2; const process = R.pipe(increment, double); process(3); // 8 입력에서 출력까지 단계적 변환을 작게 나눠 조합 가능\n장점 요약 재사용성 향상: 자주 쓰는 인자 고정 함수 생성 용이 가독성 개선: 복잡한 변환을 작은 단위로 분해 가능 조합성 증가: 파이프라인과 컴포지션에 자연스럽게 적합 테스트 용이: 부분 적용된 단일 책임 함수 단위 테스트 수월 주의 사항 과도한 중첩 사용 시 가독성 저하 위험 존재 타입스크립트에서 복잡한 커링 시 제네릭과 추론 한계 고려 필요 bind를 이용한 부분 적용은 this 바인딩까지 관여하므로 의도한 this 문맥 확인 필요 정리 커링은 다인자 함수를 단일 인자 함수의 연속으로 바꾸는 변환이며 부분 적용은 일부 인자만 먼저 고정해 새 함수를 만드는 기법 Ramda 같은 라이브러리의 자동 커링을 활용하면 재사용성과 조합성이 높아짐 작게 쪼개고 필요할 때 부분 적용해 파이프라인으로 잇는 패턴이 핵심\n참고자료 https://ramdajs.com/docs/#curry https://ramdajs.com/docs/#add https://en.wikipedia.org/wiki/Currying https://en.wikipedia.org/wiki/Partial_application ","permalink":"https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법\nn개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해\n함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환\u003c/li\u003e\n\u003cli\u003e부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법\u003c/li\u003e\n\u003cli\u003e관계: 커링된 함수는 부분 적용을 자연스럽게 지원함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-간단-예시\"\u003e동작 원리와 간단 예시\u003c/h3\u003e\n\u003cp\u003e일반 함수\u003c/p\u003e","title":"커링과 부분 적용 이해하기: 함수형 자바스크립트 핵심 패턴"},{"content":"개요 findUnique로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 where와 include를 어떻게 조합해야 하는지 정리함 관계 필터링을 where에 넣을 수 있는지, include에서 필터가 가능한지 헷갈리기 쉬운 지점 정리\n핵심 개념 findUnique는 유니크 키로 정확히 하나의 레코드를 찾는 용도 findUnique의 where는 유니크 필드만 허용됨, 관계 필터나 일반 조건 결합 불가 include는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션 to-many 관계에 한해 include 내부에서 where 사용 가능, to-one 관계는 where 불가 where 사용 패턴 잘못된 예시 // findUnique에 관계 필터 결합 시도 → 타입 에러 // (User(1) → Post(N) → Metadata(1) 관계) await db.user.findUnique({ where: { id: userId, // \u0026#39;posts\u0026#39;는 유니크 필드가 아니므로 \u0026#39;where\u0026#39;에서 관계 필터링 불가 posts: { some: { metadata: { editorEmail: email } } }, }, }); 올바른 최소 조건 await db.user.findUnique({ where: { id: userId }, // \u0026#39;id\u0026#39;는 유니크 필드 }); 관계 조건이 필요하면 findFirst 또는 findMany 사용 // \u0026#39;findUnique\u0026#39;가 아닌 \u0026#39;findFirst\u0026#39;를 사용하면 // \u0026#39;where\u0026#39;에 관계 필터를 포함할 수 있음 await db.user.findFirst({ where: { id: userId, posts: { some: { metadata: { editorEmail: email } } }, }, });요약하면 findUnique에는 유니크 조건만, 관계 기반 필터는 findFirst 또는 findMany로 처리함\ninclude 사용 패턴 올바른 기본 형태 (User → Posts → Metadata 관계) await db.user.findUnique({ where: { id: userId }, include: { posts: { include: { metadata: true } }, // \u0026#39;posts\u0026#39;와 중첩된 \u0026#39;metadata\u0026#39; 포함 }, }); 잘못된 형태 // include에 관계 필터를 직접 넣는 구문은 불가 include: { posts: { // \u0026#39;include\u0026#39; 내부에서 필터링을 이렇게 할 수 없음 (Prisma 4.x 이하) // \u0026#39;include\u0026#39;는 \u0026#39;true\u0026#39; 또는 다른 include/select 객체만 받음 include: { metadata: { editorEmail: email } }, }, } 의도에 부합하는 형태 (Prisma 5.x+ 권장) await db.user.findUnique({ where: { id: userId }, include: { posts: { // to-many 관계인 \u0026#39;posts\u0026#39;에 \u0026#39;where\u0026#39;를 걸어 필터링 where: { metadata: { editorEmail: email } }, // 필터링된 \u0026#39;posts\u0026#39;에 연결된 \u0026#39;metadata\u0026#39;를 포함 include: { metadata: true }, }, }, });설명\nto-many 관계인 posts에 where를 걸어 하위 metadata의 editorEmail로 필터링 가능 조건에 맞지 않는 posts는 제외되어 빈 배열([])로 반환됨 to-one 관계는 include에서 where를 쓸 수 없으며, 관계가 없으면 해당 필드는 null 반환 결론 예시 단일 User를 유니크 키로 찾고, 연관된 Posts는 특정 email을 가진 Metadata가 있는 경우만 포함하고, 사용자의 Profile과 Role도 함께 가져오고 싶다면 아래 형태를 권장\nconst userId = \u0026#34;user-unique-id-123\u0026#34;; const email = \u0026#34;target-editor@example.com\u0026#34;; await db.user.findUnique({ where: { id: userId }, include: { // 1. (to-many) \u0026#39;posts\u0026#39; 관계 posts: { // 2. \u0026#39;posts\u0026#39; 목록을 \u0026#39;metadata.editorEmail\u0026#39; 기준으로 필터링 where: { metadata: { editorEmail: email } }, // 3. 필터링을 통과한 \u0026#39;posts\u0026#39;의 \u0026#39;metadata\u0026#39;도 함께 로드 include: { metadata: true }, }, // 4. (to-one) \u0026#39;profile\u0026#39; 관계 profile: true, // 5. (to-one) \u0026#39;role\u0026#39; 관계 role: true, }, });주의 사항 findUnique의 where에는 유니크 필드만 입력 가능, 관계 필터 결합 불가 관계 조건이 결합된 조회가 필요하면 findFirst 또는 findMany로 상위 where에 관계 필터 사용 include의 where는 to-many 관계에만 적용 가능 to-many 관계에서 include의 where 조건 미매칭 시, 해당 관계는 null이 아닌 빈 배열([]) 반환 선택적 필드 제어가 필요하면 select와 include를 목적에 맞게 혼용 권장 참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/retrieving-data#findunique https://www.prisma.io/docs/orm/prisma-client/queries/retrieving-data#including-relations https://www.prisma.io/docs/orm/prisma-client/queries/relation-queries#filtering-by-a-related-records-fields ","permalink":"https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efindUnique\u003c/code\u003e로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 \u003ccode\u003ewhere\u003c/code\u003e와 \u003ccode\u003einclude\u003c/code\u003e를 어떻게 조합해야 하는지 정리함\n관계 필터링을 \u003ccode\u003ewhere\u003c/code\u003e에 넣을 수 있는지, \u003ccode\u003einclude\u003c/code\u003e에서 필터가 가능한지 헷갈리기 쉬운 지점 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efindUnique\u003c/code\u003e는 유니크 키로 정확히 \u003cstrong\u003e하나\u003c/strong\u003e의 레코드를 찾는 용도\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efindUnique\u003c/code\u003e의 \u003ccode\u003ewhere\u003c/code\u003e는 \u003cstrong\u003e유니크 필드만\u003c/strong\u003e 허용됨, 관계 필터나 일반 조건 결합 불가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einclude\u003c/code\u003e는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eto-many 관계\u003c/strong\u003e에 한해 \u003ccode\u003einclude\u003c/code\u003e 내부에서 \u003ccode\u003ewhere\u003c/code\u003e 사용 가능, to-one 관계는 \u003ccode\u003ewhere\u003c/code\u003e 불가\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"where-사용-패턴\"\u003ewhere 사용 패턴\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e잘못된 예시\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// findUnique에 관계 필터 결합 시도 → 타입 에러\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// (User(1) → Post(N) → Metadata(1) 관계)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e db\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindUnique\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  where\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    id: \u003cspan style=\"color:#81a1c1\"\u003euserId\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// \u0026#39;posts\u0026#39;는 유니크 필드가 아니므로 \u0026#39;where\u0026#39;에서 관계 필터링 불가\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e    posts\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e some\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e metadata\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e editorEmail: \u003cspan style=\"color:#81a1c1\"\u003eemail\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e올바른 최소 조건\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e db\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindUnique\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  where\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e id: \u003cspan style=\"color:#81a1c1\"\u003euserId\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e \u003cspan style=\"color:#616e87;font-style:italic\"\u003e// \u0026#39;id\u0026#39;는 유니크 필드\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e관계 조건이 필요하면 findFirst 또는 findMany 사용\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// \u0026#39;findUnique\u0026#39;가 아닌 \u0026#39;findFirst\u0026#39;를 사용하면\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// \u0026#39;where\u0026#39;에 관계 필터를 포함할 수 있음\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e db\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindFirst\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  where\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    id: \u003cspan style=\"color:#81a1c1\"\u003euserId\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    posts\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e some\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e metadata\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e editorEmail: \u003cspan style=\"color:#81a1c1\"\u003eemail\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e요약하면 \u003ccode\u003efindUnique\u003c/code\u003e에는 유니크 조건만, 관계 기반 필터는 \u003ccode\u003efindFirst\u003c/code\u003e 또는 \u003ccode\u003efindMany\u003c/code\u003e로 처리함\u003c/p\u003e","title":"Prisma findUnique에서 where와 include 제대로 쓰기"},{"content":"개요 Node.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리 바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명\n핵심 개념 V8 엔진, Ignition 바이트코드와 JIT 최적화 libuv, 비동기 I O 백엔드와 이벤트 루프 단계 모듈 시스템, CommonJS와 ES Module의 로딩 차이 전역 실행 컨텍스트와 런타임 내장 객체 마이크로태스크 큐와 process.nextTick의 우선순위 실행 순서 요약 Node 바이너리 시작 런타임 초기화와 내부 바인딩 준비 모듈 로더 기동 및 엔트리 파일 로드 V8 파싱과 바이트코드 컴파일 전역 실행 컨텍스트 구성과 최상위 코드 실행 비동기 작업 등록 이벤트 루프 진입 비동기 콜백 처리 반복 graph TD A[Node 시작] --\u0026gt; B[V8, libuv 초기화] B --\u0026gt; C[모듈 로딩] C --\u0026gt; D[파싱 및 컴파일] D --\u0026gt; E[최상위 코드 실행] E --\u0026gt; F[이벤트 루프] F --\u0026gt; G[비동기 처리 반복]단계별 동작 1단계 Node 바이너리 시작 node yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨 V8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨\n2단계 런타임 초기화 V8, libuv, 암호화와 압축 등 필수 의존성 초기화 process 객체와 argv, env, versions 설정 표준 입출력 스트림 바인딩 준비\n3단계 모듈 로더 실행 엔트리 파일을 기준으로 모듈 해석과 로딩 수행\nCommonJS require 사용 시 동기 로딩과 함수 래핑 적용 (function exports, require, module, **filename, **dirname { \u0026hellip; }) 형태로 감쌈 **filename, **dirname 은 CommonJS에서만 제공됨 ES Module import 사용 시 비동기 로딩과 링크 단계 수행 mjs 확장자 또는 package 설정의 type module 조건에서 활성화됨 ESM에는 **filename, **dirname 미제공이며 import.meta.url 사용 권장 의존성 그래프를 구축하고 모듈 결과를 캐시에 보관함 4단계 파싱과 바이트코드 컴파일 V8이 소스 코드를 AST로 파싱한 뒤 Ignition 바이트코드로 컴파일함 실행 중 반복 패턴이 관찰되면 JIT 최적화가 적용됨\n5단계 전역 실행 컨텍스트 구성 ExecutionContext를 만들고 전역 객체와 내장 바인딩을 연결함 global, process, require CommonJS 한정, import ESM 문맥 등 환경이 확정됨 엔트리 파일의 최상위 레벨 코드가 동기적으로 실행됨\n6단계 비동기 작업 등록 setTimeout, Promise, 파일 I O, 네트워크 I O 등은 즉시 실행 대신 콜백을 적절한 큐에 등록함\n타이머 큐, I O 큐, 체크 큐 등 이벤트 루프 단계별 큐에 배치됨 마이크로태스크는 별도 큐에 등록됨 이 시점까지는 콜백이 실행되지 않고 등록만 진행됨 7단계 이벤트 루프 진입 초기 스크립트 평가가 끝나면 이벤트 루프로 진입함 대표 단계 순서\ntimers 단계에서 setTimeout, setInterval 콜백 처리 pending callbacks 단계에서 일부 시스템 콜백 처리 idle, prepare 단계 내부 용도 poll 단계에서 I O 처리 및 대기 check 단계에서 setImmediate 처리 close callbacks 단계에서 close 이벤트 처리 각 콜백 실행 직후에 process.nextTick 큐와 마이크로태스크 큐가 소진됨 우선순위는 process.nextTick 먼저, 그 다음 Promise then, queueMicrotask 순으로 처리됨 8단계 비동기 콜백 처리 반복 대기 중인 큐에서 콜백을 꺼내 실행하고 필요 시 새로운 비동기 작업을 다시 등록함 작업이 남아있는 동안 루프가 계속 순환함\nCJS와 ESM 로딩 차이 요약 require 동기 로딩과 캐시 기반 재사용, 파일 해석과 실행이 호출 시점에 일어남 import 비동기 로딩과 링크, 정적 의존성 해석 우선, 토폴로지 정리 후 실행 런타임 전역 제공 요소 차이 존재 CommonJS의 **filename, **dirname은 ESM에 없음 마이크로태스크와 nextTick 주의 process.nextTick은 Node 전용 큐로 매 단계와 콜백 직후 최우선 처리됨 Promise then 등 마이크로태스크는 nextTick 처리 이후 실행됨 과도한 nextTick 사용은 이벤트 루프 굶김을 유발할 수 있음 종료 조건 활성 타이머, 보류된 I O, 등록된 콜백 등 이벤트 루프에서 처리할 작업이 더 이상 없음 명시적 process.exit 호출 간단 예시 아래 코드는 동기 실행과 마이크로태스크, 타이머의 상대적 순서를 보여줌\nconsole.log(\u0026#39;start\u0026#39;) setTimeout(() =\u0026gt; { console.log(\u0026#39;timeout\u0026#39;) }, 0) Promise.resolve().then(() =\u0026gt; { console.log(\u0026#39;promise\u0026#39;) }) console.log(\u0026#39;end\u0026#39;)실행 순서 1 start 동기 2 end 동기 3 promise 마이크로태스크 4 timeout 타이머\n정리 Node.js는 바이너리 기동 후 V8과 libuv를 초기화하고 모듈을 로딩한 뒤 최상위 코드를 실행함 비동기 작업은 등록만 수행되고 초기 평가가 끝나면 이벤트 루프에 진입하여 단계별로 콜백을 처리함 process.nextTick이 마이크로태스크보다 먼저 실행되는 점, CommonJS와 ESM의 로딩 및 전역 차이를 구분할 것\n참고자료 https://nodejs.org/en/learn/asynchronous/event-loop-timers-and-nexttick https://nodejs.org/api/modules.html https://nodejs.org/api/esm.html https://docs.libuv.org/en/v1.x/design.html https://v8.dev/docs ","permalink":"https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리\n바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eV8 엔진, Ignition 바이트코드와 JIT 최적화\u003c/li\u003e\n\u003cli\u003elibuv, 비동기 I O 백엔드와 이벤트 루프 단계\u003c/li\u003e\n\u003cli\u003e모듈 시스템, CommonJS와 ES Module의 로딩 차이\u003c/li\u003e\n\u003cli\u003e전역 실행 컨텍스트와 런타임 내장 객체\u003c/li\u003e\n\u003cli\u003e마이크로태스크 큐와 process.nextTick의 우선순위\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"실행-순서-요약\"\u003e실행 순서 요약\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eNode 바이너리 시작\u003c/li\u003e\n\u003cli\u003e런타임 초기화와 내부 바인딩 준비\u003c/li\u003e\n\u003cli\u003e모듈 로더 기동 및 엔트리 파일 로드\u003c/li\u003e\n\u003cli\u003eV8 파싱과 바이트코드 컴파일\u003c/li\u003e\n\u003cli\u003e전역 실행 컨텍스트 구성과 최상위 코드 실행\u003c/li\u003e\n\u003cli\u003e비동기 작업 등록\u003c/li\u003e\n\u003cli\u003e이벤트 루프 진입\u003c/li\u003e\n\u003cli\u003e비동기 콜백 처리 반복\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"mermaid\"\u003egraph TD\nA[Node 시작] --\u0026gt; B[V8, libuv 초기화]\nB --\u0026gt; C[모듈 로딩]\nC --\u0026gt; D[파싱 및 컴파일]\nD --\u0026gt; E[최상위 코드 실행]\nE --\u0026gt; F[이벤트 루프]\nF --\u0026gt; G[비동기 처리 반복]\u003c/pre\u003e\u003ch3 id=\"단계별-동작\"\u003e단계별 동작\u003c/h3\u003e\n\u003ch4 id=\"1단계-node-바이너리-시작\"\u003e1단계 Node 바이너리 시작\u003c/h4\u003e\n\u003cp\u003enode yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨\nV8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨\u003c/p\u003e","title":"Node.js 실행 흐름과 이벤트 루프 단계 정리"},{"content":"개념/배경 DI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함 객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용하는 것임 이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함\n문제 상황: 강한 결합 (Tight Coupling) 전형적인 문제 패턴은 클래스 내부에서 다른 구체적인 클래스(Concrete Class)를 new 키워드로 직접 생성하여 사용하는 것임\n의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 반드시 함께 수정해야 함 단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐 예를 들어 Gamer가 BlueSwitchKeyboard를 직접 생성해 사용한다면, Gamer는 BlueSwitchKeyboard라는 구체적인 구현에 영구적으로 고정됨 만약 키보드 종류를 RedSwitchSilentKeyboard로 바꾸려면 Gamer 클래스의 내부 코드를 직접 수정해야 함 이 상태를 결합도가 높다고 부름\n예제 코드 (강한 결합) class BlueSwitchKeyboard { type() { console.log(\u0026#34;찰칵- 찰칵-\u0026#34;); } } // Gamer가 BlueSwitchKeyboard라는 \u0026#39;구현\u0026#39;에 직접 의존함 class Gamer { constructor() { // 문제 지점: Gamer가 사용할 키보드를 스스로 생성함 this.keyboard = new BlueSwitchKeyboard(); } play() { console.log(\u0026#34;게임 시작!\u0026#34;); this.keyboard.type(); } } const gamer = new Gamer(); gamer.play(); DI 적용: 느슨한 결합 (Loose Coupling) 핵심 변경점은 제어의 역전(Inversion of Control, IoC)을 적용하는 것임\nGamer는 더 이상 키보드를 직접 만들지 않음 (생성 책임 제거) 외부에서 생성자를 통해 keyboard 인스턴스를 주입받음 Gamer는 주입받은 객체가 type 메서드를 가진다는 인터페이스에만 의존함 예제 코드 (느슨한 결합) // 다양한 키보드 구현체들 class BlueSwitchKeyboard { type() { console.log(\u0026#34;찰칵- 찰칵-\u0026#34;); } } class RedSwitchSilentKeyboard { type() { console.log(\u0026#34;서걱... 서걱...\u0026#34;); } } // Gamer는 \u0026#39;type\u0026#39; 메서드를 가진 객체라면 무엇이든 OK class Gamer { constructor(keyboard) { // 👍 개선 지점: 외부에서 \u0026#39;keyboard\u0026#39; 역할을 하는 객체를 주입받음 this.keyboard = keyboard; } play() { console.log(\u0026#34;게임 시작!\u0026#34;); this.keyboard.type(); // 그냥 계약(type)대로 호출할 뿐임 } } // \u0026#39;조립\u0026#39;은 외부에서 수행함 // 1. 파란 축 키보드가 필요한 경우 const blueKeyboard = new BlueSwitchKeyboard(); const gamer1 = new Gamer(blueKeyboard); gamer1.play(); // 2. 빨간 축 저소음 키보드가 필요한 경우 const redKeyboard = new RedSwitchSilentKeyboard(); const gamer2 = new Gamer(redKeyboard); gamer2.play(); // Gamer 코드는 전혀 수정되지 않았음 이제 Gamer 코드를 단 한 줄도 바꾸지 않고도, type 메서드를 가진 어떤 키보드 구현체든 자유롭게 주입하여 교체할 수 있음\n왜 결합도가 낮아지는가 의존 대상이 구체적인 구현에서 추상적인 역할로 전환되기 때문임\nBefore (강한 결합): Gamer 클래스가 BlueSwitchKeyboard라는 특정 구현 클래스를 직접 알아야 했음 After (느슨한 결합): Gamer 클래스는 \u0026lsquo;type 메서드를 제공하는 무언가\u0026rsquo;라는 인터페이스에만 의존함 Gamer는 이제 BlueSwitchKeyboard나 RedSwitchSilentKeyboard의 존재 자체를 알 필요가 없음 결합의 기준점이 \u0026lsquo;특정 제품\u0026rsquo;이 아닌 \u0026lsquo;제품의 기능 명세\u0026rsquo;로 이동하면서, 변경의 파급 효과가 극적으로 줄어듦\n이는 \u0026ldquo;구체적인 구현이 아닌 추상화에 의존하라\u0026rdquo;(Depend on abstractions, not on concretions)는 SOLID 원칙 중 하나인 의존성 역전 원칙의 핵심 실천 방식임\n테스트와 확장성 테스트 용이성 DI를 사용하면 실제 의존 객체 대신 Mock Object을 쉽게 주입할 수 있음 실제 하드웨어에 의존하거나 네트워크 통신을 하는 무거운 객체를 가벼운 가짜 객체로 대체하여, 빠르고 고립된 단위 테스트가 가능해짐\n예제 코드 (테스트) // 테스트를 위한 가짜 키보드 (Mock) const mockKeyboard = { type: () =\u0026gt; { console.log(\u0026#34;가짜 키보드 입력 테스트\u0026#34;); // 테스트 검증 로직 추가 가능 (예: 호출되었는지 확인) }, }; // 실제 키보드 클래스 없이 Gamer의 play 기능만 고립시켜 테스트 가능 const testGamer = new Gamer(mockKeyboard); testGamer.play();확장성 새로운 기능의 키보드(MembraneKeyboard, OpticalSwitchKeyboard 등)가 추가되어도 Gamer 코드는 수정할 필요가 전혀 없음 외부에서 객체를 생성하고 주입하는 Composition Root에서 어떤 구현을 사용할지만 결정하면 됨\nDI와 IoC 컨테이너 작은 규모에서는 위 예제처럼 생성자나 메서드를 통한 수동 DI만으로도 충분한 효과를 볼 수 있음\n하지만 프로젝트 규모가 커지면, 수십 개의 객체가 서로 복잡한 의존 관계를 맺고, 이들의 생성 순서와 수명(Lifecycle) 관리가 복잡한 반복 작업이 됨\nIoC 컨테이너는 이 \u0026lsquo;조립\u0026rsquo; 과정을 자동화하고 중앙에서 관리해주는 프레임워크 기능임\nex. NestJS, Spring, Angular의 DI 시스템 개발자가 클래스 생성자에 필요한 의존성을 \u0026lsquo;선언\u0026rsquo;만 해두면 (예: @Injectable()) 컨테이너가 런타임에 필요한 실제 인스턴스를 찾아 \u0026lsquo;주입\u0026rsquo;해 줌 IoC 컨테이너는 단순 주입 외에도 객체의 수명 주기(Lifecycle) 관리 (싱글톤, 요청 스코프 등), 순환 참조 감지 등 고급 기능을 제공함 ⚠️ 주의사항 서비스 로케이터 패턴 남용 주의 서비스 로케이터는 DI와 달리 의존성을 외부에 명시적으로 드러내지 않고 클래스 내부에 숨김/ 이는 테스트를 어렵게 하고 코드의 의존 관계 추론을 방해할 수 있음 과도한 생성자 인자 한 클래스의 생성자에 5개가 넘는 의존성이 주입된다면, 해당 클래스가 단일 책임 원칙(SRP)을 위반하고 있을 가능성이 높음/ 설계를 재검토하고 책임을 분리해야 함 런타임 타입 검증 타입스크립트 같은 정적 타입 시스템이 없다면, 런타임에 주입된 객체가 필요한 메서드(type 등)를 가지고 있는지 보장하기 어려움/ 이 경우, 인터페이스 검증 로직을 추가로 고려할 수 있음 순환 의존성 (Circular Dependency) A가 B를, B가 다시 A를 의존하는 상황은 IoC 컨테이너를 망가뜨리고 설계 문제를 암시하는 강력한 신호임/ 역할 분리나 중간 계층(Port) 도입으로 의존성 방향을 한쪽으로 정리해야 함 🏁 마무리 DI의 본질은 \u0026lsquo;생성\u0026rsquo;의 책임과 \u0026lsquo;사용\u0026rsquo;의 책임을 분리하는 것임\n사용 객체(Gamer)는 자신이 사용할 대상의 역할만 바라보고 동작함 실제 구현 객체를 생성하는 책임은 외부의 Composition Root이나 IoC 컨테이너가 담당함 이 간단한 책임 분리를 통해 구현 교체가 자유로워지고, 테스트가 가벼워지며, 시스템 전체의 결합도가 낮아져 유연하고 확장 가능한 설계가 완성됨\n참고자료 Martin Fowler - Inversion of Control Containers and the Dependency Injection pattern Wikipedia - Dependency injection NestJS - Custom providers ","permalink":"https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/","summary":"\u003ch2 id=\"개념배경\"\u003e개념/배경\u003c/h2\u003e\n\u003cp\u003eDI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함\n\u003cstrong\u003e객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용\u003c/strong\u003e하는 것임\n이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"문제-상황-강한-결합-tight-coupling\"\u003e문제 상황: 강한 결합 (Tight Coupling)\u003c/h2\u003e\n\u003cp\u003e전형적인 문제 패턴은 클래스 내부에서 다른 \u003cstrong\u003e구체적인 클래스\u003c/strong\u003e(Concrete Class)를 \u003ccode\u003enew\u003c/code\u003e 키워드로 직접 생성하여 사용하는 것임\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 \u003cstrong\u003e반드시 함께 수정\u003c/strong\u003e해야 함\u003c/li\u003e\n\u003cli\u003e단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어 \u003ccode\u003eGamer\u003c/code\u003e가 \u003ccode\u003eBlueSwitchKeyboard\u003c/code\u003e를 직접 생성해 사용한다면, \u003ccode\u003eGamer\u003c/code\u003e는 \u003ccode\u003eBlueSwitchKeyboard\u003c/code\u003e라는 구체적인 구현에 영구적으로 고정됨\n만약 키보드 종류를 \u003ccode\u003eRedSwitchSilentKeyboard\u003c/code\u003e로 바꾸려면 \u003ccode\u003eGamer\u003c/code\u003e 클래스의 내부 코드를 직접 수정해야 함\n이 상태를 \u003cstrong\u003e결합도가 높다\u003c/strong\u003e고 부름\u003c/p\u003e","title":"DI가 결합도를 낮추는 원리와 최소 예시"},{"content":"개요 KISS는 Keep It Simple, Stupid 또는 Keep It Simple and Straightforward의 약자이며 1960년대 미 해군에서 출발한 설계 원칙입니다. 소프트웨어에서는 불필요한 복잡성을 제거하고 이해와 변경이 쉬운 구조를 지향합니다. 목표는 적은 개념과 짧은 경로로 같은 가치를 제공하는 시스템을 만드는 것임\n핵심 개념 단순함 추구: 필요 최소의 개념, 규칙, 구성 요소 유지 이해 용이성: 읽고 추론하기 쉬운 흐름과 명명 유지보수 용이성: 응집도 높이고 결합도 낮춰 변경 영향 최소화 적용 방법 처음부터 모든 시나리오를 포괄하려 하지 말고 현재 요구에 맞춘 최소 기능으로 시작 큰 만능 모듈 대신 작고 역할이 분리된 구성으로 나누기 공개 인터페이스를 최소화하고 기본값을 합리적으로 설계 데이터 흐름을 단방향으로 단순화하고 예외 경로는 명시적으로 처리 관련 원칙 DRY: 중복 제거로 변경 비용과 오류 가능성 감소 YAGNI: 지금 필요 없는 기능은 만들지 않음 간단 예시 모든 옵션을 받는 doSomething(config) 하나로 처리하려는 유혹을 경계. 대신 doSimpleA, doSimpleB처럼 명확한 역할의 작은 함수로 분리하고 기본 동작을 안전하게 설계함. 설정이 꼭 필요할 때만 제한된 형태로 노출\n주의와 한계 지나친 단순화는 요구 사항을 놓치거나 성능 병목을 숨길 수 있음. 단순함은 기능 포기나 임시방편이 아니라 핵심을 분리하고 불필요를 걷어내는 구조적 선택이어야 함. 변경 가능성, 운영 환경, 팀 역량 같은 제약을 고려해 균형 잡힌 트레이드오프 설계 필요\n마무리 KISS의 본질은 덜 하는 것이 아니라 더 잘 하는 것에 있음. 작게 시작하고 반복적으로 다듬으면서 복잡성이 자연스럽게 커지지 않도록 경계하는 습관이 유지보수 가능한 코드베이스를 만든다 함\n참고자료 https://en.wikipedia.org/wiki/KISS_principle https://en.wikipedia.org/wiki/Don%27t_repeat_yourself https://martinfowler.com/bliki/Yagni.html ","permalink":"https://blog.jsontapose.com/posts/kiss-principle-software-design-799a74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eKISS는 Keep It Simple, Stupid 또는 Keep It Simple and Straightforward의 약자이며 1960년대 미 해군에서 출발한 설계 원칙입니다. 소프트웨어에서는 불필요한 복잡성을 제거하고 이해와 변경이 쉬운 구조를 지향합니다. 목표는 적은 개념과 짧은 경로로 같은 가치를 제공하는 시스템을 만드는 것임\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단순함 추구: 필요 최소의 개념, 규칙, 구성 요소 유지\u003c/li\u003e\n\u003cli\u003e이해 용이성: 읽고 추론하기 쉬운 흐름과 명명\u003c/li\u003e\n\u003cli\u003e유지보수 용이성: 응집도 높이고 결합도 낮춰 변경 영향 최소화\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"적용-방법\"\u003e적용 방법\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e처음부터 모든 시나리오를 포괄하려 하지 말고 현재 요구에 맞춘 최소 기능으로 시작\u003c/li\u003e\n\u003cli\u003e큰 만능 모듈 대신 작고 역할이 분리된 구성으로 나누기\u003c/li\u003e\n\u003cli\u003e공개 인터페이스를 최소화하고 기본값을 합리적으로 설계\u003c/li\u003e\n\u003cli\u003e데이터 흐름을 단방향으로 단순화하고 예외 경로는 명시적으로 처리\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"관련-원칙\"\u003e관련 원칙\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDRY: 중복 제거로 변경 비용과 오류 가능성 감소\u003c/li\u003e\n\u003cli\u003eYAGNI: 지금 필요 없는 기능은 만들지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e모든 옵션을 받는 doSomething(config) 하나로 처리하려는 유혹을 경계. 대신 doSimpleA, doSimpleB처럼 명확한 역할의 작은 함수로 분리하고 기본 동작을 안전하게 설계함. 설정이 꼭 필요할 때만 제한된 형태로 노출\u003c/p\u003e","title":"KISS 원리: 소프트웨어 설계에서 불필요한 복잡성 줄이기"},{"content":"개념/배경 Parameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨 함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함\n문법 type Parameters\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends ( ...args: infer P ) =\u0026gt; any ? P : never; T가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출 T가 함수 타입이 아니면 never 반환 추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능 사용 예시 기본 추출\nfunction greet(name: string, age: number) { return `Hello, ${name}. You are ${age} years old`; } type GreetParameters = Parameters\u0026lt;typeof greet\u0026gt;; // [name: string, age: number] 매개변수 타입 재사용\ntype GreetParameters = Parameters\u0026lt;typeof greet\u0026gt;; const newGreet = (...args: GreetParameters) =\u0026gt; greet(...args);위와 같이 스프레드와 결합해 기존 함수의 매개변수 시그니처를 그대로 보존하는 래퍼를 작성 가능함 시그니처 변경 시 컴파일 시점에 파급 오류가 발생하므로 타입 드리프트를 방지하는 효과가 있음\n비동기 함수에도 동일하게 적용 가능함 매개변수 추출은 반환 타입과 무관하며 Promise 여부에 영향 받지 않음\n동작 포인트 infer 키워드를 사용한 조건부 타입으로 매개변수 튜플 P를 도출하는 구조 튜플에 라벨이 표시될 수 있으나 라벨은 가독성 보조 요소이며 타입 호환성에는 영향이 크지 않음 any에 대한 Parameters는 any[]로 간주될 수 있어 타입 안전성이 약해짐 가능한 한 구체적인 함수 타입을 대상으로 사용 권장 주의 사항 함수 타입이 아닌 입력은 항상 never가 됨 type NotAFunction = Parameters\u0026lt;number\u0026gt;; // never 오버로드가 있는 함수 타입을 대상으로 사용할 때 의도한 시그니처와 추출 결과가 어긋날 수 있음 가능한 한 명시적인 함수 타입 별칭을 만들어 두고 해당 타입에 대해 Parameters를 적용하는 방식 권장 매개변수에 this 바인딩 타입이 있는 함수의 경우, 호출 시그니처 정의 방식에 따라 결과가 달라질 수 있음 this 파라미터를 분리한 호출 시그니처를 명시해 예측 가능성 확보 권장 베스트 프랙티스 기존 함수의 매개변수 타입을 재사용하는 래퍼, 프락시, 데코레이터, 로깅 헬퍼 등에 적극 활용 API 경계에서 입력 검증 로직과 타입을 일치시키기 위해 Parameters 결과를 폼 파서나 밸리데이터와 연계 팀 규칙으로 any를 허용하는 Parameters 사용을 제한하고, 구체 타입 기반으로만 사용하도록 가이드 마무리 Parameters는 함수 타입의 매개변수 목록을 튜플로 추출해 재사용성과 타입 안전성을 동시에 확보하는 유틸리티 타입임 조건부 타입과 infer를 기반으로 동작하며, 함수가 아닌 타입에는 never를 반환함 과도한 중복 선언을 줄이고 래퍼 함수의 타입 드리프트를 방지하는 데 실용적임\n참고자료 https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterst https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#labeled-tuple-elements ","permalink":"https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eParameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨\n함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함\u003c/p\u003e\n\u003ch3 id=\"문법\"\u003e문법\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003etype\u003c/span\u003e Parameters\u003cspan style=\"color:#eceff4\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003eT\u003c/span\u003e \u003cspan style=\"color:#8fbcbb\"\u003eextends\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#8fbcbb\"\u003e...args\u003c/span\u003e\u003cspan style=\"color:#bf616a\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#8fbcbb\"\u003eany\u003c/span\u003e\u003cspan style=\"color:#bf616a\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eany\u003c/span\u003e\u003cspan style=\"color:#81a1c1\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e T \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eextends\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#eceff4\"\u003e...\u003c/span\u003eargs: \u003cspan style=\"color:#81a1c1\"\u003einfer\u003c/span\u003e P\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003eany\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1\"\u003e?\u003c/span\u003e P\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  : \u003cspan style=\"color:#81a1c1\"\u003enever\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eT가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출\u003c/li\u003e\n\u003cli\u003eT가 함수 타입이 아니면 never 반환\u003c/li\u003e\n\u003cli\u003e추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"사용-예시\"\u003e사용 예시\u003c/h3\u003e\n\u003cp\u003e기본 추출\u003c/p\u003e","title":"TypeScript Parameters 유틸리티 타입 개념과 안전한 활용"},{"content":"개요 InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 메모리에 캐싱하는 영역임 디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임 InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 심장부라 할 수 있음\n쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임\n버퍼 풀 구성 요소 버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴\n데이터 페이지: 실제 테이블 로우(Row)가 저장된 페이지 인덱스 페이지: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함) 기타 관리 페이지: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등 핵심 개념 페이지 캐싱 InnoDB는 디스크 데이터를 페이지 단위로 다룸 클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 페이지 전체를 버퍼 풀로 가져옴 이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함\n더티 페이지와 쓰기 지연 애플리케이션이 데이터를 변경(INSERT, UPDATE)하면,\n버퍼 풀에 적재된 페이지가 메모리상에서 먼저 수정됨 이 페이지는 \u0026lsquo;더티 페이지(Dirty Page)\u0026rsquo;(디스크와 내용이 다른 상태)로 표시됨 변경 내용은 즉시 디스크 데이터 파일에 쓰지 않고, 백그라운드 스레드가 모아서(Batch) 디스크에 반영(Flush)함 이렇게 모아서 쓰면 랜덤 I/O를 줄이고, 디스크 쓰기 효율을 올릴 수 있음\n리두 로그 (Redo Log) InnoDB는 WAL(Write-Ahead Logging) 방식을 사용함 데이터 페이지를 디스크에 쓰기 전에, 먼저 리두 로그에 변경 내용을 기록함\n트랜잭션 커밋 흐름 요약\n버퍼 풀의 페이지 수정 (→ 더티 페이지) 리두 로그 버퍼에 변경 내역 기록 커밋 시점: 리두 로그를 디스크로 동기화 (fsync) 애플리케이션에 커밋 성공 응답 (이후) 더티 페이지는 백그라운드에서 천천히 디스크에 플러시 서버가 크래시 나도, 디스크에 반영 안 된 더티 페이지 내용은 리두 로그를 적용해 복구할 수 있음 (일관성 보장)\nLRU 기반 페이지 교체 버퍼 풀 크기는 한정되어 있어, 새 페이지를 로드할 자리가 없으면 기존 페이지를 교체(Eviction)해야 함 InnoDB는 단순 LRU가 아닌, LRU 리스트를 \u0026ldquo;Young 영역\u0026quot;과 \u0026ldquo;Old 영역\u0026quot;으로 나누는 변형된 알고리즘을 사용함 (이는 Full Table Scan 같은 대용량 순차 스캔이 버퍼 풀의 \u0026lsquo;핫 데이터\u0026rsquo;를 밀어내는 상황을 방지하기 위함)\n핵심은 \u0026ldquo;최근에 자주 쓰인 페이지는 오래 남기고, 오래 안 쓰인 페이지부터 내보낸다\u0026quot;는 것\n읽기/쓰기 동작 흐름 읽기 경로 클라이언트가 특정 데이터 조회 요청 InnoDB가 해당 페이지가 버퍼 풀에 있는지 확인 있으면 (Cache Hit): 메모리에서 즉시 반환 (매우 빠름) 없으면 (Cache Miss): 디스크에서 페이지를 읽어와 버퍼 풀에 적재 후 반환 (느림) → 버퍼 풀 히트율(Hit Rate)이 높을수록 디스크 I/O가 줄어 성능이 좋아짐 쓰기 경로 애플리케이션이 데이터를 변경하면 버퍼 풀의 페이지에 먼저 반영 (→ 더티 페이지가 됨) 변경 내용이 리두 로그에 기록됨 커밋 시점: 리두 로그가 우선 디스크에 안전하게 기록됨 (애플리케이션 응답 완료) 더티 페이지 자체는 백그라운드 스레드(Page Cleaner)가 디스크로 천천히 내려 보냄 (체크포인트 관리) 이 구조 덕분에 쓰기 트랜잭션이 많아도 애플리케이션은 비교적 빠르게 커밋 응답을 받을 수 있음\n버퍼 풀 크기 설정 기본 원칙 innodb_buffer_pool_size 값은 전체 RAM, 워크로드 특성, 같은 서버에서 돌아가는 다른 프로세스를 모두 고려해서 잡아야 함 전형적인 전용 DB 서버 기준, 러프하게 전체 메모리의 50%~75% 정도를 할당함\n스왑(Swap)은 절대 금물 버퍼 풀 크기를 욕심내서 크게 잡았다가 OS 스왑이 발생하면, 메모리가 디스크처럼 동작하게 되어 성능이 급격히 나빠짐 \u0026ldquo;버퍼 풀 히트율 조금 더 높이기\u0026quot;보다 \u0026ldquo;절대 스왑 안 나게 하기\u0026quot;를 우선하는 게 안전함\n버퍼 풀 인스턴스 대용량 버퍼 풀(수십 GB 이상)일 경우, innodb_buffer_pool_instances를 조정하여 버퍼 풀을 여러 인스턴스로 나누면 락 경합을 줄여 동시성 향상에 도움이 될 수 있음\n모니터링 지표와 튜닝 버퍼 풀 히트율 높은 히트율(예: 99% 이상)은 디스크 I/O가 적다는 뜻 SHOW ENGINE INNODB STATUS로 확인 가능함 워크로드 자체가 디스크를 많이 타는지, 읽기 패턴이 어떤지 같이 봐야 함\n더티 페이지 비율 더티 페이지가 너무 많이 쌓이면(예: innodb_max_dirty_pages_pct), 플러시 작업이 몰려서 디스크가 갑자기 바빠지고 응답 지연이 발생할 수 있음 innodb_io_capacity 등을 조절해 더티 페이지가 적정 수준에서 꾸준히 플러시되도록 유도해야 함\n정리 버퍼 풀은 읽기(캐싱)와 쓰기(지연/배치) 성능을 모두 책임지는 InnoDB의 핵심임 운영 시에는 스왑이 나지 않는 보수적인 크기에서 시작하고, 모니터링 지표(히트율, 더티 페이지, 플러시 지연)를 근거로 점진적으로 조정하는 접근이 안전함\nMySQL 5.7, 8.0에서는 innodb_buffer_pool_size를 온라인(동적)으로 조정 가능함 서비스 중단 없이 부하 패턴 변화에 맞춰 버퍼 풀 크기를 늘리거나 줄일 수 있음\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size ","permalink":"https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003eInnoDB 버퍼 풀은 데이터와 인덱스 페이지를 \u003cstrong\u003e메모리에 캐싱\u003c/strong\u003e하는 영역임\n디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임\nInnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 \u003cstrong\u003e심장부\u003c/strong\u003e라 할 수 있음\u003c/p\u003e\n\u003cp\u003e쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"버퍼-풀-구성-요소\"\u003e버퍼 풀 구성 요소\u003c/h2\u003e\n\u003cp\u003e버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 페이지\u003c/strong\u003e: 실제 테이블 로우(Row)가 저장된 페이지\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인덱스 페이지\u003c/strong\u003e: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기타 관리 페이지\u003c/strong\u003e: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-개념\"\u003e핵심 개념\u003c/h2\u003e\n\u003ch3 id=\"페이지-캐싱\"\u003e페이지 캐싱\u003c/h3\u003e\n\u003cp\u003eInnoDB는 디스크 데이터를 페이지 단위로 다룸\n클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 \u003cstrong\u003e페이지 전체\u003c/strong\u003e를 버퍼 풀로 가져옴\n이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함\u003c/p\u003e","title":"MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드"},{"content":"개요 @nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임 DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함 핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임\nApiProperty 개념과 사용 @ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임 타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공 코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함\n간단 사용 예시\nclass CreateUserDto { @ApiProperty({ description: \u0026#34;사용자 이름\u0026#34;, example: \u0026#34;John Doe\u0026#34; }) name: string; }이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨\n주요 옵션 필요한 만큼만 설정해 최소 문서화로 시작하고 점진적으로 보강하는 방식 권장\ndescription: 속성 의미 설명 example: 대표 예시 값 required: 필수 여부, 기본값 true type: 복잡 타입 또는 명시가 필요한 경우 사용 enum: 허용 값 집합 지정 isArray: 배열 여부 명시 옵션 스니펫\n@ApiProperty({ description: \u0026#39;사용자 나이\u0026#39;, example: 30, type: Number }) age: number @ApiProperty({ enum: [\u0026#39;admin\u0026#39;, \u0026#39;user\u0026#39;] }) role: string @ApiProperty({ type: String, isArray: true }) tags: string[]required는 별도 지정 없으면 true로 처리됨 PartialType을 통해 생성된 DTO에서는 해당 필드들이 선택적이 되어 Swagger에도 반영됨\n배열과 중첩 객체 배열 표시\n@ApiProperty({ type: String, isArray: true, description: \u0026#39;태그 목록\u0026#39; }) tags: string[]중첩 객체 표시\nclass AddressDto { @ApiProperty() street: string; @ApiProperty() city: string; } class CreateUserDto { @ApiProperty({ type: AddressDto }) address: AddressDto; }Swagger UI에서는 정의한 타입을 따라 객체 구조와 예시가 노출됨\nPickType 개념과 사용 PickType은 기존 DTO에서 특정 속성만 선택해 새로운 DTO 생성하는 유틸리티임 중복 정의 없이 필요한 필드만 가져와 입력이나 응답 모델을 재사용 가능 Swagger 스키마도 선택된 필드만 반영됨\n기본 사용 예시\nclass CreateUserDto { username: string; password: string; email: string; } class LoginDto extends PickType(CreateUserDto, [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]) {}활용 포인트\n코드 재사용성 향상 및 중복 제거 입력 모델과 응답 모델을 상황에 맞춰 최소 단위로 분리 가능 스키마가 원본 DTO 변경을 자동 추적해 일관성 유지 관련 유틸리티 OmitType: 특정 속성만 제외하고 나머지로 새 DTO 생성 class PublicUserDto extends OmitType(CreateUserDto, [\u0026#34;password\u0026#34;]) {} PartialType: 모든 속성을 선택적으로 변경해 부분 업데이트 시 유용 class UpdateUserDto extends PartialType(CreateUserDto) {}조합 사용 시 공통 DTO 하나를 기준으로 입력, 응답, 수정 등 다양한 변형 모델을 일관되게 관리 가능\n팁 타입 추론에 의존해 단순 필드는 최소 정의, 설명과 예시가 필요한 필드에만 @ApiProperty 부여 복잡 타입이나 배열, enum은 type, isArray, enum으로 명시적 선언 권장 응답 모델에서 노출되면 안 되는 필드는 OmitType으로 사전에 제거 부분 업데이트 API는 PartialType 기반 DTO로 required 플래그 자동 조정 유도 문서 신뢰성을 위해 예시 값 example은 실제 도메인 형식과 일치하도록 유지 마무리 @ApiProperty로 DTO 속성 단위 문서화를 정교하게 관리하고, PickType OmitType PartialType으로 DTO 재사용성을 극대화하는 전략 권장 코드와 문서의 단일 소스화를 통해 API 스펙의 정확성, 추적 가능성, 유지보수성을 동시에 확보 가능\n참고자료 https://docs.nestjs.com/openapi/introduction https://github.com/nestjs/swagger https://swagger.io/specification/ ","permalink":"https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임\nDTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함\n핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임\u003c/p\u003e\n\u003ch3 id=\"apiproperty-개념과-사용\"\u003eApiProperty 개념과 사용\u003c/h3\u003e\n\u003cp\u003e@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임\n타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공\n코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함\u003c/p\u003e\n\u003cp\u003e간단 사용 예시\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eclass\u003c/span\u003e CreateUserDto \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003e@ApiProperty\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e description\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;사용자 이름\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e example\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;John Doe\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  name: \u003cspan style=\"color:#81a1c1\"\u003estring\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨\u003c/p\u003e","title":"NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법"},{"content":"개요 Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함 skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함\n핵심 동작 cursor는 그 지점부터 시작 await prisma.user.findMany({ cursor: { id: 100 }, take: 5, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: 100부터 시작해 5개 반환 skip: 1은 cursor에 해당하는 레코드를 건너뜀 await prisma.user.findMany({ cursor: { id: 100 }, skip: 1, take: 5, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: 101부터 5개 반환 예시로 보는 차이 데이터가 아래와 같다고 가정\n98, 99, 100, 101, 102, 103, 104, 105, 106, 107\nskip 없이 cursor: { id: 100 }, take: 3, orderBy: { id: \u0026#39;asc\u0026#39; } // 결과: [100, 101, 102] skip: 1과 함께 cursor: { id: 100 }, skip: 1, take: 3, orderBy: { id: \u0026#39;asc\u0026#39; } // 결과: [101, 102, 103] 왜 skip: 1을 쓰는가 페이지 간 중복 방지 목적\n// 첫 페이지 const page1 = await prisma.user.findMany({ take: 3, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: [98, 99, 100] // nextCursor = 100 // 다음 페이지 const page2 = await prisma.user.findMany({ cursor: { id: 100 }, skip: 1, take: 3, orderBy: { id: \u0026#34;asc\u0026#34; }, }); // 결과: [101, 102, 103] 중복 없음 코드 패턴 요약 더보기 여부 판단을 위해 take를 limit + 1로 지정하는 패턴 권장 nextCursor는 반환 목록의 마지막 id 사용 const data = await prisma.user.findMany({ take: limit + 1, ...(cursor \u0026amp;\u0026amp; { cursor: { id: cursor }, skip: 1 }), orderBy: { id: \u0026#34;asc\u0026#34; }, }); const hasMore = data.length \u0026gt; limit; const items = hasMore ? data.slice(0, -1) : data; const nextCursor = items.length ? items[items.length - 1].id : null; return { data: items, hasMore, nextCursor };내부 처리 관점 사용자 질문 요지: take: 501, skip: 1, cursor: { id: 1 }이라면 실제로 1부터 502까지 502개의 로우를 확인하는가\n인덱스 관점에서 맞음 일반적인 실행 흐름 인덱스 탐색으로 id = 1 위치 도달 그 항목은 skip으로 제외 이후 연속된 501개 항목을 읽어 반환 결과적으로 인덱스 레벨에서 502개 항목을 방문하는 효과가 발생 클라이언트로 반환되는 레코드 수는 501개 SQL 관점 설명 Prisma의 cursor 기반 페이지네이션은 보통 OFFSET을 쓰지 않고 정렬 컬럼 기준 범위 조건으로 변환됨 단일 정렬 키 id 기준 오름차순의 경우 개념적으로 아래와 유사한 형태\nSELECT ... FROM user_nickname_log WHERE id \u0026gt; 1 -- cursor: { id: 1 }, skip: 1일 때의 개념적 조건 ORDER BY id ASC LIMIT 501 -- take만큼 제한 skip: 1 없이 cursor만 쓰면 WHERE id \u0026gt;= 1에 가까운 조건으로 해석됨 skip: 1을 붙이면 WHERE id \u0026gt; 1로 바뀌는 효과가 나서 중복 제거 실제 생성 SQL과 실행 계획은 데이터베이스와 드라이버, 정렬 키 구성에 따라 다를 수 있음 핵심은 OFFSET으로 앞 페이지를 건너뛰지 않고 인덱스 범위 스캔으로 이어가기 때문에 커서 기반 페이지네이션의 성능 특성이 보장된다는 점임\n정리 cursor는 기준 레코드 지점부터 시작 skip: 1은 기준 레코드를 제외해 중복 제거 limit + 1 패턴으로 hasMore를 안정적으로 판정 인덱스 관점에서 cursor 레코드 포함 총 502개 항목을 방문하고 501개만 반환하는 해석 가능 Prisma는 일반적으로 WHERE 범위 조건과 LIMIT을 활용해 cursor 기반 페이지네이션을 수행하며 OFFSET 기반 페이지네이션과 다름 현재와 같은 구현은 동작 의도와 성능 측면 모두에서 타당함\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/pagination https://www.prisma.io/docs/orm/prisma-client/queries/pagination#cursor-based-pagination ","permalink":"https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003ePrisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함\nskip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함\u003c/p\u003e\n\u003ch3 id=\"핵심-동작\"\u003e핵심 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ecursor는 그 지점부터 시작\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e prisma\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindMany\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  cursor\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e id: \u003cspan style=\"color:#81a1c1\"\u003e100\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  take: \u003cspan style=\"color:#81a1c1\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  orderBy\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e id\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;asc\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 결과: 100부터 시작해 5개 반환\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eskip: 1은 cursor에 해당하는 레코드를 건너뜀\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e prisma\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindMany\u003cspan style=\"color:#eceff4\"\u003e({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  cursor\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e id: \u003cspan style=\"color:#81a1c1\"\u003e100\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  skip: \u003cspan style=\"color:#81a1c1\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  take: \u003cspan style=\"color:#81a1c1\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  orderBy\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e id\u003cspan style=\"color:#81a1c1\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;asc\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e// 결과: 101부터 5개 반환\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"예시로-보는-차이\"\u003e예시로 보는 차이\u003c/h3\u003e\n\u003cp\u003e데이터가 아래와 같다고 가정\u003c/p\u003e","title":"Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미"},{"content":"개요 Prisma의 findMany는 다중 레코드 조회용 메서드 기본값은 대상 모델의 모든 레코드 반환 where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원 옵션 조합으로 조건 기반 조회를 간결하게 구성 가능\n기본 사용법 가장 단순한 호출 형태\nconst users = await prisma.user.findMany();주요 옵션 옵션은 필요한 것만 선택적으로 사용\nwhere: 조건 필터링 select: 필드 서브셋 선택 include: 관계 데이터 로드 orderBy: 정렬 기준 지정 skip, take: 오프셋 기반 페이징 distinct: 특정 필드 기준 중복 제거 where로 조건 필터링 단일 조건부터 복합 조건까지 표현 가능\nconst active = await prisma.user.findMany({ where: { isActive: true }, });in 조건 지정한 값 배열 중 하나와 일치하는 레코드 매칭\nconst some = await prisma.user.findMany({ where: { id: { in: [1, 2, 3] } }, });비교 연산자 숫자, 날짜, 문자열 등 비교 지원\nequals, not lt, lte, gt, gte in, notIn const range = await prisma.user.findMany({ where: { age: { gte: 18, lte: 30 } }, });복합 논리 연산 AND, OR 조합으로 다중 조건 구성\nconst mixed = await prisma.user.findMany({ where: { OR: [{ age: { lt: 18 } }, { role: \u0026#34;admin\u0026#34; }], }, });in과 비교 연산자 결합으로 범위와 집합 조건을 동시에 표현 가능\nconst filtered = await prisma.user.findMany({ where: { id: { in: [1, 2, 3, 4, 5] }, age: { gt: 20 }, }, });select로 필요한 필드만 조회 응답 페이로드 최소화에 유용\nconst names = await prisma.user.findMany({ select: { name: true, email: true }, });주의사항: 같은 호출에서 select와 include를 동시에 사용 불가, 하나만 선택\ninclude로 관계 데이터 로드 연관 모델을 함께 가져오기\nconst withPosts = await prisma.user.findMany({ include: { posts: true }, });필요한 필드만 부분 선택하려면 include 내부 select 사용\nconst withTitles = await prisma.user.findMany({ include: { posts: { select: { title: true } }, }, });orderBy로 정렬 단일 또는 다중 필드 정렬 지원\nconst recent = await prisma.user.findMany({ orderBy: { createdAt: \u0026#34;desc\u0026#34; }, });여러 필드 정렬은 배열로 순서 지정 가능\nskip, take로 페이징 오프셋 기반 페이지네이션 구성\nconst page = await prisma.user.findMany({ skip: 10, take: 5, });대용량 페이지 이동 시 skip 비용 증가 가능성 존재, 일관성 보장을 위해 cursor 기반 페이징 고려 권장\nconst next = await prisma.user.findMany({ cursor: { id: lastId }, skip: 1, take: 10, orderBy: { id: \u0026#34;asc\u0026#34; }, });distinct로 중복 제거 지정한 스칼라 필드 조합 기준으로 중복 제거\nconst uniqNames = await prisma.user.findMany({ distinct: [\u0026#34;name\u0026#34;], });데이터베이스와 드라이버 제약에 따라 지원 범위가 다를 수 있으므로 최신 문서 확인 권장\n예시 조합 조건 필터 + 필드 선택 + 관계 일부 선택 + 정렬 + 제한 개수 조합\nconst result = await prisma.user.findMany({ where: { isActive: true, age: { gte: 18 } }, select: { name: true, email: true, posts: { select: { title: true } }, }, orderBy: { createdAt: \u0026#34;desc\u0026#34; }, take: 10, });주의와 베스트 프랙티스 select와 include는 같은 호출에서 동시 사용 불가 정렬 없이 take만 사용 시 결과 순서 비결정적일 수 있음, orderBy 동반 사용 권장 오프셋 페이징(skip)은 페이지 번호가 커질수록 비용 증가 가능, 커서 기반 페이징 고려 where로 불필요한 데이터 전송 최소화, 필요한 필드만 select로 제한 distinct는 스칼라 필드 기준 사용 권장, 모델 및 드라이버 호환성 확인 정리 findMany는 다중 레코드 조회의 기본 도구 where로 정밀 필터링, select/include로 응답 축소 또는 관계 로드, orderBy와 skip·take로 정렬과 페이징 제어, distinct로 중복 제거 가능 in과 비교 연산자, AND·OR 조합으로 실제 요구사항을 간결하게 표현 가능 커서 기반 페이징과 필드 최소화로 성능과 안정성 확보 권장\n참고자료 https://www.prisma.io/docs/orm/reference/prisma-client-reference#findmany https://www.prisma.io/docs/orm/prisma-client/queries/filters https://www.prisma.io/docs/orm/prisma-client/queries/pagination ","permalink":"https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003ePrisma의 findMany는 다중 레코드 조회용 메서드\n기본값은 대상 모델의 모든 레코드 반환\nwhere 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원\n옵션 조합으로 조건 기반 조회를 간결하게 구성 가능\u003c/p\u003e\n\u003ch3 id=\"기본-사용법\"\u003e기본 사용법\u003c/h3\u003e\n\u003cp\u003e가장 단순한 호출 형태\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e users \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eawait\u003c/span\u003e prisma\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003euser\u003cspan style=\"color:#eceff4\"\u003e.\u003c/span\u003efindMany\u003cspan style=\"color:#eceff4\"\u003e();\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"주요-옵션\"\u003e주요 옵션\u003c/h3\u003e\n\u003cp\u003e옵션은 필요한 것만 선택적으로 사용\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhere: 조건 필터링\u003c/li\u003e\n\u003cli\u003eselect: 필드 서브셋 선택\u003c/li\u003e\n\u003cli\u003einclude: 관계 데이터 로드\u003c/li\u003e\n\u003cli\u003eorderBy: 정렬 기준 지정\u003c/li\u003e\n\u003cli\u003eskip, take: 오프셋 기반 페이징\u003c/li\u003e\n\u003cli\u003edistinct: 특정 필드 기준 중복 제거\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"where로-조건-필터링\"\u003ewhere로 조건 필터링\u003c/h3\u003e\n\u003cp\u003e단일 조건부터 복합 조건까지 표현 가능\u003c/p\u003e","title":"Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자"},{"content":"개요 JavaScript에서 함수는 일급 객체로 취급됨 이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함 이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨\n핵심 개념 변수에 할당 가능 다른 함수의 인수로 전달 가능 다른 함수의 반환값으로 사용 가능 객체의 프로퍼티로 저장 가능 간단 예시 변수에 할당\nconst greet = (name) =\u0026gt; `Hello, ${name}`;인수로 전달\nconst run = (fn, v) =\u0026gt; fn(v); run(greet, \u0026#34;Bob\u0026#34;);반환값으로 사용 및 클로저\nconst mul = (m) =\u0026gt; (v) =\u0026gt; v * m; mul(2)(5);객체 프로퍼티로 저장해 메서드 구성\nconst obj = { name: \u0026#34;Charlie\u0026#34;, greet() { return `Hi, I\u0026#39;m ${this.name}`; }, }; obj.greet();동작 원리 함수는 객체로 구현되어 프로퍼티와 메서드 보유함(Function.prototype의 call, apply, bind 등) 함수 식과 선언 모두 값으로 평가되어 식 컨텍스트에서 자유롭게 이동 가능함 반환 함수가 외부 스코프 변수를 캡처하면 클로저 형성됨 참조가 값으로 전달되므로 동일 함수 객체를 여러 곳에서 공유 가능함\n이점 함수를 값으로 다뤄 조합성과 재사용성 향상\n고차 함수로 로직을 파라미터화하여 정책 주입 용이 콜백으로 비동기 흐름 연결 및 이벤트 처리 단순화 클로저로 상태 은닉 및 부분 적용 구현 용이 합성으로 작은 함수를 결합해 파이프라인 구성 가능 주의 사항 this 바인딩은 호출 방식에 의존함, 메서드를 분리해 호출 시 this가 바뀔 수 있으므로 bind 등으로 명시적 바인딩 권장 클로저가 불필요한 대상을 오래 참조하면 메모리 유지 발생 가능, 긴 생명주기 객체 참조 최소화 필요 콜백 중첩은 가독성 저하 유발, Promise와 async/await로 흐름 평탄화 권장\n마무리 JavaScript 함수의 일급 객체 성질은 함수형 스타일을 실용적으로 적용하게 하는 기반임 값처럼 전달하고 반환하는 패턴을 표준화해두면 모듈 경계가 명확해지고 테스트 용이성이 개선됨 핵심은 함수를 데이터처럼 다루되 컨텍스트(this)와 수명주기 관리에 신경 쓰는 것임\n참고자료 https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind ","permalink":"https://blog.jsontapose.com/posts/javascript-first-class-functions-5dcc7e/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eJavaScript에서 함수는 일급 객체로 취급됨\n이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함\n이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e변수에 할당 가능\u003c/li\u003e\n\u003cli\u003e다른 함수의 인수로 전달 가능\u003c/li\u003e\n\u003cli\u003e다른 함수의 반환값으로 사용 가능\u003c/li\u003e\n\u003cli\u003e객체의 프로퍼티로 저장 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"간단-예시\"\u003e간단 예시\u003c/h3\u003e\n\u003cp\u003e변수에 할당\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e greet \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ename\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e`Hello, \u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e${\u003c/span\u003ename\u003cspan style=\"color:#a3be8c\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#a3be8c\"\u003e`\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e인수로 전달\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e run \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003efn\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e v\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e fn\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ev\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erun\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003egreet\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#a3be8c\"\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e반환값으로 사용 및 클로저\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003econst\u003c/span\u003e mul \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003em\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003ev\u003cspan style=\"color:#eceff4\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#eceff4\"\u003e=\u0026gt;\u003c/span\u003e v \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e m\u003cspan style=\"color:#eceff4\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emul\u003cspan style=\"color:#eceff4\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e2\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e)(\u003c/span\u003e\u003cspan style=\"color:#b48ead\"\u003e5\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e객체 프로퍼티로 저장해 메서드 구성\u003c/p\u003e","title":"JavaScript 함수는 왜 일급 객체인가 — 의미와 활용"},{"content":"개념과 배경 InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임 대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함 사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함 이때 결정 규칙이 존재함\n먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용 그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용 세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함 따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함\n핵심 개념 정리 클러스터형 인덱스 테이블의 물리적 정렬 기준이 되는 인덱스 PK 또는 그에 준하는 키가 담당 명시적 PK 부재 시 동작 NOT NULL 유니크 인덱스가 있으면 해당 인덱스를 클러스터 키로 채택 없으면 6바이트 숨김 row_id 생성 후 클러스터 키로 사용 세컨더리 인덱스 리프에 클러스터 키 값을 포함하여 최종 레코드에 도달하는 구조 FK 제약 참조 대상은 PK 또는 유니크 키가 필요 숨김 row_id는 외부에서 참조 불가 장점 설계 유연성 확보 로우의 고유 식별을 강제하지 않음 중복 허용 설계 가능 로그나 임시 적재 같은 일회성 데이터에 적합 스키마 선언 단순화 별도 PK 칼럼을 정의 관리하지 않음 내부적으로는 InnoDB가 식별자를 보유하므로 개발자는 이를 의식하지 않아도 됨 내부 식별 자동 관리 내부 row_id로 일관된 클러스터링 확보 별도의 AUTO_INCREMENT 칼럼을 두지 않아도 되는 선택지 존재 단점 클러스터링 효율 저하 가능성 워크로드가 특정 칼럼 기준 범위 조회 중심인 경우 해당 칼럼을 PK로 잡을 때보다 페이지 지역성과 스캔 효율이 떨어질 수 있음 숨김 row_id 기준 정렬은 업무 키와 무관하므로 의도한 액세스 패턴과 불일치 무결성 및 중복 제어 부재 PK나 유니크 키가 없으면 동일 데이터의 다중 삽입을 제약하기 어려움 중복 제거와 정합성 보장이 애플리케이션 책임으로 이동 FK 사용 제약 FK는 참조 대상이 PK 또는 유니크 키여야 함 숨김 row_id는 외부에서 참조할 수 없어 실질적으로 FK 기반 관계형 모델 구성 난이도 상승 운영 관리와 확장성 저하 대용량 환경에서 주 식별자 부재는 트러블슈팅과 튜닝 지점을 모호하게 만듦 인덱스를 다수 추가해도 클러스터 키가 워크로드와 맞지 않으면 성능 이득이 제한적일 수 있음 예측 불가능성 증가 숨김 row_id는 사용자 가시성과 제어가 없어 클러스터링 순서나 재배치 영향 분석이 어려움 언제 PK 생략을 고려할 수 있는가 로그 수집과 임시 적재처럼 개별 로우 식별이 비핵심이고 중복 허용 전제가 있는 경우 FK를 사용하지 않고 일회성 처리 후 주기적 파티션 드롭이나 벌크 삭제로 관리하는 테이블 접근 패턴이 대부분 단순 삽입과 기간 기반 일괄 삭제이며 조회가 제한적인 워크로드 이 경우에도 최소한의 제약을 두는 편이 안전함\n업무적으로 유일해야 하는 칼럼 조합에는 유니크 인덱스 부여 권장 파티션 키 또는 보존 기간 기준의 관리 전략을 명확히 문서화 조회가 늘거나 관계가 필요해질 가능성에 대비해 스키마 변경 경로를 마련 실무 권장 사항과 트레이드오프 OLTP 워크로드 기준 기본값은 명시적 PK 부여 단조 증가 surrogate key를 PK로 채택해 클러스터 페이지 분할 비용을 낮추는 전략 선호 명시적 PK는 다음 이점을 제공 클러스터 인덱스가 워크로드 접근 패턴을 반영하도록 설계 가능 세컨더리 인덱스의 참조 대상이 명확해 룩업 비용 예측 용이 FK 구성과 무결성 보장 단순화 PK 생략은 스키마와 코드가 단순해 보이지만 운영 단계에서 성능 최적화와 무결성 확보 비용이 커질 수 있음 정리 InnoDB는 항상 클러스터형 인덱스를 필요로 함 명시적 PK가 없으면 NOT NULL 유니크 키를 우선 사용하고 그마저 없으면 6바이트 숨김 row_id를 생성해 대체함 PK 없이 인덱스만 두는 설계는 특수 목적에서만 고려 로그와 임시 저장 등 중복 허용과 낮은 정합성 요구의 시나리오에 한정하는 편이 안전 일반적인 OLTP 환경에서는 명시적 PK가 사실상 필수 무결성 보장과 쿼리 최적화, FK 구성, 예측 가능한 성능 튜닝 측면에서 이점이 큼 결론적으로 PK를 두지 않는 선택은 예외적 상황으로 제한하고 대부분의 테이블에는 업무 맥락에 맞는 명시적 PK를 설계하는 것이 바람직함 참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/innodb-primary-key.html https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html ","permalink":"https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/","summary":"\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eInnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임\n대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함\n사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함\n이때 결정 규칙이 존재함\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용\u003c/li\u003e\n\u003cli\u003e그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함\n따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함\u003c/p\u003e","title":"InnoDB에서 PK 없는 테이블의 동작과 트레이드오프"},{"content":"개요 Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함\n문제를 명확히 하기 작성한 코드의 기대 동작 정의 실제 관측된 동작과의 차이 정리 실패 조건과 재현 절차 고정 문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음\n다양한 가정과 빠른 배제 API를 올바른 개체와 메서드로 사용했는지 확인 오타, 잘못된 인수 순서, 잘못된 기본값 사용 여부 점검 코드 변경 이력이 해당 증상과 인과관계 있는지 검증 실제 값과 다른 상수를 가정해 추론하지 않았는지 점검 타인이 작성한 코드라면 의도와 계약을 먼저 파악 작게 만들고 자주 실행하는 전략 권장. 최소 동작 코어를 먼저 통과시키고, 점진적으로 수정·확장하며 각 단계에서 실패를 국소화함\n디버거 기본 개념 Breakpoint 중단점. 실행을 특정 라인에서 멈춤. 코드에 debugger 구문을 넣거나 에디터에서 라인 왼쪽 클릭 등으로 설정\nWatch 특정 변수나 표현식 값을 지속 관찰. 값 변화와 조건 만족 시점을 빠르게 확인하는 용도\n예시\nfunction fibonacci(n) { if (n \u0026lt; 2) return n; const result = fibonacci(n - 1) + fibonacci(n - 2); return result; }watch에 result === 5 추가 시 false에서 true로 전환되는 시점을 즉시 파악 가능\nCall Stack 현재 호출 중인 함수 스택 추적. 어디에서 무엇이 호출되었는지 역추적 가능\nStep controls\nContinue 다음 중단점까지 진행 Step over 현재 라인 실행, 함수 내부는 건너뜀 Step into 함수 내부로 진입, 라인 단위 실행 Step out 현재 함수 나머지를 실행하고 리턴 지점에서 멈춤 Chrome DevTools로 Node.js 디버깅 Node 8부터 V8 Inspector를 정식 지원. 기존 \u0026ndash;debug 플래그는 폐기되고 \u0026ndash;inspect 계열로 통일됨. 가장 간단한 진입 방법은 다음과 같음\n초기 진입\nnode \u0026ndash;inspect app.js 실행 처음 라인부터 멈추려면 node \u0026ndash;inspect-brk app.js 사용 실행 로그 예시\nDebugger listening on ws://127.0.0.1:9229/... For help, see: https://nodejs.org/en/docs/inspector Chrome 접속\n주소창에 chrome://inspect 입력 후 Devices 화면으로 이동 Remote Target에서 실행 중인 Node 프로세스를 선택해 inspect 진입 유의사항\n기본 디버그 포트는 9229. 충돌 시 \u0026ndash;inspect=127.0.0.1:0 같은 동적 포트를 사용해 충돌 회피 외부 접근이 가능한 호스트로 열지 않기. 로컬 호스트 바인딩 유지 권장 node-inspect CLI 사용 터미널 기반 디버깅이 필요하면 내장 CLI 디버거 사용\n진입\nnode inspect 파일명 기본 명령\ncont 또는 c 계속 실행 next 또는 n 다음 라인으로 이동 step 또는 s 함수 내부로 진입 out 또는 o 현재 함수에서 빠져나옴 run 또는 restart 재실행 repl 현 위치 컨텍스트에서 표현식 평가 임시 중단점\n코드에 debugger 구문 삽입 후 cont로 진행하면 해당 지점에서 중단 CLI는 GUI 없이도 재현 자동화 스크립트나 원격 SSH 환경에서 빠르게 상태를 확인하기에 유용함\nVS Code에서 디버깅 VS Code는 Node 디버거를 기본 통합 제공. 대부분은 실행 메뉴에서 F5로 시작 가능\n첫 실행\n실행 \u0026gt; 디버깅 시작 또는 F5 선택 launch.json이 없으면 환경 선택 팝업에서 Node.js 선택 launch.json 역할\n실행 파일, 인자, 환경 변수, 작업 디렉터리, 포트 등 디버깅 구성을 선언적으로 관리 팀 단위로 동일한 재현 절차를 공유하는 데 유용 최소 설정 예시\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Launch Program\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/app.js\u0026#34; } ] } 단축키\n계속 또는 일시중지 F5 단위 실행 F10 단계 진입 F11 단계 빠져나오기 Shift+F11 다시 시작 Ctrl+Shift+F5 중지 Shift+F5 실전 팁과 주의사항 프로덕션에서 \u0026ndash;inspect 노출 금지. 로컬 또는 제한된 네트워크에서만 사용 포트 고정이 필요 없으면 \u0026ndash;inspect=127.0.0.1:0로 충돌 회피 debugger 구문과 남은 중단점은 커밋 전에 제거 또는 비활성화 비동기 흐름 디버깅 시 콜 스택에서 프레임을 좁히고, 필요 시 로그와 디버거를 병행하여 원인 단정 재현이 어려운 케이스는 입력과 환경을 고정하고 최소 재현 코드를 별도 파일로 분리해 분석 마무리 디버깅의 핵심은 문제를 작게 만들고 실행 흐름과 상태를 검증 가능한 근거로 좁혀가는 것임. Node.js에서는 Chrome DevTools, node-inspect, VS Code 세 가지 축만 숙지해도 대부분의 서버 사이드 이슈를 빠르고 안전하게 추적 가능함. 도구는 상황에 맞게 고르되, 재현성 확보와 가설 검증 루프를 짧게 유지하는 것이 성패를 가름함\n참고자료 https://nodejs.org/en/learn/getting-started/debugging https://nodejs.org/api/inspector.html https://developer.chrome.com/docs/devtools/javascript/watch-variables/ https://code.visualstudio.com/docs/nodejs/nodejs-debugging ","permalink":"https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함\u003c/p\u003e\n\u003ch3 id=\"문제를-명확히-하기\"\u003e문제를 명확히 하기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e작성한 코드의 기대 동작 정의\u003c/li\u003e\n\u003cli\u003e실제 관측된 동작과의 차이 정리\u003c/li\u003e\n\u003cli\u003e실패 조건과 재현 절차 고정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음\u003c/p\u003e","title":"Node.js 환경에서 디버깅하기"},{"content":"개요 TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임 각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음\nenum 개념과 동작 열거형 타입을 선언하는 문법 숫자 기반과 문자열 기반 모두 지원 컴파일 결과로 양방향 매핑을 담은 JS 객체 생성 키로 값 조회, 값으로 키 역조회 가능 예시\nenum BooleanType { False = 0, True = 1, }컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨\nvar BooleanType = { 0: \u0026#34;False\u0026#34;, 1: \u0026#34;True\u0026#34;, False: 0, True: 1 };주의점\n멤버 이름에 숫자 이름 사용 불가 예) enum X { 1: \u0026lsquo;A\u0026rsquo; } 에러 발생 멤버 종류 Constant Member: 고정 상수값 보유 Computed Member: 표현식 평가 결과를 값으로 가짐 값 타입별 종류 Numeric enum String enum Heterogeneous enum (숫자와 문자열 혼합 사용, 특별한 이유 없으면 지양) 자동 할당 첫 멤버 미초기화 시 0부터 시작 이전 멤버가 숫자 상수면 다음 미초기화 멤버는 이전값 + 1 할당 enum Direction { Up, // 0 Down, // 1 Left, // 2 Right, // 3 }장점 의도 표현력 높음, 양방향 매핑으로 상수 집합을 하나의 식별자로 추상화 가능 정의된 값만 사용하도록 강제 가능, 오입력 방지에 유리 단점 컴파일된 JS 코드가 객체와 초기화 로직을 포함하여 번들 크기 증가 IIFE로 생성되는 사이드이펙트 때문에 일반적으로 트리 셰이킹에 취약 const enum enum의 코드 비용과 간접 참조 비용을 줄이는 목적의 변형 문법 핵심 특징\n멤버 접근 지점에 값이 인라인됨 컴파일 시 enum 구현체가 제거됨 Computed Member 금지, 상수 표현식만 허용 예시\nconst enum Direction { Up, Down, } const xs = [Direction.Up, Direction.Down];컴파일 결과에서 배열 리터럴에 숫자 값이 직접 인라인됨\n멤버는 문자열 리터럴 접근으로만 사용 가능하지 않은 방식은 에러 발생 장점\n실행 시 오브젝트 생성 비용 제거, 번들 크기 감소 가능 주의 및 함정\n빌드 파이프라인에서 트랜스파일러가 const enum 인라인을 보장하지 않으면 깨짐 예) 일부 Babel, isolatedModules 환경, 타입 정보 손실되는 트랜스파일 경로 등 라이브러리 경계 넘어 사용하는 경우 소비자 빌드 설정에 따라 오류 유발 가능 이유로 프로덕션 코드베이스에서 const enum 사용을 제한하거나 금지하는 팀이 많음 as const TypeScript 3.4의 const assertion 문법 목적\n값의 타입 추론 범위를 리터럴 단위로 좁히기 위한 선언적 방법 객체, 배열, 중첩 구조를 포함해 값 전반을 상수로 취급하게 함 핵심 효과\n문자열/숫자 값이 리터럴 타입으로 고정됨 객체 수준으로 사용 시 프로퍼티에 readonly 적용됨 간단 예시\nconst s = \u0026#34;NLP\u0026#34; as const; // 타입이 \u0026#39;NLP\u0026#39;로 고정 const obj = { a: 1, b: \u0026#34;x\u0026#34; } as const; // obj.a: 1, obj.b: \u0026#39;x\u0026#39;, 모두 readonly let으로 선언한 값에도 as const를 붙이면 리터럴 타입으로 고정됨\n재할당 또는 변경 시 타입 오류 또는 readonly 위반으로 막힘 Discriminated Union과의 결합 조건 분기에서 안전하게 속성을 접근하려면 판별 가능한 유니온이 유용함\n공통 판별 키 kind 등으로 각 분기를 좁혀 타입 안전한 접근 보장 as const로 리터럴 값을 고정하면 판별 키가 확정되어 오류 제거에 도움 예시\ntype Shape = { kind: \u0026#34;circle\u0026#34;; radius: number } | { kind: \u0026#34;square\u0026#34;; x: number }; function area(s: Shape) { if (s.kind === \u0026#34;circle\u0026#34;) return Math.PI * s.radius * s.radius; return s.x * s.x; }객체 리터럴 작성 시 kind 값을 as const로 고정하면 판별 정확도 향상\nconst enum 대체 패턴(as const 기반) const enum 없이도 값 집합을 타입으로 뽑아 쓰는 패턴\nconst BooleanType = { False: 0, True: 1 } as const; type BooleanTypeValue = (typeof BooleanType)[keyof typeof BooleanType]; // 0 | 1 특징\n런타임 객체는 단방향 매핑만 가짐 타입은 값 집합의 유니온으로 안전하게 반영됨 번들에 불필요한 초기화 함수 없음, 트리 셰이킹 친화적 enum처럼 값→키 역조회가 필요하면 별도 맵 구성 필요 선택 기준 이중 매핑 필요 여부가 1차 기준\n값↔키 양방향 매핑과 역조회가 유용한 도메인이면 enum 고려 매핑 방향이 단방향이고 값 집합을 타입으로만 활용하면 as const + 유니온 추출 권장 빌드 환경과 도구 호환성도 중요\nconst enum은 인라인이 보장되는 단일 tsc 파이프라인에서만 안정적 다양한 트랜스파일 단계나 라이브러리 경계를 넘는 경우 as const 대안이 안전 요약\nenum은 의도 표현과 역조회가 필요한 경우 적합하지만 번들 비용과 트리 셰이킹 한계 존재 const enum은 이론상 가장 가벼우나 빌드 파이프라인 제약과 함정으로 실무에서 채택 신중 필요 as const는 리터럴 타입 고정과 readonly 부여로 타입 안전성을 높이고, const enum의 주요 사용처를 무리 없이 대체함 마무리 양방향 매핑과 역조회가 반드시 필요하면 enum 선택 그 외 대부분의 상수 집합과 타입 추론 고정 요구에는 as const 기반 패턴 권장 const enum은 빌드 구성과 팀 규칙을 충분히 검토한 뒤 제한적으로 사용 권장\n참고자료 https://www.typescriptlang.org/docs/handbook/enums.html https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#const-assertions https://www.kabuku.co.jp/developers/good-bye-typescript-enum ","permalink":"https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임\n각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음\u003c/p\u003e\n\u003ch3 id=\"enum-개념과-동작\"\u003eenum 개념과 동작\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e열거형 타입을 선언하는 문법\u003c/li\u003e\n\u003cli\u003e숫자 기반과 문자열 기반 모두 지원\u003c/li\u003e\n\u003cli\u003e컴파일 결과로 양방향 매핑을 담은 JS 객체 생성\n\u003cul\u003e\n\u003cli\u003e키로 값 조회, 값으로 키 역조회 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-ts\" data-lang=\"ts\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eenum\u003c/span\u003e BooleanType \u003cspan style=\"color:#eceff4\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  False \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e0\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  True \u003cspan style=\"color:#81a1c1\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#eceff4\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨\u003c/p\u003e","title":"TypeScript enum, const enum, as const 차이와 선택 기준"},{"content":"기본 문법 LIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문 WHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치\n두 가지 형태 사용\nSELECT 컬럼명 FROM 테이블명 LIMIT 개수 SELECT 컬럼명 FROM 테이블명 LIMIT 개수 OFFSET 시작_인덱스일부 dialect에서는 아래 축약형도 존재\n-- MySQL, SQLite SELECT 컬럼명 FROM 테이블명 LIMIT 시작_인덱스, 개수1. LIMIT 개수 LIMIT 뒤 숫자는 인덱스가 아닌 개수\nSELECT * FROM Book LIMIT 1현재 정렬 기준에서 맨 위 행 1개만 반환 ORDER BY가 없으면 반환되는 행은 비결정적일 수 있음\n2. LIMIT 개수 OFFSET 시작 OFFSET은 0부터 시작 다음 예시는 4번째 행부터 1개 반환\nSELECT * FROM Book LIMIT 1 OFFSET 33. OFFSET 생략 문법 아래 형태는 시작 인덱스와 개수를 쉼표로 전달\n-- MySQL, SQLite 전용 SELECT * FROM Book LIMIT 1, 31번 인덱스부터 3개의 행 반환 PostgreSQL 등에서는 이 문법 미지원이므로 LIMIT 개수 OFFSET 시작 형태 사용\n주의 ORDER BY 없이 LIMIT만 사용하면 결과 순서 보장 안 됨 큰 OFFSET은 비용 증가 위험, 대량 페이징에서는 정렬 키 기반 커서 방식 고려 OFFSET은 0부터 시작, 오프바이원 실수 주의 참고자료 https://www.postgresql.org/docs/current/queries-limit.html https://dev.mysql.com/doc/refman/8.0/en/select.html https://www.sqlite.org/lang_select.html ","permalink":"https://blog.jsontapose.com/posts/sql-limit-offset-basics-4a9880/","summary":"\u003ch3 id=\"기본-문법\"\u003e기본 문법\u003c/h3\u003e\n\u003cp\u003eLIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문\nWHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치\u003c/p\u003e\n\u003cp\u003e두 가지 형태 사용\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e개수\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e개수\u003c/span\u003e \u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eOFFSET\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e시작\u003c/span\u003e_인덱스\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e일부 dialect에서는 아래 축약형도 존재\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e-- MySQL, SQLite\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#616e87;font-style:italic\"\u003e\u003c/span\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e컬럼명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eFROM\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e테이블명\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e시작\u003c/span\u003e_인덱스\u003cspan style=\"color:#eceff4\"\u003e,\u003c/span\u003e \u003cspan style=\"color:#bf616a\"\u003e개수\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"1-limit-개수\"\u003e1. LIMIT 개수\u003c/h3\u003e\n\u003cp\u003eLIMIT 뒤 숫자는 인덱스가 아닌 개수\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eSELECT\u003c/span\u003e \u003cspan style=\"color:#81a1c1\"\u003e*\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eFROM\u003c/span\u003e Book\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#81a1c1;font-weight:bold\"\u003eLIMIT\u003c/span\u003e \u003cspan style=\"color:#b48ead\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e현재 정렬 기준에서 맨 위 행 1개만 반환\nORDER BY가 없으면 반환되는 행은 비결정적일 수 있음\u003c/p\u003e\n\u003ch3 id=\"2-limit-개수-offset-시작\"\u003e2. LIMIT 개수 OFFSET 시작\u003c/h3\u003e\n\u003cp\u003eOFFSET은 0부터 시작\n다음 예시는 4번째 행부터 1개 반환\u003c/p\u003e","title":"SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징"},{"content":"개요 Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음 Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 \u0026ndash;debug는 폐기, \u0026ndash;inspect로 통일됨 CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함\n이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함\n핵심 개념 v8-inspector 프로토콜 V8이 노출하는 디버깅 프로토콜 Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조 \u0026ndash;inspect vs \u0026ndash;inspect-brk \u0026ndash;inspect는 바로 실행하면서 디버거 접속 대기 \u0026ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용 포트 기본 포트 9229 사용 \u0026ndash;inspect=PORT, \u0026ndash;inspect-brk=PORT 형태로 변경 가능 프론트엔드 Chromium 기반 개발자도구로 연결 가능 chrome://inspect 에서 Node 대상 탐색 및 연결 node-inspect Node 내장 CLI 디버거 동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행 크롬 개발자도구로 디버깅 Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정\n서버를 인스펙터 모드로 시작 node --inspect bin/www # Debugger listening on ws://127.0.0.1:9229/\u0026lt;uuid\u0026gt; # For help see https://nodejs.org/en/docs/inspector 브라우저에서 chrome://inspect 접속 Remote Target 목록에서 해당 Node 프로세스 확인 inspect 버튼으로 개발자도구 연결 디버깅 방법은 웹 프론트 디버깅과 동일 브레이크포인트 설정, 콜스택 확인, 스텝 인/아웃, 워치, 콘솔 활용 애플리케이션 시작 시점부터 멈추려면 \u0026ndash;inspect-brk 사용 node-inspect로 터미널 디버깅 GUI 없이도 빠르게 문제를 추적할 때 유용\n디버거 시작 node inspect bin/www # Debugger listening on ws://127.0.0.1:9229/\u0026lt;uuid\u0026gt; # Debugger attached # Break on start in bin/www:1 기본 명령 cont, c 계속 실행 next, n 다음 라인으로 이동 step, s 함수 내부로 진입 out, o 호출한 함수로 빠져나오기 run, restart 프로세스 재시작 repl 현재 컨텍스트에서 표현식 실행 브레이크포인트 팁 코드에 debugger 구문을 삽입해 명시적 중단점으로 사용 가능 간단 예시\ndebug\u0026gt; cont # ... debugger 구문에서 일시정지됨 debug\u0026gt; repl Press Ctrl + C to leave debug repl \u0026gt; console.log(app.settings) \u0026lt; { env: \u0026#39;development\u0026#39;, \u0026#39;view engine\u0026#39;: \u0026#39;jade\u0026#39;, ... } \u0026gt; undefined경로 등 민감한 값은 출력 시 마스킹 권장\n포트와 연결 관리 기본 포트 9229 충돌 시 \u0026ndash;inspect=9230 처럼 변경 동일한 포트에 크롬 개발자도구 또는 node-inspect 중 하나만 독점 연결하지 않도록 유의 원격 서버에서 사용할 경우 네트워크에 디버그 포트를 그대로 노출하지 않음 신뢰 네트워크에서만 접속 허용 또는 포트포워딩, 터널링 사용 권장 운영 시 유의사항 \u0026ndash;inspect는 성능에 약간의 오버헤드가 있을 수 있음 프로덕션 상시 활성화는 지양, 재현 가능한 환경에서 일시적으로 활성화 권장 초기화 코드 이슈 추적은 \u0026ndash;inspect-brk가 더 안정적 디버깅 세션 중 프로세스가 재시작되면 연결이 끊기므로 재연결 필요 정리 Node.js의 디버깅은 v8-inspector를 중심으로 표준화되었음 \u0026ndash;inspect 또는 \u0026ndash;inspect-brk로 프로세스를 띄우고, 크롬 개발자도구나 node-inspect 중 선호 도구로 연결해 브레이크포인트와 스텝 실행, REPL까지 한 흐름으로 해결 가능함 개발 단계에서 빠르게 재현하고 추적하는 기본 루틴으로 정착시키면 콘솔 로그만으로 놓치는 분기와 타이밍 이슈를 줄일 수 있음\n참고자료 Node.js v8.0.0 Release Debugging Node.js Apps with the Inspector Node.js Debugger API node-inspect Repository Express 참고자료 https://nodejs.org/en/blog/release/v8.0.0/ https://nodejs.org/en/docs/inspector/ https://nodejs.org/api/debugger.html https://github.com/nodejs/node-inspect https://expressjs.com/ ","permalink":"https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNode.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음\nNode.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 \u0026ndash;debug는 폐기, \u0026ndash;inspect로 통일됨\nCLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함\u003c/p\u003e\n\u003cp\u003e이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ev8-inspector 프로토콜\n\u003cul\u003e\n\u003cli\u003eV8이 노출하는 디버깅 프로토콜\u003c/li\u003e\n\u003cli\u003eNode 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect vs \u0026ndash;inspect-brk\n\u003cul\u003e\n\u003cli\u003e\u0026ndash;inspect는 바로 실행하면서 디버거 접속 대기\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e포트\n\u003cul\u003e\n\u003cli\u003e기본 포트 9229 사용\u003c/li\u003e\n\u003cli\u003e\u0026ndash;inspect=PORT, \u0026ndash;inspect-brk=PORT 형태로 변경 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e프론트엔드\n\u003cul\u003e\n\u003cli\u003eChromium 기반 개발자도구로 연결 가능\u003c/li\u003e\n\u003cli\u003echrome://inspect 에서 Node 대상 탐색 및 연결\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003enode-inspect\n\u003cul\u003e\n\u003cli\u003eNode 내장 CLI 디버거\u003c/li\u003e\n\u003cli\u003e동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"크롬-개발자도구로-디버깅\"\u003e크롬 개발자도구로 디버깅\u003c/h3\u003e\n\u003cp\u003eExpress 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정\u003c/p\u003e","title":"Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법"},{"content":"컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음 조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함\n개념과 정의 컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층 사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴\n핵심 구성요소 API 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영\nkubectl, 컨트롤러, 스케줄러 등 모든 클라이언트는 API 서버를 통해 상호작용\n예시\nkubectl get pods kubectl apply -f app.yaml etcd — 클러스터 상태를 저장하는 분산 키-값 저장소\n네임스페이스, 파드, 서비스, 컨피그맵 등 모든 리소스 스펙과 상태 저장 강한 일관성 기반으로 컨트롤 루프의 신뢰성에 핵심 역할 스케줄러 kube-scheduler — 새 파드를 어떤 노드에 배치할지 결정\n리소스 여유, 어피니티/안티어피니티, 톨러레이션, 노드 셀렉터 등을 고려해 최적 노드 선택 프리엠션과 스코어링으로 공정성과 효율성 균형 유지 컨트롤러 매니저 kube-controller-manager — 다양한 컨트롤러의 조정 루프 실행\n레플리카셋, 잡, 데몬셋, 노드, 엔드포인트 등 컨트롤러가 선언된 상태에 맞게 생성·삭제·수정 수행 핵심은 지속적 리컨실리에이션으로 상태 수렴 보장 동작 개요 사용자가 Desired State를 API로 제출 etcd에 영속화 스케줄러가 파드 배치 결정 컨트롤러들이 실제 상태를 감시하고 조정 워커 노드의 kubelet이 파드 실행과 헬스 리포팅 수행 이 흐름이 반복되며 장애나 변동에도 선언된 상태로 복귀하는 자기치유 성질을 구현함 EKS와 일반 k8s 차이 관리 관점\n일반 k8s — 컨트롤 플레인 노드 설치, etcd 운영과 백업 전략, 버전 업그레이드 플랜, 보안 패치, 모니터링, 다중 AZ 기반 HA를 직접 설계·운영해야 함 EKS — 컨트롤 플레인은 완전관리형으로 제공, 마스터 노드와 etcd는 사용자가 접근·관리하지 않음, 내부적으로 백업·복구와 패치·HA가 관리됨, 제어플레인 로그를 CloudWatch로 전송 가능 비용 구조\n일반 k8s — 컨트롤 플레인 인프라 비용, 운영 인력 비용, 백업 스토리지와 모니터링 도구 비용을 직접 산정 EKS — 클러스터당 제어플레인 사용료가 시간 단위 과금, 워커 노드는 EC2 등 사용량 기반, EBS·ELB 등 연동 리소스는 각각 과금 통합 기능\n일반 k8s — 로드밸런서 연동, 스토리지 프로비저닝, 인증·인가, 로깅/모니터링을 별도 구성 필요 EKS — AWS Load Balancer Controller로 ALB/NLB 연동, EBS/EFS CSI 드라이버 통합, IAM Roles for Service Accounts IRSA로 퍼미션 연계, Control Plane 로깅과 메트릭의 CloudWatch 통합 용이 네트워킹\n일반 k8s — CNI 선택·설치, 네트워크 정책 구현, 인그레스 컨트롤러 구성 필요 EKS — AWS VPC CNI 기본 제공으로 VPC 네이티브 IP 모델, Security Groups for Pods로 L3/L4 격리 가능, 표준 Kubernetes NetworkPolicy는 별도 구현체 필요 Calico 등, 인그레스는 AWS Load Balancer Controller 사용 권장 실제 사용 예시 클러스터 생성\n일반 k8s — 컨트롤 플레인 노드 준비, kubeadm init, etcd 구성, CNI 설치, 인증서와 RBAC 설정, HA면 컨트롤 플레인 복수 AZ 배치와 프런트 VIP 구성 필요\nEKS — 명령 몇 줄로 제어플레인과 매니지드 노드그룹 생성 가능\neksctl create cluster \\ --name my-cluster \\ --region ap-northeast-2 \\ --nodes 2 업그레이드\n일반 k8s — 사전 etcd 스냅샷, 컨트롤 플레인 컴포넌트 순차 업그레이드, kubelet 및 CNI 애드온 호환성 검증, 워커 노드 롤링 업데이트가 필요\nEKS — 컨트롤 플레인 버전을 먼저 올리고 노드그룹을 순차 업그레이드, 콘솔이나 eksctl로 진행 가능\neksctl upgrade cluster \\ --name my-cluster \\ --version 1.24 주의와 베스트 프랙티스 컨트롤 플레인 가용성 — 일반 k8s는 etcd 쿼럼과 컨트롤 플레인 노드 다중화가 핵심, EKS는 다중 AZ가 기본이지만 리전 장애 시 DR 전략 별도 고려 권장 업그레이드 — 마이너 버전 스큐 정책과 애드온 호환성 체크, 사전 테스트 클러스터에서 리허설 권장 보안 — EKS는 IRSA로 최소권한 부여, 일반 k8s는 OIDC 연계와 RBAC 최소화 적용, API 서버 접근 경계 명확화 네트워크 정책 — EKS에서 SG for Pods와 NetworkPolicy는 모델이 다름, 필요한 레이어에 맞게 병행 설계 권장 관측성 — 컨트롤 플레인 로그와 감사 로그 활성화, 메트릭 기반으로 컨트롤러 지연과 스케줄링 실패 감시 마무리 컨트롤 플레인은 선언된 상태를 기준으로 클러스터를 지속적으로 수렴시키는 조정자 역할을 수행함 일반 k8s는 높은 설계 자유도와 통제가 장점이나 운영 복잡도가 큼, EKS는 운영 부담을 크게 줄이는 대신 서비스 종속성과 과금 구조를 함께 고려해야 함 워크로드 특성과 팀의 운영 성숙도에 맞춰 관리형과 자가 운영형 중 합리적 선택 필요\n참고자료 https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/controller/ https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html https://aws.amazon.com/eks/pricing/ https://docs.aws.amazon.com/eks/latest/userguide/pod-security-groups.html https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.6/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-control-plane-eks-2af164/","summary":"\u003cp\u003e컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음\n조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함\u003c/p\u003e\n\u003ch3 id=\"개념과-정의\"\u003e개념과 정의\u003c/h3\u003e\n\u003cp\u003e컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층\n사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴\u003c/p\u003e\n\u003ch3 id=\"핵심-구성요소\"\u003e핵심 구성요소\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAPI 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영\u003c/p\u003e","title":"쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교"},{"content":"개요 가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리 컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명\n가드란 NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소 미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점 요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨 canActivate가 true 또는 Promise을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생\n프로젝트 준비 Nest CLI로 샘플 프로젝트 생성\n$ nest new our-nestjs패키지 매니저 선택 후 기본 템플릿 생성됨\n가드로 요청 전달 CanActivate 인터페이스 구현으로 가드 정의\nimport { Injectable, CanActivate } from \u0026#34;@nestjs/common\u0026#34;; @Injectable() export class AuthGuard implements CanActivate { canActivate() { return true; } }canActivate가 true를 반환하므로 요청은 컨트롤러로 전달됨\n컨트롤러에 가드 적용 UseGuards 데코레이터로 클래스 또는 메서드 단위 적용 가능\nimport { Controller, Get, UseGuards } from \u0026#34;@nestjs/common\u0026#34;; @UseGuards(AuthGuard) @Controller() export class AppController { @Get() getHello() { return \u0026#34;Hello World!\u0026#34;; } }curl로 확인\n$ curl http://localhost:3000 Hello World!가드로 요청 차단 반대로 false를 반환하면 요청은 차단되고 403 Forbidden 응답\n@Injectable() export class AuthGuard implements CanActivate { canActivate() { return false; } }$ curl http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Forbidden resource\u0026#34;,\u0026#34;error\u0026#34;:\u0026#34;Forbidden\u0026#34;,\u0026#34;statusCode\u0026#34;:403}가드로 인증 구현 ExecutionContext로 HTTP 요청 객체에 접근해 헤더 등 입력값 검사 가능 Bearer 토큰을 단순 검증하는 예시\nimport { CanActivate, ExecutionContext, BadRequestException, Injectable, } from \u0026#34;@nestjs/common\u0026#34;; @Injectable() export class AuthGuard implements CanActivate { canActivate(context: ExecutionContext) { const req = context.switchToHttp().getRequest(); const auth = req.headers[\u0026#34;authorization\u0026#34;] as string | undefined; if (!auth) throw new BadRequestException(); const [scheme, token] = auth.split(\u0026#34; \u0026#34;); return scheme?.toLowerCase() === \u0026#34;bearer\u0026#34; \u0026amp;\u0026amp; token === \u0026#34;1234\u0026#34;; } }의미\nAuthorization 헤더가 없으면 BadRequestException 발생해 400 응답 Bearer 스킴이며 토큰이 1234일 때만 통과 실서비스에서는 다음 중 하나 이상 필요\n토큰으로 사용자 조회 또는 권한 검증 서드파티 인증 서버 연동 또는 캐시 검증 JWT 디코딩 및 서명 검증 인증 가드 테스트 잘못된 토큰이면 403\n$ curl -H \u0026#34;Authorization: Bearer 1111\u0026#34; http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Forbidden resource\u0026#34;,\u0026#34;error\u0026#34;:\u0026#34;Forbidden\u0026#34;,\u0026#34;statusCode\u0026#34;:403}올바른 토큰이면 성공\n$ curl -H \u0026#34;Authorization: Bearer 1234\u0026#34; http://localhost:3000 Hello World!헤더가 없으면 400\n$ curl http://localhost:3000 {\u0026#34;message\u0026#34;:\u0026#34;Bad Request\u0026#34;,\u0026#34;statusCode\u0026#34;:400}주의와 베스트 프랙티스 가드는 인증·인가 같은 접근 제어에 집중, 복잡한 비즈니스 로직은 서비스로 위임 공통 검증은 글로벌 가드로 등록해 중복 제거 반환형은 boolean 또는 Promise 사용, 명시적 예외는 Exception 클래스로 던짐 로깅은 콘솔 대신 프레임워크 로거 사용 권장 세분화된 역할 검증은 메타데이터와 커스텀 데코레이터 조합으로 역할 기반 가드 구성 권장 마무리 Guard는 컨트롤러 앞단에서 요청을 선별하는 확실한 진입점 제공 간단한 구현만으로도 인증과 접근 제어의 기본선을 세울 수 있음 실서비스에서는 토큰 검증, 캐시, 외부 인증 연동을 조합해 성능과 보안의 균형을 맞출 것\n참고자료 https://docs.nestjs.com/guards https://docs.nestjs.com/fundamentals/execution-context https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization https://curl.se/docs/manpage.html ","permalink":"https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리\n컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명\u003c/p\u003e\n\u003ch3 id=\"가드란\"\u003e가드란\u003c/h3\u003e\n\u003cp\u003eNestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소\n미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점\n요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨\ncanActivate가 true 또는 Promise\u003c!-- raw HTML omitted --\u003e을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생\u003c/p\u003e","title":"NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시"},{"content":"개요 쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템 핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프 각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능\n구성요소 관계 한눈에 kubectl / CI │ ▼ kube-apiserver ──\u0026gt; etcd │ ▲ │ └(상태 영속) │ ├─ kube-scheduler(어디 배치할지 결정) └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등) [각 워커 노드] kubelet ──(CRI gRPC)──\u0026gt; container runtime ──(OCI)──\u0026gt; runc/crun ──\u0026gt; cgroup 설정 + 컨테이너 시작 │ │ ├─(CNI 호출) 네트워크/IP 할당 └─ 네임스페이스/마운트 등 격리 └─ kube-proxy(서비스 라우팅: iptables/ipvs) 모든 컴포넌트의 권위자이자 입구는 apiserver etcd와 직접 통신하는 주체는 apiserver만 존재 kubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지 container runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행 Pod 생성에서 Running까지 사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화 controller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등 scheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩 대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지 kubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당 kubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달 runtime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행 kubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고 kube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립 클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료 cgroup과 리소스 제한 연결 PodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정 CPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여 메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제 쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심 장애·스케일·자체 복구 흐름 컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행 노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택 HPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소 용어 핵심 정리 control plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소 worker node 파드를 실제로 실행하는 머신 풀 kubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당 container runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수 cgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정 마무리 apiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당\n참고자료 https://kubernetes.io/docs/concepts/overview/components/ https://kubernetes.io/docs/concepts/architecture/ https://kubernetes.io/docs/concepts/architecture/cri/ https://kubernetes.io/docs/concepts/workloads/pods/ https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/ https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html https://kubernetes.io/docs/concepts/services-networking/ ","permalink":"https://blog.jsontapose.com/posts/kubernetes-core-components-and-flow-915d3a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템\n핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프\n각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능\u003c/p\u003e\n\u003ch3 id=\"구성요소-관계-한눈에\"\u003e구성요소 관계 한눈에\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekubectl / CI\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ▼\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekube-apiserver ──\u0026gt; etcd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │  ▲\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │  └(상태 영속)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ├─ kube-scheduler(어디 배치할지 결정)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[각 워커 노드]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekubelet ──(CRI gRPC)──\u0026gt; container runtime ──(OCI)──\u0026gt; runc/crun ──\u0026gt; cgroup 설정 + 컨테이너 시작\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    │                                        │\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ├─(CNI 호출) 네트워크/IP 할당            └─ 네임스페이스/마운트 등 격리\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    └─ kube-proxy(서비스 라우팅: iptables/ipvs)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e모든 컴포넌트의 권위자이자 입구는 apiserver\u003c/li\u003e\n\u003cli\u003eetcd와 직접 통신하는 주체는 apiserver만 존재\u003c/li\u003e\n\u003cli\u003ekubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지\u003c/li\u003e\n\u003cli\u003econtainer runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pod-생성에서-running까지\"\u003ePod 생성에서 Running까지\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화\u003c/li\u003e\n\u003cli\u003econtroller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등\u003c/li\u003e\n\u003cli\u003escheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩\u003c/li\u003e\n\u003cli\u003e대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지\u003c/li\u003e\n\u003cli\u003ekubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당\u003c/li\u003e\n\u003cli\u003ekubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달\u003c/li\u003e\n\u003cli\u003eruntime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행\u003c/li\u003e\n\u003cli\u003ekubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고\u003c/li\u003e\n\u003cli\u003ekube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립\u003c/li\u003e\n\u003cli\u003e클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"cgroup과-리소스-제한-연결\"\u003ecgroup과 리소스 제한 연결\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정\u003c/li\u003e\n\u003cli\u003eCPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여\u003c/li\u003e\n\u003cli\u003e메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제\u003c/li\u003e\n\u003cli\u003e쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"장애스케일자체-복구-흐름\"\u003e장애·스케일·자체 복구 흐름\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행\u003c/li\u003e\n\u003cli\u003e노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택\u003c/li\u003e\n\u003cli\u003eHPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"용어-핵심-정리\"\u003e용어 핵심 정리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003econtrol plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소\u003c/li\u003e\n\u003cli\u003eworker node 파드를 실제로 실행하는 머신 풀\u003c/li\u003e\n\u003cli\u003ekubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당\u003c/li\u003e\n\u003cli\u003econtainer runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수\u003c/li\u003e\n\u003cli\u003ecgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eapiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당\u003c/p\u003e","title":"Kubernetes 핵심 구성요소와 동작 흐름"},{"content":"개요 EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구 병목 파악과 인덱스 전략 점검에 사용\n핵심 개념 select_type SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음 PRIMARY 가장 바깥쪽 SELECT SUBQUERY 서브쿼리 DERIVED FROM 절의 서브쿼리 UNION UNION의 두 번째 이후 SELECT type 실행 품질 지표, 위에서 아래로 유리 system 테이블에 단 하나의 행 const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회 eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭 ref 인덱스를 사용한 동등 조건 검색 range 인덱스를 사용한 범위 검색 index 인덱스 전체 스캔 ALL 테이블 전체 스캔, 최악 possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음 key 실제 사용된 인덱스, NULL이면 인덱스 미사용 rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리 filtered 조건 후 남는 행 비율 추정치, 높을수록 유리 Extra 추가 단서 Using index 커버링 인덱스 사용, 유리 Using where WHERE 조건으로 필터링 수행 Using filesort 추가 정렬 필요, 비용 큼 Using temporary 임시 테이블 사용, 비용 큼 해석 기준 type이 const, ref, range 범주에 위치 key가 NULL이 아니고 적절한 인덱스 선택 rows 추정치가 작고 filtered 비율이 높음 Extra에 Using filesort, Using temporary 부재 예시와 해석 type: ALL possible_keys: NULL rows: 3527425 Extra: Using where; Using filesort 테이블 전체 스캔으로 많은 행을 읽게 됨 인덱스 후보와 실제 사용 인덱스가 없음 WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승 현재 계획은 인덱스 설계와 조건식 재검토 필요 주의와 팁 rows와 filtered는 통계 기반 추정치라 실제와 오차 가능 filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용 Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음 인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려 커버링 인덱스 구성 시 Extra의 Using index로 확인 가능 마무리 EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기 위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장\n참고자료 https://dev.mysql.com/doc/refman/8.0/en/explain.html https://dev.mysql.com/doc/refman/8.0/en/explain-output.html ","permalink":"https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eEXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구\n병목 파악과 인덱스 전략 점검에 사용\u003c/p\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eselect_type\n\u003cul\u003e\n\u003cli\u003eSIMPLE 단순 SELECT, 서브쿼리나 UNION 없음\u003c/li\u003e\n\u003cli\u003ePRIMARY 가장 바깥쪽 SELECT\u003c/li\u003e\n\u003cli\u003eSUBQUERY 서브쿼리\u003c/li\u003e\n\u003cli\u003eDERIVED FROM 절의 서브쿼리\u003c/li\u003e\n\u003cli\u003eUNION UNION의 두 번째 이후 SELECT\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003etype 실행 품질 지표, 위에서 아래로 유리\n\u003cul\u003e\n\u003cli\u003esystem 테이블에 단 하나의 행\u003c/li\u003e\n\u003cli\u003econst PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회\u003c/li\u003e\n\u003cli\u003eeq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭\u003c/li\u003e\n\u003cli\u003eref 인덱스를 사용한 동등 조건 검색\u003c/li\u003e\n\u003cli\u003erange 인덱스를 사용한 범위 검색\u003c/li\u003e\n\u003cli\u003eindex 인덱스 전체 스캔\u003c/li\u003e\n\u003cli\u003eALL 테이블 전체 스캔, 최악\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003epossible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음\u003c/li\u003e\n\u003cli\u003ekey 실제 사용된 인덱스, NULL이면 인덱스 미사용\u003c/li\u003e\n\u003cli\u003erows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리\u003c/li\u003e\n\u003cli\u003efiltered 조건 후 남는 행 비율 추정치, 높을수록 유리\u003c/li\u003e\n\u003cli\u003eExtra 추가 단서\n\u003cul\u003e\n\u003cli\u003eUsing index 커버링 인덱스 사용, 유리\u003c/li\u003e\n\u003cli\u003eUsing where WHERE 조건으로 필터링 수행\u003c/li\u003e\n\u003cli\u003eUsing filesort 추가 정렬 필요, 비용 큼\u003c/li\u003e\n\u003cli\u003eUsing temporary 임시 테이블 사용, 비용 큼\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"해석-기준\"\u003e해석 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003etype이 const, ref, range 범주에 위치\u003c/li\u003e\n\u003cli\u003ekey가 NULL이 아니고 적절한 인덱스 선택\u003c/li\u003e\n\u003cli\u003erows 추정치가 작고 filtered 비율이 높음\u003c/li\u003e\n\u003cli\u003eExtra에 Using filesort, Using temporary 부재\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"예시와-해석\"\u003e예시와 해석\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etype: ALL\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epossible_keys: NULL\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erows: 3527425\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExtra: Using where; Using filesort\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e테이블 전체 스캔으로 많은 행을 읽게 됨\u003c/li\u003e\n\u003cli\u003e인덱스 후보와 실제 사용 인덱스가 없음\u003c/li\u003e\n\u003cli\u003eWHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승\u003c/li\u003e\n\u003cli\u003e현재 계획은 인덱스 설계와 조건식 재검토 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"주의와-팁\"\u003e주의와 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003erows와 filtered는 통계 기반 추정치라 실제와 오차 가능\u003c/li\u003e\n\u003cli\u003efiltered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용\u003c/li\u003e\n\u003cli\u003eUsing filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음\u003c/li\u003e\n\u003cli\u003e인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려\u003c/li\u003e\n\u003cli\u003e커버링 인덱스 구성 시 Extra의 Using index로 확인 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003c/h3\u003e\n\u003cp\u003eEXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기\n위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장\u003c/p\u003e","title":"MySQL EXPLAIN 실행 계획 해석 가이드"},{"content":"블록체인 인덱서 가이드 인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임 디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\n왜 인덱서가 필요한가 블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼 디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함 전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임 핵심 개념 인덱싱 대상 데이터 유형 블록 헤더와 트랜잭션 메타데이터\n블록번호, 타임스탬프, 가스 사용량, 트랜잭션 해시 등 스마트 컨트랙트 이벤트 로그\n토픽과 데이터 필드, 인덱스드 파라미터, 로그 인덱스 등 컨트랙트 상태 스냅샷 또는 파생 지표\n잔액 스냅샷, 포지션 지표, 시계열 집계 등 용어 정리 서브그래프\n특정 도메인을 위한 스키마형 인덱싱 단위 최종성 Finality\n블록이 되돌려지지 않을 확률이 충분히 낮은 상태를 의미함 재구성 Reorg\n더 긴 체인이 나타나 일부 블록이 교체되는 현상으로 인덱서가 롤백과 재처리를 수행해야 함 백필 Backfill\n과거 블록 범위를 대량으로 인덱싱하는 작업이며 라이브 스트림과 병행 운영 필요함 아키텍처 구성 요소 수집기 Ingestor\n풀노드 또는 게이트웨이에 구독 혹은 폴링으로 연결해 새 블록과 트랜잭션, 로그 수신 블록 범위 큐와 재시도, 속도 제한 제어 포함 권장 파서 Parser\nABI 기반 디코딩으로 이벤트와 함수 호출 입력을 구조화함 주소, 체인ID, 블록번호, 트랜잭션 해시를 기본 정규화 키로 포함 인덱서 Indexer\n예상 질의 패턴에 맞춘 보조 인덱스와 머티리얼라이즈드 뷰 생성 멱등 처리로 중복 입력에 안전해야 함 저장소 Storage\n관계형 SQL, 문서형, 키밸류, 시계열 중 워크로드에 맞게 혼합 선택 쓰기 집중 구간과 읽기 집중 구간을 분리 설계 권장 서비스 API\nGraphQL 또는 REST 제공 캐시, 커서 기반 페이지네이션, 레이트 리밋, 다중 리전 배포 포함 권장 동작 원리 1) 데이터 수집 최신 블록 스트림 수신 토픽 기반 필터로 관심 이벤트만 선별 가능 블록 범위 작업 단위를 설정해 재시도와 병렬 처리 제어 2) 정리와 저장 ABI로 이벤트 파싱 후 표준 스키마로 정규화\n파티셔닝 키 설계 예시\n주소별 파티션, 컨트랙트별 파티션, 체인ID별 샤딩 스토리지 선택 가이드\nSQL은 조인과 강한 정합성 강점 NoSQL은 쓰기 성능과 수평 확장 강점 혼합 접근으로 원본 로그 테이블과 조회 최적화 테이블을 분리 3) 제공과 캐싱 핫 키에 인메모리 캐시와 세그먼트 캐시 적용 커서 기반 페이지네이션으로 대량 스캔 방지 지표성 데이터는 사전 집계 테이블이나 머티리얼라이즈드 뷰 사용 4) 최종성과 재처리 N 컨펌 이후 확정 마킹으로 Reorg 영향 최소화 Reorg 발생 시 영향 범위만 역인덱스 삭제 후 재인덱싱 백필 잡과 라이브 스트림의 경계 관리로 중복 작업 방지 데이터 모델과 스키마 예시 원본 이벤트 로그 테이블 예시 CREATE TABLE ev_raw ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, log_index INT NOT NULL, topic0 VARBINARY(32) NOT NULL, topic1 VARBINARY(32) NULL, topic2 VARBINARY(32) NULL, topic3 VARBINARY(32) NULL, data BLOB NOT NULL, PRIMARY KEY (chain_id, block_number, tx_hash, log_index) )조회 최적화 테이블 예시 CREATE TABLE nft_transfers ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, token_id DECIMAL(78,0) NOT NULL, from_address VARBINARY(20) NOT NULL, to_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, PRIMARY KEY (chain_id, contract_address, token_id, block_number, tx_hash), INDEX idx_owner_history (chain_id, to_address, block_number DESC) )GraphQL 질의 예시 query { transfers(first: 10, where: { from: \u0026#34;0xaaaa...\u0026#34;, to: null }) { id from to value blockNumber txHash } }핵심은 애플리케이션이 자주 묻는 질문을 스키마와 인덱스로 선제 정의하는 것임 원장 재탐색 없이 즉시 응답 가능한 형태로 데이터를 재구성하는 것이 목표임\n일관성 모델 확정 상태와 미확정 상태를 명시 구분\n응답 필드에 finality_level 또는 confirmations 포함 권장 API 파라미터로 최종성 레벨 허용\n예시로 minConfirmations=12 전달 시 해당 기준 충족 데이터만 반환 읽기 스냅샷 일관성 유지로 동일 요청 내 시간축 안정성 보장\n재처리와 멱등성 블록 범위 단위의 재인덱싱이 가능하도록 범위 메타 유지\n멱등 키 설계\n(chain_id, tx_hash, log_index) 또는 이벤트 고유 해시로 중복 삽입 방지 업서트 기반 로딩으로 재처리 안전성 확보\nINSERT INTO nft_transfers (...) VALUES (...) ON DUPLICATE KEY UPDATE block_time = VALUES(block_time) 성능과 비용 최적화 백필은 대역폭 우선, 라이브는 지연 우선으로 튜닝 파티션 핫스팟 회피를 위해 주소 해싱 또는 범위 셔플링 적용 대규모 이벤트의 경우 배치 크기와 커밋 간격을 체계적으로 설정 스키마 버저닝을 통해 마이그레이션 시 이중 기록 전략 적용 권장 운영과 관측성 필수 지표\n블록 지연, 수집 지연, 처리 라그, 오류율, 재시도율, 큐 적체량 알람 기준\n라그 급증, Reorg 빈도 증가, 특정 컨트랙트 오류 급증 롤백과 재시작\n저장소에 체크포인트와 커밋 오프셋 기록으로 안전 복구 가능하게 설계 보안과 무결성 데이터 출처 이중화와 교차 검증 적용\n서로 다른 노드나 공급자에서 샘플 검증 수행 권장 서명 검증 가능한 데이터는 파이프라인 내 즉시 검증\n민감 메타데이터는 암호화 저장과 접근 통제 적용\n주요 플랫폼 비교 요약 The Graph\nGraphQL 기반 서브그래프 모델과 커스텀 스키마, 매핑 지원 이벤트 중심 도메인 모델링이 단순함 Covalent\n멀티체인 통합 API와 공통 스키마 제공 빠른 프로토타이핑과 대시보드 연동 용이 QuickNode\n노드와 인덱싱 API 조합으로 고성능 엔드포인트 제공 Moralis\n멀티체인 디앱 백엔드 도구로 지갑과 NFT 중심 인덱싱 제공 자체 구축\n유연성과 데이터 소유권 강점 운영 복잡성과 비용 증가 단점 존재 대표 사용 사례 지갑 화면에서 주소 기준 트랜잭션과 토큰 잔액 즉시 조회 디파이 포지션 수익률과 담보 상태를 실시간 계산 NFT 소유 목록, 전송 이력, 메타데이터 동기화 제공 온체인 데이터 기반 분석과 알림 트리거 생성 베스트 프랙티스 체크리스트 스키마 설계 상위 핵심 질의 세 가지를 먼저 정하고 파티셔닝과 보조 인덱스를 결정 원본 로그 테이블과 조회 최적화 테이블을 분리 운영 시간 기반 파티셔닝과 주소 기반 인덱스를 함께 고려 재처리 전략 블록 범위 메타를 보관해 부분 재인덱싱 가능하게 유지 멱등 키와 업서트로 중복 삽입 방지 일관성과 최종성 확정과 미확정 데이터를 응답에서 구분 API에 최종성 파라미터 제공 성능과 비용 백필 파이프라인은 대역폭과 병렬성 극대화 라이브 스트림은 지연과 안정성 최적화 핫 파티션 회피를 위한 해싱 또는 샤딩 적용 운영과 관측성 라그와 오류 지표를 1급 시민으로 모니터링 스키마 버저닝과 롤백 계획을 문서화 보안과 무결성 공급자 이중화와 교차검증 구성 서명 검증 가능한 지표는 수집 단계에서 검증 안티 패턴 WHERE 절에 함수 연산을 남발해 인덱스를 무력화하는 패턴 원본 로그 테이블 하나로만 모든 질의를 처리하려는 단일 스키마 고집 Reorg 가정 부재로 롤백 경로가 없는 파이프라인 커서 대신 페이지 오프셋을 사용해 심각한 스캔을 유발하는 페이지네이션 간단 레퍼런스 이더리움 JSON-RPC eth_getLogs로 토픽 필터링 수집 가능 Solidity 이벤트는 ABI로 디코딩해 구조화 가능 GraphQL은 선택적 필드 조회와 관계 탐색에 유리함 query WalletView($owner: String!, $first: Int!, $cursor: String) { erc20Balances(owner: $owner, first: $first, after: $cursor) { edges { node { contract symbol decimals balance updatedAt } cursor } pageInfo { hasNextPage endCursor } } } 마무리 인덱서는 제품이 자주 묻는 질문을 데이터 구조로 먼저 표현하는 도구임 초기 단계에서 질의 패턴과 최종성 전략을 분명히 하고 재처리, 관측성, 비용의 트레이드오프를 문서화할 것 관리형 서비스와 자체 구축을 혼합해 민첩성과 통제력을 균형 있게 가져갈 것 참고자료 https://thegraph.com/docs/en/ https://www.covalenthq.com/docs/ https://www.quicknode.com/docs https://docs.moralis.io/ https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs https://docs.soliditylang.org/en/latest/contracts.html#events ","permalink":"https://blog.jsontapose.com/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/","summary":"\u003ch1 id=\"블록체인-인덱서-가이드\"\u003e블록체인 인덱서 가이드\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임\n디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"왜-인덱서가-필요한가\"\u003e왜 인덱서가 필요한가\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼\u003c/li\u003e\n\u003cli\u003e디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함\u003c/li\u003e\n\u003cli\u003e전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-개념\"\u003e핵심 개념\u003c/h2\u003e\n\u003ch3 id=\"인덱싱-대상-데이터-유형\"\u003e인덱싱 대상 데이터 유형\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e블록 헤더와 트랜잭션 메타데이터\u003c/p\u003e","title":"블록체인 인덱서 가이드"},{"content":"개요 퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함 이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름 합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함 PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임 실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\n합의가 필요한 이유와 기준 안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음 활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨 최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨 시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요 성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건 탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요 PoW 작업증명 핵심 정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조 구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요 난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행 보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미 장점\n단순한 검증 경량 노드도 헤더 체인과 작업 증명만으로 유효성 확인 가능 시빌 내성 경제적 비용이 명확하며 물리 자원 기반 보안 단점 에너지 비용 과다 전력과 하드웨어 비용이 지속적으로 소모됨 처리 지연 블록 간격 확대와 오프라인 확률로 인해 확률적 최종성에 의존함 여러 컨펌 대기가 필요 중앙화 유인 대규모 채굴 인프라와 풀 집중 경향 존재 운영 팁 블록 간격과 크기 설정은 고아 블록 비율을 고려해 네트워크 전파 지연을 상회하도록 보수적으로 설정 난이도 조정 주기는 급격한 난이도 스윙을 줄이도록 이동 평균이나 클리핑 적용 수수료 시장 안정화를 위해 기본 수수료 규칙과 대역폭 관리 병행 PoS 지분증명 핵심 정의 토큰 지분을 예치한 검증자가 블록 제안 및 투표 권한을 획득하는 방식 에너지 소모를 낮추고 결정적 최종성 또는 짧은 확률적 최종성을 지향 선정 방식 난수 또는 가중 무작위 선택 VRF 위원회 선출 라운드별 리더 로테이션 등 다양함 안전 장치 슬래싱 이중 제안 또는 상충 투표에 대해 지분 일부 소각해 부정 행위 억제 체크포인트와 파이널라이저로 최종성 확보 대표적 이슈\n아무 것도 걸지 않기 문제 포크마다 비용 없이 투표 가능 설계 시 슬래싱과 보상 구조로 해결 롱레인지 공격 오래된 키로 과거부터 새로운 체인을 위조 가능 약한 주관성 체크포인트 동기화와 키 회수 정책으로 대응 지분 집중 대량 보유의 복리 효과로 중앙화 경향 완화 위해 보상 곡선과 위임 구조 설계 필요 장점 저전력 고효율 일반 하드웨어로 검증 가능해 참여 문턱 완화 빠른 확정 위원회 기반 투표와 파이널리티 가젯으로 블록 확정 지연 축소 단점 프로토콜 복잡도 증가 상태 관리 키 보안 슬래싱 운영 리스크 존재 경제 보안은 토큰 가치에 의존 가격 급락 시 보안 예산 저하 가능 운영 팁 검증자 키 관리 분리 서명 키와 위임 키 분리하고 온라인 노출 최소화 모니터링 필수 가용성 저하와 네트워크 분할 시 슬래싱 위험에 대비해 자동 장애 조치와 경보 체계 구축 업그레이드 경로 사전 예고와 버전 롤링 전략으로 네트워크 분리 리스크 완화 영지식증명 기본 개념 요약 목적 특정 명제가 참임을 비밀 자체를 드러내지 않고 증명 핵심 성질 세 가지\n완전성 증명자가 정당하면 검증자는 수용 건전성 증명자가 거짓이면 들킴 확률이 무시 가능 수준으로 낮음 영지식성 검증 과정에서 비밀에 대한 추가 정보 누설 없음 직관적 비유 알리바바 동굴 이야기 증명자는 비밀번호를 알려주지 않지만 검증자가 무작위로 요구한 출구를 반복해서 만족시킴으로써 지식을 입증함 반복 횟수를 늘릴수록 속임수 성공 확률이 기하급수적으로 줄어듦 zk-SNARK와 zk-STARK 한눈에 정리 zk-SNARK 짧은 증명 크기와 빠른 검증 장점 신뢰 설정이 필요한 설계가 일반적이며 곡선 쌍선형 연산 의존 zk-STARK 신뢰 설정 불필요 투명성 확보 해시 중심 구성 대규모 산술화에 강점 단 증명 크기가 다소 큼 검증도 상수항이 큰 편 최근 동향 순환 증명과 집계 증명으로 대량 트랜잭션을 하나의 짧은 증명으로 압축하는 기술 발전 중 블록체인에서 영지식증명이 유용한 지점 프라이버시 보호 거래 금액과 주소를 숨기면서도 보유액과 보존 법칙을 증명 가능 프라이버시 코인과 선택적 공개 기능에 활용 경량 검증과 확장성 체인 외부에서 상태 전이의 올바름을 증명하고 온체인에서는 짧은 증명만 검증 레이어2 유효성 롤업과 브리지에서 핵심 역할 탈중앙 신원 DID 자격증명 내용을 공개하지 않고 특정 속성 보유 여부를 증명 가능 최소 정보 공개 원칙 준수 합의 검증 비용 절감 블록 제안자가 트랜잭션 집합의 유효성에 대한 증명을 첨부하면 검증자의 부하 감소 가능 특히 대규모 검증 집합에서 효과적 PoW와 ZKP의 접점 경량 노드 강화 SPV 유사 모델을 한 단계 더 줄여 거래와 상태 전이를 영지식 증명으로 요약 검증 데이터 요구량 감소 데이터 가용성과의 분리 증명으로 계산의 정당성을 담보하고 실제 데이터는 샘플링 기반 가용성 검증으로 처리 조합 시 대역폭 부담 경감 현실 제약 PoW 체인에 직접 ZKP를 의무화하면 블록 생성 지연과 수수료 급등 가능 선택적 채택 또는 L2에서 사용 후 앵커링 전략이 실용적 PoS와 ZKP의 접점 빠른 최종성 보조 확정 투표와 함께 블록 유효성에 대한 유효성 증명을 첨부하면 재검증 비용 감소와 상태 동기화 속도 향상 기대 경계 조건 롱레인지 공격 방지 로직과 ZKP의 신뢰 설정 문제가 충돌하지 않도록 설계 필요 검증 키 관리와 프로빙 공격 대응 필수 레이어2 조합 PoS L1은 데이터 가용성과 보안에 집중 L2는 ZKP 기반 유효성 증명으로 대량 처리 규모 확장 구조가 주류로 이동 중 간단 예시 시나리오 전송자 A가 금액 x를 보유하고 있고 x의 일부 y를 B에게 보낸다는 명제를 산술 회로로 구성 A는 입력 금액과 잔액을 숨긴 채 보존 법칙과 서명 유효성 이중 지불 방지 조건을 모두 만족한다는 zk 증명을 생성 블록 제안자는 거래 본문이 아니라 증명과 최소한의 커밋먼트만 포함해 블록을 구성 검증자는 모든 트랜잭션을 재연산하지 않고 증명만 검증해 유효성 확인 네트워크 전체의 검증 비용과 데이터 노출이 줄어듦 주의 사항과 한계 PoW\n에너지 비용과 환경 부담 현실적 고려 필요 정책 변화와 전력 시장 리스크 반영 채굴 풀 집중 위험 수수료 변동성과 수익 불안정성으로 해시 파워 급변 가능 PoS 슬래싱 운영 리스크 네트워크 분할 장애나 키 누출 시 손실 발생 가능 기계적 가용성과 이중 서명 방지 자동화 필수 지분 집중 완화 필요 보상 곡선 설계 위임 한도 분산 인센티브 도입 고려 ZKP 구현 난도 높음 회로 설계와 산술화 최적화에 고도의 전문성 요구 사소한 변경으로도 보안 성질이 깨질 수 있음 신뢰 설정 이슈 TTP를 요구하는 시스템은 설정 자료 유출에 대한 위협 모델을 명확화해야 함 멀티 파티 설정과 폐기 의식 같은 절차 필요 성능 비용 증명 생성 시간이 길고 메모리 사용량이 큼 온체인 검증 가스 비용과 트레이드오프 존재 규제와 프라이버시 충돌 익명성 기능은 규제 요구와 충돌 가능 선택적 공개와 감사 권한 설계 필요 설계와 운영 베스트 프랙티스 체크리스트 요구사항 정렬 최종성 목표 지연 허용치 처리량과 비용 한도를 수치로 정의 보안 예산 추적 PoW는 전력 단가와 장비 감가 PoS는 시가총액과 연간 인플레이션을 기반으로 경제 보안 측정 파라미터 거버넌스 난이도 조정 간격 파이널리티 임계치 슬래싱 파라미터를 온체인 거버넌스 또는 보호된 프로세스로 관리 롤백 규칙 사전 명시 경량 클라이언트 우선 누구나 검증 가능한 경량 노드 경로 제공 체크포인트와 ZKP 기반 동기화 옵션 검토 키 보안 모델 검증자 키 다중화 하드웨어 보안 모듈 사용 원격 서명 분리 공용 백업 절차 문서화 ZKP 도입 전략 파일럿을 레이어2나 특정 자산 유형에 적용 증명 생성 파이프라인과 회로 버전 관리 자동 테스트 구축 관측 가능성 메트릭 합의 파라미터 슬래싱 이벤트 고아 블록율 파이널리티 지연을 지속 수집 경보 기준 수립 마무리 합의 알고리즘 선택은 기술 취향이 아니라 시스템 목표와 제약에 대한 정량적 타협의 산물임 PoW는 단순하고 강인하지만 에너지 비용과 지연의 대가가 큼 PoS는 고성능과 유연성을 제공하지만 프로토콜 복잡도와 운영 리스크를 동반함 영지식증명은 프라이버시와 검증 비용을 동시에 다루는 실용 도구로 자리잡는 중이며 신뢰 설정과 성능 한계에 대한 공학적 해결이 빠르게 진행되고 있음 현실적인 접근은 L1 합의는 보안을 우선하고 L2에서 ZKP로 확장성과 프라이버시를 확보하는 계층화 설계임 명확한 목표 지표 설정과 파라미터 거버넌스 자동화된 검증과 관측 가능성을 갖춘 운영이 장기적 안정성을 보장함\n참고자료 https://bitcoin.org/bitcoin.pdf https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ https://arxiv.org/abs/1710.09437 https://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf https://z.cash/technology/zksnarks/ https://zkproof.org https://vitalik.ca/general/2021/12/06/pos2021.html https://www.lgcns.com/blog/cns-tech/security/29926/ ","permalink":"https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함\n이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름\n합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함\nPoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임\n실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\u003c/p\u003e\n\u003ch3 id=\"합의가-필요한-이유와-기준\"\u003e합의가 필요한 이유와 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음\u003c/li\u003e\n\u003cli\u003e활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨\u003c/li\u003e\n\u003cli\u003e최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨\u003c/li\u003e\n\u003cli\u003e시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요\u003c/li\u003e\n\u003cli\u003e성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건\u003c/li\u003e\n\u003cli\u003e탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pow-작업증명-핵심\"\u003ePoW 작업증명 핵심\u003c/h3\u003e\n\u003cp\u003e정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조\n구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요\n난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행\n보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미\n장점\u003c/p\u003e","title":"블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용"},{"content":"개요 채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임 역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음 이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨 아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\n핵심 개념과 정의 블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부 트랜잭션 계정 상태를 변화시키는 요청 또는 메시지 채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체 작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙 난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할 넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값 메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합 블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합 왜 채굴이 필요한가 탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음 예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함 채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함 PoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\n생성 어렵게 만들면 공격자가 과거를 마음대로 재구성하기 어려워짐 검증 쉽게 만들면 모든 노드가 빠르게 유효성 확인이 가능함 동작 원리와 절차 PoW 기반 네트워크에서 채굴자가 블록을 만드는 일반 흐름은 다음과 같음\n사용자가 지갑으로 트랜잭션에 서명하고 네트워크에 브로드캐스트함 노드가 트랜잭션을 수신해 로컬 메모리풀에 적재함 채굴자가 메모리풀에서 수수료가 유리하고 유효한 트랜잭션을 선별해 임시 블록 후보를 구성함, 블록 가스 한도 내에서 수익 최대화 목표 각 트랜잭션의 서명과 잔고 및 논리적 제약을 검증하고, 로컬 가상머신에서 실행하여 상태 전이를 시뮬레이션함 블록 헤더에 포함될 머클 루트, 이전 블록 해시, 타임스탬프, 난이도, 넌스 등을 조립함 채굴기가 넌스를 바꿔가며 헤더 해시가 목표 난이도 기준 이하가 되도록 반복 계산함, 목표를 만족하면 유효한 작업증명 완료 채굴자는 찾은 증명과 함께 블록을 전파함, 함께 전파되는 상태 요약은 다른 노드가 결과를 빠르게 확인하도록 돕는 용도 다른 노드는 증명 검증 후 로컬 실행으로 상태를 재현해 일치 여부 확인함 다수 노드가 유효하다고 인정하면 해당 블록이 체인에 연결되고 이전 블록 위에 최종성 확률이 쌓이기 시작함 블록을 제안한 채굴자는 보상과 포함된 트랜잭션 수수료를 수령함 보상 구조와 인센티브 채굴 보상은 크게 두 부분으로 구성됨\n기본 보상 새 블록 생성 보상, 네트워크 규칙에 의해 일정 주기로 조정될 수 있음 수수료 보상 블록에 포함된 트랜잭션이 지불하는 수수료의 합계, 수요와 혼잡도에 따라 변동 역사적으로 이더리움 PoW에서는 기본 보상이 네트워크 업그레이드를 거치며 5 → 3 → 2 단위로 축소된 바 있음, 혼잡 시에는 수수료 비중이 커져 채굴자 수익에 큰 영향을 줌 PoW의 경제적 설계는 보상을 통해 정직한 참여를 유도하고, 높은 계산 비용을 통해 악의적 재작성 비용을 크게 만듦 증명 생성은 계산적으로 어렵지만 검증은 매우 쉬움, 따라서 네트워크 전체가 빠르게 합의 상태를 공유할 수 있음 비용 구조와 수익성 판단 채굴 수익성은 단순 보상 규모가 아니라 총비용 대비 순이익으로 판단함\n하드웨어 비용 GPU 또는 ASIC 장비, 보조 부품, 예비 부품, 감가상각 전력 비용 소비 전력과 단가, 지역별 전력 정책, 피크 요금 운영 비용 냉각과 환기, 먼지 및 습도 대응, 전기 배선과 안정화 장치, 모니터링 시스템, 공간 임대, 유지보수 인력 네트워크 난이도와 코인 가격, 수수료 시장, 장비 효율이 동적으로 상호작용하기 때문에 손익분기점은 수시로 변함 개별 상황 가정 후 계산기를 활용해 해시레이트, 전력 소모, 전기요금, 난이도, 수수료를 넣고 일일 혹은 월간 예상 수익을 추정하는 접근 권장 가격 변동성, 난이도 조정, 장비 고장률, 가동률 저하, 네트워크 정책 변경 위험을 보수적으로 반영하는 것 중요 채굴 방식 비교 CPU 채굴 초기에는 가능했으나 현재는 연산 밀도가 낮아 경제성 부족 GPU 채굴 범용성과 병렬성 확보, 여러 장을 리그로 구성해 확장 가능, 시장 유통성과 중고 처분 용이성이 장점이나 전력 효율은 ASIC 대비 불리 ASIC 채굴 특정 알고리즘 전용 설계로 높은 해시당 전력 효율 제공, 다만 초기 투자비 크고 알고리즘 혹은 시장 변화에 취약, 세대 교체 주기가 짧아 감가상각 리스크 큼 클라우드 채굴 하드웨어 없이 해시레이트 임대, 초기 비용과 운영 부담 감소 장점이 있으나 계약 불투명성, 수익 분배 구조, 커스터디 리스크에 각별한 주의 필요 채굴 풀의 역할과 구조 개인이 단독으로 블록을 찾을 확률은 매우 낮음, 풀은 참여자의 해시 파워를 모아 변동성을 줄이고 보다 자주 보상을 획득하도록 함 풀 보상 분배는 기여도 기반으로 수행되며 PPS, PPLNS 등 다양한 정산 방식 존재, 각 방식의 리스크와 변동성 특성 상이함 풀 선택 시 고려 요소 운영 투명성, 수수료율, 지연시간, 서버 위치와 품질, 최소 출금 한도, 보안 공지 대응력, 탈중앙성에 미치는 영향 풀 집중화는 네트워크 보안에 부정적일 수 있으므로 단일 풀이 과도한 비중을 차지하는 상황은 경계 필요\n보안과 한계, 운영상의 베스트프랙티스 전력과 열 관리 과부하 차단기와 분산 배전, 항온항습과 적절한 배기 경로 설계, 화재 감시 시스템 구축 펌웨어와 드라이버 신뢰 가능한 소스만 사용, 자동 업데이트 비활성 후 검증 배포, 설정 백업 유지 물리 보안 장비 잠금과 출입 통제, 원격 전원 차단 장치 준비, 영상과 환경 센서 모니터링 풀 및 지갑 보안 출금 화이트리스트, 다중서명 혹은 하드웨어 월렛 사용, 풀 API 토큰 보호 재무 관리 변동성 헤지 전략, 정기적인 손익 분석, 감가상각과 현금 흐름 관리 규제와 환경 고려 지역 규제 준수, 소음 규제 대응, 재생에너지 사용 검토, 전력 계약 합법성 확인 PoW는 높은 에너지 비용과 장비 자본 집약이라는 구조적 한계를 가짐, 반면 공격 비용을 높여 보안을 확보한다는 장점 존재 간단 예시로 보는 합의와 순서 보장 순서1 Alice → Bob 1 단위 전송 요청 생성 및 서명 순서2 네트워크에 전파되어 메모리풀에 대기 순서3 채굴자가 유효성을 확인하고 블록 후보에 포함 순서4 채굴자가 유효한 작업증명을 먼저 찾으면 블록 전파 순서5 다른 노드가 빠르게 검증 후 채택, 전 세계가 동일한 순서로 상태를 갱신 이 흐름이 반복되며 이중지불 시도가 자연스럽게 배제됨, 잘못된 순서나 잔고 부족 요청은 유효성 검증에서 탈락함 이더리움 전환 사례에서 얻는 시사점 이더리움은 PoW에서 PoS로 전환하며 에너지 소비를 대폭 감소시키고 채굴 경제학에서 스테이킹 경제학으로 무게중심을 이동시켰음 PoW 채굴의 개념과 절차는 여전히 유효한 학습 주제이며, PoW 네트워크 운영과 보안 모델 이해에 핵심적임 네트워크 설계는 기술과 경제 인센티브의 균형 위에 서며, 보상 구조와 비용 구조를 함께 설계해야 지속 가능성이 확보됨\n마무리 채굴은 블록을 만드는 생산 행위이자 합의를 물리적으로 고정하는 보안 장치임 동작 원리를 이해하면 트랜잭션 순서 보장, 이중지불 방지, 경제 인센티브 설계를 하나의 체계로 연결해 볼 수 있음 실제 투자나 운영을 고려한다면 전력 단가, 장비 효율, 난이도, 수수료 시장, 규제 리스크를 보수적으로 평가하고, 풀 선택과 보안 운용에 표준 절차를 갖추는 것이 우선임 PoW와 PoS의 차이를 비교해 각 네트워크의 보안 가정을 명확히 이해하는 태도가 중요함\n참고자료 https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining/ https://ethereum.org/en/roadmap/merge/ https://en.wikipedia.org/wiki/Double-spending https://etherscan.io/ether-mining-calculator https://www.fidelity.com/learning-center/trading-investing/crypto/what-is-mining ","permalink":"https://blog.jsontapose.com/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임\n역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음\n이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨\n아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부\u003c/li\u003e\n\u003cli\u003e트랜잭션 계정 상태를 변화시키는 요청 또는 메시지\u003c/li\u003e\n\u003cli\u003e채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체\u003c/li\u003e\n\u003cli\u003e작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙\u003c/li\u003e\n\u003cli\u003e난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할\u003c/li\u003e\n\u003cli\u003e넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값\u003c/li\u003e\n\u003cli\u003e메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합\u003c/li\u003e\n\u003cli\u003e블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"왜-채굴이-필요한가\"\u003e왜 채굴이 필요한가\u003c/h3\u003e\n\u003cp\u003e탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음\n예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함\n채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함\nPoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\u003c/p\u003e","title":"블록체인 채굴 개념과 동작 원리 PoW 보상 구조 이더리움 전환 사례"},{"content":"개요 Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표 ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구 핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\n배경과 목적 이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼 저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적 L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것 ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\n핵심 개념 Layer 2\nL1의 합의와 보안을 상속받아 트랜잭션을 오프체인에서 처리한 후 압축된 증거를 L1에 제출하는 확장 계층 목표는 가스 비용 절감, TPS 증가, 빠른 최종성 확보 ZK Rollup\n트랜잭션 배치를 실행한 결과가 올바름을 증명하는 유효성 증명 제출 방식 모든 원시 트랜잭션 데이터를 L1에 게시하지 않고 상태 변화의 유효성만 증명하여 확정 가능 Optimistic Rollup 대비 사후 분쟁 윈도우 감소, 빠른 확정성 기대 ZK Stack\nZK Rollup을 구성하기 위한 오픈 프레임워크 시퀀서, 증명기, 검증 계약, 데이터 가용성, 브리징 등 구성요소를 모듈 단위로 조립하는 설계 지향 데이터 가용성과 EIP-4844\n상태 차이와 배치 관련 데이터를 블롭 형태로 게시하여 비용 효율을 높이는 전략 블롭 데이터는 일정 기간 보존되며, 검증과 재구성에 필요한 최소 요건 충족을 목표 동작 원리와 구조 트랜잭션 수명주기 개요 사용자가 JSON-RPC를 통해 L2 네트워크로 트랜잭션 제출, 멤풀 적재 시퀀서가 트랜잭션을 실행해 블록화 후 배치 생성 사용자에게 즉시 실행 응답 반환 가능, 최종성은 L1 커밋·검증 후 확보 배치가 L1로 전송되어 데이터 가용성 보장 상태로 커밋됨 ZK 증명이 생성되어 L1 검증 계약에서 확인됨 검증 완료 후 배치 실행 확정, 상태 루트와 로그가 온체인 기준으로 고정 L1 상호작용 단계 커밋 단계\n시퀀서가 L1 롤업 컨트랙트에 배치 커밋 호출 수행 EIP-4844 블롭을 통해 상태 차이 등 필요한 데이터의 가용성 보장 증명 단계\n배치 실행의 유효성을 ZK 증명으로 생성하여 L1에 제출 검증 계약이 증명을 확인하여 상태 전이의 정당성 확립 실행 단계\n검증 완료 즉시 배치가 확정 처리되며, L2 로그를 포함한 머클 구조가 저장됨 구성 요소 Sequencer 계층\nRPC 서비스: 트랜잭션 제출, 상태 조회 등 API 제공 Sequencer: 트랜잭션 정렬·실행·블록화, 검증 제약을 준수하는 실행 파이프라인 유지 L1 연동 오퍼레이터: 입금, 업그레이드 등 L1 이벤트 동기화 및 배치 커밋 전송 역할 Prover \u0026amp; Verifier 파이프라인\n증인 생성 단계: 거래 세부 공개 없이 유효함을 입증하기 위한 데이터 구성 회로 실행 단계: VM 실행의 정합성을 검증하는 회로를 기준으로 증명 생성 및 검증 수행 연산 코드, 스토리지 상호작용, 사전컴파일 통합 등을 포함하는 실행 정합성 보장 목표 배치 전체를 순회하며 최종 상태 루트까지의 업데이트 일관성 확인 증명 압축 단계: L2에서 생성된 큰 STARK류 증명을 소형 SNARK류로 압축하여 L1 검증 비용 절감 L1 Rollup Contracts\n블롭을 사용해 상태 차이와 압축된 바이트코드 저장 유효성 증명 수신·검증 L1↔L2 메시징과 브리징 지원 네이티브 계정 추상화 Abstract의 모든 계정은 스마트 컨트랙트 계정으로 동작하며 동일한 트랜잭션 수명주기 준수 EOA와 CA 이원화 대신 IAccount 인터페이스 기반의 단일 모델 적용 EOA 지갑으로 서명해도 실행 경로에서는 기본 계정 구현체로 변환되어 처리됨 가스 지불은 본인 또는 페이마스터를 통해 유연하게 수행 가능\n트랜잭션 플로우 제출\nJSON-RPC로 트랜잭션 제출, 멤풀 적재 from 필드를 스마트 컨트랙트 계정 주소로 설정 가능 부트로더 처리\n멤풀에서 트랜잭션을 읽어 배치 단위로 처리 NonceHolder 시스템 컨트랙트 질의로 nonce 사용 여부 확인 from 주소에 코드가 없으면 기본 계정 구현으로 해석해 실행 경로 표준화 스마트 컨트랙트 계정 검증·실행\nvalidateTransaction 호출로 실행 허용 여부 판단 및 접근 제어 수행 executeTransaction 호출로 실제 실행 경로 진입 payForTransaction 또는 prepareForPaymaster 호출로 가스 지불 경로 선택 페이마스터 경로 선택적 수행\nvalidateAndPayForPaymasterTransaction 호출로 후원 여부 결정 및 가스 지불 집행 postTransaction 훅으로 사후 처리 로직 수행 가능 스마트 컨트랙트 지갑 설계 포인트 IAccount 인터페이스 구현 기반 표준 동작 확보 onlyBootloader 제약으로 부트로더 외 호출 차단 컨트랙트 배포는 시스템 컨트랙트를 통한 isSystemCall 경로 사용 효율적 실행을 위한 저수준 호출 라이브러리 활용 권장 가스 지불은 부트로더에 직접 지불 또는 페이마스터 입력 처리 함수 사용 Nonce 관리 트랜잭션 시작 전 NonceHolder 시스템 컨트랙트의 validateNonceUsage 호출로 중복 사용 방지 유효성 검사 단계에서 nonce를 소비 처리해야 함 옵션\nminNonce 증가로 해당 값 미만 nonce 일괄 사용 처리 setValueUnderNonce를 통해 특정 nonce 슬롯에 0이 아닌 값 기록 편의 메서드 incrementMinNonceIfEquals 사용 권장 NonceHolder 호출에는 트랜잭션의 isSystem 플래그 설정 필요, 시스템 호출 유틸 사용 권장 서명 검증과 EIP-1271 스마트 컨트랙트 계정은 EOA와 달리 고정 서명 검증 로직이 없으므로 EIP-1271 구현 권장 isValidSignature를 통해 임의 로직으로 서명 유효성 판단 가능, EIP-712 타입 데이터 서명과 결합 시 사용자 경험 및 보안 개선 기대\ncontract ERC1271 { // bytes4(keccak256(\u0026#34;isValidSignature(bytes32,bytes)\u0026#34;)) bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature( bytes32 _hash, bytes memory _signature ) public view returns (bytes4 magicValue) {} }Paymaster 개념 다른 계정을 대신해 가스비를 지불하는 스마트 컨트랙트 역할 IPaymaster 인터페이스 준수 필수 계정 소유자의 가스비 직접 지불을 대체해 비용 스폰서십, 토큰 기반 가스 지불 등 사용성 개선 제공 실행 경로에서는 prepareForPaymaster 이후 paymaster가 검증과 결제를 수행 오남용 방지를 위한 한도·쿨다운·화이트리스트 정책 필요\nAGW(Abstract Global Wallet) 개요 네이티브 계정 추상화를 전제로 한 사용자 온보딩 레이어 이메일, 소셜, 패스키 등 친숙한 로그인으로 최초 가입 후 동일 계정으로 트랜잭션 생성 가능 핵심은 서명자 관리와 복구, 다중 서명자, 가스 스폰서십 등 계정 수명주기 운영을 일관된 UX로 제공하는 것\nAGW 작동 방식 1단계 EOA 생성 사용자 로그인 방식을 통해 내부적으로 EOA 생성 2단계 스마트 컨트랙트 지갑 배포 배포 초기화 시 1단계 EOA를 승인된 서명자로 등록 이후 단계 서명자 추가·삭제, 패스키 기반 서명자 등록, 모듈 확장 등 계정 운영 기능 사용 스마트 컨트랙트 지갑은 네이티브 1급 시민으로 동작하며, 기본 곡선인 secp256k1 중심 운영 권장 패스키 확장 시 secp256r1 서명자 지원 가능, EIP-712 기반 서명 검증 로직 조합 권장\n스마트 지갑 기능 모듈 예 복구 모듈 이메일 복구, 가디언 복구 등 키 분실 시 계정 복원 경로 제공 페이마스터 연동 트랜잭션 가스비 후원, 특정 토큰 지불 라우팅 구성 다중 서명자 역할 기반 서명 정책, 임계값 승인 정책 확장 패스키 지원 FIDO 기반 기기 서명자를 지갑에 연결해 무서버 키 경험 제공 주의 사항과 트레이드오프 데이터 가용성 비용\n블롭 가격은 네트워크 수요에 따라 변동, 배치 크기와 커밋 주기 최적화 필요 증명 대기 시간\n증명 생성은 계산 집약적, 하드웨어와 회로 최적화 상태에 따라 지연 발생 가능 사용자 응답은 즉시성 확보 가능하나 L1 최종성은 증명 완료 이후 확보 시퀀서 검열 리스크\n단일 시퀀서 운영 시 트랜잭션 포함 지연 가능성 존재 추후 분산화 로드맵, 포크 선택 규칙, 포스 인클루전 메커니즘 고려 필요 브리징과 메시징 안전성\nL1 확정 전 교차체인 메시지 사용 시 미확정 리스크 존재 지연 큐, 취소·재시도 정책, 상태 증명 기반 수령 조건 명시 필요 페이마스터 남용 방지\n한도, 속도 제한, 수신자·함수 화이트리스트 운용 토큰 기반 가스 지불은 환산 레이트 변동과 유동성 부족 문제 고려 Nonce 경쟁과 재진행\n중복 제출 방지, 재전송 정책, minNonce 관리 정책 표준화 필요 간단 예시와 실무 팁 JSON-RPC 제출 시 from을 스마트 컨트랙트 계정 주소로 지정해 계정 자체 검증 로직 구동 검증 단계에서 nonce 소비를 먼저 처리해 재진입·중복 실행 방지 EIP-712 타입 데이터 서명 사용으로 서명 범위와 목적을 명확히 표현 부트로더 전용 함수는 onlyBootloader로 차단, 외부 호출 경로 executeTransactionFromOutside를 별도 제어 L1 상호작용은 commit → prove → execute 순서 준수, 운영 관점에서 배치 커밋 지표와 증명 큐 길이를 모니터링 운영 베스트 프랙티스 배치 정책\n수요에 따른 동적 배치 크기와 커밋 주기 조정, 블롭 단가와 증명 대기 시간의 균형 추구 가시성 확보\n시퀀서 지연, 증명 생성 시간, 실패율, 큐 길이, L1 가스 단가, 블롭 단가 대시보드화 계정 추상화 보안\nvalidateTransaction에서 호출자·서명·정책 일관성 검증, 실패 시 명시적 에러 코드 반환 페이마스터 입력 파싱과 예산 검사 철저, 사후 훅에서 외부 호출 시 재진입 방지 릴리즈 전략\n테스트넷에서 계정·페이마스터·브리징 경로를 통합 리허설, 가스 상한과 오류 복구 시나리오 검증 회로와 증명 백엔드\n회로 업데이트는 롤링 업그레이드 전략 채택, 검증 키 교체와 컨트랙트 버전 호환성 체크리스트 운영 마무리 Abstract는 ZK Rollup과 EIP-4844를 결합해 확장성과 비용 효율을 확보하고, 네이티브 계정 추상화로 개발자와 사용자의 상호작용을 단순화하는 접근을 취함 시퀀서·증명 파이프라인·L1 계약 간 경계를 명확히 하고, 계정 추상화와 페이마스터 정책을 보안 우선으로 설계하면 운영 안정성을 크게 높일 수 있음 이 문서의 개념과 베스트 프랙티스를 기준으로 트랜잭션 수명주기, 지갑 모듈, 데이터 가용성 튜닝을 체계적으로 검토할 것을 권장함\n참고자료 https://abs.xyz/ https://eips.ethereum.org/EIPS/eip-4844 https://eips.ethereum.org/EIPS/eip-1271 https://era.zksync.io/docs/ https://vitalik.ca/general/2021/01/05/rollup.html https://ethereum.org/en/roadmap/danksharding/ ","permalink":"https://blog.jsontapose.com/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAbstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표\nZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구\n핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\u003c/p\u003e\n\u003ch3 id=\"배경과-목적\"\u003e배경과 목적\u003c/h3\u003e\n\u003cp\u003e이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼\n저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적\nL2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것\nZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\u003c/p\u003e","title":"Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW"},{"content":"개요 Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임 ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음 프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\n핵심 개념과 정의 Public Client\n퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트 블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당 Wallet Client\n개인키를 보유한 계정에 대해 트랜잭션 서명과 전송을 수행하는 클라이언트 시뮬레이션, 가스 추정, nonce 처리, write 컨트랙트 호출 담당 Transport\nHTTP나 WebSocket 등 JSON-RPC 통신 방법 추상화 계층 성능과 안정성에 영향을 주는 핵심 요소 Chain 구성\nchain 객체에 chainId, 네트워크 이름, 기본 RPC 엔드포인트, 네이티브 통화 단위 등의 메타데이터 포함 올바른 체인 설정이 시뮬레이션과 서명, 전송의 전제 조건 ABI 기반 타입 안전성\nABI를 바탕으로 함수 이름, 파라미터, 반환형에 대한 타입 추론 제공 런타임 이전에 오타나 파라미터 타입 오류를 차단하는 효과 데이터 타입\n금액, 블록 번호, 가스 등 정수 값은 BigInt 반환이 기본 주소, 바이트 데이터는 0x 프리픽스 hex 문자열 사용 동작 원리와 구조 읽기 흐름\nPublic Client가 RPC 호출을 통해 블록이나 상태를 조회함 컨트랙트 읽기 시 getContract 또는 readContract 유틸을 사용하여 call 실행 쓰기 흐름\nWallet Client가 계정을 보유하고 시뮬레이션으로 가스와 파라미터를 검증한 뒤 트랜잭션 전송 simulateContract 결과를 writeContract에 그대로 전달하는 패턴이 안전하고 권장됨 분리의 이점\n읽기와 쓰기 책임이 분리되어 보안 경계와 테스트 용이성 향상 서버 환경에서는 Public Client만 배포해 민감 키가 없는 조회 전용 API 제공 가능 설치와 환경 준비 패키지 설치\nnpm install viem 필수 준비물\n신뢰 가능한 RPC 엔드포인트 URL 준비 테스트넷에서는 faucet로 ETH 확보 환경 변수로 개인키, RPC URL 등 민감정보 관리 권장 사용법 1: 네트워크 연결과 블록 조회 아래 스니펫은 메인넷에 연결하고 최신 블록과 블록 번호를 조회하는 최소 예시임\nimport { createPublicClient, http } from \u0026#34;viem\u0026#34;; import { mainnet } from \u0026#34;viem/chains\u0026#34;; const publicClient = createPublicClient({ chain: mainnet, transport: http(process.env.RPC_URL), }); const run = async () =\u0026gt; { const block = await publicClient.getBlock(); const blockNumber = await publicClient.getBlockNumber(); // block 해시, 타임스탬프, 가스 사용량 등 핵심 필드 사용 console.log(block.hash, block.timestamp, block.gasUsed); console.log(blockNumber); }; run(); blockNumber는 BigInt 반환값임 gas, 수수료, 블록 번호 등 정수 값 처리 시 숫자 오버플로 방지를 위해 BigInt 유지 또는 명시적 변환 필요 http 전송 대신 웹소켓 전송도 가능하나 서버 환경 안정성, 프록시 구성, 리밸런싱 전략 고려 필요 사용법 2: 컨트랙트 읽기와 쓰기 한 스니펫에서 읽기와 쓰기를 묶어 핵심 흐름만 정리함\nimport { getContract, createPublicClient, createWalletClient, http, } from \u0026#34;viem\u0026#34;; import { sepolia } from \u0026#34;viem/chains\u0026#34;; import { privateKeyToAccount } from \u0026#34;viem/accounts\u0026#34;; const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.RPC_URL), }); const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`); const walletClient = createWalletClient({ account, chain: sepolia, transport: http(process.env.RPC_URL), }); // 읽기 예시 const contract = getContract({ address: \u0026#34;0xYourContractAddress\u0026#34;, abi: YourAbi, client: publicClient, }); const name = await contract.read.name(); // 쓰기 예시 const { request } = await publicClient.simulateContract({ address: \u0026#34;0xYourContractAddress\u0026#34;, abi: YourAbi, functionName: \u0026#34;store\u0026#34;, args: [100n], account, }); const txHash = await walletClient.writeContract(request); console.log(name, txHash); address에는 목표 컨트랙트 주소 입력 abi에는 실제 ABI 배열 주입 read 호출은 call을 사용하므로 가스 소모 없음 write 호출은 시뮬레이션으로 가스, 인자, 권한 문제를 사전 검증한 뒤 전송 txHash로 익스플로러에서 상태 확인 가능 동작 살펴보기와 실전 팁 getContract와 read\ngetContract는 ABI를 바탕으로 타입 안전한 메서드 집합 생성 contract.read.balanceOf(\u0026lsquo;0x\u0026hellip;\u0026rsquo;)처럼 각 함수가 자동 완성되며 잘못된 함수명이나 인자 타입을 컴파일 타임에 차단 simulateContract와 writeContract\n시뮬레이션 단계에서 revert 이유와 디코딩된 오류를 확인 가능 request에는 to, data, value, gas, maxFeePerGas 등 전송에 필요한 필드가 완성되어 포함됨 writeContract에 request를 그대로 넘겨 불일치 위험 최소화 가스 수수료와 EIP-1559\n대부분 체인은 baseFee 기반의 maxFeePerGas, maxPriorityFeePerGas 조합 사용 시뮬레이션 결과를 그대로 쓰거나, 트래픽이 많은 시간대에는 우선순위 수수료를 다소 상향해 확정 속도 확보 BigInt와 단위 처리\nERC-20 amount, 수수료 모두 BigInt로 다룸 parseUnits, formatUnits 유틸 사용으로 10진 문자열과 wei 단위 간 변환 안정화 체인 불일치와 계정 네트워크\nwalletClient와 simulateContract의 chain은 동일해야 함 RPC URL이 다른 체인을 가리키면 nonce, 수수료, 시뮬레이션 결과가 어긋나 실패 가능 주의사항과 한계 개인키 보호\nPRIVATE_KEY는 서버 비밀 변수 관리 또는 HSM, KMS 연동 고려 프런트엔드 환경에 개인키 하드코딩 금지 RPC 신뢰도와 레이트 리밋\n공용 RPC는 속도와 가용성이 낮을 수 있음 상용 환경은 신뢰 가능한 제공자와 백업 엔드포인트 구성 권장 재시도와 오류 처리\n네트워크 에러, 서버 오류, 체인 재구성 등 다양한 실패 케이스 존재 지수 백오프, idempotency 고려, 트랜잭션 재전송 시 nonce 관리 필요 테스트넷과 가스\n테스트넷은 faucet 지급 지연, 빈 블록, 비활성 노드 등 특성이 존재 가스 부족, 체인 혼잡에 따른 확정 지연을 정상 동작 범위로 간주할 수 있어야 함 ABI 신뢰성\n오타 또는 잘못된 ABI는 런타임 revert를 유발함 배포된 바이트코드와 ABI 매칭 검증 권장 베스트 프랙티스 시뮬레이션 우선 전략\n모든 write 호출 전 simulateContract로 가스와 인자 검증 환경 변수 분리\nRPC_URL, PRIVATE_KEY, CONTRACT_ADDRESS를 환경 변수로 분리해 배포 환경별 설정 편의 확보 블록 간 일관성\n이벤트나 상태를 조합해 읽을 때는 동일 블록 높이 기준을 유지하는 스냅샷 전략 고려 멀티콜 활용\n여러 read를 묶어 왕복 비용 절감 가능 로깅과 관찰성\ntxHash, nonce, gasUsed, effectiveFeePerGas, 블록 번호를 구조화 로그로 남겨 운영 이슈 분석 용이성 확보 간단 예시로 보는 검증 흐름 writeContract에서 반환된 txHash 확인 체인 익스플로러에서 해당 txHash 조회로 블록 포함 여부, 리시트 상태, 이벤트 로그 검증 컨트랙트의 view 함수로 최종 상태 교차 확인 이 흐름을 자동화해 배치나 백엔드 작업에서 신뢰도 있는 완료 판정 기준으로 사용 가능\n마무리 Viem은 읽기와 쓰기 클라이언트 분리, 시뮬레이션 중심의 전송 흐름, 타입 안전한 ABI 접근이라는 명확한 철학을 가짐 이 기본기만 갖추면 블록 조회, 컨트랙트 읽기, 트랜잭션 생성이라는 세 가지 축을 빠르게 실무에 적용 가능 개인키와 RPC 관리, 시뮬레이션과 가스 전략, 오류 처리라는 운영 디테일을 함께 설계하면 프로덕션에서도 일관된 안정성을 확보할 수 있음\n참고자료 https://viem.sh/docs https://viem.sh/docs/clients/public https://viem.sh/docs/clients/wallet https://viem.sh/docs/actions/public/getBlock https://viem.sh/docs/contract/readContract https://viem.sh/docs/contract/writeContract https://ethereum.org/en/developers/docs/apis/json-rpc https://etherscan.io https://docs.alchemy.com/reference/ethereum-apis ","permalink":"https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eViem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임\nethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음\n프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePublic Client\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트\u003c/li\u003e\n\u003cli\u003e블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWallet Client\u003c/p\u003e","title":"Viem으로 이더리움 읽기·쓰기 시작하기 가이드"},{"content":"개요 영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함 블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임 이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\n목적과 맥락 비밀을 공개하지 않고 유효성만 검증하려는 요구 증가 퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대 오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구 핵심 개념과 정의 Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체 Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체 Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식 Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명 Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제 Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립 영지식 증명의 세 가지 성질 완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨 건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤 영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함 직관적 예시 알리바바 동굴 동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음 검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함 Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2 k회 독립 반복하면 모두 속일 확률 2^-k로 급감 검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함 핵심 포인트\n비밀 노출 없이 유효성만 확인 가능 무작위 도전과 반복으로 사기 가능성 급감 대화 기록만으로 비밀 자체를 유추 불가 형식적 관점과 시뮬레이터 대화형 증명은 Prover P와 Verifier V가 커밋-챌린지-리스폰스 구조로 상호작용함 Transcript는 도전값과 응답 및 공개 상태를 포함하는 관찰 기록을 의미함 영지식성은 시뮬레이터 S가 비밀 없이도 실제와 분포가 같은 Transcript를 생성할 수 있음을 요구함 의미는 검증자가 얻은 정보가 공개 난수로도 재현 가능한 수준에 한정됨을 보장한다는 것임 사전 공모 이슈와 설계 포인트 대화형 프로토콜에선 검증자와 Prover가 사전 공모했다면 제3자는 배제 불가 이슈가 생김 이 경우를 지정 검증자 영지식 designated-verifier ZK로 분류 가능 공개 검증이 필요하면 비대화형 영지식 NIZK 또는 공개 검증 가능한 Σ-프로토콜 조합을 사용해 누구나 검증 가능하게 설계 필요 Fiat–Shamir 변환으로 도전값을 해시로 결정하면 제3자도 단일 증명을 검증 가능 운영 시 검증자의 내부 시드나 도전값 생성 과정을 과도하게 공개하면 지정 검증자 시나리오의 영지식성이 약화될 수 있음 대화형과 비대화형 대화형 Interactive 실시간으로 도전과 응답을 주고받는 구조. 장점은 단순성과 강한 보안 모델. 단점은 왕복 상호작용과 제3자 설득 한계 가능 비대화형 Non-Interactive 하나의 짧은 증명을 생성해 누구나 검증. Fiat–Shamir로 대화형 도전을 해시로 대체. SNARK와 STARK 등에서 표준 사용 트레이드오프 네트워크 왕복 제거와 공개 검증 가능성 vs 해시를 랜덤 오라클로 보는 가정과 경우에 따라 신뢰 설정 필요 디지털 서명과의 차이 신원 노출 서명은 공개키로 서명자 신원이 구조적으로 드러남. ZK는 신원과 비밀 모두 숨기고 유효성만 증명 가능 제3자 설득 서명은 메시지-서명 쌍을 누구나 검증 가능해 완전 설득 지향. ZK도 NIZK나 공개 검증 가능한 구성에선 제3자 설득 가능. 다만 지정 검증자 ZK에선 제3자 설득이 제한됨 프록시 릴레이 공격 대화형 식별 프로토콜은 중간자 릴레이 공격 위험 존재. 세션 바인딩과 채널 인증, 도전값 바인딩으로 완화 필요. 서명은 보통 프로토콜 레벨 인증과 채널 보안으로 대응 연결 고리 Σ-프로토콜에 Fiat–Shamir를 적용하면 서명 스킴으로 전환 가능. 대표가 Schnorr 서명임 ZKP Under the Hood 이산로그 기반 Σ-프로토콜 가장 고전적인 지식증명은 이산로그 가정 위에서 동작함 공통 입력 y = g^x mod p에서 x가 비밀이며 Prover는 x를 안다는 사실을 증명함\n기본 설정 큰 소수 p와 생성원 g를 가진 소수 차수 q 부분군 선택. 연산은 지수에서 mod q로 수행 공통 값 y = g^x mod p는 공개. x는 Prover만 아는 비밀 1비트 챌린지 버전 직관 커밋 Prover가 임의의 r를 뽑아 C = g^r mod p 전송 챌린지 Verifier가 z ∈ {0,1} 전송 응답 z = 0이면 r 공개. z = 1이면 s = r + x mod q 공개 검증 z = 0이면 g^r ≟ C 확인. z = 1이면 g^s ≟ C · y 확인 Prover가 x를 모르면 두 경우를 동시에 만족시키는 응답을 준비 불가. 1회 속임 확률 1/2. k회 반복 시 2^-k로 감소 일반화된 Schnorr 식별 프로토콜 도전값 c를 Z_q에서 무작위 선택 커밋 C = g^r 응답 s = r + c·x mod q 검증 g^s ≟ C · y^c 비대화형으로는 c = H(domain, context, g, y, C)로 정하고 단일 증명을 생성함. 여기서 H는 도메인 분리와 컨텍스트 바인딩을 포함한 해시 함수이며 랜덤 오라클 가정 하에서 분석함 주의사항 안전한 구현은 군 차수 q 기준으로 지수 연산 수행 필요 r은 CSPRNG로 매 증명마다 새로 생성. r 재사용은 즉시 비밀 유출로 이어짐 해시 입력엔 도메인 분리 태그와 세션 ID, 검증자 식별 등 컨텍스트를 바인딩해 재생 공격과 교차 프로토콜 간섭을 방지 필요 간단 검증 스니펫 예시 아래는 원리 전달용 최소 형태임. 실제 구현에선 안전한 군 선택, 상수시간 연산, 에러 처리 포함 필요\n## 공개 파라미터 p, g, y와 커밋 C, 도전 z, 응답 resp를 검증하는 예시 def verify_one_bit(p, g, y, C, z, resp): if z == 0: ## resp == r return pow(g, resp, p) == C else: ## resp == s = r + x mod q return pow(g, resp, p) == (C * y) % p def verify_schnorr(p, g, y, C, c, s): ## 일반형 검증식 g^s == C * y^c mod p left = pow(g, s, p) right = (C * pow(y, c, p)) % p return left == right확률적 보장과 파라미터 선택 1회 속임 확률은 1 / |ChallengeSpace| 임 1비트 도전이면 1/2. k회 독립 반복 시 2^-k로 수렴 NIZK나 공개 검증에서는 도전 공간을 128비트 이상으로 설정해 단일 증명으로 충분한 사운드니스 확보 권장 블록체인 환경에서는 검증 비용과 증명 크기, 사운드니스 비트를 함께 고려해 회로 크기와 파라미터를 선택 필요 설계 포인트와 운영 수칙 그룹과 곡선 선택 secp256k1, P-256, BLS12-381, Bandersnatch, ristretto255 등 표준 계열 우선 고려 난수 생성 CSPRNG 필수. 커밋 nonce r 재사용 금지. 시스템 RNG 품질 모니터링 필요 파라미터 바인딩 도전 해시에 프로토콜 식별자, 세션 ID, 검증자 식별 또는 채널 특성 포함해 세션 고정 효과 확보 트랜스크립트 관리 지정 검증자 시나리오에서는 불필요한 내부 난수 공개를 줄임. 공개 검증 목표면 처음부터 NIZK 또는 SNARK류 선택 부채널 대응 타이밍 누수와 캐시 기반 누수에 대비해 상수시간 구현과 블라인딩 적용 리플레이 및 릴레이 방지 세션 바인딩, nonce, 타임스탬프, 채널 인증 적용 회귀 방지 회로나 명세 변경 시 검증 규칙에 대한 테스트 자동화와 호환성 체크 필요 SNARK vs STARK vs Bulletproofs 한눈 비교 항목 SNARK STARK Bulletproofs 설정 일부 시스템 신뢰 설정 필요. Plonk류는 범용 SRS 가능 투명 설정. 신뢰 설정 불요 신뢰 설정 불요 증명 크기 매우 작음 수십 바이트 수준까지 가능 비교적 큼 수십 KB 이상 로그 크기. 범위증명은 수 KB 수준 검증 비용 빠름. 온체인 친화적 보통에서 빠름. 해시 중심 검증 비용 큼. 집계로 완화 가능 보안 가정 페어링과 다항식 약속 등 수학적 가정 해시 기반 IOP와 FRI. 포스트 양자 내성 기대 내적 논증 기반. 일반군 가정 활용 예 zkEVM, 롤업, 영지식 브리지 투명한 롤업, 대규모 추적 증명 범위증명, UTXO 프라이버시 각 계열의 실제 성능은 구현과 회로 구조, 하드웨어에 크게 의존함\n블록체인 적용 예 잔액과 금액을 숨긴 비공개 전송과 감사 가능성 확보 신원 속성 최소 공개 KYC 예 나이 이상 여부만 증명 영지식 롤업 상태 전개 증명과 데이터 가용성 보완 오라클 입력의 유효성 증명과 오프체인 계산 검증 MPC와 결합한 다자 프라이버시 계산의 결과 정합성 증명 자주 묻는 질문 ZK면 항상 제3자 설득 불가임? 아님. NIZK나 공개 검증 가능한 구성에선 누구나 검증 가능함 STARK는 포스트 양자 보안 보장임? 양자에 대해 알려진 공격이 약하다는 의미의 내성 기대 수준임. 수학적 증명된 보장은 아님 왜 r 재사용이 위험함? 서로 다른 도전에 같은 r을 쓰면 x가 선형식으로 노출됨 왜 q 모듈러를 강조함? 안전한 지수 연산의 정의역은 군 차수 q이기 때문임. p-1 전역 모듈러는 안전하지 않을 수 있음 검증과 회귀 방지 체크리스트 사운드니스 목표 비트와 도전 공간이 요구 수준 충족하는지 점검 난수 생성 모듈 품질과 시드 관리 상태 감사 도메인 분리 태그와 세션 ID가 해시 입력에 포함되는지 확인 재생 공격과 프록시 릴레이 가능성에 대한 테스트와 채널 인증 적용 상수시간 연산 준수 여부와 메모리 접근 패턴 누수 점검 회로 변경 시 검증 규칙 스냅샷과 회귀 테스트 자동화 마무리 영지식 증명은 비밀을 드러내지 않고도 유효성을 설득하는 체계임 완전성-건전성-영지식성의 삼각을 이해하고 대화형과 비대화형의 차이를 파악하면 설계 선택이 명확해짐 실무에서는 안전한 군 선택과 난수, 도전 공간 크기, 세션 및 채널 바인딩, 신뢰 설정과 부채널 대응을 종합적으로 관리 필요 목표는 비밀을 지키면서도 누구나 또는 지정된 상대가 납득할 수 있는 검증 가능한 시스템을 만드는 것임\n참고 링크 https://en.wikipedia.org/wiki/Zero-knowledge_proof https://en.wikipedia.org/wiki/Interactive_proof_system https://en.wikipedia.org/wiki/Schnorr_identification https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic https://en.wikipedia.org/wiki/SNARK https://en.wikipedia.org/wiki/STARK_(cryptography) https://en.wikipedia.org/wiki/Bulletproofs https://hyun-jeong.medium.com ","permalink":"https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함\n블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임\n이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\u003c/p\u003e\n\u003ch2 id=\"목적과-맥락\"\u003e목적과 맥락\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e비밀을 공개하지 않고 유효성만 검증하려는 요구 증가\u003c/li\u003e\n\u003cli\u003e퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대\u003c/li\u003e\n\u003cli\u003e오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProver 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체\u003c/li\u003e\n\u003cli\u003eVerifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체\u003c/li\u003e\n\u003cli\u003eWitness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식\u003c/li\u003e\n\u003cli\u003eStatement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명\u003c/li\u003e\n\u003cli\u003eChallenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제\u003c/li\u003e\n\u003cli\u003eTranscript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"영지식-증명의-세-가지-성질\"\u003e영지식 증명의 세 가지 성질\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨\u003c/li\u003e\n\u003cli\u003e건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤\u003c/li\u003e\n\u003cli\u003e영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"직관적-예시-알리바바-동굴\"\u003e직관적 예시 알리바바 동굴\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음\u003c/li\u003e\n\u003cli\u003e검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함\u003c/li\u003e\n\u003cli\u003eProver가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2\u003c/li\u003e\n\u003cli\u003ek회 독립 반복하면 모두 속일 확률 2^-k로 급감\u003c/li\u003e\n\u003cli\u003e검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e핵심 포인트\u003c/p\u003e","title":"영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이"},{"content":"개념과 배경 Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함 짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨 노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\n핵심 용어 정리 스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\n오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\n리오그 깊이 교체되는 블록의 개수로 측정함\n메인 체인 선택 규칙\nPoW에선 누적 작업량이 큰 체인이 우선됨 이더리움 PoS에선 LMD-GHOST 포크초이스를 따르되 마지막 최종화 지점 하위만 후보가 됨 왜 리오그가 생김 네트워크 지연이나 전파 경합으로 같은 높이의 블록이 동시에 생성됨 일부 노드는 A를, 다른 노드는 B를 바탕으로 다음 블록을 쌓음 시간이 지나 우세한 체인이 결정되면 노드가 그 체인으로 교체함 버려진 체인의 트랜잭션은 소실되는 게 아니라 다시 메모풀로 돌아가 재포함을 기다림 합의별 리오그의 차이 PoW 계열 직관 우세 체인 기준은 블록 수가 아니라 누적 작업량임 자연 발생 리오그는 보통 깊이 1에서 끝남 보안 관례로 비트코인은 6컨펌 정도를 사람·서비스가 안전 구간으로 삼는 경우가 많음 다수 해시 파워를 가진 상대는 더 깊은 리오그를 인위적으로 만들 수 있으므로 고가치 결제일수록 더 많은 컨펌을 기다리는 전략이 쓰임 이더리움 PoS 직관 슬롯은 12초, 32슬롯이 1에폭이며 포크초이스는 LMD-GHOST와 FFG 최종화 규칙을 함께 사용함 헤드는 가장 최근 가중치가 높은 체인 머리, 세이프 헤드는 보수적 추정, 파이널라이즈드는 FFG로 최종화된 체크포인트 아래 체인 상태를 뜻함 정상 조건에선 리오그 깊이가 작고 파이널라이즈드 이후로의 리오그는 대규모 비정상 행동 없이는 사실상 불가에 가까움 대략 두 개의 에폭이 지나면 보통 최종화되어 실사용에선 약 12분 남짓을 강한 확정 구간으로 본다는 관례가 있음 환경과 네트워크 상황에 따라 달라질 수 있음 L2에서의 리오그 관점 L2→L1 메시지는 L1에 기록되고 관련 규칙을 충족하면 재전송하지 않음 옵티미스틱 롤업은 챌린지 윈도우가 지나야 강한 확정으로 취급하며 그 전에는 지연을 감안해야 함 L1이 뒤집히는 아주 이례적인 상황을 제외하면 L1에 최종적으로 기록된 상태는 다시 뒤집히지 않는다는 점을 전제로 시스템을 설계함 리오그와 헷갈리기 쉬운 것들 RBF나 수수료 경쟁으로 인해 메모풀에서 트랜잭션이 교체되는 현상은 리오그와 별개임 프로토콜 업그레이드를 위한 하드포크는 합의 규칙 자체를 바꾸는 이벤트이며 자연 발생 리오그와는 범주가 다름 과거 이더리움 PoW 시절의 옴머 포함은 스테일 블록 보상 메커니즘일 뿐 리오그 자체가 아님 서비스 설계에 미치는 영향 결제와 출금\n자산·위험도·체인별로 컨펌 수 정책을 문서화해 운영함 고가치 결제는 더 많은 컨펌을 요구하고 저가치·소액은 사용자 경험을 위해 낮출 수 있음 데이터 처리\n인덱싱은 높이만 저장하지 말고 블록 해시와 부모 해시를 함께 저장 리오그 감지 시 롤백 가능한 저널을 두고 되감기 후 재처리 트랜잭션 처리\n멱등성 확보를 위해 논스·컨트랙트 상태·이벤트 ID를 함께 검증 재방송은 동일 논스로 수행해 중복 실행을 피함 UX\n잠정 상태 표시와 컨펌 카운터 제공 세이프 헤드와 파이널라이즈드의 차이를 사용자에게 명확히 안내 리오그 감지와 대응 패턴 헤드 해시 변화 모니터링과 특정 깊이 이상 변화시 경보\n최신 N개 블록의 체인ID·높이·해시·부모 해시·도착 시각을 원장과 별도 테이블에 윈도우로 관리\n확정 레벨별로 파이프라인을 분기\n헤드 기준 실시간 기능 세이프 기준 중요 알림 파이널 기준 영구 저장 간단 의사코드\nonNewBlock(b): save(b.height, b.hash, b.parent) if parentNotHead(): // reorg 발생 rollbackUntilCommonAncestor() replayFromAncestor() routePipelinesByCommitment(head, safe, finalized)운영 체크리스트 컨펌 정책과 리오그 최대 허용 깊도가 문서화되어 있음 인덱서가 롤백과 재처리를 지원함 알림 시스템이 헤드 전환과 리오그 이벤트를 기록함 파이널라이즈드 구간만 영구 저장하거나 백그라운드 확정화 작업을 운영함 L2의 챌린지 윈도우와 브리지 지연을 고려해 타임라인을 설계함 간단 시나리오 한국과 미국에서 같은 높이 블록이 동시에 생성됨 각 지역 노드가 자신이 먼저 본 블록 위로 다음 블록을 쌓음 한쪽 체인이 한 블록 더 빨리 쌓이며 우세해지면 다른 쪽은 스테일 처리됨 스테일 체인에 있던 거래는 메모풀로 돌아가 메인 체인에 재포함을 기다림\n참고자료 https://en.bitcoin.it/wiki/Chain_Reorganization?utm_source=chatgpt.com https://learnmeabitcoin.com/technical/blockchain/chain-reorganization/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/?utm_source=chatgpt.com https://www.alchemy.com/overviews/ethereum-commitment-levels?utm_source=chatgpt.com ","permalink":"https://blog.jsontapose.com/posts/blockchain-reorg-chain-reorganization-f4966a/","summary":"\u003ch2 id=\"개념과-배경\"\u003e개념과 배경\u003c/h2\u003e\n\u003cp\u003eReorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함\n짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨\n노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\u003c/p\u003e\n\u003ch2 id=\"핵심-용어-정리\"\u003e핵심 용어 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\u003c/p\u003e","title":"블록체인 Reorg(체인 재구성) 이해"},{"content":"개요 프라이빗키 관리 방식에 따라 암호화폐 월렛은 커스토디얼(custodial) 과 논커스토디얼(noncustodial) 로 구분됨 각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 초보자도 이해할 수 있게 정리하면서 실무자가 바로 적용할 수 있는 체크리스트까지 제시함\n핵심 개념 커스토디얼 월렛 제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조 로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\n논커스토디얼 월렛 사용자가 프라이빗키를 직접 보유·관리하는 구조 브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\n핵심 차이 한 줄 정리 키의 소유·통제 주체가 제3자인가 사용자 본인인가의 차이\n모델별 동작 원리와 구성 커스토디얼 키 보관 중앙화된 키 보관소와 접근제어 체계를 운용 보통 핫월렛 과 콜드월렛 을 분리해 즉시성 vs 보관 안정성을 균형 있게 설계함 운영 통제 권한 분리, 변경 이력 추적, 승인 워크플로, 이상 징후 모니터링을 포함 유저 경험 계정 비밀번호·2FA 등 웹서비스 UX에 가깝고 분실 시 고객지원으로 복구 가능성이 있음 논커스토디얼 키 생성·저장·복구를 사용자 단말 또는 전용 기기에서 수행 하드웨어 지갑은 기기 내 보안영역에서 서명 연산을 수행해 키를 외부로 노출하지 않음 시드 문구(BIP‑39) 와 HD 지갑(BIP‑32, BIP‑44) 로 여러 주소를 파생해 사용함 분실·도난·손상에 대비한 백업·복구 절차가 필수임 하이브리드 접근 멀티시그 N개 중 M개 서명이 있어야 지출 가능 운영자 간 책임 분산과 단일 키 손실 리스크 완화에 효과적 키 분할과 복구 Shamir Secret Sharing 은 백업·복구에 적합하나 서명 자체는 수행하지 않음 임계값 서명(MPC/TSS) 여러 파티가 키 조각을 재조합 없이 공동 서명 단일 실패 지점 제거와 유연한 권한 정책이 장점 보안·규제·운영 관점 비교 구분 커스토디얼 논커스토디얼 키 소유 서비스 사업자 사용자 복구 용이성 계정 기반 복구 지원 가능 사용자가 책임, 백업 실패 시 복구 불가 보안 초점 내부자 위협·핫월렛 침해·운영 취약점 피싱·악성코드·물리 분실·백업 실패 컴플라이언스 관할에 따라 수탁 라이선스·KYC/AML 등 요구 가능 개인 사용은 상대적으로 자유, 조직은 회계·규정 준수 정책 필요 확장성/운영 기업 통제·감사 로그·승인 워크플로에 유리 사용자 자율성 최상, 표준화된 기업 통제는 구현 난이도 존재 일반 용도 거래소·커스터디 업체·핀테크 개인 보관·DAO 금고·개별 팀 지갑 위협 모델 수립 가이드 가치와 빈도 소액·빈번 결제는 접근성·자동화 우선, 대액·장기 보관은 보존·격리가 우선 공격면 피싱 링크·악성 확장프로그램·사기 승인 서명, 내부자 오남용, 인프라 취약점, 물리적 분실 복구 요구 사람 교체·기기 손상·지역 재해 등 현실 시나리오에서 얼마나 빨리 복구 가능한지 평가 감사 가능성 로그 불변성·승인 이력·역활분리와 규정 준수 증빙 가능성 점검 커스토디얼 선택 체크리스트 운영 보안 핫·콜드 분리, 다중인증, 권한 분리, 변경관리, 침해사고 대응 계획 보유 여부 키 관리 체계 HSM 또는 동급 보안 모듈 사용, 키 생성·보관·회전 절차 문서화, 접근 통제 로그 유지 감사·인증 SOC 2 Type II, ISO/IEC 27001, 취약점 스캐닝·모의침투 주기 운영 여부 재무·보험 보험 범위와 면책 조항을 명확히 공개하는지, 준비금·준법 체계 확인 규제 준수 관할 내 라이선스·KYC/AML 의무 이행, 제재 대응 정책 보유 논커스토디얼 선택 체크리스트 백업·복구 시드 문구 오프라인 보관, 금고·내화 금속 플레이트 등 물리 보안, 복구 리허설 정기 수행 기기 보안 하드웨어 지갑 사용, 펌웨어 서명 검증, 기기 PIN·패스프레이즈 사용, 분실 시 스스로 wipe 가능한지 확인 트랜잭션 안전 서명 전 도메인 분리 정보를 기기 화면에서 직접 확인, 승인 범위·스팸 토큰·허가 영속성 점검 멀티시그·MPC 병용 단일 키 실패 지점 제거, 역할 기반 승인 정책 적용 자동화 요구 스케줄 결제·트리거 송금 등 자동화는 지갑 권한 최소화와 일회성 권한 부여로 제한 운영 베스트 프랙티스 핵심 원칙 최소 권한, 강한 인증, 분리 보관, 반복 검증 지출 정책 금액 구간별 다른 승인 경로 적용, 시간지연 타임락과 알림으로 오탐·오남용 방지 주소 화이트리스트 높은 금액은 사전 등록 주소로만 송금 모니터링 대기열 이상, 실패율 급증, 신규 승인 요청 급증, 지출 한도 임계 접근 알림 키 수명주기 관리 생성·배포·사용·보관·회수·폐기 전 과정 문서화와 정기 점검 사고 대응 유출 의심 즉시 키 회전, 멀티시그 참여자 교체, 브리지·거래소 연락망 업데이트, 법무·준법 협업 라인 확보 시나리오별 권장 아키텍처 개인 사용자 데일리 소액은 모바일 지갑 사용 장기 보관·대액은 하드웨어 지갑과 오프라인 백업 병행 승인 내역 정기 점검과 피싱 훈련 연습 권장\n소규모 팀/스타트업 운영비 지출용 커스토디얼 핫월렛 + 멀티시그 콜드 보관 회계·승인 로그를 공유 드라이브가 아닌 전용 감사 시스템에 적재\n기업·DAO 금고 MPC 기반 금고 또는 다중 하드웨어 지갑 멀티시그 역할 기반 접근제어와 오프보딩 절차, 비상 시나리오의 대체 서명자 지정\n자주 하는 실수와 교정 Shamir 분할 = 안전한 서명이라고 오해 Shamir는 복구용 비밀 분할 기법이고 서명은 수행하지 않음 서명 분산은 MPC/TSS 를 사용함 하드웨어 지갑이면 무조건 안전 펌웨어 진위 검증, 공급망 위협, 화면 검증 습관 없으면 위험이 남음 보험이 있으니 안심 보험은 조건과 면책이 많아 모든 손실을 보장하지 않음 범위·상한·예외를 반드시 확인해야 함 커스토디얼은 모두 동일 보안 수준·감사 성숙도·규제 준수·재무 건전성에 큰 차이가 있음 최소 보안 기준 가이드 개인 하드웨어 지갑 1대 이상, 시드 문구 오프라인 백업 2곳, 패스프레이즈 병행, 피싱 훈련 팀 멀티시그 M‑of‑N, 변경 승인 워크플로, 월간 복구 리허설, 화이트리스트 송금 기업 MPC 금고 또는 멀티시그 금고, HSM 또는 동급 보안 모듈, SOC 2 Type II·침투테스트, 사고 대응 플레이북 운영 간단 권장 흐름 1 단계 자산 규모 분류와 위협 모델 정의 2 단계 논커스토디얼·커스토디얼·하이브리드 중 적합 아키텍처 선정 3 단계 백업·복구 문서화와 정기 리허설 시행 4 단계 멀티시그 또는 MPC로 단일 실패 지점 제거 5 단계 지출 정책·화이트리스트·모니터링·사고 대응 체계 운영\n결론 프라이빗키 소유·통제가 보안과 편의의 출발점임 대액·장기 자산은 논커스토디얼과 멀티시그·MPC 조합이 유리하고 업무 자동화·고객 지원이 중요한 경우 커스토디얼이 효율적일 수 있음 모든 선택은 위협 모델·규정 준수·복구 요구를 기준으로 문서화하고 정기적으로 검증해야 함\n참고자료 BIP‑32 계층적 결정성 지갑 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP‑39 니모닉 문구 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP‑44 파생 경로 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki Torus Key Infrastructure 개요 https://docs.tor.us/key-infrastructure/overview NIST SP 800‑57 Part 1 키 관리 권고 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final FIPS 140‑3 암호 모듈 보안 요구사항 https://csrc.nist.gov/publications/detail/fips/140/3/final AICPA SOC 2 안내 https://www.aicpa-cima.com/resources/article/what-is-soc-2 ","permalink":"https://blog.jsontapose.com/posts/custodial-vs-noncustodial-wallets-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e프라이빗키 관리 방식에 따라 암호화폐 월렛은 \u003cstrong\u003e커스토디얼(custodial)\u003c/strong\u003e 과 \u003cstrong\u003e논커스토디얼(noncustodial)\u003c/strong\u003e 로 구분됨\n각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 \u003cstrong\u003e초보자도 이해할 수 있게\u003c/strong\u003e 정리하면서 \u003cstrong\u003e실무자가 바로 적용할 수 있는 체크리스트\u003c/strong\u003e까지 제시함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e커스토디얼 월렛\u003c/strong\u003e\n제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조\n로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e논커스토디얼 월렛\u003c/strong\u003e\n사용자가 프라이빗키를 직접 보유·관리하는 구조\n브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e핵심 차이 한 줄 정리\u003c/strong\u003e\n키의 \u003cstrong\u003e소유·통제 주체\u003c/strong\u003e가 제3자인가 사용자 본인인가의 차이\u003c/p\u003e","title":"커스토디얼 vs 논커스토디얼 월렛 비교"},{"content":"개요 블록체인은 중앙 기관 없이 참여자들이 거래를 기록·검증·공유하는 분산 원장 기술임 이 글은 블록체인을 초보자 친화적으로 설명하고, 실무 체크리스트까지 정리함\n큰 그림: 시스템 구성 노드(Node): 블록체인 소프트웨어 실행 주체\n풀노드: 모든 블록·트랜잭션 검증·저장 라이트 클라이언트: 헤더·머클 증명 기반 최소 검증 (참고) 아카이브 노드: 오래된 상태 포함 전체 상태 유지(필수 아님) 블록(Block): 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\n합의(Consensus): 어떤 블록이 정식 이력인지 네트워크가 공동으로 결정하는 규칙\nPoW: 작업증명(연산 경쟁) PoS: 지분증명(검증자·보증금 기반) 해시(Hash)와 위·변조 방지 해시 함수(SHA-256, Keccak-256 등): 입력을 고정 길이로 압축하는 일방향 함수임\n충돌 가능성은 이론상 존재하나 실무적으로 극히 낮음 입력이 조금만 바뀌어도 출력이 크게 달라져 무결성 검증에 적합 체인 무결성: 각 블록 헤더에 이전 블록의 해시가 포함됨 → 중간 블록 하나만 바꿔도 이후 전체를 재계산해야 하므로 변조 난이도 매우 높음\n블록헤더와 머클트리(데이터 구조) 블록헤더 대표 필드(비트코인 예시)\nversion, prev_block_hash, merkle_root, timestamp, bits(난이도), nonce 헤더 전체를 해시한 값이 블록 ID 역할을 함 머클트리(Merkle Tree)\n트랜잭션 목록을 해시 이진트리로 요약 → 머클루트(루트 해시) 로 대표 라이트 클라이언트는 머클 증명만 받아 특정 트랜잭션 포함 여부를 검증 가능(SPV) 거래 흐름: 생성 → 서명 → 전파 → 블록 포함 → 확정 생성: 송신자가 수신자 주소·금액으로 트랜잭션 생성 서명: 개인키로 전자서명(비대칭키: ECDSA/secp256k1 등) 전파: P2P 네트워크로 브로드캐스트 → 각 노드의 mempool 에 적재 블록 포함: 합의 규칙에 따라 트랜잭션이 블록에 포함 확정(Finality/확인수): 후속 블록이 더해질수록 되돌리기 어려움 비트코인: 평균 블록 간격 ≈ 10분, 확인수 6 관행(사용처·금액 따라 상이) 이더리움(현행 PoS): 슬롯 ≈ 12초, 체크포인트·파이널리티 개념 사용(정상 시 약 2 에폭에서 최종화, 대략 10~15분 수준). “N 블록이면 충분” 같은 단정 대신 파이널리티 달성 여부 확인이 안전함 상태 모델: UTXO vs 계정(Account) UTXO(비트코인 계열)\n“사용하지 않은 트랜잭션 출력(코인)”을 조합해 지불, 잔돈은 새 UTXO로 생성 장점: 병렬화에 유리, 프라이버시 패턴 일부 이점 유의: 선택/잔돈 전략, 수수료(단위: sat/vByte) 최적화 필요 계정 모델(이더리움 계열)\n계정 잔액·컨트랙트 상태(State) 갱신 장점: 스마트 컨트랙트·상태머신 구현 용이 유의: 상태 증가(State bloat)·가스 비용·리플레이 방지(EIP-155) 등 고려 PoW(작업증명): 난이도·보상·보안 원리: 헤더 + nonce 바꿔가며 목표값(난이도) 이하 해시 찾기 난이도 조정: 네트워크 해시파워 변화에 맞춰 목표 평균 블록 시간 유지(예: 비트코인 2016블록마다 ≈ 2주 간격 조정) 보상: 블록 보상(반감기 존재) + 수수료 보안성: 공격자는 네트워크 해시의 과반수 수준 필요 → 대형 체인에서는 경제적·물리적 비용 거대 간단 PoW 의사코드(개념 학습용)\ntarget = difficulty_to_target(bits) nonce = 0 while True: header = serialize(version, prev_hash, merkle_root, timestamp, bits, nonce) h = sha256d(header) # SHA256(SHA256(header)) if h \u0026lt; target: print(\u0026#34;Found!\u0026#34;, nonce, h.hex()) break nonce += 1 실무 팁\n해시 라이브러리·엔디언 처리·직렬화 포맷(가변 길이 정수 등) 정확도 중요 반감기 이벤트는 채굴 수익성·해시파워·보안에 직격 영향 PoS(지분증명): 검증자·파이널리티·리스크 원리: 토큰 스테이킹 으로 검증자 선정(무작위 + 지분 가중 + 추가 규칙)\n블록·어테스테이션: 검증자가 블록 제안·감사(투표) 수행\n파이널리티: 일정 조건(예: ≥ 2/3 가중치가 찬성) 만족 시 체크포인트 최종화\n위협 모델\nNothing-at-Stake: 여러 체인에 동시 투표 유혹 → 슬래싱 으로 억제 롱레인지 공격: 과거부터 조용히 대체 체인 생성 → 약한 주관성(weak subjectivity)·체크포인트·동기화 규칙으로 방어 수수료와 가스: Bitcoin vs Ethereum Bitcoin: 수수료 = 바이트 크기 × 단가(sat/vByte)\n수수료 추정은 mempool 혼잡도·정책 영향 큼 Ethereum(EIP-1559)\nBase Fee(블록에 의해 자동 조정, 소각) + Priority Fee(팁) + gas_used 사용자 입장: 예상 가능한 수수료 + 혼잡 시 팁으로 우선순위 확보 컨트랙트 호출은 가스 한도 내에서만 실행됨(한도 부족 시 revert) 포크(Fork)와 체인 재조직(Reorg) 소프트 포크: 규칙 강화로 하위 호환 유지(예: SegWit 트랜잭션 가변성 해결, 블록 용량 효율화) 하드 포크: 규칙 불일치 → 미업데이트 노드와 체인 분리 가능(예: ETH/ETC) 운영 유의\n포크 전후 송금 보수적 운영(리플레이·정책 불확실성) 거래소·지갑 대응 계획 사전 확인 자연스런 재조직(reorg) 는 드물지만 발생 가능 → 높은 가치 송금은 여유 확인수/파이널리티 확보 보안 메커니즘·공격 모델 51% 공격(PoW): 과반 해시파워로 더 긴 체인을 만들어 이중지불 가능\n대형 체인: 비용·탐지 리스크 막대 중소 체인: 실질 리스크 존재 → 심도 있는 모니터링·안전 확인수 확대 권장 네트워크 공격: 이클립스(Eclipse)·Sybil·시간 왜곡 등 → 피어 다양화·시계 동기화·피어 밴 정책 필요\n지갑·키 관리\n개인키 유출 = 자금 유출 권장: 하드웨어 지갑, 멀티시그, 콜드월렛, 백업 시 BIP39 시드 문구 별도·오프라인 보관 확장성: 온체인 한계와 오프체인/Layer2 온체인 한계: 블록 크기·주기 제약 → TPS 제한, 탈중앙화·보안·확장성(블록체인 트릴레마) 간 트레이드오프 존재\n오프체인 결제(라이트닝 네트워크)\n양자 간 결제 채널 열고 다수 거래를 오프체인 처리, 최종 상태만 온체인 정산 핵심 메커니즘: 타임락, 페널티 트랜잭션, 경로 탐색 장점: 속도·수수료 우수 / 과제: UX·유동성·라우팅 Rollup(이더리움 L2)\nOptimistic Rollup: 사기 증명 기반, 이의제기 기간 후 확정 ZK Rollup: 영지식 증명 기반, 검증 빠름(증명 생성 비용·지연 고려) 데이터 가용성(DA): L1에 핵심 데이터 또는 블롭(EIP-4844) 으로 게시 → L2 상태 재구성 가능성 확보 로드맵: 프로토-덴크샤딩(EIP-4844) → 데이터 비용 절감, 장기적으론 완전 덴크샤딩으로 확장성 개선 MEV \u0026amp; PBS(이더리움)\nMEV: 거래 재배치·추출을 통한 가치 → 사용성·공정성 이슈 PBS: 제안자/빌더 분리로 역할 분담, 중앙화·검열 리스크 완화 시도 실무 체크리스트(운영·보안·개발) 노드 운영\n최신 클라이언트·보안 패치 적용, 피어 다변화 모니터링: 블록 지연, reorg, mempool 혼잡, 디스크/네트워크 지표 지갑·키 관리\n하드웨어 지갑·멀티시그·콜드스토리지 적용 시드 백업(오프라인), 접근 통제(2인 승인 등) 스마트 컨트랙트(이더리움)\n감사(Audit)·포멀 검증·테스트넷 충분 운용 가스 최적화: 저장소 쓰기 최소화, 재진입·정수 오버플로 방지, 최신 컴파일러 사용 업그레이드 전략: 프록시 패턴·권한 관리(Owner/Role)·타임락 수수료 전략\nBitcoin: sat/vByte 동적 설정, 급행·보통·저속 정책 분리 Ethereum: EIP-1559의 maxFeePerGas/maxPriorityFeePerGas 합리 설정 포크·네트워크 이벤트 대응\n공지 수집, 송금 동결/완화 기준, 고객 안내 시나리오 준비 간단 비교 표 항목 비트코인(PoW) 이더리움(PoS, Merge 이후) 블록 간격 ~10분 슬롯 ~12초(에폭=32 슬롯) 최종성 확률적(확인수↑) 체크포인트 최종성(정상 시 2 에폭 내외) 수수료 바이트 기준(sat/vByte) EIP-1559(BaseFee 소각 + Tip) 상태 모델 UTXO 계정 + 스마트 컨트랙트 확장성 방향 SegWit·Taproot·Lightning Rollup(Optimistic/ZK) + EIP-4844 자주 틀리는 포인트 “이더리움은 N 블록이면 안전” → (X) 현재는 파이널리티 달성 여부로 판단하는 게 정확함 “PoS는 그냥 코인 많이 가진 사람 승리” → (X) 무작위성·메시지 투표·슬래싱·최종성 규칙이 결합된 프로토콜 전체가 보안 근거임 “SegWit은 리플레이 공격 방지” → (부분 부정확) 핵심 목적은 트랜잭션 가변성(malleability) 해결 및 용량 효율화임 결론 블록체인은 암호학(해시·서명), 분산합의(PoW/PoS), 네트워크 설계가 맞물린 시스템임 설계 선택(PoW vs PoS, UTXO vs 계정, 온체인 vs 오프체인)이 보안·성능·분산화에 직접 영향 실무 핵심은 키 관리·노드 보안·포크/이벤트 대응·수수료 전략·컨트랙트 품질 보증임 확장성은 Layer2 + 데이터 가용성 + 프로토콜 개선을 병행하는 다층 해법이 현실적임 참고자료 비트코인 개요: https://bitcoin.org/ko/how-it-works 비트코인 개발자 가이드(데이터 구조·프로토콜): https://developer.bitcoin.org/devguide/ 이더리움 화이트페이퍼: https://ethereum.org/en/whitepaper/ 이더리움 PoS/합의 문서: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ EIP-1559(수수료 시장): https://eips.ethereum.org/EIPS/eip-1559 EIP-4844(프로토-덴크샤딩/블롭): https://eips.ethereum.org/EIPS/eip-4844 Lightning BOLT 사양: https://github.com/lightning/bolts SegWit 개요(트랜잭션 가변성 개선): https://bitcoinops.org/en/topics/segwit/ ","permalink":"https://blog.jsontapose.com/posts/blockchain-principles-mining-hash-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인은 \u003cstrong\u003e중앙 기관 없이\u003c/strong\u003e 참여자들이 거래를 기록·검증·공유하는 \u003cstrong\u003e분산 원장\u003c/strong\u003e 기술임\n이 글은 블록체인을 \u003cstrong\u003e초보자 친화적으로\u003c/strong\u003e 설명하고, \u003cstrong\u003e실무 체크리스트\u003c/strong\u003e까지 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"큰-그림-시스템-구성\"\u003e큰 그림: 시스템 구성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e노드(Node)\u003c/strong\u003e: 블록체인 소프트웨어 실행 주체\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e풀노드\u003c/strong\u003e: 모든 블록·트랜잭션 검증·저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트 클라이언트\u003c/strong\u003e: 헤더·머클 증명 기반 최소 검증\u003c/li\u003e\n\u003cli\u003e(참고) \u003cstrong\u003e아카이브 노드\u003c/strong\u003e: 오래된 상태 포함 전체 상태 유지(필수 아님)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e블록(Block)\u003c/strong\u003e: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e합의(Consensus)\u003c/strong\u003e: 어떤 블록이 정식 이력인지 네트워크가 \u003cstrong\u003e공동으로\u003c/strong\u003e 결정하는 규칙\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoW: 작업증명(연산 경쟁)\u003c/li\u003e\n\u003cli\u003ePoS: 지분증명(검증자·보증금 기반)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해시hash와-위변조-방지\"\u003e해시(Hash)와 위·변조 방지\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 함수(SHA-256, Keccak-256 등)\u003c/strong\u003e: 입력을 고정 길이로 압축하는 일방향 함수임\u003c/p\u003e","title":"블록체인이란? 블록체인 개념 총정리"},{"content":"개요 이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함 개념 정의에 그치지 않고 운영 시 주의점, 보상·출금 흐름, 짧은 체인 재구성(Reorg) 원인과 완화책까지 다룸\n개념과 배경 PoS는 PoW의 에너지 경쟁을 대체해 예치된 지분을 바탕으로 검증자를 선정하는 합의 메커니즘임 이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 검증자 기반 보안 모델로 이행함\n주요 속성 요약\n에너지 소비 대폭 축소 스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨 위반 시 슬래싱과 페널티로 예치금이 감소함 계층 분리와 Beacon Chain의 역할 이더리움은 합의 계층(Beacon Chain) 과 실행 계층(Execution Layer) 를 분리해 설계함\n실행 계층은 트랜잭션 처리와 EVM 실행을 담당함 Beacon Chain은 시간 관리와 역할 배정, 투표 집계, 최종성 판단을 담당함 Beacon Chain의 핵심 기능\n슬롯과 에포크라는 통일된 시간 프레임 제공 매 슬롯의 블록 제안자와 증명자 배정 증명자 투표를 집계해 정당한 체인과 최종성을 결정함 이 분리는 클라이언트 다양성 확보와 확장 로드맵에 유리한 아키텍처 선택임\n시간 구조와 동작 단위 슬롯(slot)\n블록 제안이 가능한 최소 시간 단위 1 슬롯 = 12초 슬롯마다 1명의 제안자만 지정됨 제안자가 제때 블록을 제안하지 못하면 슬롯 미스로 간주하고 빈 슬롯이 될 수 있음 에포크(epoch)\n1 에포크 = 32 슬롯 ≈ 6분 24초 에포크 단위로 위원회 재편성, 랜덤 시드 갱신, 최종성 관련 집계가 이뤄짐 에포크는 체크포인트 역할을 하며 최종성 로직의 기준 단위로 사용됨 검증자와 스테이킹 규칙 최소 32 ETH를 예치해야 정식 검증자가 됨 한 검증자 계정에 반영되는 유효 예치 상한은 32 ETH임 더 많은 ETH를 운용하려면 32 ETH 단위로 여러 검증자를 운영해야 함 검증자 활성·비활성 전환에는 대기 큐와 지연이 존재함 보상 기회는 전체 검증자 대비 보유 검증자 수에 비례해 증가함 예를 들어 64 ETH로 두 검증자를 운영하면 제안·투표 참여 기회가 대략 두 배가 됨\n제안자(Proposer)와 증명자(Attester) 매 슬롯 한 명의 제안자가 블록을 제안함 다수의 증명자가 해당 블록에 대해 attestation 을 제출함 검증자들은 여러 위원회(committee) 로 무작위 배정되어 병렬로 검증을 수행함 집계된 투표는 포크 선택과 최종성 판단에 사용됨 위원회 구조의 목적은 검증 부담 분산 과 독립 다중 관측 을 통해 안전성과 처리량을 동시에 확보하는 것임\n무작위성과 검증자 배정 이더리움은 RANDAO 믹스 를 사용해 예측이 어렵고 조작에 강한 난수를 생성함 역사적으로 VRF나 VDF 같은 대안이 거론되었으나 현재 메인넷은 RANDAO 기반을 사용함 생성된 난수는 차기 에포크의 제안자·위원회 배정에 활용됨 특정 주체가 지속 우선 선정되는 편향을 줄이는 것이 목표임 포크 선택과 최종성 개요 포크 선택은 LMD‑GHOST 를 기반으로 하며 최신 메시지를 반영해 가장 무거운 서브트리를 선택함 짧은 지연으로 더 나은 블록을 선택하도록 proposer boost 가 도입되어 reorg 위험을 줄임 최종성은 Casper FFG 를 통해 에포크 수준 체크포인트를 정당화·최종화함 일정 이상 검증자 참여가 확보되면 체크포인트가 finalized 상태가 되어 경제적으로 되돌리기 매우 어려워짐 보상과 벌칙의 구조 보상 항목\n블록 제안 보상 제안자가 유효 블록을 포함할 때 수취 증명 보상 attestation을 정확하고 신속하게 제출한 검증자에게 지급 동기화 위원회 보상 라이트 클라이언트 지원을 위한 서명 참여 검증자에게 지급 벌칙과 슬래싱\n오프라인이나 지연 제출 등에는 경미한 페널티 가 부과됨 체인이 장기간 미파이널리티 상태에 빠지면 inactivity leak 이 발생해 페널티가 점진적으로 커짐 슬래싱 은 이중 제안 혹은 이중·감싸기 투표 같은 안전성 위반에 적용되며 금액과 네트워크 상황에 따라 손실이 커질 수 있음 동일 키를 여러 노드에서 가동하면 슬래싱 위험이 급증하므로 금지해야 함 보상 규모와 페널티는 전체 활성 예치 규모와 참여율 등 네트워크 상태에 따라 동적으로 변함\n출금과 인출 흐름 2023년 상반기 업그레이드 이후 출금 기능 이 활성화됨 부분 출금 은 32 ETH 초과분이 자동으로 실행 계층의 출금 주소로 전달됨 완전 출금 은 검증자가 정상 종료를 통해 활성 집합에서 빠진 뒤 전 잔액을 인출하는 흐름임 출금 처리는 블록당 포함 가능한 수가 제한되어 있어 대기 지연이 발생할 수 있음 출금 주소 유형과 자격 전환이 올바르게 설정되어 있어야 자동 처리가 가능함 운영 포인트\n출금 대기 시간과 큐 상태를 모니터링해 유동성을 관리함 출금 주소 관리 실수를 방지하기 위해 변경 절차를 문서화하고 검증 절차를 둠 Reorg가 발생하는 이유와 완화책 Reorg는 PoS에서도 짧은 길이 로 발생할 수 있음 주요 원인\n블록·attestation 전파 지연으로 노드 간 관측 차이가 발생함 슬롯 미스 이후 후속 제안자가 다른 선행 상태를 기준으로 블록을 만들 수 있음 노드 시간 동기화 불량이나 리소스 병목으로 처리 지연이 발생함 완화책\n시간 동기화는 chrony 등으로 정확히 유지함 고품질 피어 확보와 충분한 피어 수를 유지하고 네트워크 지연을 최소화함 최신 클라이언트와 다양한 클라이언트 조합으로 클라이언트 다양성 을 보장함 proposer boost와 attest 포함 지연 지표를 모니터링해 파라미터와 인프라를 튜닝함 대부분의 reorg는 1~2 블록에서 수렴하며 최종성 규칙으로 빠르게 안정화됨\n운영 체크리스트 노드와 인프라\n최신 합의·실행 클라이언트 유지 피어 수·지연·대역폭·디스크 IOPS 모니터링 장애를 분리하기 위해 실행·합의 클라이언트의 조합을 다양화함 키 관리\n슬래싱 방지 파일과 원격 서명기 사용 시 중복 서명 방지 설정 확인 단일 실패 지점 제거를 위해 핫·백업 구성과 자동 페일오버를 명확히 구분함 키 백업과 복구 절차를 오프라인으로 주기 점검함 운영 정책\n32 ETH 단위로 검증자를 수평 확장해 장애 격리와 보상 변동성을 줄임 모니터링 지표를 표준화함 참여율, attestation 포함 거리, 미스 슬롯, reorg 발생률, 동기화 위원회 가동률, 출금 큐 길이 등 MEV‑Boost 사용 시 릴레이 다양화와 로컬 빌더 폴백을 준비해 가용성과 검열 리스크를 낮춤 위험과 중앙화 고려 거대 스테이킹 풀과 커스터디 집중은 검열·단일 실패 지점 위험을 키움 클라이언트 다양성 부족은 버그 발생 시 네트워크 안정성을 해칠 수 있음 리퀴드 스테이킹 파생상품은 유동성을 제공하지만 의사결정 집중과 딜레마를 유발할 수 있음 정책과 거버넌스, 릴레이·빌더 다양화, 커뮤니티 모니터링으로 리스크를 분산해야 함 마무리 이더리움 PoS는 RANDAO 기반 무작위성, LMD‑GHOST 포크 선택, Casper FFG 최종성, 검증자 보상·벌칙 체계 를 결합해 에너지 효율과 보안을 동시에 달성하려는 설계임 운영자는 시간 동기화와 피어 품질, 키 관리, 클라이언트 다양성, 보상·출금 파이프라인을 지속적으로 점검해야 함 짧은 reorg는 네트워크 현실에서 발생할 수 있으나 적절한 인프라와 파라미터 튜닝, 최신 클라이언트 운용으로 빈도와 영향을 최소화할 수 있음\n참고자료 이더리움 PoS 개요 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos 합의 사양과 가스퍼 개요 https://github.com/ethereum/consensus-specs EIP‑4895 출금과 Capella 업그레이드 참고 https://eips.ethereum.org/EIPS/eip-4895 합의 계층 클라이언트와 실행 계층 클라이언트 목록 https://ethereum.org/en/developers/docs/nodes-and-clients MEV‑Boost 운영 가이드 참고 https://www.flashbots.net ","permalink":"https://blog.jsontapose.com/posts/ethereum-pos-proof-of-stake-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함\n개념 정의에 그치지 않고 \u003cstrong\u003e운영 시 주의점\u003c/strong\u003e, \u003cstrong\u003e보상·출금 흐름\u003c/strong\u003e, \u003cstrong\u003e짧은 체인 재구성(Reorg) 원인과 완화책\u003c/strong\u003e까지 다룸\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003ePoS는 PoW의 에너지 경쟁을 대체해 \u003cstrong\u003e예치된 지분을 바탕으로 검증자를 선정\u003c/strong\u003e하는 합의 메커니즘임\n이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 \u003cstrong\u003e검증자 기반 보안 모델\u003c/strong\u003e로 이행함\u003c/p\u003e\n\u003cp\u003e주요 속성 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에너지 소비 대폭 축소\u003c/li\u003e\n\u003cli\u003e스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨\u003c/li\u003e\n\u003cli\u003e위반 시 슬래싱과 페널티로 예치금이 감소함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"계층-분리와-beacon-chain의-역할\"\u003e계층 분리와 Beacon Chain의 역할\u003c/h3\u003e\n\u003cp\u003e이더리움은 \u003cstrong\u003e합의 계층(Beacon Chain)\u003c/strong\u003e 과 \u003cstrong\u003e실행 계층(Execution Layer)\u003c/strong\u003e 를 분리해 설계함\u003c/p\u003e","title":"이더리움 PoS(Proof of Stake) 소개"},{"content":"개요 NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 리빌, 에어드롭, 화이트리스트, 마켓플레이스를 실무 관점으로 정리함 핵심은 개념 이해를 넘어 운영 체크리스트, 보안 리스크, 가격 형성 메커니즘까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\n공통 전제와 기본 개념 NFT 표준 주로 ERC‑721과 ERC‑1155를 사용함 721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\n메타데이터와 저장소 토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장 중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\n로열티 EIP‑2981 표준이 존재하나 집행은 마켓별 정책에 의존하는 경향이 있음 창작자 수익 분배 구조를 미리 확인 필요\n리빌 Reveal 정의 민팅 직후에는 공통 플레이스홀더 이미지를 노출하고, 이후 시점에 각 토큰의 최종 속성·이미지를 공개하는 절차를 말함\n왜 쓰는가\n판매 초기의 기대감 형성과 공정한 희소성 배분 유도 초반 스니핑을 줄이고 커뮤니티 이벤트와 연동하기 위함 가격 형성상 특징\n리빌 전에는 외형과 속성이 같아 보여 가격 수렴이 발생하기 쉬움 리빌 후에는 속성 조합·희소성에 따라 재평가가 빠르게 진행됨 희귀 속성은 프리미엄이 붙고 평범 속성은 하방 압력이 커지는 패턴이 일반적임 공정성·신뢰 장치\n프로비넌스 해시 공개로 민팅 전 전체 순서를 커밋해 치환·조작 가능성을 낮춤 메타데이터 동결과 BaseURI 고정으로 리빌 후 임의 수정 리스크 축소 온체인 또는 영속 스토리지에 최종 자료 고정 운영 체크리스트\n리빌 시점, 방식(일괄·구간·랜덤 시프트), 프로비넌스 공개 여부 확인 메타데이터 저장소와 동결 계획 점검 리빌 직후 가격 변동성 대비 유동성 전략 수립 에어드롭 Airdrop 정의 NFT 또는 토큰을 무상 배포해 초기 유입과 참여 보상을 유도하는 방식\n유형\n푸시형 프로젝트가 직접 전송 클레임형 스냅샷 기준 자격자에게 기간 내 청구 권한 부여 조건형 소셜 참여, 보유 토큰, 온체인 행위 등 조건을 충족해야 함 비용과 유동성\n가스 부담 주체가 누구인지 확인 필요 수령 자산의 2차 유동성 가능성과 잠금 조건 여부 확인 보안 체크리스트\n개인키·시드 문구 요청은 100% 사기 setApprovalForAll 무제한 승인 요구, 임의 Permit 서명 요구, 낯선 도메인의 서명 팝업에 주의 의심 에어드롭은 더스팅 공격 가능성 고려, 상호작용 자체를 피하는 것이 안전한 경우 많음 현실적 기대치\n극소수 성공 사례를 제외하면 무료 배포물의 평균 가치는 시간 경과에 따라 하락하는 경향 로드맵, 팀 신뢰도, 파트너십, 토큰 설계까지 종합 평가 필요 화이트리스트 Allowlist 정의 특정 지갑에게 민팅 우선권을 부여하는 명단을 의미하며 줄여서 화리라 부름 포용적 표현으로 Allowlist 용어를 쓰는 프로젝트가 많음\n부여 방식\n커뮤니티 기여, 미션, 추천, 보유 토큰 기반 토큰 게이팅 온체인 머클 증명으로 명단을 검증해 가스·데이터 비용을 절감 타입\n보장형 배정량이 확정되어 민팅 시점에 구매 가능 경쟁형 FCFS나 시간 창을 두어 네트워크 상태·속도에 따라 성공 여부가 갈림 래플형 추첨으로 공정 배분 시도 실무 체크리스트\n1인당 구매 한도, 민팅가, 시간 창, 체인·네트워크 확인 가스 워 방지 장치 유무 확인(쿨다운, 랜덤 시프트, 캡) 어뷰징·봇 통제 정책 확인, 위반 시 박탈 규정 숙지 주의\nAllowlist를 과다 남발하는 프로젝트는 민팅 종료 후 가격 하락 리스크가 크므로 유통 설계와 수요 검증 필요 NFT 마켓플레이스 역할 NFT의 가시화, 매매, 오더북을 제공하는 플랫폼을 의미함 글로벌로 OpenSea, Blur, Rarible 등이 대표적이며 국내에는 Klip Drops, 업비트 NFT 등이 존재함\n거래 방식\n고정가 리스팅 판매자가 원하는 가격 제시 경매형 영국식 상승 경매, 더치 경매 등 변형 포함 오퍼 특정 토큰 혹은 전체 컬렉션에 대한 구매 제안 접수 집계기가 여러 거래소의 유동성을 묶어 더 나은 가격·체결 속도를 제공하기도 함 핵심 지표와 해석 요령\n바닥가 Floor 컬렉션 내 최저 매물가이나 거래된 가격이 아님 얕은 호가에 의해 왜곡 가능하므로 체결 이력, 호가 두께, 분포를 함께 보아야 함 체결량·보유 분포 단기 매물 출회 압력과 고래 집중도 파악에 유용함 워시 트레이딩 자기계약 간 거래로 볼륨 부풀리기가 발생할 수 있어 탐지 지표 참고 필요 수수료와 로열티\n마켓 수수료와 창작자 로열티 정책이 거래소마다 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 선택적인 경우가 많아 실제 지급 여부를 확인해야 함 보안과 권한 관리\n판매 전 부여한 무제한 승인은 거래 후 revoke 툴로 회수 권장 피싱 도메인과 서명 위임 요청에 대한 교육이 필수 플랫폼 선택 기준\n유동성 규모, 수수료 구조, 지원 체인, 커뮤니티 활성도, 집계기 연동 여부, 로열티 정책 일관성 확인 빠른 판단 가이드 리빌 일정과 프로비넌스 공개, 메타데이터 동결 계획을 먼저 확인 에어드롭 은 개인키·시드·무제한 승인 요구 시 즉시 중단 화이트리스트 는 한도·가격·시간 창과 검증 방식(머클) 확인 마켓플레이스 는 바닥가만 보지 말고 체결 이력·호가 두께·수수료·로열티 정책까지 함께 판단 예시 시나리오 개인 사용자 민팅 직후 리빌 전 거래는 변동성 대비 효익이 낮을 수 있어 리빌 일정 확인 후 접근 수령한 에어드롭은 승인 요청이 없는지 먼저 점검하고 필요 시 상호작용을 피함 프로젝트 운영자 머클 기반 Allowlist와 프로비넌스 커밋으로 신뢰 확보 메타데이터 동결과 영속 스토리지 사용으로 변경 리스크 최소화 워시 트레이딩 방지 메시지와 리스팅 교육 자료를 함께 제공 마무리 리빌은 가치 재평가의 계기 에어드롭은 초기 분배와 참여 보상 수단 화이트리스트는 수요 조절과 공정 배분 장치 마켓플레이스는 가격 발견과 유동성의 장 각 제도의 의도·설계·리스크를 이해하고 보안 수칙을 지키면 의사결정의 품질을 높일 수 있음\n참고자료 ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 OpenZeppelin Merkle 증명 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography Ethereum 개발자 문서 NFT 개요 https://ethereum.org/en/developers/docs/standards/tokens/ 추가 읽을거리 https://magazine.cheil.com/51780 ","permalink":"https://blog.jsontapose.com/posts/nft-23q12akw/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 \u003cstrong\u003e리빌\u003c/strong\u003e, \u003cstrong\u003e에어드롭\u003c/strong\u003e, \u003cstrong\u003e화이트리스트\u003c/strong\u003e, \u003cstrong\u003e마켓플레이스\u003c/strong\u003e를 실무 관점으로 정리함\n핵심은 개념 이해를 넘어 \u003cstrong\u003e운영 체크리스트\u003c/strong\u003e, \u003cstrong\u003e보안 리스크\u003c/strong\u003e, \u003cstrong\u003e가격 형성 메커니즘\u003c/strong\u003e까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"공통-전제와-기본-개념\"\u003e공통 전제와 기본 개념\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNFT 표준\u003c/strong\u003e\n주로 ERC‑721과 ERC‑1155를 사용함\n721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메타데이터와 저장소\u003c/strong\u003e\n토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장\n중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\u003c/p\u003e","title":"NFT 핵심 용어 정리"},{"content":"서문 NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움 이 글은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고 구매·발행·보관 시 유의사항과 운영 관행을 담는 것을 목표로 함\n개념과 배경 NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함 동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 고유 식별자와 속성을 가져 상호 교환 시 동일 가치를 보장하지 않음 블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음 온체인 소유권이 저작권·초상권 등 법적 권리와 자동 동치가 아님에 유의해야 함\nNFT는 보통 세 요소로 이해하면 실무에 유리함\n디지털 미디어 이미지·영상·음원·게임 아이템 등 사용자에게 보이는 대상 메타데이터 이름·설명·속성·미디어 링크를 담은 JSON 문서 스마트컨트랙트 발행·이전 규칙을 구현한 코드로 표준은 주로 ERC‑721과 ERC‑1155를 사용함 대부분의 프로젝트는 미디어 파일을 체인 밖에 보관하고 메타데이터에 링크를 넣는 오프체인 저장을 택함 장기 보존성을 위해 IPFS·Arweave 같은 영속형 스토리지 사용과 메타데이터 동결 계획이 중요함\n메인넷과 인프라 이해 NFT는 이더리움·폴리곤·솔라나·클레이튼 등 메인넷 혹은 L2 위에서 발행·거래됨 거래 실행에는 가스비가 들며 이더리움은 EIP‑1559 기반의 베이스피와 우선순위 팁 구조를 가짐 네트워크 상태와 우선순위 설정에 따라 체결 속도와 비용이 크게 달라짐 거래와 토큰 상태는 블록 탐색기에서 확인 가능하며 예시는 이더스캔과 클레이튼 스코프 등이 있음\n체인별 계약 주소·체인 ID가 다르므로 피싱 사이트가 제시하는 계약을 탐색기에서 교차 확인하는 습관이 필요함 브리징과 크로스체인 전송 시에는 락 앤 민트 모델·메시지 지연·브리지 보안을 이해하고 한도·대기 시간을 고려해야 함\n지갑과 보안 지갑은 주소와 그 주소를 통제하는 프라이빗 키·시드 문구를 관리함 메타마스크·카이카스 같은 브라우저 확장형은 편리하지만 핫월렛이라 위험 노출이 큼 대액·장기 보관 자산은 하드웨어 지갑에 두고 일상 거래는 별도 소액용 지갑을 쓰는 분리 보관이 권장됨\n시드 문구 보관 원칙\n오프라인 백업과 물리 분산 보관 사진·클라우드·메신저 업로드 금지 테스트 복구 절차를 정기 수행 권한과 서명 보안\n웹사이트 연결 시 도메인·체인·요청 권한을 확인하고 setApprovalForAll 무제한 승인은 꼭 필요한 범위에만 부여 거래가 아닌 서명 요청도 자산 이전 권한을 위임할 수 있으니 상세를 읽고 필요 시 거부 사용이 끝난 승인 권한은 권한 취소 도구로 주기적으로 회수 민팅 Minting 실무 절차 민팅은 메타데이터와 미디어 링크를 컨트랙트에 기록해 토큰을 새로 발행하는 행위 민팅이 체인에 포함되면 이벤트 로그에서 Transfer 이벤트의 From 주소가 0x0000000000000000000000000000000000000000 로 표시되는 것이 일반적임\n두 가지 맥락을 구분하면 혼동이 줄어듦\n프로젝트 관점 컨트랙트를 배포하고 토큰을 생성하는 개발·운영 작업 구매자 관점 민팅 페이지에서 최초 구매에 참여하는 행위 민팅 유형과 운영 포인트\n퍼블릭 민팅 누구나 가능하며 인기 컬렉션은 즉시 매진되므로 가스 전략과 자동화 대비가 필요 프라이빗 민팅 Allowlist 사전 등록 지갑만 참여 가능하며 일반적으로 가격·수량·시간 창이 별도로 정의됨 무료 민팅 민팅가는 0이지만 가스비가 들며 사후 로열티·수수료 구조를 확인해야 함 민팅 전 체크리스트\n계약 주소·체인·민팅가·한도·시간 창을 공지와 탐색기에서 이중 확인 메타데이터 저장 방식과 리빌·프로비넌스 계획을 확인 페이지가 제시하는 컨트랙트 소스 공개·감사 여부 확인 가스비 상한과 우선순위 팁을 과도하게 올려 불필요한 낭비가 없도록 시뮬레이션 마켓플레이스와 2차 거래 오픈씨·블러·라리블 등 마켓플레이스에 지갑을 연결해 리스팅과 오퍼를 관리함 주요 거래 방식은 고정가 리스팅·경매·컬렉션 오퍼 등이 있으며 유동성은 거래소마다 상이함\n가격 해석과 유의점\n바닥가 floor 는 현재 최저 매물가일 뿐 실제 체결가가 아님 체결 이력·호가 두께·보유 분포를 함께 봐야 수급을 판단할 수 있음 워시 트레이딩 으로 볼륨이 부풀려질 수 있으므로 비정상 패턴에 주의 로열티와 수수료\n마켓 수수료 와 크리에이터 로열티 정책은 플랫폼별로 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 거래소 정책에 의존하는 경우가 많음 실제 로열티 지급 여부와 비율을 거래 전 확인 필요 권한과 보안\n리스팅 과정에서 부여한 무제한 승인은 판매 종료 후 회수 권장 낯선 도메인의 서명 팝업과 필드가 비정상적으로 긴 메시지는 피싱 징후일 수 있음 메타데이터·저장·리빌 운영 메타데이터 는 ERC‑721 메타데이터 스펙의 name·description·image·attributes 필드를 따르는 것이 일반적 저장소 는 IPFS·Arweave 같이 링크 무결성과 장기 보존에 유리한 방식을 권장 리빌 은 발행 직후 플레이스홀더를 제공하고 이후 속성을 공개하는 절차로 가격 재평가가 일어남 조작 의심을 줄이기 위해 프로비넌스 해시 공개·랜덤 시드·베이스 URI 잠금 같은 신뢰 장치를 제공하는 것이 실무 베스트 프랙티스임 운영·커뮤니티 관행과 실무 팁 프로젝트 운영자 관점\n컨트랙트 소스 공개와 보안 감사 진행 Allowlist를 머클 증명으로 검증해 가스와 데이터 비용을 절감 봇 완화를 위한 레이트 리밋·쿨다운·인증을 설계 리빌 일정·기준·랜덤 방식과 메타데이터 동결 계획을 사전 공지 로열티 정책을 명확히 하고 플랫폼별 집행 차이에 대한 안내 제공 구매자·보유자 관점\n리빌 전후의 가격 변동성과 유동성 얕음에 대비 권한 관리와 피싱 방지 교육을 습관화 브리지·체인 전환 전에는 수수료·지연·보안 리스크를 점검 에어드롭·민팅 DM은 대부분 피싱일 가능성이 높으므로 공식 채널만 신뢰 빠른 점검 체크리스트 계약 주소·체인·민팅가·수량 한도·시간 창 교차 확인 메타데이터 저장소와 리빌·프로비넌스 공개 여부 확인 마켓 수수료·로열티 정책·체결 이력과 호가 두께 확인 권한 부여 최소화와 사용 후 권한 회수 습관 유지 시드 문구 오프라인 분산 보관과 정기 복구 테스트 수행 마무리 NFT는 표준·메타데이터·컨트랙트 권한·저장 전략이 서로 맞물려 동작하는 생태계임 개념을 이해하는 것만으로는 부족하며 보안과 운영 절차를 마련해야 실전에서 손실을 줄일 수 있음 민팅·거래·보관 단계별로 위의 체크리스트를 적용하면 의사결정 품질을 안정적으로 끌어올릴 수 있음\n참고자료 Etherscan 블록 탐색기 https://etherscan.io Klaytn Scope 블록 탐색기 https://scope.klaytn.com OpenSea 마켓플레이스 https://opensea.io MetaMask 지갑 https://metamask.io ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 Ethereum 개발자 문서 토큰 표준 개요 https://ethereum.org/en/developers/docs/standards/tokens Klaytn 개발자 문서 https://docs.klaytn.foundation ","permalink":"https://blog.jsontapose.com/posts/nft-concept-20gd0fl/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003eNFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움\n이 글은 \u003cstrong\u003e실무자 관점\u003c/strong\u003e에서 NFT의 핵심 개념을 단계적으로 정리하고 \u003cstrong\u003e구매·발행·보관 시 유의사항\u003c/strong\u003e과 \u003cstrong\u003e운영 관행\u003c/strong\u003e을 담는 것을 목표로 함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eNFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함\n동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 \u003cstrong\u003e고유 식별자와 속성\u003c/strong\u003e을 가져 상호 교환 시 동일 가치를 보장하지 않음\n블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음\n온체인 소유권이 \u003cstrong\u003e저작권·초상권 등 법적 권리와 자동 동치가 아님\u003c/strong\u003e에 유의해야 함\u003c/p\u003e","title":"NFT란? NFT 핵심 개념 정리"}]