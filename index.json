[{"content":"개요 Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표 ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구 핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\n배경과 목적 이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼 저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적 L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것 ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\n핵심 개념 Layer 2\nL1의 합의와 보안을 상속받아 트랜잭션을 오프체인에서 처리한 후 압축된 증거를 L1에 제출하는 확장 계층 목표는 가스 비용 절감, TPS 증가, 빠른 최종성 확보 ZK Rollup\n트랜잭션 배치를 실행한 결과가 올바름을 증명하는 유효성 증명 제출 방식 모든 원시 트랜잭션 데이터를 L1에 게시하지 않고 상태 변화의 유효성만 증명하여 확정 가능 Optimistic Rollup 대비 사후 분쟁 윈도우 감소, 빠른 확정성 기대 ZK Stack\nZK Rollup을 구성하기 위한 오픈 프레임워크 시퀀서, 증명기, 검증 계약, 데이터 가용성, 브리징 등 구성요소를 모듈 단위로 조립하는 설계 지향 데이터 가용성과 EIP-4844\n상태 차이와 배치 관련 데이터를 블롭 형태로 게시하여 비용 효율을 높이는 전략 블롭 데이터는 일정 기간 보존되며, 검증과 재구성에 필요한 최소 요건 충족을 목표 동작 원리와 구조 트랜잭션 수명주기 개요 사용자가 JSON-RPC를 통해 L2 네트워크로 트랜잭션 제출, 멤풀 적재 시퀀서가 트랜잭션을 실행해 블록화 후 배치 생성 사용자에게 즉시 실행 응답 반환 가능, 최종성은 L1 커밋·검증 후 확보 배치가 L1로 전송되어 데이터 가용성 보장 상태로 커밋됨 ZK 증명이 생성되어 L1 검증 계약에서 확인됨 검증 완료 후 배치 실행 확정, 상태 루트와 로그가 온체인 기준으로 고정 L1 상호작용 단계 커밋 단계\n시퀀서가 L1 롤업 컨트랙트에 배치 커밋 호출 수행 EIP-4844 블롭을 통해 상태 차이 등 필요한 데이터의 가용성 보장 증명 단계\n배치 실행의 유효성을 ZK 증명으로 생성하여 L1에 제출 검증 계약이 증명을 확인하여 상태 전이의 정당성 확립 실행 단계\n검증 완료 즉시 배치가 확정 처리되며, L2 로그를 포함한 머클 구조가 저장됨 구성 요소 Sequencer 계층\nRPC 서비스: 트랜잭션 제출, 상태 조회 등 API 제공 Sequencer: 트랜잭션 정렬·실행·블록화, 검증 제약을 준수하는 실행 파이프라인 유지 L1 연동 오퍼레이터: 입금, 업그레이드 등 L1 이벤트 동기화 및 배치 커밋 전송 역할 Prover \u0026amp; Verifier 파이프라인\n증인 생성 단계: 거래 세부 공개 없이 유효함을 입증하기 위한 데이터 구성 회로 실행 단계: VM 실행의 정합성을 검증하는 회로를 기준으로 증명 생성 및 검증 수행 연산 코드, 스토리지 상호작용, 사전컴파일 통합 등을 포함하는 실행 정합성 보장 목표 배치 전체를 순회하며 최종 상태 루트까지의 업데이트 일관성 확인 증명 압축 단계: L2에서 생성된 큰 STARK류 증명을 소형 SNARK류로 압축하여 L1 검증 비용 절감 L1 Rollup Contracts\n블롭을 사용해 상태 차이와 압축된 바이트코드 저장 유효성 증명 수신·검증 L1↔L2 메시징과 브리징 지원 네이티브 계정 추상화 Abstract의 모든 계정은 스마트 컨트랙트 계정으로 동작하며 동일한 트랜잭션 수명주기 준수 EOA와 CA 이원화 대신 IAccount 인터페이스 기반의 단일 모델 적용 EOA 지갑으로 서명해도 실행 경로에서는 기본 계정 구현체로 변환되어 처리됨 가스 지불은 본인 또는 페이마스터를 통해 유연하게 수행 가능\n트랜잭션 플로우 제출\nJSON-RPC로 트랜잭션 제출, 멤풀 적재 from 필드를 스마트 컨트랙트 계정 주소로 설정 가능 부트로더 처리\n멤풀에서 트랜잭션을 읽어 배치 단위로 처리 NonceHolder 시스템 컨트랙트 질의로 nonce 사용 여부 확인 from 주소에 코드가 없으면 기본 계정 구현으로 해석해 실행 경로 표준화 스마트 컨트랙트 계정 검증·실행\nvalidateTransaction 호출로 실행 허용 여부 판단 및 접근 제어 수행 executeTransaction 호출로 실제 실행 경로 진입 payForTransaction 또는 prepareForPaymaster 호출로 가스 지불 경로 선택 페이마스터 경로 선택적 수행\nvalidateAndPayForPaymasterTransaction 호출로 후원 여부 결정 및 가스 지불 집행 postTransaction 훅으로 사후 처리 로직 수행 가능 스마트 컨트랙트 지갑 설계 포인트 IAccount 인터페이스 구현 기반 표준 동작 확보 onlyBootloader 제약으로 부트로더 외 호출 차단 컨트랙트 배포는 시스템 컨트랙트를 통한 isSystemCall 경로 사용 효율적 실행을 위한 저수준 호출 라이브러리 활용 권장 가스 지불은 부트로더에 직접 지불 또는 페이마스터 입력 처리 함수 사용 Nonce 관리 트랜잭션 시작 전 NonceHolder 시스템 컨트랙트의 validateNonceUsage 호출로 중복 사용 방지 유효성 검사 단계에서 nonce를 소비 처리해야 함 옵션\nminNonce 증가로 해당 값 미만 nonce 일괄 사용 처리 setValueUnderNonce를 통해 특정 nonce 슬롯에 0이 아닌 값 기록 편의 메서드 incrementMinNonceIfEquals 사용 권장 NonceHolder 호출에는 트랜잭션의 isSystem 플래그 설정 필요, 시스템 호출 유틸 사용 권장 서명 검증과 EIP-1271 스마트 컨트랙트 계정은 EOA와 달리 고정 서명 검증 로직이 없으므로 EIP-1271 구현 권장 isValidSignature를 통해 임의 로직으로 서명 유효성 판단 가능, EIP-712 타입 데이터 서명과 결합 시 사용자 경험 및 보안 개선 기대\ncontract ERC1271 { // bytes4(keccak256(\u0026#34;isValidSignature(bytes32,bytes)\u0026#34;)) bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature( bytes32 _hash, bytes memory _signature ) public view returns (bytes4 magicValue) {} } Paymaster 개념 다른 계정을 대신해 가스비를 지불하는 스마트 컨트랙트 역할 IPaymaster 인터페이스 준수 필수 계정 소유자의 가스비 직접 지불을 대체해 비용 스폰서십, 토큰 기반 가스 지불 등 사용성 개선 제공 실행 경로에서는 prepareForPaymaster 이후 paymaster가 검증과 결제를 수행 오남용 방지를 위한 한도·쿨다운·화이트리스트 정책 필요\nAGW(Abstract Global Wallet) 개요 네이티브 계정 추상화를 전제로 한 사용자 온보딩 레이어 이메일, 소셜, 패스키 등 친숙한 로그인으로 최초 가입 후 동일 계정으로 트랜잭션 생성 가능 핵심은 서명자 관리와 복구, 다중 서명자, 가스 스폰서십 등 계정 수명주기 운영을 일관된 UX로 제공하는 것\nAGW 작동 방식 1단계 EOA 생성 사용자 로그인 방식을 통해 내부적으로 EOA 생성 2단계 스마트 컨트랙트 지갑 배포 배포 초기화 시 1단계 EOA를 승인된 서명자로 등록 이후 단계 서명자 추가·삭제, 패스키 기반 서명자 등록, 모듈 확장 등 계정 운영 기능 사용 스마트 컨트랙트 지갑은 네이티브 1급 시민으로 동작하며, 기본 곡선인 secp256k1 중심 운영 권장 패스키 확장 시 secp256r1 서명자 지원 가능, EIP-712 기반 서명 검증 로직 조합 권장\n스마트 지갑 기능 모듈 예 복구 모듈 이메일 복구, 가디언 복구 등 키 분실 시 계정 복원 경로 제공 페이마스터 연동 트랜잭션 가스비 후원, 특정 토큰 지불 라우팅 구성 다중 서명자 역할 기반 서명 정책, 임계값 승인 정책 확장 패스키 지원 FIDO 기반 기기 서명자를 지갑에 연결해 무서버 키 경험 제공 주의 사항과 트레이드오프 데이터 가용성 비용\n블롭 가격은 네트워크 수요에 따라 변동, 배치 크기와 커밋 주기 최적화 필요 증명 대기 시간\n증명 생성은 계산 집약적, 하드웨어와 회로 최적화 상태에 따라 지연 발생 가능 사용자 응답은 즉시성 확보 가능하나 L1 최종성은 증명 완료 이후 확보 시퀀서 검열 리스크\n단일 시퀀서 운영 시 트랜잭션 포함 지연 가능성 존재 추후 분산화 로드맵, 포크 선택 규칙, 포스 인클루전 메커니즘 고려 필요 브리징과 메시징 안전성\nL1 확정 전 교차체인 메시지 사용 시 미확정 리스크 존재 지연 큐, 취소·재시도 정책, 상태 증명 기반 수령 조건 명시 필요 페이마스터 남용 방지\n한도, 속도 제한, 수신자·함수 화이트리스트 운용 토큰 기반 가스 지불은 환산 레이트 변동과 유동성 부족 문제 고려 Nonce 경쟁과 재진행\n중복 제출 방지, 재전송 정책, minNonce 관리 정책 표준화 필요 간단 예시와 실무 팁 JSON-RPC 제출 시 from을 스마트 컨트랙트 계정 주소로 지정해 계정 자체 검증 로직 구동 검증 단계에서 nonce 소비를 먼저 처리해 재진입·중복 실행 방지 EIP-712 타입 데이터 서명 사용으로 서명 범위와 목적을 명확히 표현 부트로더 전용 함수는 onlyBootloader로 차단, 외부 호출 경로 executeTransactionFromOutside를 별도 제어 L1 상호작용은 commit → prove → execute 순서 준수, 운영 관점에서 배치 커밋 지표와 증명 큐 길이를 모니터링 운영 베스트 프랙티스 배치 정책\n수요에 따른 동적 배치 크기와 커밋 주기 조정, 블롭 단가와 증명 대기 시간의 균형 추구 가시성 확보\n시퀀서 지연, 증명 생성 시간, 실패율, 큐 길이, L1 가스 단가, 블롭 단가 대시보드화 계정 추상화 보안\nvalidateTransaction에서 호출자·서명·정책 일관성 검증, 실패 시 명시적 에러 코드 반환 페이마스터 입력 파싱과 예산 검사 철저, 사후 훅에서 외부 호출 시 재진입 방지 릴리즈 전략\n테스트넷에서 계정·페이마스터·브리징 경로를 통합 리허설, 가스 상한과 오류 복구 시나리오 검증 회로와 증명 백엔드\n회로 업데이트는 롤링 업그레이드 전략 채택, 검증 키 교체와 컨트랙트 버전 호환성 체크리스트 운영 마무리 Abstract는 ZK Rollup과 EIP-4844를 결합해 확장성과 비용 효율을 확보하고, 네이티브 계정 추상화로 개발자와 사용자의 상호작용을 단순화하는 접근을 취함 시퀀서·증명 파이프라인·L1 계약 간 경계를 명확히 하고, 계정 추상화와 페이마스터 정책을 보안 우선으로 설계하면 운영 안정성을 크게 높일 수 있음 이 문서의 개념과 베스트 프랙티스를 기준으로 트랜잭션 수명주기, 지갑 모듈, 데이터 가용성 튜닝을 체계적으로 검토할 것을 권장함\n참고자료 https://abs.xyz/ https://eips.ethereum.org/EIPS/eip-4844 https://eips.ethereum.org/EIPS/eip-1271 https://era.zksync.io/docs/ https://vitalik.ca/general/2021/01/05/rollup.html https://ethereum.org/en/roadmap/danksharding/ ","permalink":"https://handsupmin.github.io/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAbstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표\nZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구\n핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\u003c/p\u003e\n\u003ch3 id=\"배경과-목적\"\u003e배경과 목적\u003c/h3\u003e\n\u003cp\u003e이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼\n저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적\nL2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것\nZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\u003c/p\u003e","title":"Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW"},{"content":"개요 Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임 ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음 프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\n핵심 개념과 정의 Public Client\n퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트 블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당 Wallet Client\n개인키를 보유한 계정에 대해 트랜잭션 서명과 전송을 수행하는 클라이언트 시뮬레이션, 가스 추정, nonce 처리, write 컨트랙트 호출 담당 Transport\nHTTP나 WebSocket 등 JSON-RPC 통신 방법 추상화 계층 성능과 안정성에 영향을 주는 핵심 요소 Chain 구성\nchain 객체에 chainId, 네트워크 이름, 기본 RPC 엔드포인트, 네이티브 통화 단위 등의 메타데이터 포함 올바른 체인 설정이 시뮬레이션과 서명, 전송의 전제 조건 ABI 기반 타입 안전성\nABI를 바탕으로 함수 이름, 파라미터, 반환형에 대한 타입 추론 제공 런타임 이전에 오타나 파라미터 타입 오류를 차단하는 효과 데이터 타입\n금액, 블록 번호, 가스 등 정수 값은 BigInt 반환이 기본 주소, 바이트 데이터는 0x 프리픽스 hex 문자열 사용 동작 원리와 구조 읽기 흐름\nPublic Client가 RPC 호출을 통해 블록이나 상태를 조회함 컨트랙트 읽기 시 getContract 또는 readContract 유틸을 사용하여 call 실행 쓰기 흐름\nWallet Client가 계정을 보유하고 시뮬레이션으로 가스와 파라미터를 검증한 뒤 트랜잭션 전송 simulateContract 결과를 writeContract에 그대로 전달하는 패턴이 안전하고 권장됨 분리의 이점\n읽기와 쓰기 책임이 분리되어 보안 경계와 테스트 용이성 향상 서버 환경에서는 Public Client만 배포해 민감 키가 없는 조회 전용 API 제공 가능 설치와 환경 준비 패키지 설치\nnpm install viem 필수 준비물\n신뢰 가능한 RPC 엔드포인트 URL 준비 테스트넷에서는 faucet로 ETH 확보 환경 변수로 개인키, RPC URL 등 민감정보 관리 권장 사용법 1: 네트워크 연결과 블록 조회 아래 스니펫은 메인넷에 연결하고 최신 블록과 블록 번호를 조회하는 최소 예시임\nimport { createPublicClient, http } from \u0026#39;viem\u0026#39; import { mainnet } from \u0026#39;viem/chains\u0026#39; const publicClient = createPublicClient({ chain: mainnet, transport: http(process.env.RPC_URL) }) const run = async () =\u0026gt; { const block = await publicClient.getBlock() const blockNumber = await publicClient.getBlockNumber() // block 해시, 타임스탬프, 가스 사용량 등 핵심 필드 사용 console.log(block.hash, block.timestamp, block.gasUsed) console.log(blockNumber) } run() blockNumber는 BigInt 반환값임 gas, 수수료, 블록 번호 등 정수 값 처리 시 숫자 오버플로 방지를 위해 BigInt 유지 또는 명시적 변환 필요 http 전송 대신 웹소켓 전송도 가능하나 서버 환경 안정성, 프록시 구성, 리밸런싱 전략 고려 필요 사용법 2: 컨트랙트 읽기와 쓰기 한 스니펫에서 읽기와 쓰기를 묶어 핵심 흐름만 정리함\nimport { getContract, createPublicClient, createWalletClient, http } from \u0026#39;viem\u0026#39; import { sepolia } from \u0026#39;viem/chains\u0026#39; import { privateKeyToAccount } from \u0026#39;viem/accounts\u0026#39; const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.RPC_URL) }) const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`) const walletClient = createWalletClient({ account, chain: sepolia, transport: http(process.env.RPC_URL) }) // 읽기 예시 const contract = getContract({ address: \u0026#39;0xYourContractAddress\u0026#39;, abi: YourAbi, client: publicClient }) const name = await contract.read.name() // 쓰기 예시 const { request } = await publicClient.simulateContract({ address: \u0026#39;0xYourContractAddress\u0026#39;, abi: YourAbi, functionName: \u0026#39;store\u0026#39;, args: [100n], account }) const txHash = await walletClient.writeContract(request) console.log(name, txHash) address에는 목표 컨트랙트 주소 입력 abi에는 실제 ABI 배열 주입 read 호출은 call을 사용하므로 가스 소모 없음 write 호출은 시뮬레이션으로 가스, 인자, 권한 문제를 사전 검증한 뒤 전송 txHash로 익스플로러에서 상태 확인 가능 동작 살펴보기와 실전 팁 getContract와 read\ngetContract는 ABI를 바탕으로 타입 안전한 메서드 집합 생성 contract.read.balanceOf(\u0026lsquo;0x\u0026hellip;\u0026rsquo;)처럼 각 함수가 자동 완성되며 잘못된 함수명이나 인자 타입을 컴파일 타임에 차단 simulateContract와 writeContract\n시뮬레이션 단계에서 revert 이유와 디코딩된 오류를 확인 가능 request에는 to, data, value, gas, maxFeePerGas 등 전송에 필요한 필드가 완성되어 포함됨 writeContract에 request를 그대로 넘겨 불일치 위험 최소화 가스 수수료와 EIP-1559\n대부분 체인은 baseFee 기반의 maxFeePerGas, maxPriorityFeePerGas 조합 사용 시뮬레이션 결과를 그대로 쓰거나, 트래픽이 많은 시간대에는 우선순위 수수료를 다소 상향해 확정 속도 확보 BigInt와 단위 처리\nERC-20 amount, 수수료 모두 BigInt로 다룸 parseUnits, formatUnits 유틸 사용으로 10진 문자열과 wei 단위 간 변환 안정화 체인 불일치와 계정 네트워크\nwalletClient와 simulateContract의 chain은 동일해야 함 RPC URL이 다른 체인을 가리키면 nonce, 수수료, 시뮬레이션 결과가 어긋나 실패 가능 주의사항과 한계 개인키 보호\nPRIVATE_KEY는 서버 비밀 변수 관리 또는 HSM, KMS 연동 고려 프런트엔드 환경에 개인키 하드코딩 금지 RPC 신뢰도와 레이트 리밋\n공용 RPC는 속도와 가용성이 낮을 수 있음 상용 환경은 신뢰 가능한 제공자와 백업 엔드포인트 구성 권장 재시도와 오류 처리\n네트워크 에러, 서버 오류, 체인 재구성 등 다양한 실패 케이스 존재 지수 백오프, idempotency 고려, 트랜잭션 재전송 시 nonce 관리 필요 테스트넷과 가스\n테스트넷은 faucet 지급 지연, 빈 블록, 비활성 노드 등 특성이 존재 가스 부족, 체인 혼잡에 따른 확정 지연을 정상 동작 범위로 간주할 수 있어야 함 ABI 신뢰성\n오타 또는 잘못된 ABI는 런타임 revert를 유발함 배포된 바이트코드와 ABI 매칭 검증 권장 베스트 프랙티스 시뮬레이션 우선 전략\n모든 write 호출 전 simulateContract로 가스와 인자 검증 환경 변수 분리\nRPC_URL, PRIVATE_KEY, CONTRACT_ADDRESS를 환경 변수로 분리해 배포 환경별 설정 편의 확보 블록 간 일관성\n이벤트나 상태를 조합해 읽을 때는 동일 블록 높이 기준을 유지하는 스냅샷 전략 고려 멀티콜 활용\n여러 read를 묶어 왕복 비용 절감 가능 로깅과 관찰성\ntxHash, nonce, gasUsed, effectiveFeePerGas, 블록 번호를 구조화 로그로 남겨 운영 이슈 분석 용이성 확보 간단 예시로 보는 검증 흐름 writeContract에서 반환된 txHash 확인 체인 익스플로러에서 해당 txHash 조회로 블록 포함 여부, 리시트 상태, 이벤트 로그 검증 컨트랙트의 view 함수로 최종 상태 교차 확인 이 흐름을 자동화해 배치나 백엔드 작업에서 신뢰도 있는 완료 판정 기준으로 사용 가능\n마무리 Viem은 읽기와 쓰기 클라이언트 분리, 시뮬레이션 중심의 전송 흐름, 타입 안전한 ABI 접근이라는 명확한 철학을 가짐 이 기본기만 갖추면 블록 조회, 컨트랙트 읽기, 트랜잭션 생성이라는 세 가지 축을 빠르게 실무에 적용 가능 개인키와 RPC 관리, 시뮬레이션과 가스 전략, 오류 처리라는 운영 디테일을 함께 설계하면 프로덕션에서도 일관된 안정성을 확보할 수 있음\n참고자료 https://viem.sh/docs https://viem.sh/docs/clients/public https://viem.sh/docs/clients/wallet https://viem.sh/docs/actions/public/getBlock https://viem.sh/docs/contract/readContract https://viem.sh/docs/contract/writeContract https://ethereum.org/en/developers/docs/apis/json-rpc https://etherscan.io https://docs.alchemy.com/reference/ethereum-apis ","permalink":"https://handsupmin.github.io/posts/viem-ethereum-read-write-guide-4a5336/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eViem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임\nethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음\n프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePublic Client\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트\u003c/li\u003e\n\u003cli\u003e블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWallet Client\u003c/p\u003e","title":"Viem으로 이더리움 읽기·쓰기 시작하기 가이드"},{"content":"개념/배경 WETH는 이더리움 네트워크의 기본 자산인 ETH를 ERC-20 표준과 호환되도록 포장한 토큰을 의미함 ETH 자체는 계정 잔고 모델을 따르며 ERC-20 인터페이스를 구현하지 않음 반면 대부분의 디파이 프로토콜과 토큰 간 상호작용은 ERC-20을 전제로 동작함 이 간극을 메우기 위해 1:1 가치로 교환 가능한 WETH가 사용됨\n핵심은 호환성과 일관성임 WETH를 사용하면 ETH를 일반적인 ERC-20 토큰처럼 전송, 승인, 보관, 스왑 등 동일한 방식으로 다룰 수 있음\n핵심 개념과 정의 정의: ETH를 스마트 컨트랙트에 예치하고 동일 수량의 ERC-20 토큰을 발행한 형태의 래핑 자산 가치 페깅: 1 WETH = 1 ETH를 목표로 하며 언제든 역변환 가능 표준 호환: ERC-20 인터페이스 준수로 승인, 전송, 수령 등 동작이 통일됨 커스터디 모델: 컨트랙트가 ETH를 보관하고, 사용자는 WETH를 보유하여 권리를 표현함 동작 원리 래핑 흐름\n사용자가 ETH를 WETH 컨트랙트에 전송 컨트랙트가 동일 수량의 WETH를 발행해 사용자에게 전송 컨트랙트는 수령한 ETH를 잠금 상태로 보관 언래핑 흐름\n사용자가 WETH를 컨트랙트에 반환 컨트랙트가 해당 WETH를 소각 보관 중인 동일 수량의 ETH를 사용자에게 반환 수수료 관점 래핑과 언래핑은 가스 비용 소모 행위이며 네트워크 혼잡도와 가스 가격에 따라 비용 변동 발생 추가 스프레드는 일반적으로 없음이나 일부 인터페이스는 서비스 수수료를 부과할 수 있음\n보안 관점 자금은 컨트랙트에 예치되므로 컨트랙트 취약점, 권한 설정 오류, 업그레이드 리스크 등에 노출 가능 광범위하게 검증되고 장기간 사용된 구현을 우선 고려 권장\n사용 사례 탈중앙화 거래소에서의 스왑 원활한 페어 구성 및 라우팅을 위해 ETH 대신 WETH를 기반 토큰으로 사용함\n유동성 풀 참여 풀의 양쪽 자산이 ERC-20이어야 하므로 ETH를 WETH로 변환해 풀 토큰 발행 및 수수료 적립에 참여함\n대출 및 담보 담보 관리, 청산, 이자 계산 로직이 ERC-20 전제를 따르므로 WETH 형태로 담보 예치 및 대출 집행 수행\n금고, 결제 라우팅, 브릿지 어댑터 컨트랙트 상호운용 통일을 위해 내부적으로 WETH를 기준 자산으로 사용해 회계 및 권한 제어 단순화\n장점과 단점 장점\nERC-20 호환으로 광범위한 디앱과 즉시 상호운용 가능 토큰 표준화로 승인, 전송, 회계 처리 흐름 단순화 라우팅 최적화로 스왑 경로 구성 및 유동성 집약에 유리 단점\n래핑·언래핑 시 가스 비용 발생 및 트랜잭션 대기 시간 필요 스마트 컨트랙트 의존으로 컨트랙트 리스크 존재 자산 표현이 둘로 나뉘어 사용자 혼란 가능 운영 시 유의점\n신뢰할 수 있는 레퍼런스 구현 사용 및 주소 재확인 필수 불필요한 무제한 승인 지양, 필요 한도만 승인하고 사용 후 승인 철회 고려 대량 언래핑 시 슬리피지 이슈는 없으나 가스 급증 구간 회피 권장 일부 구현은 EIP-2612 permit 미지원 가능, 서명 기반 승인 필요 시 인터페이스 확인 필요 간단 예시 아래는 애플리케이션에서 WETH 컨트랙트의 deposit과 withdraw를 호출하는 최소 예시임 필요에 따라 스왑이나 유동성 풀 참여 전 approve 호출이 추가될 수 있음\nimport { Contract, parseEther } from \u0026#34;ethers\u0026#34; const abi = [ \u0026#34;function deposit() payable\u0026#34;, \u0026#34;function withdraw(uint256)\u0026#34; ] const weth = new Contract(wethAddress, abi, signer) // ETH → WETH await weth.deposit({ value: parseEther(\u0026#34;1.0\u0026#34;) }) // WETH → ETH await weth.withdraw(parseEther(\u0026#34;1.0\u0026#34;)) 예시에서는 기본 동작만 다룸 프로덕션 사용 시 재진입 방지, 실패 처리, 이벤트 확인, 승인 한도 관리, 가스 전략 등을 함께 고려 필요\n한계와 미래 ETH가 네이티브 레이어에서 ERC-20과 동일한 인터페이스를 제공하지 않는 한 호환성 계층으로서 WETH 수요는 지속될 전망 계정 추상화, 지갑 라우팅, 메시지 레벨 결합이 발전해도 디앱 간 자산 인터페이스 표준화 필요성은 유지됨 다만 사용자 경험 측면에서는 프런트엔드와 지갑이 자동 래핑·언래핑을 추상화해 직접적인 노출이 줄어드는 흐름이 강화될 가능성 있음\n마무리 WETH는 ETH를 ERC-20 토큰처럼 다룰 수 있게 해 디파이 전반의 상호운용성을 제공하는 핵심 구성 요소임 래핑과 언래핑의 원리를 이해하고 컨트랙트 신뢰성, 승인 관리, 가스 비용을 고려하면 대부분의 디앱 시나리오에서 안전하고 일관된 자산 흐름을 설계할 수 있음\n참고자료 https://ethereum.org/en/developers/docs/standards/tokens/wrapped-tokens/ https://eips.ethereum.org/EIPS/eip-20 https://eips.ethereum.org/EIPS/eip-2612 ","permalink":"https://handsupmin.github.io/posts/weth-eth-erc20-guide-683552/","summary":"\u003ch3 id=\"개념배경\"\u003e개념/배경\u003c/h3\u003e\n\u003cp\u003eWETH는 이더리움 네트워크의 기본 자산인 ETH를 ERC-20 표준과 호환되도록 포장한 토큰을 의미함\nETH 자체는 계정 잔고 모델을 따르며 ERC-20 인터페이스를 구현하지 않음\n반면 대부분의 디파이 프로토콜과 토큰 간 상호작용은 ERC-20을 전제로 동작함\n이 간극을 메우기 위해 1:1 가치로 교환 가능한 WETH가 사용됨\u003c/p\u003e\n\u003cp\u003e핵심은 호환성과 일관성임\nWETH를 사용하면 ETH를 일반적인 ERC-20 토큰처럼 전송, 승인, 보관, 스왑 등 동일한 방식으로 다룰 수 있음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e정의: ETH를 스마트 컨트랙트에 예치하고 동일 수량의 ERC-20 토큰을 발행한 형태의 래핑 자산\u003c/li\u003e\n\u003cli\u003e가치 페깅: 1 WETH = 1 ETH를 목표로 하며 언제든 역변환 가능\u003c/li\u003e\n\u003cli\u003e표준 호환: ERC-20 인터페이스 준수로 승인, 전송, 수령 등 동작이 통일됨\u003c/li\u003e\n\u003cli\u003e커스터디 모델: 컨트랙트가 ETH를 보관하고, 사용자는 WETH를 보유하여 권리를 표현함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리\"\u003e동작 원리\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e래핑 흐름\u003c/p\u003e","title":"WETH 이해와 활용 가이드 – ETH를 ERC-20로 포장하는 이유와 동작 원리"},{"content":"개념 스테이킹은 여러 사용자가 자금을 모아 검증자 노드를 운영하고 보상과 위험을 지분 비율로 공유하는 참여 모델\n동작 검증자에는 최소 예치금 필요 이더리움은 32 ETH 요구 풀에 위임하면 노드가 검증을 수행하고 발생 보상을 분배 규정 위반이나 다운타임 발생 시 슬래싱으로 원금 일부 손실 위험\n참고자료 https://ethereum.org/en/staking/ https://polkadot.network/learn/staking/ ","permalink":"https://handsupmin.github.io/posts/staking-basics-ethereum-validator-32eth-8cc2be/","summary":"\u003ch3 id=\"개념\"\u003e개념\u003c/h3\u003e\n\u003cp\u003e스테이킹은 여러 사용자가 자금을 모아 검증자 노드를 운영하고 보상과 위험을 지분 비율로 공유하는 참여 모델\u003c/p\u003e\n\u003ch3 id=\"동작\"\u003e동작\u003c/h3\u003e\n\u003cp\u003e검증자에는 최소 예치금 필요\n이더리움은 32 ETH 요구\n풀에 위임하면 노드가 검증을 수행하고 발생 보상을 분배\n규정 위반이나 다운타임 발생 시 슬래싱으로 원금 일부 손실 위험\u003c/p\u003e\n\u003ch3 id=\"참고자료\"\u003e참고자료\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://ethereum.org/en/staking/\"\u003ehttps://ethereum.org/en/staking/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://polkadot.network/learn/staking/\"\u003ehttps://polkadot.network/learn/staking/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"스테이킹 핵심 개념과 이더리움 검증자 32 ETH 요건"},{"content":"개요 영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함 블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임 이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\n목적과 맥락 비밀을 공개하지 않고 유효성만 검증하려는 요구 증가 퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대 오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구 핵심 개념과 정의 Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체 Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체 Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식 Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명 Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제 Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립 영지식 증명의 세 가지 성질 완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨 건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤 영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함 직관적 예시 알리바바 동굴 동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음 검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함 Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2 k회 독립 반복하면 모두 속일 확률 2^-k로 급감 검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함 핵심 포인트\n비밀 노출 없이 유효성만 확인 가능 무작위 도전과 반복으로 사기 가능성 급감 대화 기록만으로 비밀 자체를 유추 불가 형식적 관점과 시뮬레이터 대화형 증명은 Prover P와 Verifier V가 커밋-챌린지-리스폰스 구조로 상호작용함 Transcript는 도전값과 응답 및 공개 상태를 포함하는 관찰 기록을 의미함 영지식성은 시뮬레이터 S가 비밀 없이도 실제와 분포가 같은 Transcript를 생성할 수 있음을 요구함 의미는 검증자가 얻은 정보가 공개 난수로도 재현 가능한 수준에 한정됨을 보장한다는 것임 사전 공모 이슈와 설계 포인트 대화형 프로토콜에선 검증자와 Prover가 사전 공모했다면 제3자는 배제 불가 이슈가 생김 이 경우를 지정 검증자 영지식 designated-verifier ZK로 분류 가능 공개 검증이 필요하면 비대화형 영지식 NIZK 또는 공개 검증 가능한 Σ-프로토콜 조합을 사용해 누구나 검증 가능하게 설계 필요 Fiat–Shamir 변환으로 도전값을 해시로 결정하면 제3자도 단일 증명을 검증 가능 운영 시 검증자의 내부 시드나 도전값 생성 과정을 과도하게 공개하면 지정 검증자 시나리오의 영지식성이 약화될 수 있음 대화형과 비대화형 대화형 Interactive 실시간으로 도전과 응답을 주고받는 구조. 장점은 단순성과 강한 보안 모델. 단점은 왕복 상호작용과 제3자 설득 한계 가능 비대화형 Non-Interactive 하나의 짧은 증명을 생성해 누구나 검증. Fiat–Shamir로 대화형 도전을 해시로 대체. SNARK와 STARK 등에서 표준 사용 트레이드오프 네트워크 왕복 제거와 공개 검증 가능성 vs 해시를 랜덤 오라클로 보는 가정과 경우에 따라 신뢰 설정 필요 디지털 서명과의 차이 신원 노출 서명은 공개키로 서명자 신원이 구조적으로 드러남. ZK는 신원과 비밀 모두 숨기고 유효성만 증명 가능 제3자 설득 서명은 메시지-서명 쌍을 누구나 검증 가능해 완전 설득 지향. ZK도 NIZK나 공개 검증 가능한 구성에선 제3자 설득 가능. 다만 지정 검증자 ZK에선 제3자 설득이 제한됨 프록시 릴레이 공격 대화형 식별 프로토콜은 중간자 릴레이 공격 위험 존재. 세션 바인딩과 채널 인증, 도전값 바인딩으로 완화 필요. 서명은 보통 프로토콜 레벨 인증과 채널 보안으로 대응 연결 고리 Σ-프로토콜에 Fiat–Shamir를 적용하면 서명 스킴으로 전환 가능. 대표가 Schnorr 서명임 ZKP Under the Hood 이산로그 기반 Σ-프로토콜 가장 고전적인 지식증명은 이산로그 가정 위에서 동작함 공통 입력 y = g^x mod p에서 x가 비밀이며 Prover는 x를 안다는 사실을 증명함\n기본 설정 큰 소수 p와 생성원 g를 가진 소수 차수 q 부분군 선택. 연산은 지수에서 mod q로 수행 공통 값 y = g^x mod p는 공개. x는 Prover만 아는 비밀 1비트 챌린지 버전 직관 커밋 Prover가 임의의 r를 뽑아 C = g^r mod p 전송 챌린지 Verifier가 z ∈ {0,1} 전송 응답 z = 0이면 r 공개. z = 1이면 s = r + x mod q 공개 검증 z = 0이면 g^r ≟ C 확인. z = 1이면 g^s ≟ C · y 확인 Prover가 x를 모르면 두 경우를 동시에 만족시키는 응답을 준비 불가. 1회 속임 확률 1/2. k회 반복 시 2^-k로 감소 일반화된 Schnorr 식별 프로토콜 도전값 c를 Z_q에서 무작위 선택 커밋 C = g^r 응답 s = r + c·x mod q 검증 g^s ≟ C · y^c 비대화형으로는 c = H(domain, context, g, y, C)로 정하고 단일 증명을 생성함. 여기서 H는 도메인 분리와 컨텍스트 바인딩을 포함한 해시 함수이며 랜덤 오라클 가정 하에서 분석함 주의사항 안전한 구현은 군 차수 q 기준으로 지수 연산 수행 필요 r은 CSPRNG로 매 증명마다 새로 생성. r 재사용은 즉시 비밀 유출로 이어짐 해시 입력엔 도메인 분리 태그와 세션 ID, 검증자 식별 등 컨텍스트를 바인딩해 재생 공격과 교차 프로토콜 간섭을 방지 필요 간단 검증 스니펫 예시 아래는 원리 전달용 최소 형태임. 실제 구현에선 안전한 군 선택, 상수시간 연산, 에러 처리 포함 필요\n## 공개 파라미터 p, g, y와 커밋 C, 도전 z, 응답 resp를 검증하는 예시 def verify_one_bit(p, g, y, C, z, resp): if z == 0: ## resp == r return pow(g, resp, p) == C else: ## resp == s = r + x mod q return pow(g, resp, p) == (C * y) % p def verify_schnorr(p, g, y, C, c, s): ## 일반형 검증식 g^s == C * y^c mod p left = pow(g, s, p) right = (C * pow(y, c, p)) % p return left == right 확률적 보장과 파라미터 선택 1회 속임 확률은 1 / |ChallengeSpace| 임 1비트 도전이면 1/2. k회 독립 반복 시 2^-k로 수렴 NIZK나 공개 검증에서는 도전 공간을 128비트 이상으로 설정해 단일 증명으로 충분한 사운드니스 확보 권장 블록체인 환경에서는 검증 비용과 증명 크기, 사운드니스 비트를 함께 고려해 회로 크기와 파라미터를 선택 필요 설계 포인트와 운영 수칙 그룹과 곡선 선택 secp256k1, P-256, BLS12-381, Bandersnatch, ristretto255 등 표준 계열 우선 고려 난수 생성 CSPRNG 필수. 커밋 nonce r 재사용 금지. 시스템 RNG 품질 모니터링 필요 파라미터 바인딩 도전 해시에 프로토콜 식별자, 세션 ID, 검증자 식별 또는 채널 특성 포함해 세션 고정 효과 확보 트랜스크립트 관리 지정 검증자 시나리오에서는 불필요한 내부 난수 공개를 줄임. 공개 검증 목표면 처음부터 NIZK 또는 SNARK류 선택 부채널 대응 타이밍 누수와 캐시 기반 누수에 대비해 상수시간 구현과 블라인딩 적용 리플레이 및 릴레이 방지 세션 바인딩, nonce, 타임스탬프, 채널 인증 적용 회귀 방지 회로나 명세 변경 시 검증 규칙에 대한 테스트 자동화와 호환성 체크 필요 SNARK vs STARK vs Bulletproofs 한눈 비교 항목 SNARK STARK Bulletproofs 설정 일부 시스템 신뢰 설정 필요. Plonk류는 범용 SRS 가능 투명 설정. 신뢰 설정 불요 신뢰 설정 불요 증명 크기 매우 작음 수십 바이트 수준까지 가능 비교적 큼 수십 KB 이상 로그 크기. 범위증명은 수 KB 수준 검증 비용 빠름. 온체인 친화적 보통에서 빠름. 해시 중심 검증 비용 큼. 집계로 완화 가능 보안 가정 페어링과 다항식 약속 등 수학적 가정 해시 기반 IOP와 FRI. 포스트 양자 내성 기대 내적 논증 기반. 일반군 가정 활용 예 zkEVM, 롤업, 영지식 브리지 투명한 롤업, 대규모 추적 증명 범위증명, UTXO 프라이버시 각 계열의 실제 성능은 구현과 회로 구조, 하드웨어에 크게 의존함\n블록체인 적용 예 잔액과 금액을 숨긴 비공개 전송과 감사 가능성 확보 신원 속성 최소 공개 KYC 예 나이 이상 여부만 증명 영지식 롤업 상태 전개 증명과 데이터 가용성 보완 오라클 입력의 유효성 증명과 오프체인 계산 검증 MPC와 결합한 다자 프라이버시 계산의 결과 정합성 증명 자주 묻는 질문 ZK면 항상 제3자 설득 불가임? 아님. NIZK나 공개 검증 가능한 구성에선 누구나 검증 가능함 STARK는 포스트 양자 보안 보장임? 양자에 대해 알려진 공격이 약하다는 의미의 내성 기대 수준임. 수학적 증명된 보장은 아님 왜 r 재사용이 위험함? 서로 다른 도전에 같은 r을 쓰면 x가 선형식으로 노출됨 왜 q 모듈러를 강조함? 안전한 지수 연산의 정의역은 군 차수 q이기 때문임. p-1 전역 모듈러는 안전하지 않을 수 있음 검증과 회귀 방지 체크리스트 사운드니스 목표 비트와 도전 공간이 요구 수준 충족하는지 점검 난수 생성 모듈 품질과 시드 관리 상태 감사 도메인 분리 태그와 세션 ID가 해시 입력에 포함되는지 확인 재생 공격과 프록시 릴레이 가능성에 대한 테스트와 채널 인증 적용 상수시간 연산 준수 여부와 메모리 접근 패턴 누수 점검 회로 변경 시 검증 규칙 스냅샷과 회귀 테스트 자동화 마무리 영지식 증명은 비밀을 드러내지 않고도 유효성을 설득하는 체계임 완전성-건전성-영지식성의 삼각을 이해하고 대화형과 비대화형의 차이를 파악하면 설계 선택이 명확해짐 실무에서는 안전한 군 선택과 난수, 도전 공간 크기, 세션 및 채널 바인딩, 신뢰 설정과 부채널 대응을 종합적으로 관리 필요 목표는 비밀을 지키면서도 누구나 또는 지정된 상대가 납득할 수 있는 검증 가능한 시스템을 만드는 것임\n참고 링크 https://en.wikipedia.org/wiki/Zero-knowledge_proof https://en.wikipedia.org/wiki/Interactive_proof_system https://en.wikipedia.org/wiki/Schnorr_identification https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic https://en.wikipedia.org/wiki/SNARK https://en.wikipedia.org/wiki/STARK_(cryptography) https://en.wikipedia.org/wiki/Bulletproofs https://medium.com/@hyun_jeong/h-3c3d45861ced https://medium.com/@hyun_jeong/%EC%B6%94%EA%B0%80-%EB%B9%84%EB%8C%80%ED%99%94%ED%98%95-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-6452fa5db079 https://medium.com/@hyun_jeong/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0%EC%9D%98-%EA%B7%BC%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%88%98%ED%95%99-%EC%9D%B4%EC%95%BC%EA%B8%B0-1-427948ca28c5 https://medium.com/@hyun_jeong/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0%EC%9D%98-%EA%B7%BC%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%88%98%ED%95%99-%EC%9D%B4%EC%95%BC%EA%B8%B0-2-14c72b5f158 https://medium.com/@hyun_jeong/zk-snarks%EC%9D%98-%EC%88%98%ED%95%99-%EC%9D%B4%EC%95%BC%EA%B8%B0-1-e960e76f705a https://medium.com/@hyun_jeong/zk-snarks%EC%9D%98-%EC%88%98%ED%95%99-%EC%9D%B4%EC%95%BC%EA%B8%B0-2-53dadcb691f9 https://medium.com/@hyun_jeong/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EC%A0%9C-7%ED%8E%B8-zk-snarks%EC%9D%98-%EC%88%98%ED%95%99-%EC%9D%B4%EC%95%BC%EA%B8%B0-3-49d2ba35337b https://medium.com/@hyun_jeong/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EB%B2%88%EC%99%B8-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%99%95%EC%9E%A5-%EC%86%94%EB%A3%A8%EC%85%98-%EB%B0%8F-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%86%8C%EA%B0%9C-298afa0f59fe https://medium.com/@hyun_jeong/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85-%EC%8B%9C%EB%A6%AC%EC%A6%88-centrifuge%EC%9D%98-%EC%98%81%EC%A7%80%EC%8B%9D-%EC%A6%9D%EB%AA%85-%ED%99%9C%EC%9A%A9-84879a112bc9 ","permalink":"https://handsupmin.github.io/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함\n블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임\n이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\u003c/p\u003e\n\u003ch2 id=\"목적과-맥락\"\u003e목적과 맥락\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e비밀을 공개하지 않고 유효성만 검증하려는 요구 증가\u003c/li\u003e\n\u003cli\u003e퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대\u003c/li\u003e\n\u003cli\u003e오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProver 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체\u003c/li\u003e\n\u003cli\u003eVerifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체\u003c/li\u003e\n\u003cli\u003eWitness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식\u003c/li\u003e\n\u003cli\u003eStatement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명\u003c/li\u003e\n\u003cli\u003eChallenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제\u003c/li\u003e\n\u003cli\u003eTranscript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"영지식-증명의-세-가지-성질\"\u003e영지식 증명의 세 가지 성질\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨\u003c/li\u003e\n\u003cli\u003e건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤\u003c/li\u003e\n\u003cli\u003e영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"직관적-예시-알리바바-동굴\"\u003e직관적 예시 알리바바 동굴\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음\u003c/li\u003e\n\u003cli\u003e검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함\u003c/li\u003e\n\u003cli\u003eProver가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2\u003c/li\u003e\n\u003cli\u003ek회 독립 반복하면 모두 속일 확률 2^-k로 급감\u003c/li\u003e\n\u003cli\u003e검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e핵심 포인트\u003c/p\u003e","title":"영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이"},{"content":"개념과 배경 Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함 짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨 노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\n핵심 용어 정리 스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\n오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\n리오그 깊이 교체되는 블록의 개수로 측정함\n메인 체인 선택 규칙\nPoW에선 누적 작업량이 큰 체인이 우선됨 이더리움 PoS에선 LMD-GHOST 포크초이스를 따르되 마지막 최종화 지점 하위만 후보가 됨 왜 리오그가 생김 네트워크 지연이나 전파 경합으로 같은 높이의 블록이 동시에 생성됨 일부 노드는 A를, 다른 노드는 B를 바탕으로 다음 블록을 쌓음 시간이 지나 우세한 체인이 결정되면 노드가 그 체인으로 교체함 버려진 체인의 트랜잭션은 소실되는 게 아니라 다시 메모풀로 돌아가 재포함을 기다림 합의별 리오그의 차이 PoW 계열 직관 우세 체인 기준은 블록 수가 아니라 누적 작업량임 자연 발생 리오그는 보통 깊이 1에서 끝남 보안 관례로 비트코인은 6컨펌 정도를 사람·서비스가 안전 구간으로 삼는 경우가 많음 다수 해시 파워를 가진 상대는 더 깊은 리오그를 인위적으로 만들 수 있으므로 고가치 결제일수록 더 많은 컨펌을 기다리는 전략이 쓰임 이더리움 PoS 직관 슬롯은 12초, 32슬롯이 1에폭이며 포크초이스는 LMD-GHOST와 FFG 최종화 규칙을 함께 사용함 헤드는 가장 최근 가중치가 높은 체인 머리, 세이프 헤드는 보수적 추정, 파이널라이즈드는 FFG로 최종화된 체크포인트 아래 체인 상태를 뜻함 정상 조건에선 리오그 깊이가 작고 파이널라이즈드 이후로의 리오그는 대규모 비정상 행동 없이는 사실상 불가에 가까움 대략 두 개의 에폭이 지나면 보통 최종화되어 실사용에선 약 12분 남짓을 강한 확정 구간으로 본다는 관례가 있음 환경과 네트워크 상황에 따라 달라질 수 있음 L2에서의 리오그 관점 L2→L1 메시지는 L1에 기록되고 관련 규칙을 충족하면 재전송하지 않음 옵티미스틱 롤업은 챌린지 윈도우가 지나야 강한 확정으로 취급하며 그 전에는 지연을 감안해야 함 L1이 뒤집히는 아주 이례적인 상황을 제외하면 L1에 최종적으로 기록된 상태는 다시 뒤집히지 않는다는 점을 전제로 시스템을 설계함 리오그와 헷갈리기 쉬운 것들 RBF나 수수료 경쟁으로 인해 메모풀에서 트랜잭션이 교체되는 현상은 리오그와 별개임 프로토콜 업그레이드를 위한 하드포크는 합의 규칙 자체를 바꾸는 이벤트이며 자연 발생 리오그와는 범주가 다름 과거 이더리움 PoW 시절의 옴머 포함은 스테일 블록 보상 메커니즘일 뿐 리오그 자체가 아님 서비스 설계에 미치는 영향 결제와 출금\n자산·위험도·체인별로 컨펌 수 정책을 문서화해 운영함 고가치 결제는 더 많은 컨펌을 요구하고 저가치·소액은 사용자 경험을 위해 낮출 수 있음 데이터 처리\n인덱싱은 높이만 저장하지 말고 블록 해시와 부모 해시를 함께 저장 리오그 감지 시 롤백 가능한 저널을 두고 되감기 후 재처리 트랜잭션 처리\n멱등성 확보를 위해 논스·컨트랙트 상태·이벤트 ID를 함께 검증 재방송은 동일 논스로 수행해 중복 실행을 피함 UX\n잠정 상태 표시와 컨펌 카운터 제공 세이프 헤드와 파이널라이즈드의 차이를 사용자에게 명확히 안내 리오그 감지와 대응 패턴 헤드 해시 변화 모니터링과 특정 깊이 이상 변화시 경보\n최신 N개 블록의 체인ID·높이·해시·부모 해시·도착 시각을 원장과 별도 테이블에 윈도우로 관리\n확정 레벨별로 파이프라인을 분기\n헤드 기준 실시간 기능 세이프 기준 중요 알림 파이널 기준 영구 저장 간단 의사코드\nonNewBlock(b): save(b.height, b.hash, b.parent) if parentNotHead(): // reorg 발생 rollbackUntilCommonAncestor() replayFromAncestor() routePipelinesByCommitment(head, safe, finalized) 운영 체크리스트 컨펌 정책과 리오그 최대 허용 깊도가 문서화되어 있음 인덱서가 롤백과 재처리를 지원함 알림 시스템이 헤드 전환과 리오그 이벤트를 기록함 파이널라이즈드 구간만 영구 저장하거나 백그라운드 확정화 작업을 운영함 L2의 챌린지 윈도우와 브리지 지연을 고려해 타임라인을 설계함 간단 시나리오 한국과 미국에서 같은 높이 블록이 동시에 생성됨 각 지역 노드가 자신이 먼저 본 블록 위로 다음 블록을 쌓음 한쪽 체인이 한 블록 더 빨리 쌓이며 우세해지면 다른 쪽은 스테일 처리됨 스테일 체인에 있던 거래는 메모풀로 돌아가 메인 체인에 재포함을 기다림\n참고자료 https://en.bitcoin.it/wiki/Chain_Reorganization?utm_source=chatgpt.com https://learnmeabitcoin.com/technical/blockchain/chain-reorganization/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/?utm_source=chatgpt.com https://www.alchemy.com/overviews/ethereum-commitment-levels?utm_source=chatgpt.com ","permalink":"https://handsupmin.github.io/posts/blockchain-reorg-chain-reorganization-f4966a/","summary":"\u003ch2 id=\"개념과-배경\"\u003e개념과 배경\u003c/h2\u003e\n\u003cp\u003eReorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함\n짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨\n노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\u003c/p\u003e\n\u003ch2 id=\"핵심-용어-정리\"\u003e핵심 용어 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\u003c/p\u003e","title":"블록체인 Reorg(체인 재구성) 이해"},{"content":"개념과 배경 스마트 컨트랙트는 체인 내부 상태만 신뢰하고 외부 네트워크에 직접 접근하지 않음 가격·날씨·게임 결과 같은 외부 데이터를 참조하려면 중간자 역할이 필요함 오라클은 외부 데이터를 온체인으로 들여오거나 온체인 이벤트를 외부 시스템에 전달하는 인터페이스 역할 수행 이 연결이 잘못 설계되면 컨트랙트의 무결성이 오라클 신뢰도에 종속되는 구조적 한계가 발생함\n핵심 개념과 정의 오라클: 블록체인과 외부 세계를 잇는 데이터 브리지 역할 인바운드 오라클: 외부 데이터를 온체인으로 주입 아웃바운드 오라클: 온체인 이벤트를 외부 서비스나 장치로 전달 중앙화 오라클: 단일 주체가 데이터 제공 단일 실패 지점과 조작 리스크 존재 탈중앙화 오라클: 다수 노드와 다중 소스 집계 신뢰성과 가용성 강화 대신 비용과 복잡도 상승 소프트웨어 오라클: API 기반 웹 데이터 공급 하드웨어 오라클: 센서·IoT 장치에서 물리 정보 수집과 증빙 제공 오라클 문제: 체인 합의는 내부 상태만 보장 외부 진실성은 합의 밖에 있어 신뢰 경계가 오라클로 이동하는 과제 존재 동작 원리와 구조 요청 응답 패턴: 컨트랙트가 요청을 생성하고 오라클 네트워크가 수집·검증 후 결과를 콜백으로 전달 퍼블리시 패턴: 오라클이 주기적으로 데이터를 온체인에 게시하고 컨슈머는 읽기만 수행 집계 방식: 다중 소스 수집 후 중앙값 또는 가중 평균 산출 이상치 제거 규칙 포함 검증 기법: 서명 기반 인증, 임계치 다중서명, 커밋 리빌, 신뢰 실행 환경 원격 증명, TLS 증빙, 메르클 증명 등 선택지 존재 데이터 신선도: 하트비트 주기, 변경 폭 임계치 기반 갱신 트리거, 최대 지연 한도 설정 전달 보안: 콜백 함수 화이트리스트와 접근 제어 논스·타임스탬프로 리플레이 방지 비용 모델: 온체인 저장과 콜백은 가스 비용 증가 업데이트 주기와 보안 강도를 목적에 맞춰 절충 필요 위협 모델과 취약점 데이터 원천 조작: 저유동성 구간이나 플래시론을 이용한 가격 왜곡 MEV와 타이밍: 블록 포함 순서와 재구성에 따른 관측 시점 왜곡 블록 타임 오용: block.timestamp는 제한적 조작 허용 범위가 있어 현실 시간 대체로 부적합 릴레이 재생: 과거 응답 재사용 시도 논스·체인ID·세션 바인딩으로 차단 필요 키 관리: 운영 키 탈취 시 악성 업데이트 가능 임계치 서명과 HSM 사용 권장 TEE 한계: 측채널과 신규 취약점 가능성 원격 증빙 검증과 이중화 필요 브리지 혼동: 교차체인 메시징은 오라클과 유사하나 보안 가정과 합의 상속 방식이 다름 경계 구분 필요 설계 패턴 푸시형 가격 피드: 오라클이 주기적으로 포스트 컨슈머는 최신값을 읽고 신선도 검사 풀형 요청 응답: 컨슈머가 자산·시장·윈도우를 명시해 요청 생성 오라클이 비동기로 응답 낙관적 오라클: 먼저 값을 게시하고 이의 제기 윈도우 동안 분쟁 없으면 확정 파생상품과 거버넌스 판정에 유용 라이트클라이언트 기반: 다른 체인의 상태를 검증 가능한 증명으로 반영 신뢰를 오라클에서 원체인 합의로 이동시키는 접근 간단 예시 가격 피드를 읽고 오래된 값은 거부하는 최소 구현 예시\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.24; interface IOracle { function latestValue() external view returns (int256 value, uint256 updatedAt); } contract UsesOracle { IOracle public oracle; uint256 public maxStale = 5 minutes; error StalePrice(); constructor(address oracleAddr) { oracle = IOracle(oracleAddr); } function price() public view returns (int256) { (int256 v, uint256 t) = oracle.latestValue(); if (block.timestamp - t \u0026gt; maxStale) revert StalePrice(); return v; } } 확장 포인트 다중 오라클에서 값을 수집해 중앙값 계산 업데이트 주기와 최대 지연을 스토리지 파라미터로 설정하고 거버넌스로만 갱신 체인ID·자산ID·라운드ID를 함께 저장해 재생 공격과 혼선 방지 설계 선택지 비교 요약 분류 장점 단점 적합한 경우 중앙화 오라클 단순·저비용·낮은 지연 단일 실패 지점과 검열 리스크 내부 시스템 연계와 제한적 신뢰 도메인 탈중앙 집계 오라클 고가용성·조작 내성·감사 용이 설계 복잡·가스 비용 증가 디파이 핵심 지표와 공공 데이터 낙관적 오라클 저비용·유연한 소스 확정 지연·분쟁 처리 필요 파생상품 결제와 거버넌스 판정 라이트클라이언트 원체인 합의 상속 구현 복잡·검증 비용 교차체인 상태 증명과 브리지 체크리스트 신뢰 모델과 보안 가정이 문서화되어 있음 데이터 소스 다변화와 이상치 규칙이 명시됨 최대 지연과 허용 오차 상수가 컨트랙트에 고정됨 콜백 접근 제어와 세션 바인딩이 구현됨 이벤트·지표·알림이 배포 전후 모니터링에 연결됨 폴백과 동결 모드가 안전하게 작동함 테스트가 지연·이상치·재구성·가스 급등을 포함함 대표 사용 사례 디파이 담보 청산과 대출 한도 계산을 위한 외부 가격 피드 보험 기상 데이터 트리거로 자동 청구 처리 자동화 결제 특정 지표가 기준치 도달 시 결제 실행 게임과 NFT 오프체인 경기 결과나 난수의 온체인 반영 검증 가능한 난수 생성기 사용 권장 IoT 센서 측정치 기록 또는 온체인 조건에 따른 장비 제어 오라클의 장점 확장성 온체인 로직이 외부 정보에 기반한 의사결정 수행 가능 자동화 조건 충족 시 트랜잭션 자동 실행 데이터 다양성 금융·기상·물류·위치 등 다양한 도메인 연계 한계와 트레이드오프 신뢰 문제 중앙화는 단일 실패 지점 탈중앙화는 비용과 복잡도 상승 데이터 지연과 가용성 실시간성 한계와 네트워크 혼잡 시 업데이트 누락 가능 경제적 공격 가격 조작과 플래시론 악용 다중 소스와 완화 규칙 필요 거버넌스와 업그레이드 운영 키 관리 리스크 롤백 계획과 투명한 변경 절차 필요 마무리 오라클은 스마트 컨트랙트를 현실 세계와 연결하는 핵심 인프라 설계의 본질은 신뢰 경계 관리와 비용 대비 안전성 최적화에 있음 신뢰 모델 명시와 신선도·폴백·모니터링·테스트를 포함한 운영 전략을 갖추면 오라클 리스크를 통제 가능한 수준으로 낮출 수 있음\n참고자료 https://en.wikipedia.org/wiki/Oracle_(blockchain) https://docs.chain.link/ https://docs.api3.org/ https://docs.bandchain.org/ https://vitalik.ca/general/2021/05/05/voting.html ","permalink":"https://handsupmin.github.io/posts/blockchain-oracle-guide-91a3d2/","summary":"\u003ch2 id=\"개념과-배경\"\u003e개념과 배경\u003c/h2\u003e\n\u003cp\u003e스마트 컨트랙트는 체인 내부 상태만 신뢰하고 외부 네트워크에 직접 접근하지 않음\n가격·날씨·게임 결과 같은 외부 데이터를 참조하려면 중간자 역할이 필요함\n오라클은 외부 데이터를 온체인으로 들여오거나 온체인 이벤트를 외부 시스템에 전달하는 인터페이스 역할 수행\n이 연결이 잘못 설계되면 컨트랙트의 무결성이 오라클 신뢰도에 종속되는 구조적 한계가 발생함\u003c/p\u003e\n\u003ch2 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e오라클\u003c/strong\u003e: 블록체인과 외부 세계를 잇는 데이터 브리지 역할\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인바운드 오라클\u003c/strong\u003e: 외부 데이터를 온체인으로 주입\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e아웃바운드 오라클\u003c/strong\u003e: 온체인 이벤트를 외부 서비스나 장치로 전달\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e중앙화 오라클\u003c/strong\u003e: 단일 주체가 데이터 제공 단일 실패 지점과 조작 리스크 존재\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e탈중앙화 오라클\u003c/strong\u003e: 다수 노드와 다중 소스 집계 신뢰성과 가용성 강화 대신 비용과 복잡도 상승\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e소프트웨어 오라클\u003c/strong\u003e: API 기반 웹 데이터 공급\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e하드웨어 오라클\u003c/strong\u003e: 센서·IoT 장치에서 물리 정보 수집과 증빙 제공\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e오라클 문제\u003c/strong\u003e: 체인 합의는 내부 상태만 보장 외부 진실성은 합의 밖에 있어 신뢰 경계가 오라클로 이동하는 과제 존재\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"동작-원리와-구조\"\u003e동작 원리와 구조\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e요청 응답 패턴\u003c/strong\u003e: 컨트랙트가 요청을 생성하고 오라클 네트워크가 수집·검증 후 결과를 콜백으로 전달\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e퍼블리시 패턴\u003c/strong\u003e: 오라클이 주기적으로 데이터를 온체인에 게시하고 컨슈머는 읽기만 수행\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e집계 방식\u003c/strong\u003e: 다중 소스 수집 후 중앙값 또는 가중 평균 산출 이상치 제거 규칙 포함\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e검증 기법\u003c/strong\u003e: 서명 기반 인증, 임계치 다중서명, 커밋 리빌, 신뢰 실행 환경 원격 증명, TLS 증빙, 메르클 증명 등 선택지 존재\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 신선도\u003c/strong\u003e: 하트비트 주기, 변경 폭 임계치 기반 갱신 트리거, 최대 지연 한도 설정\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e전달 보안\u003c/strong\u003e: 콜백 함수 화이트리스트와 접근 제어 논스·타임스탬프로 리플레이 방지\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e비용 모델\u003c/strong\u003e: 온체인 저장과 콜백은 가스 비용 증가 업데이트 주기와 보안 강도를 목적에 맞춰 절충 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"위협-모델과-취약점\"\u003e위협 모델과 취약점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 원천 조작\u003c/strong\u003e: 저유동성 구간이나 플래시론을 이용한 가격 왜곡\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMEV와 타이밍\u003c/strong\u003e: 블록 포함 순서와 재구성에 따른 관측 시점 왜곡\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e블록 타임 오용\u003c/strong\u003e: block.timestamp는 제한적 조작 허용 범위가 있어 현실 시간 대체로 부적합\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e릴레이 재생\u003c/strong\u003e: 과거 응답 재사용 시도 논스·체인ID·세션 바인딩으로 차단 필요\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e키 관리\u003c/strong\u003e: 운영 키 탈취 시 악성 업데이트 가능 임계치 서명과 HSM 사용 권장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTEE 한계\u003c/strong\u003e: 측채널과 신규 취약점 가능성 원격 증빙 검증과 이중화 필요\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e브리지 혼동\u003c/strong\u003e: 교차체인 메시징은 오라클과 유사하나 보안 가정과 합의 상속 방식이 다름 경계 구분 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"설계-패턴\"\u003e설계 패턴\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e푸시형 가격 피드\u003c/strong\u003e: 오라클이 주기적으로 포스트 컨슈머는 최신값을 읽고 신선도 검사\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e풀형 요청 응답\u003c/strong\u003e: 컨슈머가 자산·시장·윈도우를 명시해 요청 생성 오라클이 비동기로 응답\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e낙관적 오라클\u003c/strong\u003e: 먼저 값을 게시하고 이의 제기 윈도우 동안 분쟁 없으면 확정 파생상품과 거버넌스 판정에 유용\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트클라이언트 기반\u003c/strong\u003e: 다른 체인의 상태를 검증 가능한 증명으로 반영 신뢰를 오라클에서 원체인 합의로 이동시키는 접근\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"간단-예시\"\u003e간단 예시\u003c/h2\u003e\n\u003cp\u003e가격 피드를 읽고 오래된 값은 거부하는 최소 구현 예시\u003c/p\u003e","title":"블록체인 오라클 개념, 유형, 동작 원리"},{"content":"개요 OpenZeppelin Contracts 5.0으로 올라가면서 토큰 표준 구현 방식이 크게 바뀜 핵심은 ERC20·ERC721·ERC1155에서 _beforeTokenTransfer와 _afterTokenTransfer 훅이 제거되고 내부 상태 갱신 진입점이 _update 하나로 통합된 것 또한 ERC777과 ERC1820Implementer가 제거됨 이 글은 4.6 계열에서 5.1까지 마이그레이션할 때 알아야 할 변경점과 안전한 이전 절차를 정리함\n핵심 변경 사항 ERC20·ERC721·ERC1155의 전송 수명주기 훅 제거 및 _update 도입 기존 훅 기반 커스터마이징은 _update 오버라이드로 이전 필요 민트와 번 포함 모든 잔액 변경 경로가 _update로 수렴 _transfer, _mint, _burn 비가상 처리 더 이상 이 함수들을 직접 오버라이드 불가 일관성 보장을 위해 상태 변경 경로를 고정 ERC777 및 ERC1820Implementer 제거 4.9에서 폐기 예고되었고 5.0에서 실제 삭제 해당 표준 인터페이스는 별도 레포에서 유지되나 구현체 제공하지 않음 동작 원리와 의도 단일 진입점 설계 모든 잔액 및 공급 변화가 _update에서 처리됨 확장과 커스터마이징은 _update를 단일 오버라이드 포인트로 사용 불변식 강화 _transfer, _mint, _burn을 잠그고 내부 루팅으로만 호출되게 하여 상태 불일치 리스크 감소 확장 간 상호작용 일관화 투표, 스냅샷, 소각 수수료, 중지 등 다양한 확장을 _update 체인으로 연결 마이그레이션 가이드 훅 사용 여부 점검 _beforeTokenTransfer, _afterTokenTransfer 오버라이드 코드 존재 여부 확인 각 훅에서 하던 검증, 제한, 회계 처리 항목을 목록화 _update 오버라이드로 이전 훅에 있던 로직을 _update에 통합 검증은 상태 갱신 전 수행 권장 필수로 super._update 호출 필요 기존 _transfer, _mint, _burn 오버라이드 삭제 5.0에서는 오버라이드 자체가 불가 커스터마이징은 _update 단일 경로로 정리 민트와 번 경계값 처리 확인 from 또는 to가 address(0)인 경우를 민트와 번으로 해석 수수료, 제한, 공급 상한과 같은 정책에서 제로 주소 여부 분기 필요 테스트와 이벤트 검증 강화 Transfer 이벤트는 여전히 발생하므로 기존 테스트 자산 가능 단, 커스터마이징이 이벤트 순서나 재진입 가능성에 영향 주지 않게 확인 최소 예시 아래는 기존 _beforeTokenTransfer에서 하던 검증을 _update로 옮기는 형태의 최소 패턴 예시\n// 상태 갱신 전 검증 수행 후 super 호출 권장 function _update(address from, address to, uint256 amount) internal virtual override { if (paused()) revert TokenPaused(); require(!blacklisted[from] \u0026amp;\u0026amp; !blacklisted[to], \u0026#34;restricted\u0026#34;); super._update(from, to, amount); } 포인트\n상태 변경 이전에 정책 검증 실행 super._update 호출로 잔액, 총공급, 이벤트 방출 등을 보장 재정의 시 외부 호출이나 콜백 삽입 지양 실무 체크리스트 오버라이드 경로 단일화 _update만 오버라이드하는지 확인 super 호출 누락 방지 잔액이나 총공급가 틀어지면 모든 기능이 연쇄 실패 민트와 번 분기 정확성 from == address(0) 민트, to == address(0) 번로 처리 Pausable, AccessControl, Snapshot, Votes 등 확장 조합 검증 오버라이드 체인 순서와 super 호출 위치 점검 이벤트 일관성 기존 프론트엔드와 인덱서가 기대하는 Transfer, Approval 이벤트 흐름 유지 확인 가스 영향 가상 함수 수 감소에 따른 소폭 변화 가능성, 기준 가스 측정으로 회귀 테스트 구축 ERC777 및 ERC1820 관련 이전 전략 ERC777 제거 대응 신규 토큰은 ERC20 기반 설계 권장 오퍼레이터 기능 필요 시 권한 제어와 메타트랜잭션 조합으로 대체 설계 검토 ERC1820Implementer 제거 대응 컨트랙트 간 인터페이스 등록에 ERC1820에 의존하던 부분 제거 또는 별도 레지스트리 재설계 필요 레거시 자산 연동 외부에서 ERC777을 계속 사용할 경우 어댑터 컨트랙트로 ERC20 인터페이스 노출 고려 자주 만나는 이슈와 원인 전송이 영구 중지되는 문제 _update에서 super 호출 누락으로 잔액 미변경 민트가 번으로 처리되는 문제 제로 주소 분기 누락 또는 반대로 작성한 조건식 확장 간 충돌 다중 상속에서 오버라이드 체인 정렬 미흡, super 호출 순서 오류 이벤트 기반 인덱싱 실패 이벤트가 여전히 발생하나 테스트에서 커스텀 리버트 후 상태 롤백을 감안하지 못한 경우 검증 전략과 회귀 방지 경계 케이스 퍼징 from 또는 to가 제로 주소인 케이스, 동일 주소 전송, 최대 공급 근접 상황 불변식 기반 테스트 총공급 = 모든 계정 잔액 합계, 전후 차액 = amount 이벤트 시퀀스 단언 Transfer 발생 여부와 파라미터 검증 가스 스냅샷 4.6 대비 변동 폭 기록으로 비정상 증가 탐지 마무리 5.0의 가장 큰 변화는 전송 수명주기 진입점을 _update로 단순화한 것 훅 기반 커스터마이징은 모두 _update로 이동해야 하며 super 호출과 분기 처리를 엄격히 지키는 것이 핵심 ERC777과 ERC1820Implementer 제거에 따른 대체 설계까지 검토하면 5.x 라인으로의 이전 리스크를 크게 줄일 수 있음\n참고자료 https://docs.openzeppelin.com/contracts/5.x/ https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v5.0.0 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3838 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3876 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066 https://docs.openzeppelin.com/contracts/5.x/upgrade ","permalink":"https://handsupmin.github.io/posts/openzeppelin-contracts-5-migration-erc20-erc721-erc1155-update-erc777-removal-73e149/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eOpenZeppelin Contracts 5.0으로 올라가면서 토큰 표준 구현 방식이 크게 바뀜\n핵심은 ERC20·ERC721·ERC1155에서 _beforeTokenTransfer와 _afterTokenTransfer 훅이 제거되고 내부 상태 갱신 진입점이 _update 하나로 통합된 것\n또한 ERC777과 ERC1820Implementer가 제거됨\n이 글은 4.6 계열에서 5.1까지 마이그레이션할 때 알아야 할 변경점과 안전한 이전 절차를 정리함\u003c/p\u003e\n\u003ch3 id=\"핵심-변경-사항\"\u003e핵심 변경 사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eERC20·ERC721·ERC1155의 전송 수명주기 훅 제거 및 _update 도입\n\u003cul\u003e\n\u003cli\u003e기존 훅 기반 커스터마이징은 _update 오버라이드로 이전 필요\u003c/li\u003e\n\u003cli\u003e민트와 번 포함 모든 잔액 변경 경로가 _update로 수렴\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e_transfer, _mint, _burn 비가상 처리\n\u003cul\u003e\n\u003cli\u003e더 이상 이 함수들을 직접 오버라이드 불가\u003c/li\u003e\n\u003cli\u003e일관성 보장을 위해 상태 변경 경로를 고정\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eERC777 및 ERC1820Implementer 제거\n\u003cul\u003e\n\u003cli\u003e4.9에서 폐기 예고되었고 5.0에서 실제 삭제\u003c/li\u003e\n\u003cli\u003e해당 표준 인터페이스는 별도 레포에서 유지되나 구현체 제공하지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리와-의도\"\u003e동작 원리와 의도\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단일 진입점 설계\n\u003cul\u003e\n\u003cli\u003e모든 잔액 및 공급 변화가 _update에서 처리됨\u003c/li\u003e\n\u003cli\u003e확장과 커스터마이징은 _update를 단일 오버라이드 포인트로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e불변식 강화\n\u003cul\u003e\n\u003cli\u003e_transfer, _mint, _burn을 잠그고 내부 루팅으로만 호출되게 하여 상태 불일치 리스크 감소\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e확장 간 상호작용 일관화\n\u003cul\u003e\n\u003cli\u003e투표, 스냅샷, 소각 수수료, 중지 등 다양한 확장을 _update 체인으로 연결\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마이그레이션-가이드\"\u003e마이그레이션 가이드\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e훅 사용 여부 점검\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e_beforeTokenTransfer, _afterTokenTransfer 오버라이드 코드 존재 여부 확인\u003c/li\u003e\n\u003cli\u003e각 훅에서 하던 검증, 제한, 회계 처리 항목을 목록화\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e_update 오버라이드로 이전\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e훅에 있던 로직을 _update에 통합\u003c/li\u003e\n\u003cli\u003e검증은 상태 갱신 전 수행 권장\u003c/li\u003e\n\u003cli\u003e필수로 super._update 호출 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e기존 _transfer, _mint, _burn 오버라이드 삭제\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e5.0에서는 오버라이드 자체가 불가\u003c/li\u003e\n\u003cli\u003e커스터마이징은 _update 단일 경로로 정리\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e민트와 번 경계값 처리 확인\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003efrom 또는 to가 address(0)인 경우를 민트와 번으로 해석\u003c/li\u003e\n\u003cli\u003e수수료, 제한, 공급 상한과 같은 정책에서 제로 주소 여부 분기 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e테스트와 이벤트 검증 강화\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eTransfer 이벤트는 여전히 발생하므로 기존 테스트 자산 가능\u003c/li\u003e\n\u003cli\u003e단, 커스터마이징이 이벤트 순서나 재진입 가능성에 영향 주지 않게 확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"최소-예시\"\u003e최소 예시\u003c/h3\u003e\n\u003cp\u003e아래는 기존 _beforeTokenTransfer에서 하던 검증을 _update로 옮기는 형태의 최소 패턴 예시\u003c/p\u003e","title":"OpenZeppelin Contracts 5.0 마이그레이션 가이드 — ERC20·ERC721·ERC1155 _update 전환과 ERC777 제거"},{"content":"개념 및 배경 Off‑chain은 블록체인 외부에서 연산·저장을 수행하고 필요한 증명 또는 요약만 온체인에 게시하는 접근을 말함 목표는 가스비 절감, 처리량 확대, 데이터 활용 유연성 확보임 온체인은 합의와 정산의 최소 핵심만 유지하고, 나머지는 오프체인 시스템으로 이전하는 설계 철학임\n핵심 개념과 정의 Off‑chain 처리 트랜잭션 집계·상태 채널 업데이트·인덱싱·분석 등을 체인 밖에서 수행하고 결과 요약만 온체인에 커밋하는 방식임\nOff‑chain Data Availability DA 트랜잭션 본문은 오프체인에 보관하고 온체인에는 검증용 최소 데이터와 유효성 또는 사기 증명만 올리는 모델임 데이터 보관자나 분산 스토리지의 지속 제공을 신뢰하거나 경제적 인센티브로 강제하는 설계가 필요함\nOn‑chain DA 대비 위치 on‑chain DA는 calldata나 EIP‑4844 블롭으로 데이터를 L1에 올려 누구나 상태를 재현할 수 있게 함 off‑chain DA는 데이터를 외부에 두고 L1에는 커밋·증명만 올려 비용을 크게 줄임\n동작 원리와 데이터 생애주기 오프체인 엔진이 다수 트랜잭션을 수집·정렬·실행 상태 차분과 루트를 계산하고 필요 시 증명 생성을 수행 L1에 상태 루트·커밋·증명 등 검증 메타데이터만 게시 원본 데이터는 오프체인 DA 레이어 또는 저장소에 보관하며 재현 요청에 응답 L1 컨트랙트는 커밋·증명을 검증하고 브릿지·정산 로직을 진행함 이 파이프라인은 L1 저장 비용과 합의 병목을 줄이는 데 효과적임\n기술 스펙트럼 맵 State Channels 개별 당사자 간 다중 결제를 오프체인으로 처리하고 개시·종료만 온체인에 기록 최종 정산과 분쟁 해결을 위한 증거 제출 경로가 핵심임\nRollups with On‑chain DA Optimistic 또는 ZK 방식으로 실행은 오프체인, 데이터는 L1에 게시해 누구나 재현 가능을 보장함\nValidium ZK + Off‑chain DA 상태의 유효성은 ZK 증명으로 보장하되 데이터는 오프체인에 보관 비용·TPS에 유리하지만 데이터 가용성 제공자 신뢰가 필요함\nOptimium AnyTrust 등 OR + Off‑chain DA 옵티미스틱 검증에 오프체인 DA를 결합한 형태로 비용을 낮추되 위원회 가용성 보장에 의존함\nIndexers Oracles 질의 응답이나 외부 사실을 체인으로 반영하는 오프체인 서비스 정확도·시빌 방지·서명 검증이 신뢰 모델의 핵심임\n장점과 주의사항 장점 요약\n비용 절감 L1에 올리는 데이터량이 줄어 가스비가 감소함 성능 개선 합의 병목을 피하고 높은 TPS를 달성하기 쉬움 데이터 유연성 민감 정보 비공개 보관과 대규모 분석·인덱싱에 유리함 주요 리스크와 대응\n데이터 가용성 위험 오프체인 데이터 손실·중단 시 상태 재현·강제 출금이 어려울 수 있음 다중 복제·위원회 서명 임계값·감사 가능한 저장 포맷과 주기 검증을 도입함\n신뢰 모델 도입 DA 제공자·위원회·운영사에 대한 신뢰가 포함됨 오프보딩·키 교체·부정행위 슬래싱·감사 로그 공개로 책임 경합을 설계함\n검열·중단 대응 시퀀서 중단·검열에 대비해 L1 강제 포함 큐와 탈출 루트를 마련함 이 경로가 DA 레이어 의존 없이 작동하는지 확인함\n검증과 보안 관점 유효성 Validity vs 가용성 Availability 를 분리해 사고를 설계하는 것이 핵심임 ZK 증명은 상태 전이의 정당성을 보장하지만 데이터 접근성은 별개임 사용자가 독립적으로 상태를 재현할 수 있도록 커밋 포맷·해시 체계·증거 경로를 문서화하고 오픈소스로 제공함 DA 장애 시를 가정한 안전 정지 모드와 강제 출금 절차를 온체인에 내장함 예시 패턴 결제 채널 채널 오픈·종료만 온체인 기록, 중간 결제는 오프체인 교환 분쟁 시 최신 서명 상태를 제출해 정산함\n인덱서 서비스 이벤트·상태를 오프체인 DB에 색인해 빠른 질의를 제공 오염 방지용으로 스냅샷 루트를 주기적으로 온체인에 커밋해 검증 가능성을 보강함\nOff‑chain DA 상세 비교 zkRollup vs Validium zkRollup on‑chain DA\n트랜잭션 데이터를 압축해 L1에 게시하고 ZK 증명을 함께 제출함 누구나 데이터를 내려받아 상태를 완전 재현 가능 비용은 데이터 게시량에 비례해 높게 책정될 수 있음 EIP‑4844 블롭 사용 시 데이터 단가가 낮아져 운영 비용을 크게 절감할 수 있음 Validium off‑chain DA\nZK 증명만 L1에 제출하고 데이터는 외부에 보관함 가스비와 TPS에 유리하지만 DA 제공자의 불능·검열이 치명적임 강제 출금·재현 경로가 DA 위원회 서명 또는 가용성 보증에 의존함 결정 기준\n검열 저항·자가 재현성 이 우선이면 zkRollup을 우선 고려 비용·처리량 이 우선이면 Validium을 고려하되 DA 보장과 탈출 경로를 온체인 명세로 고정함 유동적 요구가 섞이면 Volition 같이 토큰 단위로 on‑chain DA와 off‑chain DA를 선택하는 하이브리드도 검토함 신뢰 모델 매트릭스 모델 실행 검증 데이터 가용성 재현 가능성 주된 위험 zkRollup on‑chain DA ZK 증명 L1 블롭·calldata 전 노드 가능 데이터 비용 부담 Validium off‑chain DA ZK 증명 위원회·DA 레이어 위원회 장애 시 제한 데이터 중단·검열 Optimium AnyTrust 사기 증명 위원회·DA 레이어 도전 전제 도전 실패·위원회 리스크 State Channel 서명 증거 참여자 보관 당사자 간 제한 오프라인·분쟁 지연 표의 각 셀은 구현에 따라 달라질 수 있으니 프로토콜 명세로 확정하는 것이 중요함\n실무 체크리스트 설계 단계\n신뢰 경계 정의 운영자·위원회·사용자 역할과 실패 가정 명확화 커밋 스키마 정의 상태 루트·이벤트 루트·증명 포맷과 해시 규칙 고정 탈출 로직 정의 시퀀서 불능·DA 장애 시 강제 포함·강제 출금 경로 설계 운영 단계\nTTI TTP TTF 포함 지표 모니터링 포함 지연·증명 지연·최종성 도달 시간 추적 DA 가용성 모니터링 응답 지연·결함률·복제 카운트·위원회 서명 실패율 추적 키·권한 관리 위원회 키 교체·슬래싱·감사 로그를 주기 공개 보안·거버넌스\n업그레이드 권한 최소화와 타임락·멀티시그 적용 비상 스위치 남용 방지 조건 명문화와 온체인 공시 감사·버그바운티·재현 도구 공개로 검증 가능성 제고 오해 방지 팁 ZK 증명이 있으면 모든 리스크가 사라진다는 오해는 금물 ZK는 정당성을 보장하지만 가용성·검열 문제는 별개임 오프체인 인덱서가 반환하는 값은 편의 결과물임 신뢰 최소화를 원하면 커밋된 루트와 머클 증명을 함께 검증해야 함 마무리 Off‑chain 패턴은 확장성의 실질 해법이지만 신뢰·가용성·유효성 사이의 선택을 요구함 zkRollup과 Validium은 검증 방식은 유사하게 ZK 를 쓰되 데이터 위치에서 다른 트레이드오프를 가짐 제품 요구에 맞춰 DA 보장책·탈출 경로·운영 지표를 명확히 설계하면 비용과 성능을 확보하면서도 안전성을 유지할 수 있음\n참고자료 Ethereum Layer 2 개요 https://ethereum.org/en/developers/docs/layer-2 ZK Rollups 개요 https://ethereum.org/en/developers/docs/scaling/zk-rollups EIP‑4844 Proto‑Danksharding 블롭 https://eips.ethereum.org/EIPS/eip-4844 ","permalink":"https://handsupmin.github.io/posts/off-chain-data-availability-zkrollup-validium-274b74/","summary":"\u003ch3 id=\"개념-및-배경\"\u003e개념 및 배경\u003c/h3\u003e\n\u003cp\u003eOff‑chain은 블록체인 \u003cstrong\u003e외부\u003c/strong\u003e에서 연산·저장을 수행하고 \u003cstrong\u003e필요한 증명 또는 요약만 온체인에 게시\u003c/strong\u003e하는 접근을 말함\n목표는 \u003cstrong\u003e가스비 절감\u003c/strong\u003e, \u003cstrong\u003e처리량 확대\u003c/strong\u003e, \u003cstrong\u003e데이터 활용 유연성 확보\u003c/strong\u003e임\n온체인은 합의와 정산의 최소 핵심만 유지하고, 나머지는 오프체인 시스템으로 이전하는 설계 철학임\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOff‑chain 처리\u003c/strong\u003e\n트랜잭션 집계·상태 채널 업데이트·인덱싱·분석 등을 체인 밖에서 수행하고 결과 요약만 온체인에 커밋하는 방식임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOff‑chain Data Availability DA\u003c/strong\u003e\n트랜잭션 본문은 오프체인에 보관하고 온체인에는 검증용 최소 데이터와 \u003cstrong\u003e유효성 또는 사기 증명\u003c/strong\u003e만 올리는 모델임\n데이터 보관자나 분산 스토리지의 \u003cstrong\u003e지속 제공\u003c/strong\u003e을 신뢰하거나 경제적 인센티브로 강제하는 설계가 필요함\u003c/p\u003e","title":"Off-chain 개념과 데이터 가용성: zkRollup vs Validium 비교"},{"content":"개요 이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함 목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것\n주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요\n배경과 목적 배경: L1(예: 이더리움)의 처리량·가스비 제약을 보완하기 위해 L2 도입이 필요 ZK Rollup의 목적: 메인넷 보안성을 활용하면서 트랜잭션 처리량을 확대하고 온체인 비용을 절감. 유효성 증명(validity proof) 으로 상태 전이가 올바름을 보장해 도전 기간 없이 빠른 확정을 지향 핵심 개념과 정의 ZK Rollup: 트랜잭션을 L2에서 실행·집계하고, 그 결과에 대한 유효성 증명을 L1로 제출해 상태 변경을 확정하는 확장 방식 ZK Stack(일반): ZK Rollup 구축을 위한 회로/프루버/런타임/배포 도구의 모음(구현체별 상이) Sequencer: L2 트랜잭션을 수신·정렬·블록화하고, 배치를 생성하는 컴포넌트(중앙/탈중앙 설계 가능) Prover / Verifier: Prover가 증인(witness) 을 생성하고 회로를 실행해 증명을 만들면, L1의 Verifier(스마트 컨트랙트)가 이를 검증 네이티브 Account Abstraction(AA): 모든 계정이 컨트랙트 계정으로 동작(예: zkSync·Starknet 스타일). EIP-4337과는 별개 경로의 네이티브 모델일 수 있음 아키텍처 개요 Sequencer 영역\nRPC 게이트웨이: 트랜잭션 제출·조회 API 제공(JSON-RPC 호환/확장) 시퀀싱/실행: 멤풀에서 트랜잭션을 읽어 정렬·블록화, 실행 결과를 즉시 반환할 수 있음(체인별 정책) L1 동기화: 입출금 브리지, 시스템 이벤트 추적 Prover \u0026amp; Verifier 영역\n증인 생성 → 회로 실행 → 증명 생성/집계 → (선택) 재귀 증명 일부 구현은 STARK → SNARK 래핑 또는 재귀 SNARK로 L1 검증 비용 최적화(구현체별 다름) L1 Rollup Contracts\n배치 커밋(DA 확립), 증명 검증, 상태 루트 업데이트, 크로스체인 메시지 처리(Inbox/Outbox) 데이터 가용성(DA)\nEIP-4844 블롭을 활용해 Rollup 데이터(입력/차분)를 저비용으로 게시. 블롭은 EVM에서 직접 읽히지 않으며 일정 기간 후 가비지 컬렉션될 수 있으므로, L2 재현성은 블롭 + 노드 아카이빙 조합으로 확보 트랜잭션 생명주기(일반화) 제출: 클라이언트가 JSON-RPC로 트랜잭션 전송 → L2 멤풀 적재 시퀀싱 \u0026amp; 실행: Sequencer가 트랜잭션을 정렬·실행. 결과(성공/실패, tx hash)를 즉시 응답 가능(정책에 따름) 배치 생성: 특정 주기/조건에 따라 블록들을 묶어 배치(batch) 구성 증명 준비: Prover가 배치에 대한 witness 생성 → 회로 실행 → 유효성 증명 생성(필요 시 재귀/집계) L1 게시(DA) \u0026amp; 증명 제출: 블롭(EIP-4844) 등으로 데이터 가용성 확보 후, 증명을 Rollup Verifier에 제출 검증·확정: L1에서 증명 검증 성공 시 해당 배치의 상태 루트가 확정(finality). 브리지 메시지 처리 등 후속 로직 실행 용어 주의: 구현 문서에 나오는 proveBatches, finalize/executeBatches 등 함수명은 예시적 표현이며, 실제 명칭·시맨틱은 스택별로 다름\n증명 파이프라인(좀 더 구체적으로) witness 생성: VM 실행 트레이스, 스토리지 읽기/쓰기, precompile 호출 등을 회로 입력으로 변환\n회로 구성: 범용 VM 회로(예: RISC-V/LLVM IR 스타일) 또는 EVM 친화 회로, Merkle/KZG 등 커밋먼트 검증 서브회로 포함\n재귀·집계: 여러 증명을 트리 형태로 합성(aggregation)해 L1 검증 비용을 상수/로그 수준으로 유도\n성능 팁(운영):\n배치 크기/가짓수, 회로 분해(granularity) 설정으로 TTP(Time-To-Proof) 최적화 프루버 팜(HW 가속: GPU/FPGA/ASIC)과 큐 동시성으로 증명 처리량 보장 L1 가스/블롭 비용 변동에 맞춘 배치 시점/크기 튜닝 데이터 가용성(DA) \u0026amp; EIP-4844 블롭(Blob): EVM에 직접 접근 불가한 대용량 데이터 영역. KZG 커밋먼트로 무결성 보장 장점: calldata 대비 저렴한 데이터 게시. 롤업 비용 구조의 핵심 운영 포인트: 블롭 보존 기간 이후를 대비해 오프체인 아카이브·재생성 전략 필요. 프루닝 정책과 동기화 도구 점검 L1 Rollup Contract 주요 기능(일반화) commitBatch: 입력 데이터/상태 요약을 게시(DA) verifyBatch: 제출된 증명의 유효성 검증 finalizeBatch: 상태 루트 업데이트 및 교차메시지 확정 Bridge(입·출금): L1↔L2 메시지 박스(Inbox/Outbox), 강제 포함(Force Inclusion) 메커니즘으로 검열 대응 네이티브 계정 추상화(AA) 개요 핵심: EOA 없이 모든 계정이 컨트랙트로 동작 → 서명 검증·nonce·가스 지불 로직을 계정이 스스로 정의 장점: 키 회전/멀티시그/세션키/소셜 복구/가스 대납 등 유연한 UX 주의: mempool 정책, 부트로더/시스템 컨트랙트 인터페이스, 가스 회계 방식이 EIP-4337과 다를 수 있음 (예시) 네이티브 AA 처리 흐름 (zkSync 계열 유사 개념, 체인별 상이) 제출: JSON-RPC로 트랜잭션 제출(from이 컨트랙트 주소) 부트로더/시스템: 멤풀→배치, nonce 검증·서명 검증·가스 계산 계정 훅: validate* → execute* → paymaster/fee settlement 순으로 훅 호출 페이마스터: 정책에 맞춰 가스 대납/토큰 지불 결정, 사후 정산 훅 실행 EIP-4337(번들러/EntryPoint 기반)과 동일하지 않음. “네이티브 AA”는 프로토콜 레벨에서 계정이 컨트랙트로 정의되는 모델임\n페이마스터(가스 대납) 설계 포인트 정책: 허용 토큰·한도·쿨다운·화이트리스트/블랙리스트 검증: 오프체인 서명·쿼터 점검·리플레이 방지(nonce·만료) 리스크 관리: 불로소득(arbitrage) 악용·스팸 방지(예: 최소 잔액·인증)·실패 시 롤백 범위 최소화 스마트 컨트랙트 지갑 설계(일반) 배포 패턴: 팩토리+프록시(미니멀 프록시)로 가스 절감·업그레이드 용이 키 관리: 멀티시그·세션키(권한·만료)·키 회전·소셜 복구 서명 표준: 온체인 서명 검증은 EIP-1271 구현 권장 // 30줄 미만 예시 contract ERC1271 { bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature(bytes32 _hash, bytes memory _sig) public view returns (bytes4) { // 구현부는 지갑 정책에 맞게 작성 return MAGICVALUE; } } 보안 모델 및 리스크 유효성 증명 안전성: 회로 사운드니스, 트러스트 설정(예: SRS), 업그레이드 키 관리 시퀀서 리스크: 다운타임/검열 → 강제 포함 경로(L1 큐), 시퀀서 탈중앙화 로드맵 검토 브리지 안전성: L1 검증 완료 전 출금 불가. 메시지 재생성·체인 재조직(Reorg) 처리 방침 명확화 AA·페이마스터 남용: 스팸·사기 유입을 계정/페이마스터 레벨에서 선제 차단 운영·모니터링 지표(KPI) TTI(Time-To-Inclusion): 제출→L2 포함까지 지연 TTP(Time-To-Proof): 배치→증명 생성 완료까지 지연 TTF(Time-To-Finality): L1 검증 완료까지 전체 시간 비용 지표: L1 데이터(블롭/칼데이터) 비용, 증명 가스/수수료, L2 가스 신뢰도: 시퀀서 가용성, 강제 포함 성공률, 브리지 처리 성공률 성능·운영 베스트 프랙티스 배치 전략: 가스 시황·트래픽 패턴에 맞춘 동적 배치 크기/주기 프루버 팜: GPU/FPGA 활용·큐 병렬화·증명 집계로 지연 단축 비용 최적화: EIP-4844 블롭 우선 활용, 상태 쓰기 최소화, 재귀 증명으로 L1 검증 상수화 개발자 경험(DX): JSON-RPC 차이점 문서화, 트레이스/디버깅 도구 제공, 에러 코드 일관성 간단 운영 시나리오(요약) 사용자가 트랜잭션 제출 → Sequencer가 실행 결과를 빠르게 응답 → 일정 주기마다 배치 생성 → Prover가 증명 생성 및 집계 → L1에 블롭 데이터 게시 + 증명 제출 → Verifier가 검증하면 상태 확정 → 브리지 메시지 처리 자주 헷갈리는 포인트 교정 “ZK Rollup은 항상 STARK→SNARK 압축을 한다” → 체인별로 다름. SNARK만 쓰거나, STARK 검증을 L1에서 직접 하거나, 재귀 SNARK만 쓰는 경우도 있음 “네이티브 AA = EIP-4337” → 아님. 네이티브 AA는 프로토콜 계정 모델 자체가 컨트랙트 기반. 4337은 EOA 유지 + 번들러/EntryPoint 레이어임 “블롭 데이터는 영구 상태” → 아님. 블롭은 일시적 보존이며 EVM에서 바로 읽을 수 없음. KZG 커밋먼트로 무결성만 보장 “증명 올라가면 즉시 확정” → L1 검증 트랜잭션 확정(재조직 위험 해소)까지 감안해야 운영상 최종 확정으로 처리 마무리 본 문서는 Abstract 계열 ZK Rollup L2를 염두에 둔 일반적 아키텍처와 AA·지갑·페이마스터 동작을 설명했음\n실제 배포·운영 시에는 다음을 우선 검토 권장\n증명 백엔드 설계(회로 범위·재귀·프루버 팜) 배치·DA 전략(블롭 활용, 비용·지연 균형점) AA/페이마스터 보안 정책(남용·스팸 방지) 브리지 \u0026amp; 강제 포함 경로(검열/다운타임 대비) 체인·스택 문서를 병행하여 용어·함수명·정책 차이를 확인하고, 위 원칙을 현장에 맞게 보수적으로 적용할 것\n참고자료 EIP-1271: https://eips.ethereum.org/EIPS/eip-1271 EIP-4844(Proto-Danksharding): https://eips.ethereum.org/EIPS/eip-4844 롤업 설계 원리(Buterin): https://vitalik.ca/general/2021/06/15/rollups.html ","permalink":"https://handsupmin.github.io/posts/abstract-chain-overview-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 글은 ‘Abstract’로 지칭되는 \u003cstrong\u003eZK Rollup 기반 L2 체인\u003c/strong\u003e의 구조와 핵심 컴포넌트를 \u003cstrong\u003e실무 관점\u003c/strong\u003e에서 정리함\n목표는 \u003cstrong\u003e트랜잭션 흐름\u003c/strong\u003e, \u003cstrong\u003e증명 생성·검증 파이프라인\u003c/strong\u003e, \u003cstrong\u003e데이터 가용성(DA)\u003c/strong\u003e, \u003cstrong\u003e네이티브 계정 추상화(AA)\u003c/strong\u003e, \u003cstrong\u003e스마트 컨트랙트 지갑\u003c/strong\u003e의 동작 방식과 \u003cstrong\u003e운영·보안·성능 관점의 실무 포인트\u003c/strong\u003e를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 \u003cstrong\u003e정확성\u003c/strong\u003e을 보강하는 것\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e주의: 본 문서는 \u003cstrong\u003e일반적인 ZK Rollup 아키텍처\u003c/strong\u003e를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 \u003cstrong\u003e구현체 문서\u003c/strong\u003e를 병행 참고 필요\u003c/p\u003e","title":"Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리"},{"content":"개요 프라이빗키 관리 방식에 따라 암호화폐 월렛은 커스토디얼(custodial) 과 논커스토디얼(noncustodial) 로 구분됨 각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 초보자도 이해할 수 있게 정리하면서 실무자가 바로 적용할 수 있는 체크리스트까지 제시함\n핵심 개념 커스토디얼 월렛 제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조 로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\n논커스토디얼 월렛 사용자가 프라이빗키를 직접 보유·관리하는 구조 브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\n핵심 차이 한 줄 정리 키의 소유·통제 주체가 제3자인가 사용자 본인인가의 차이\n모델별 동작 원리와 구성 커스토디얼 키 보관 중앙화된 키 보관소와 접근제어 체계를 운용 보통 핫월렛 과 콜드월렛 을 분리해 즉시성 vs 보관 안정성을 균형 있게 설계함 운영 통제 권한 분리, 변경 이력 추적, 승인 워크플로, 이상 징후 모니터링을 포함 유저 경험 계정 비밀번호·2FA 등 웹서비스 UX에 가깝고 분실 시 고객지원으로 복구 가능성이 있음 논커스토디얼 키 생성·저장·복구를 사용자 단말 또는 전용 기기에서 수행 하드웨어 지갑은 기기 내 보안영역에서 서명 연산을 수행해 키를 외부로 노출하지 않음 시드 문구(BIP‑39) 와 HD 지갑(BIP‑32, BIP‑44) 로 여러 주소를 파생해 사용함 분실·도난·손상에 대비한 백업·복구 절차가 필수임 하이브리드 접근 멀티시그 N개 중 M개 서명이 있어야 지출 가능 운영자 간 책임 분산과 단일 키 손실 리스크 완화에 효과적 키 분할과 복구 Shamir Secret Sharing 은 백업·복구에 적합하나 서명 자체는 수행하지 않음 임계값 서명(MPC/TSS) 여러 파티가 키 조각을 재조합 없이 공동 서명 단일 실패 지점 제거와 유연한 권한 정책이 장점 보안·규제·운영 관점 비교 구분 커스토디얼 논커스토디얼 키 소유 서비스 사업자 사용자 복구 용이성 계정 기반 복구 지원 가능 사용자가 책임, 백업 실패 시 복구 불가 보안 초점 내부자 위협·핫월렛 침해·운영 취약점 피싱·악성코드·물리 분실·백업 실패 컴플라이언스 관할에 따라 수탁 라이선스·KYC/AML 등 요구 가능 개인 사용은 상대적으로 자유, 조직은 회계·규정 준수 정책 필요 확장성/운영 기업 통제·감사 로그·승인 워크플로에 유리 사용자 자율성 최상, 표준화된 기업 통제는 구현 난이도 존재 일반 용도 거래소·커스터디 업체·핀테크 개인 보관·DAO 금고·개별 팀 지갑 위협 모델 수립 가이드 가치와 빈도 소액·빈번 결제는 접근성·자동화 우선, 대액·장기 보관은 보존·격리가 우선 공격면 피싱 링크·악성 확장프로그램·사기 승인 서명, 내부자 오남용, 인프라 취약점, 물리적 분실 복구 요구 사람 교체·기기 손상·지역 재해 등 현실 시나리오에서 얼마나 빨리 복구 가능한지 평가 감사 가능성 로그 불변성·승인 이력·역활분리와 규정 준수 증빙 가능성 점검 커스토디얼 선택 체크리스트 운영 보안 핫·콜드 분리, 다중인증, 권한 분리, 변경관리, 침해사고 대응 계획 보유 여부 키 관리 체계 HSM 또는 동급 보안 모듈 사용, 키 생성·보관·회전 절차 문서화, 접근 통제 로그 유지 감사·인증 SOC 2 Type II, ISO/IEC 27001, 취약점 스캐닝·모의침투 주기 운영 여부 재무·보험 보험 범위와 면책 조항을 명확히 공개하는지, 준비금·준법 체계 확인 규제 준수 관할 내 라이선스·KYC/AML 의무 이행, 제재 대응 정책 보유 논커스토디얼 선택 체크리스트 백업·복구 시드 문구 오프라인 보관, 금고·내화 금속 플레이트 등 물리 보안, 복구 리허설 정기 수행 기기 보안 하드웨어 지갑 사용, 펌웨어 서명 검증, 기기 PIN·패스프레이즈 사용, 분실 시 스스로 wipe 가능한지 확인 트랜잭션 안전 서명 전 도메인 분리 정보를 기기 화면에서 직접 확인, 승인 범위·스팸 토큰·허가 영속성 점검 멀티시그·MPC 병용 단일 키 실패 지점 제거, 역할 기반 승인 정책 적용 자동화 요구 스케줄 결제·트리거 송금 등 자동화는 지갑 권한 최소화와 일회성 권한 부여로 제한 운영 베스트 프랙티스 핵심 원칙 최소 권한, 강한 인증, 분리 보관, 반복 검증 지출 정책 금액 구간별 다른 승인 경로 적용, 시간지연 타임락과 알림으로 오탐·오남용 방지 주소 화이트리스트 높은 금액은 사전 등록 주소로만 송금 모니터링 대기열 이상, 실패율 급증, 신규 승인 요청 급증, 지출 한도 임계 접근 알림 키 수명주기 관리 생성·배포·사용·보관·회수·폐기 전 과정 문서화와 정기 점검 사고 대응 유출 의심 즉시 키 회전, 멀티시그 참여자 교체, 브리지·거래소 연락망 업데이트, 법무·준법 협업 라인 확보 시나리오별 권장 아키텍처 개인 사용자 데일리 소액은 모바일 지갑 사용 장기 보관·대액은 하드웨어 지갑과 오프라인 백업 병행 승인 내역 정기 점검과 피싱 훈련 연습 권장\n소규모 팀/스타트업 운영비 지출용 커스토디얼 핫월렛 + 멀티시그 콜드 보관 회계·승인 로그를 공유 드라이브가 아닌 전용 감사 시스템에 적재\n기업·DAO 금고 MPC 기반 금고 또는 다중 하드웨어 지갑 멀티시그 역할 기반 접근제어와 오프보딩 절차, 비상 시나리오의 대체 서명자 지정\n자주 하는 실수와 교정 Shamir 분할 = 안전한 서명이라고 오해 Shamir는 복구용 비밀 분할 기법이고 서명은 수행하지 않음 서명 분산은 MPC/TSS 를 사용함 하드웨어 지갑이면 무조건 안전 펌웨어 진위 검증, 공급망 위협, 화면 검증 습관 없으면 위험이 남음 보험이 있으니 안심 보험은 조건과 면책이 많아 모든 손실을 보장하지 않음 범위·상한·예외를 반드시 확인해야 함 커스토디얼은 모두 동일 보안 수준·감사 성숙도·규제 준수·재무 건전성에 큰 차이가 있음 최소 보안 기준 가이드 개인 하드웨어 지갑 1대 이상, 시드 문구 오프라인 백업 2곳, 패스프레이즈 병행, 피싱 훈련 팀 멀티시그 M‑of‑N, 변경 승인 워크플로, 월간 복구 리허설, 화이트리스트 송금 기업 MPC 금고 또는 멀티시그 금고, HSM 또는 동급 보안 모듈, SOC 2 Type II·침투테스트, 사고 대응 플레이북 운영 간단 권장 흐름 1 단계 자산 규모 분류와 위협 모델 정의 2 단계 논커스토디얼·커스토디얼·하이브리드 중 적합 아키텍처 선정 3 단계 백업·복구 문서화와 정기 리허설 시행 4 단계 멀티시그 또는 MPC로 단일 실패 지점 제거 5 단계 지출 정책·화이트리스트·모니터링·사고 대응 체계 운영\n결론 프라이빗키 소유·통제가 보안과 편의의 출발점임 대액·장기 자산은 논커스토디얼과 멀티시그·MPC 조합이 유리하고 업무 자동화·고객 지원이 중요한 경우 커스토디얼이 효율적일 수 있음 모든 선택은 위협 모델·규정 준수·복구 요구를 기준으로 문서화하고 정기적으로 검증해야 함\n참고자료 BIP‑32 계층적 결정성 지갑 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP‑39 니모닉 문구 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP‑44 파생 경로 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki Torus Key Infrastructure 개요 https://docs.tor.us/key-infrastructure/overview NIST SP 800‑57 Part 1 키 관리 권고 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final FIPS 140‑3 암호 모듈 보안 요구사항 https://csrc.nist.gov/publications/detail/fips/140/3/final AICPA SOC 2 안내 https://www.aicpa-cima.com/resources/article/what-is-soc-2 ","permalink":"https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e프라이빗키 관리 방식에 따라 암호화폐 월렛은 \u003cstrong\u003e커스토디얼(custodial)\u003c/strong\u003e 과 \u003cstrong\u003e논커스토디얼(noncustodial)\u003c/strong\u003e 로 구분됨\n각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 \u003cstrong\u003e초보자도 이해할 수 있게\u003c/strong\u003e 정리하면서 \u003cstrong\u003e실무자가 바로 적용할 수 있는 체크리스트\u003c/strong\u003e까지 제시함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e커스토디얼 월렛\u003c/strong\u003e\n제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조\n로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e논커스토디얼 월렛\u003c/strong\u003e\n사용자가 프라이빗키를 직접 보유·관리하는 구조\n브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e핵심 차이 한 줄 정리\u003c/strong\u003e\n키의 \u003cstrong\u003e소유·통제 주체\u003c/strong\u003e가 제3자인가 사용자 본인인가의 차이\u003c/p\u003e","title":"커스토디얼 vs 논커스토디얼 월렛 비교"},{"content":"개요 블록체인은 중앙 기관 없이 참여자들이 거래를 기록·검증·공유하는 분산 원장 기술임 이 글은 블록체인을 초보자 친화적으로 설명하고, 실무 체크리스트까지 정리함\n큰 그림: 시스템 구성 노드(Node): 블록체인 소프트웨어 실행 주체\n풀노드: 모든 블록·트랜잭션 검증·저장 라이트 클라이언트: 헤더·머클 증명 기반 최소 검증 (참고) 아카이브 노드: 오래된 상태 포함 전체 상태 유지(필수 아님) 블록(Block): 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\n합의(Consensus): 어떤 블록이 정식 이력인지 네트워크가 공동으로 결정하는 규칙\nPoW: 작업증명(연산 경쟁) PoS: 지분증명(검증자·보증금 기반) 해시(Hash)와 위·변조 방지 해시 함수(SHA-256, Keccak-256 등): 입력을 고정 길이로 압축하는 일방향 함수임\n충돌 가능성은 이론상 존재하나 실무적으로 극히 낮음 입력이 조금만 바뀌어도 출력이 크게 달라져 무결성 검증에 적합 체인 무결성: 각 블록 헤더에 이전 블록의 해시가 포함됨 → 중간 블록 하나만 바꿔도 이후 전체를 재계산해야 하므로 변조 난이도 매우 높음\n블록헤더와 머클트리(데이터 구조) 블록헤더 대표 필드(비트코인 예시)\nversion, prev_block_hash, merkle_root, timestamp, bits(난이도), nonce 헤더 전체를 해시한 값이 블록 ID 역할을 함 머클트리(Merkle Tree)\n트랜잭션 목록을 해시 이진트리로 요약 → 머클루트(루트 해시) 로 대표 라이트 클라이언트는 머클 증명만 받아 특정 트랜잭션 포함 여부를 검증 가능(SPV) 거래 흐름: 생성 → 서명 → 전파 → 블록 포함 → 확정 생성: 송신자가 수신자 주소·금액으로 트랜잭션 생성 서명: 개인키로 전자서명(비대칭키: ECDSA/secp256k1 등) 전파: P2P 네트워크로 브로드캐스트 → 각 노드의 mempool 에 적재 블록 포함: 합의 규칙에 따라 트랜잭션이 블록에 포함 확정(Finality/확인수): 후속 블록이 더해질수록 되돌리기 어려움 비트코인: 평균 블록 간격 ≈ 10분, 확인수 6 관행(사용처·금액 따라 상이) 이더리움(현행 PoS): 슬롯 ≈ 12초, 체크포인트·파이널리티 개념 사용(정상 시 약 2 에폭에서 최종화, 대략 10~15분 수준). “N 블록이면 충분” 같은 단정 대신 파이널리티 달성 여부 확인이 안전함 상태 모델: UTXO vs 계정(Account) UTXO(비트코인 계열)\n“사용하지 않은 트랜잭션 출력(코인)”을 조합해 지불, 잔돈은 새 UTXO로 생성 장점: 병렬화에 유리, 프라이버시 패턴 일부 이점 유의: 선택/잔돈 전략, 수수료(단위: sat/vByte) 최적화 필요 계정 모델(이더리움 계열)\n계정 잔액·컨트랙트 상태(State) 갱신 장점: 스마트 컨트랙트·상태머신 구현 용이 유의: 상태 증가(State bloat)·가스 비용·리플레이 방지(EIP-155) 등 고려 PoW(작업증명): 난이도·보상·보안 원리: 헤더 + nonce 바꿔가며 목표값(난이도) 이하 해시 찾기 난이도 조정: 네트워크 해시파워 변화에 맞춰 목표 평균 블록 시간 유지(예: 비트코인 2016블록마다 ≈ 2주 간격 조정) 보상: 블록 보상(반감기 존재) + 수수료 보안성: 공격자는 네트워크 해시의 과반수 수준 필요 → 대형 체인에서는 경제적·물리적 비용 거대 간단 PoW 의사코드(개념 학습용)\ntarget = difficulty_to_target(bits) nonce = 0 while True: header = serialize(version, prev_hash, merkle_root, timestamp, bits, nonce) h = sha256d(header) # SHA256(SHA256(header)) if h \u0026lt; target: print(\u0026#34;Found!\u0026#34;, nonce, h.hex()) break nonce += 1 실무 팁\n해시 라이브러리·엔디언 처리·직렬화 포맷(가변 길이 정수 등) 정확도 중요 반감기 이벤트는 채굴 수익성·해시파워·보안에 직격 영향 PoS(지분증명): 검증자·파이널리티·리스크 원리: 토큰 스테이킹 으로 검증자 선정(무작위 + 지분 가중 + 추가 규칙)\n블록·어테스테이션: 검증자가 블록 제안·감사(투표) 수행\n파이널리티: 일정 조건(예: ≥ 2/3 가중치가 찬성) 만족 시 체크포인트 최종화\n위협 모델\nNothing-at-Stake: 여러 체인에 동시 투표 유혹 → 슬래싱 으로 억제 롱레인지 공격: 과거부터 조용히 대체 체인 생성 → 약한 주관성(weak subjectivity)·체크포인트·동기화 규칙으로 방어 수수료와 가스: Bitcoin vs Ethereum Bitcoin: 수수료 = 바이트 크기 × 단가(sat/vByte)\n수수료 추정은 mempool 혼잡도·정책 영향 큼 Ethereum(EIP-1559)\nBase Fee(블록에 의해 자동 조정, 소각) + Priority Fee(팁) + gas_used 사용자 입장: 예상 가능한 수수료 + 혼잡 시 팁으로 우선순위 확보 컨트랙트 호출은 가스 한도 내에서만 실행됨(한도 부족 시 revert) 포크(Fork)와 체인 재조직(Reorg) 소프트 포크: 규칙 강화로 하위 호환 유지(예: SegWit 트랜잭션 가변성 해결, 블록 용량 효율화) 하드 포크: 규칙 불일치 → 미업데이트 노드와 체인 분리 가능(예: ETH/ETC) 운영 유의\n포크 전후 송금 보수적 운영(리플레이·정책 불확실성) 거래소·지갑 대응 계획 사전 확인 자연스런 재조직(reorg) 는 드물지만 발생 가능 → 높은 가치 송금은 여유 확인수/파이널리티 확보 보안 메커니즘·공격 모델 51% 공격(PoW): 과반 해시파워로 더 긴 체인을 만들어 이중지불 가능\n대형 체인: 비용·탐지 리스크 막대 중소 체인: 실질 리스크 존재 → 심도 있는 모니터링·안전 확인수 확대 권장 네트워크 공격: 이클립스(Eclipse)·Sybil·시간 왜곡 등 → 피어 다양화·시계 동기화·피어 밴 정책 필요\n지갑·키 관리\n개인키 유출 = 자금 유출 권장: 하드웨어 지갑, 멀티시그, 콜드월렛, 백업 시 BIP39 시드 문구 별도·오프라인 보관 확장성: 온체인 한계와 오프체인/Layer2 온체인 한계: 블록 크기·주기 제약 → TPS 제한, 탈중앙화·보안·확장성(블록체인 트릴레마) 간 트레이드오프 존재\n오프체인 결제(라이트닝 네트워크)\n양자 간 결제 채널 열고 다수 거래를 오프체인 처리, 최종 상태만 온체인 정산 핵심 메커니즘: 타임락, 페널티 트랜잭션, 경로 탐색 장점: 속도·수수료 우수 / 과제: UX·유동성·라우팅 Rollup(이더리움 L2)\nOptimistic Rollup: 사기 증명 기반, 이의제기 기간 후 확정 ZK Rollup: 영지식 증명 기반, 검증 빠름(증명 생성 비용·지연 고려) 데이터 가용성(DA): L1에 핵심 데이터 또는 블롭(EIP-4844) 으로 게시 → L2 상태 재구성 가능성 확보 로드맵: 프로토-덴크샤딩(EIP-4844) → 데이터 비용 절감, 장기적으론 완전 덴크샤딩으로 확장성 개선 MEV \u0026amp; PBS(이더리움)\nMEV: 거래 재배치·추출을 통한 가치 → 사용성·공정성 이슈 PBS: 제안자/빌더 분리로 역할 분담, 중앙화·검열 리스크 완화 시도 실무 체크리스트(운영·보안·개발) 노드 운영\n최신 클라이언트·보안 패치 적용, 피어 다변화 모니터링: 블록 지연, reorg, mempool 혼잡, 디스크/네트워크 지표 지갑·키 관리\n하드웨어 지갑·멀티시그·콜드스토리지 적용 시드 백업(오프라인), 접근 통제(2인 승인 등) 스마트 컨트랙트(이더리움)\n감사(Audit)·포멀 검증·테스트넷 충분 운용 가스 최적화: 저장소 쓰기 최소화, 재진입·정수 오버플로 방지, 최신 컴파일러 사용 업그레이드 전략: 프록시 패턴·권한 관리(Owner/Role)·타임락 수수료 전략\nBitcoin: sat/vByte 동적 설정, 급행·보통·저속 정책 분리 Ethereum: EIP-1559의 maxFeePerGas/maxPriorityFeePerGas 합리 설정 포크·네트워크 이벤트 대응\n공지 수집, 송금 동결/완화 기준, 고객 안내 시나리오 준비 간단 비교 표 항목 비트코인(PoW) 이더리움(PoS, Merge 이후) 블록 간격 ~10분 슬롯 ~12초(에폭=32 슬롯) 최종성 확률적(확인수↑) 체크포인트 최종성(정상 시 2 에폭 내외) 수수료 바이트 기준(sat/vByte) EIP-1559(BaseFee 소각 + Tip) 상태 모델 UTXO 계정 + 스마트 컨트랙트 확장성 방향 SegWit·Taproot·Lightning Rollup(Optimistic/ZK) + EIP-4844 자주 틀리는 포인트 “이더리움은 N 블록이면 안전” → (X) 현재는 파이널리티 달성 여부로 판단하는 게 정확함 “PoS는 그냥 코인 많이 가진 사람 승리” → (X) 무작위성·메시지 투표·슬래싱·최종성 규칙이 결합된 프로토콜 전체가 보안 근거임 “SegWit은 리플레이 공격 방지” → (부분 부정확) 핵심 목적은 트랜잭션 가변성(malleability) 해결 및 용량 효율화임 결론 블록체인은 암호학(해시·서명), 분산합의(PoW/PoS), 네트워크 설계가 맞물린 시스템임 설계 선택(PoW vs PoS, UTXO vs 계정, 온체인 vs 오프체인)이 보안·성능·분산화에 직접 영향 실무 핵심은 키 관리·노드 보안·포크/이벤트 대응·수수료 전략·컨트랙트 품질 보증임 확장성은 Layer2 + 데이터 가용성 + 프로토콜 개선을 병행하는 다층 해법이 현실적임 참고자료 비트코인 개요: https://bitcoin.org/ko/how-it-works 비트코인 개발자 가이드(데이터 구조·프로토콜): https://developer.bitcoin.org/devguide/ 이더리움 화이트페이퍼: https://ethereum.org/en/whitepaper/ 이더리움 PoS/합의 문서: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ EIP-1559(수수료 시장): https://eips.ethereum.org/EIPS/eip-1559 EIP-4844(프로토-덴크샤딩/블롭): https://eips.ethereum.org/EIPS/eip-4844 Lightning BOLT 사양: https://github.com/lightning/bolts SegWit 개요(트랜잭션 가변성 개선): https://bitcoinops.org/en/topics/segwit/ ","permalink":"https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인은 \u003cstrong\u003e중앙 기관 없이\u003c/strong\u003e 참여자들이 거래를 기록·검증·공유하는 \u003cstrong\u003e분산 원장\u003c/strong\u003e 기술임\n이 글은 블록체인을 \u003cstrong\u003e초보자 친화적으로\u003c/strong\u003e 설명하고, \u003cstrong\u003e실무 체크리스트\u003c/strong\u003e까지 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"큰-그림-시스템-구성\"\u003e큰 그림: 시스템 구성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e노드(Node)\u003c/strong\u003e: 블록체인 소프트웨어 실행 주체\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e풀노드\u003c/strong\u003e: 모든 블록·트랜잭션 검증·저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트 클라이언트\u003c/strong\u003e: 헤더·머클 증명 기반 최소 검증\u003c/li\u003e\n\u003cli\u003e(참고) \u003cstrong\u003e아카이브 노드\u003c/strong\u003e: 오래된 상태 포함 전체 상태 유지(필수 아님)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e블록(Block)\u003c/strong\u003e: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e합의(Consensus)\u003c/strong\u003e: 어떤 블록이 정식 이력인지 네트워크가 \u003cstrong\u003e공동으로\u003c/strong\u003e 결정하는 규칙\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoW: 작업증명(연산 경쟁)\u003c/li\u003e\n\u003cli\u003ePoS: 지분증명(검증자·보증금 기반)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해시hash와-위변조-방지\"\u003e해시(Hash)와 위·변조 방지\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 함수(SHA-256, Keccak-256 등)\u003c/strong\u003e: 입력을 고정 길이로 압축하는 일방향 함수임\u003c/p\u003e","title":"블록체인이란? 블록체인 개념 총정리"},{"content":"개요 스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음 블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림 이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\n문제 정의와 영향 배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함 예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식 가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가 공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음 RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임 핵심 개념과 대안 1) 매핑으로 존재 여부 O(1) 검사 저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\nmapping(address =\u0026gt; bool) public users; function register(address user) public { require(!users[user], \u0026#34;already registered\u0026#34;); users[user] = true; } 장점 고정 비용으로 존재 확인이 가능 주의 매핑은 온체인 열거 불가이므로 조회 인덱스는 별도로 설계해야 함\n2) 배열 + 매핑 병행 패턴 배열에 값, 매핑에 인덱스 정보를 저장해 추가·삭제·조회 O(1) 과 열거 가능을 동시에 달성함 삭제는 스왑 후 pop으로 상수 시간 처리함\n간단 라이브러리 예시\n// 24줄 예시 라이브러리 library AddressSet { struct Set { address[] _list; mapping(address =\u0026gt; uint256) _index; } function contains(Set storage s, address a) internal view returns (bool) { return s._index[a] != 0; } function add(Set storage s, address a) internal returns (bool) { if (contains(s, a)) return false; s._list.push(a); s._index[a] = s._list.length; return true; } function remove(Set storage s, address a) internal returns (bool) { uint256 i = s._index[a]; if (i == 0) return false; uint256 li = s._list.length; address last = s._list[li - 1]; s._list[i - 1] = last; s._index[last] = i; s._list.pop(); delete s._index[a]; return true; } function length(Set storage s) internal view returns (uint256) { return s._list.length; } function at(Set storage s, uint256 i) internal view returns (address) { return s._list[i]; } } 3) 루프 상한이 명확한 배치 패턴 무제한 루프가 아니라 상한이 보장된 반복만 허용하고 나머지는 다음 호출로 미룸 예 require(batch.length \u0026lt;= MAX_BATCH) 와 체크포인트 저장\n4) 온체인 최소화·오프체인 인덱싱 상태 변경만 온체인에 기록하고 열거·검색은 이벤트 기반 인덱서에 위임함 The Graph 같은 인덱서 또는 백엔드 DB를 사용해 조회 성능을 확보함\n5) 푸시 대신 풀 패턴 N명에게 한 번에 분배하는 푸시 루프 대신 각 수령자가 claim으로 가져가게 해 루프를 제거함 머클 드롭처럼 증명 기반 청구를 쓰면 대량 분배에서도 O(1) per user 달성 가능\n동작 원리 상세 배열 + 매핑 배열에 값 저장, 매핑에 값 → 배열 인덱스+1 저장으로 0을 미존재로 활용 삭제 시 타깃 인덱스에 마지막 요소를 스왑하고 pop, 스왑된 요소의 인덱스를 갱신 삽입·삭제·존재 확인이 모두 상수 시간으로 동작하며 length·at로 열거 가능 실무 포인트 주의·한계·베스트 프랙티스 금기는 무제한 반복이며 루프 자체 금지는 아님 반복의 상한이 코드로 보장되면 안전하게 사용할 수 있음 매핑은 열거가 불가 온체인 열거가 필요하면 배열을 병행하거나 이벤트 인덱싱을 설계함 배열+매핑 병행은 상태 동기화가 생명 삽입·삭제마다 두 구조를 함께 갱신하고 실패 시 일관성 유지를 보장해야 함 대량 작업은 오프체인에서 사전 계산하고 온체인에는 커밋·증명만 올림 함수는 최악 케이스 가스 기준으로 설계하고 배포 전 시뮬레이션으로 수렴 여부를 확인함 관리자 권한으로 아카이빙·프루닝을 허용하면 장기적으로 가스 추세를 안정화할 수 있음 검증된 구현 사용을 우선 고려 OpenZeppelin EnumerableSet 같은 표준 라이브러리는 경계 사례가 잘 다듬어져 있음 추가 최적화 팁 가스·안정성 SSTORE 비용 상식 신규 슬롯 기록은 매우 비싸고 기존 값 업데이트가 상대적으로 저렴하며 가스 환급은 최근 제안들로 크게 축소됨 많은 슬롯을 자주 비우는 설계는 기대만큼 환급이 일어나지 않을 수 있음 콜드·웜 접근 처음 접근하는 저장소·계정은 콜드 비용이 높고 같은 트랜잭션 내 재접근은 웜으로 저렴해짐 같은 키를 여러 번 읽는다면 한 번 읽어 메모리에 캐시하고 사용함 데이터 모델 집합이 ID 기반이면 mapping(uint256 =\u0026gt; uint256) 비트맵으로 압축해 SSTORE 개수를 줄일 수 있음 루프 미세 최적화 상한이 작은 루프에서 unchecked { ++i } 로 증가 비용을 절감할 수 있으나 오버플로 안전성을 스스로 보장해야 함 외부 호출은 풀 패턴 루프 안에서 외부 호출을 하지 말고 사용자가 개별 청구하는 풀 모델로 전환해 재진입·가스 폭탄 리스크를 줄임 EIP‑2930 접근 리스트 가스 민감 트랜잭션은 Access List로 콜드 비용을 일부 완화하는 방식을 검토함 간단한 설계 대안 조회 전용 인덱스 오프체인 위임 온체인은 상태 변경과 이벤트만 발행 페이지네이션 제공 한 호출당 처리량을 제한해 UX와 가스 안정성을 동시에 확보 상한·쿼터·할당량 도입 최대 원소 수나 1회 배치 한도를 프로토콜 상수로 명시하고 초과 시 아카이빙 트리거 검증과 회귀 방지 가스 예산 테스트 최대 예상 n에 대해 단위·통합 테스트로 가스 사용량을 프로파일링 일관성 테스트 배열·매핑 동기화가 항상 유지되는지 경계 케이스로 검증 모니터링 트랜잭션 실패율, 가스 사용 추세, out of gas 류 에러 알람을 운영 대시보드에 포함 프로퍼티 기반 테스트 삽입·삭제·재삽입을 무작위 시퀀스로 실행해 인버리언트를 검증 감사 체크리스트 사용자 입력에 의해 루프 길이가 통제 불가한 경로가 있는지 외부 호출이 루프 내부에 존재하는지 반복 상한을 보장하는 require 검사가 있는지 로컬 캐시 없이 동일 SLOAD를 반복하는지 상태 구조가 장기적으로 가스가 비단조 증가하도록 설계됐는지 실패 시 롤백으로 상태 일관성이 유지되는지 마무리 스마트 컨트랙트의 O(n) 루프는 단순한 비효율이 아니라 운영 불능으로 연결될 수 있는 위험 요소임 매핑과 배열+매핑 패턴으로 상수 시간 검사를 확보하고, 배치·풀·오프체인 인덱싱을 결합해 열거와 성능을 균형 있게 달성할 것 배포 전에는 최악 케이스 가스를 기준으로 테스트하고, 배포 후에는 모니터링과 프루닝 정책으로 장기 안정성을 유지할 것\n참고자료 OpenZeppelin EnumerableSet https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol EIP‑2929 Gas cost increases for state access https://eips.ethereum.org/EIPS/eip-2929 EIP‑3529 Reduction in refunds https://eips.ethereum.org/EIPS/eip-3529 The Graph 문서 인덱싱 개요 https://thegraph.com/docs MerkleProof 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography ","permalink":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 \u003cstrong\u003e실행 불가\u003c/strong\u003e로 이어질 수 있음\n블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 \u003cstrong\u003e가스 한도 초과\u003c/strong\u003e를 일으켜 서비스 가용성을 떨어뜨림\n이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"문제-정의와-영향\"\u003e문제 정의와 영향\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함\n예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식\u003c/li\u003e\n\u003cli\u003e가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가\u003c/li\u003e\n\u003cli\u003e공격자가 \u003cstrong\u003e가스 그리핑\u003c/strong\u003e을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 \u003cstrong\u003eDoS\u003c/strong\u003e가 될 수 있음\u003c/li\u003e\n\u003cli\u003eRPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 \u003cstrong\u003e미포함·리버트\u003c/strong\u003e임\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-대안\"\u003e핵심 개념과 대안\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e1) 매핑으로 존재 여부 O(1) 검사\u003c/strong\u003e\n저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\u003c/p\u003e","title":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"},{"content":"개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\n쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\n이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\n1. 핵심 용어 정리 오프체인 서명 (Off-chain Signature) 블록체인 외부(주로 백엔드 서버)에서 생성된 디지털 서명을 의미함 이 방식은 서명을 생성하는 과정에서 가스비가 들지 않고, 서버의 다양한 로직과 결합할 수 있는 장점이 있음\n메타 트랜잭션 (Meta-transaction) 사용자가 가스비를 직접 내지 않고, 트랜잭션에 대한 의도만 \u0026lsquo;서명\u0026rsquo;으로 표현하면, 제3의 대리인(Relayer)이 이를 대신 실행하고 수수료를 지불하는 패턴임 오프체인 서명은 이 메타 트랜잭션을 구현하는 핵심 기술임\n가스리스 트랜잭션 (Gasless Transaction) 메타 트랜잭션을 통해 사용자가 느끼기에 가스비 없이 트랜잭션을 처리하는 경험을 의미함 서비스 제공자가 페이마스터 등을 통해 가스비를 대납함으로써 구현됨\nEIP-712 단순 문자열이 아닌, 구조화된 데이터에 대한 서명 표준임 이 표준을 사용하면 사용자가 자신이 무엇에 서명하는지 명확히 알 수 있으며, 다른 체인이나 다른 컨트랙트에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지할 수 있어 보안성이 매우 높음\n2. 오프체인 서명 검증의 전체 흐름 서버, 사용자, 그리고 컨트랙트 간의 상호작용은 다음과 같은 단계로 이루어짐\n사용자 요청 사용자의 클라이언트(웹/앱)는 트랜잭션을 바로 블록체인에 보내는 대신, 트랜잭션에 필요한 정보들을 백엔드 서버에 API 요청으로 보냄\n서버 검증 및 서명 서버는 요청이 유효한지 검증함 (예: 우리 서비스의 정식 사용자인가? 요청 내용이 합당한가?) 검증이 완료되면, 서버는 EIP-712 표준에 따라 트랜잭션 파라미터가 담긴 메시지를 만들고, 서버의 개인키로 이 메시지에 서명함\n사용자 트랜잭션 제출 서버는 생성된 서명(signature)과 관련 데이터들을 사용자에게 다시 응답으로 보내줌 사용자의 클라이언트는 이 서명 데이터를 포함하여 트랜잭션를 구성하고, 최종적으로 블록체인(스마트 컨트랙트)에 제출함\n컨트랙트 검증 스마트 컨트랙트는 제출된 트랜잭션을 받아 서명이 유효한지 검증함 검증에 성공하면, 컨트랙트는 약속된 작업을 수행함 (예: 가스비 대납, 아이템 지급 등)\n3. 핵심 원리: 컨트랙트의 서명 검증 과정 컨트랙트는 서버의 개인키를 모르는데, 어떻게 서버가 서명했다는 것을 신뢰할 수 있을까? 이 과정은 암호학적 원리를 이용해 세 단계로 진행됨\n1단계: 데이터 해시(Hash) 재구성 컨트랙트는 사용자가 제출한 파라미터들(userAddress, expiryTimestamp 등)을 받아, 서버가 서명을 생성했을 때와 완벽히 동일한 구조와 순서로 이 데이터들을 조합하여 해시(hash) 값을 다시 계산함\n이때 EIP-712 표준에 따라 컨트랙트의 이름, 버전, 체인 ID 등이 포함된 도메인 분리자(Domain Separator)가 해시와 함께 사용되어 다른 컨트랙트에서 서명이 재사용되는 것을 막음\n// 1. 전달받은 파라미터로 해시 재계산 bytes32 hash = keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice )); bytes32 digest = hashTypedDataV4(hash); // 도메인 분리자와 결합 2단계: 서명자 주소 복원 ecrecover라는 암호학적 함수는 메시지 해시(digest)와 서명값(signature), 이 두 가지를 입력받아 해당 서명을 만들 수 있는 유일한 공개키, 즉 서명자의 주소를 역으로 계산해냄 이 과정에서 서버의 개인키는 절대 노출되지 않음\n// 2. 서명에서 주소 복원 address recoveredAddress = digest.recover(signature); 3단계: 서명자 주소 비교 마지막으로, 2단계에서 복원된 주소가 스마트 컨트랙트에 미리 저장된 신뢰할 수 있는 서버의 주소(signer)와 일치하는지 비교함 두 주소가 일치한다면, 이 서명은 우리가 신뢰하는 서버가 생성한 유효한 서명임이 증명된 것임\n// 3. 복원된 주소가 signer와 일치하는지 확인 require(signer == recoveredAddress, \u0026#34;Paymaster: Invalid signer\u0026#34;); 4. 데이터 무결성: 서명된 데이터는 어떻게 신뢰하는가? \u0026ldquo;만약 사용자가 유효한 서명을 받은 뒤, 파라미터 값만 몰래 바꿔서 제출하면 어떡하지?\u0026rdquo; 결론부터 말하면, 불가능함\n서명 검증 과정 자체가 데이터의 무결성을 보장하기 때문임 만약 사용자가 파라미터를 1비트라도 변경하면, 1단계에서 재구성되는 해시값이 원래의 해시값과 완전히 달라짐 결과적으로 2단계에서 주소 복원에 실패하거나 엉뚱한 주소를 반환하게 되어, 3단계의 주소 비교에서 반드시 실패하게 됨\n이처럼, 서명은 데이터의 해시와 한 쌍으로 묶여있기 때문에 데이터가 조금이라도 변조되면 서명은 즉시 무효가 됨 이 원리 덕분에 우리는 데이터가 서버가 승인한 원본 그대로임을 신뢰할 수 있음\n마무리 오프체인 서명 검증은 온체인의 신뢰성과 오프체인의 유연성을 결합한 강력한 패턴임 이를 통해 가스비 소모 없이 복잡한 비즈니스 로직을 온체인 시스템에 안전하게 적용할 수 있음 서명 검증 과정 자체가 데이터의 무결성과 서명자의 신뢰성을 동시에 보장하므로, 다양한 분야에서 보안성과 효율성을 높이는 데 활용될 수 있음\n","permalink":"https://handsupmin.github.io/posts/off-chain-signature-verification-542a33/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음\n이때 \u003cstrong\u003e오프체인 서명 검증\u003c/strong\u003e(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\u003c/p\u003e\n\u003cp\u003e쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음\n가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\u003c/p\u003e\n\u003cp\u003e이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\u003c/p\u003e","title":"오프체인 서명 검증(Off-chain Signature Verification)이란?"},{"content":"개요 재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임 목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음\n왜 필요한가 트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함 재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함 롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림 핵심 개념 내부 증명 Inner proofs 원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\n합성 회로 Aggregator 이전 단계 증명들의 검증 로직을 회로로 구현하고 그 결과가 참임을 나타내는 새 증명을 생성\n최종 증명 Outer proof 여러 단계를 거쳐 하나로 압축된 최상위 증명 온체인은 이 증명 하나만 확인하면 전체 집합의 유효성을 신뢰할 수 있음\n공개 입력 바인딩 Public input binding 어떤 증명들을 합쳤는지, 어떤 데이터 루트에 대해 성립하는지 루트 커밋·메타데이터를 공개 입력에 포함해 무결성을 보장함\n동작 흐름 개별 증명 생성 L2에서 트랜잭션 또는 배치 단위로 증명 생성 1차 합성 합성 회로가 증명 A, B를 회로 내부에서 검증하고 A∧B가 참임을 증명 반복 합성 결과들을 다시 쌍으로 묶어 트리 형태로 합성해 증명 개수를 절반씩 축소 최종 합성 1개 증명으로 수렴 온체인 검증 L1은 최종 증명 1개만 검증해 전체 유효성에 도달 직관은 증명을 검증하는 회로에 대해 다시 증명을 만든다는 생각으로 이해하면 됨\n설계 선택지와 트레이드오프 증명 시스템 선택\nGroth16 on BN254 검증이 빠르고 EVM 프리컴파일 지원이 좋아 온체인 비용이 낮은 편이나 회로 변경 시 신뢰 설정이 필요하고 공개 입력 크기에 민감함 PLONK류 KZG 커밋 유연한 회로 합성과 대규모 회로에 적합하나 온체인 검증은 곡선·프리컴파일 제약을 받음 Halo2·IPA 계열 신뢰 설정 없이 동일 곡선 내 재귀가 용이해 깊은 재귀에 유리하나 구현 난이도와 상수 계수가 큼 Nova·SuperNova 폴딩 스킴 증명 크기와 재귀 성능이 우수하고 스트리밍 합성에 적합하나 온체인 검증 경로는 추가 압축 단계가 필요한 설계가 일반적임 곡선 전략\n페어링 재귀는 보통 곡선 사이클 MNT4/6, BLS12‑377 ↔ BW6‑761 등을 활용하거나 서로 다른 곡선 간 검증기를 회로화함 EVM에서 직접 검증할 최종 증명은 BN254 프리컴파일을 활용하는 구성이 실무적으로 유리함 집계 토폴로지\n이진 트리 단순하고 지연 균형이 좋음 k‑ary 트리 폭을 늘려 재귀 깊이를 더 줄이되 각 단계 회로가 커짐 스트리밍 합성 입력이 도착하는 대로 누적하는 PCD·폴딩 기반 경로가 실시간 파이프라인에 유리함 정확성·사운드니스 포인트 공개 입력 바인딩 합성 대상 집합을 명확히 커밋 머클 루트·배치 루트·VK 해시 등으로 고정해 혼합 공격을 차단함\n검증기 회로의 완전성 내부 검증 로직은 검증 키 VK와 증명 π의 결합을 정확히 구현해야 함 VK 해시를 공개 입력에 포함해 검증 키 스와핑을 방지함\n도메인 분리와 RNG 각 재귀 단계의 트랜스크립트 도메인을 분리해 Fiat‑Shamir 충돌을 방지함\n사운드니스 누수 관리 여러 단계 합성 시 오류 누적을 고려해 보안 파라미터를 충분히 잡고, 필요 시 최종 단계에서 재압축 증명으로 마무리함\n온체인 검증과 가스 감각 이더리움 메인넷은 BN254 페어링 프리컴파일 EIP‑196/197을 제공하므로 Groth16 BN254 최종 증명 검증이 일반적으로 가장 경제적임 BLS12‑381 프리컴파일은 메인넷에 기본 탑재되어 있지 않으므로 해당 곡선 기반 증명은 직접 검증 비용이 큼 실무 감각으로 단일 Groth16 검증은 수십만 가스 수준이며 다수 증명을 개별 검증하는 것 대비 재귀 한 번으로 크게 절감 가능함 L2에서는 프리컴파일·유효성 브릿지 정책이 다를 수 있으므로 대상 체인의 가스 모델과 프리미티브를 우선 확인 필요함 합성 스케줄 예시 코드 스니펫 # n개의 내부 증명을 이진 트리로 재귀 합성하는 스케줄 개념 예시 def aggregate(proofs): level = proofs while len(level) \u0026gt; 1: nxt = [] for i in range(0, len(level), 2): a = level[i] b = level[i+1] if i+1 \u0026lt; len(level) else level[i] nxt.append(prove_verify(a, b)) # \u0026#34;a와 b를 검증하는 회로\u0026#34;에 대한 새 증명 생성 level = nxt return level[0] # 최종 증명 위 스니펫은 구조 설명용이며 실제 구현은 증명 시스템·곡선·검증기 회로에 따라 상이함\n운영 가드레일과 파이프라인 배치 크기 캡 증명 생성기 큐 길이와 메모리를 감안해 단계별 최대 입력을 제한 타임아웃·재시도 각 단계별 SLA를 두고 실패 시 병렬 재스케줄 또는 부분 재구성 적용 관측성 TTI 포함 지연, TTP 증명 생성 지연, TTF 최종성 도달 시간, 실패율, 메모리 피크를 모니터링 키·파라미터 롤오버 VK·SRS 교체 절차를 정의하고 공개 입력에 버전을 바인딩 테스트·검증 체크리스트 재귀 깊이 스윕 1→2→4→… 단계별로 증명 시간·메모리·최종 증명 크기 프로파일링 경계 케이스 빈 배치, 1개 배치, 홀수 개 입력, 순서 섞임, 공개 입력 미스매치, VK 변경 등 실패 경로 검증 스냅샷·해시 고정 동일 입력 집합에 대해 루트와 최종 증명이 안정적으로 재현되는지 확인 온체인 리허설 가스 한도와 calldata 한도를 기준으로 최종 증명 크기와 검증 호출이 수렴하는지 점검 Aggregation vs Recursion vs Batching Aggregation 여러 증명을 함께 검증하도록 한 번에 묶는 기법으로 비재귀적 접근까지 포함해 쓰이는 넓은 용어 Recursion 검증기를 회로화하고 그에 대한 또 다른 증명을 생성하는 계층적 접근 Batching 입력을 모아 처리하는 운영 기법으로 재귀·집계와 결합하면 시너지가 큼 활용 시나리오 롤업 L2에서 다수 배치 증명을 합성해 L1에 최종 1개 증명만 제출 프라이버시 애플리케이션 여러 단계 정책 만족을 하나의 최종 증명으로 제시 데이터 가용성·보관 증명 여러 청크 검증을 합성해 단일 확인 단계로 축소 언제 재귀를 쓰지 말지 내부 증명 수가 적고 온체인에서 직접 검증해도 가스 절감 효과가 미미한 경우 지연 민감 워크로드에서 재귀 단계가 P99 지연을 악화시키는 경우 증명 시스템 이질성으로 회로 복잡도가 과도하게 커지는 경우 마무리 재귀적 ZKP의 본질은 증명을 다시 증명해 검증 부담을 한 점으로 수렴시키는 데 있음 실전에서는 증명 시스템·곡선·집계 토폴로지·가스 모델을 함께 설계하고, 공개 입력 바인딩·검증기 회로의 완전성·도메인 분리로 사운드니스를 확보하는 것이 핵심임 목표 TPS·지연·오프체인 리소스·온체인 가스 정책을 기준으로 배치와 재귀 깊이를 조율하면 비용과 안정성을 동시에 달성할 수 있음\n참고자료 EIP‑196 BN128 Curve Addition and Scalar Multiplication https://eips.ethereum.org/EIPS/eip-196 EIP‑197 BN128 Pairing https://eips.ethereum.org/EIPS/eip-197 Halo2 Book https://zcash.github.io/halo2 Nova Recursive Arguments https://eprint.iacr.org/2021/370 SuperNova https://eprint.iacr.org/2022/1758 SnarkPack Practical SNARK Aggregation https://eprint.iacr.org/2021/529 Plonky2 Fast Recursive Proofs https://github.com/mir-protocol/plonky2 ","permalink":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 \u003cstrong\u003e계층적으로 합성\u003c/strong\u003e해 \u003cstrong\u003e단일 증명\u003c/strong\u003e으로 만드는 기법임\n목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 \u003cstrong\u003e검증 비용을 상수 수준으로 수렴\u003c/strong\u003e시키는 데 있음\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"왜-필요한가\"\u003e왜 필요한가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e트랜잭션 단위로 개별 증명을 온체인 검증하면 \u003cstrong\u003e검증 비용이 선형 증가\u003c/strong\u003e함\u003c/li\u003e\n\u003cli\u003e재귀를 쓰면 n개의 증명을 \u003cstrong\u003e트리 형태로 합성\u003c/strong\u003e해 \u003cstrong\u003e한 번의 최종 검증\u003c/strong\u003e으로 대체 가능함\u003c/li\u003e\n\u003cli\u003e롤업·배치 처리·프라이버시 워크로드에서 \u003cstrong\u003e확장성\u003c/strong\u003e과 \u003cstrong\u003e최종성 지연 단축\u003c/strong\u003e을 동시에 노림\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e내부 증명 Inner proofs\u003c/strong\u003e\n원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\u003c/p\u003e","title":"재귀적 영지식 증명이란? (Recursion ZKP)"},{"content":"개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\nzkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\n문제 정의: 단순 설계 페이마스터의 명확한 한계 가장 먼저 검토한 toAddressPaymaster는 특정 컨트랙트로 향하는 트랜잭션의 가스비만 대납해주는 단순한 모델임. 하지만 이 방식은 두 가지 치명적인 허점을 가짐\n의도치 않은 트랜잭션 허용: 신규 사용자에게 지갑을 만들어주는 AccountFactory 컨트랙트 주소를 페이마스터에 등록할 경우, 우리 서비스와 무관한 모든 사용자가 이 팩토리를 사용할 때 발생하는 가스비를 우리가 전부 대납하게 됨. 페이마스터가 의도치 않게 공공재가 되어버리는 상황\n가스비 소모 공격에 취약: gasLimit을 검증하는 로직이 없어, 악의적 사용자가 가스비를 비정상적으로 높게 책정해 트랜잭션 한 번으로 페이마스터의 모든 자금을 고갈시킬 수 있는 위험이 존재함\n결론적으로 우리가 허용한 사용자가 우리가 의도한 작업을 할 때 발생하는 합리적인 수준의 가스비만을 선별적으로 대납할 똑똑한 방법이 필요했음\n해결의 실마리: Off-chain Signature Verification 이 문제의 해결책으로 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 도입하기로 결정함\n이 패턴은 블록체인 외부(서버)에서 생성된 디지털 서명을 블록체인 위(스마트 컨트랙트)에서 검증하는 방식임. 즉, 가스비 대납 여부를 컨트랙트가 단독으로 결정하는 게 아니라, 우리가 통제하는 서버의 \u0026lsquo;허가\u0026rsquo;를 받아 결정하게 만드는 것\n이 과정에서 다음과 같은 주요 개념들이 활용됨\n메타 트랜잭션(Meta-transaction): 사용자가 직접 트랜잭션을 생성하고 가스비를 지불하는 대신, 트랜잭션의 내용이 될 데이터에 서명만 함. 그러면 이 서명을 받은 대리인(Relayer)이 실제 트랜잭션으로 만들어 수수료를 대신 내고 블록체인에 제출하는 패턴. 우리가 구현할 페이마스터는 zkSync 시스템이 릴레이어 역할을 해주는 메타 트랜잭션의 일종임\nEIP-712: 단순 텍스트가 아닌, json처럼 구조화된 데이터에 대한 서명 표준. 사용자가 무엇에 서명하는지 명확히 인지할 수 있고, 다른 컨트랙트나 체인에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지하는 도메인 분리(Domain Separator) 기능을 포함하고 있어 페이마스터 서명에 필수적임\n구현 과정: 서명 기반 페이마스터 설계 및 개발 전체 흐름은 서버의 서명 생성(Off-chain)과 컨트랙트의 서명 검증(On-chain) 두 단계로 나뉨\n1. 서버 (Off-chain): 서명 생성 단계 사용자가 트랜잭션을 실행하기 직전, 클라이언트는 트랜잭션 데이터를 백엔드 서버로 전송함. 서버는 다음 절차를 수행\n요청 검증: 요청을 보낸 사용자가 우리 서비스의 유효한 사용자인지, 트랜잭션 내용이 비즈니스 로직에 부합하는지 등을 검증\n가스비 추정 및 파라미터 설정: 트랜잭션에 필요한 가스비를 추정하고, 여기에 약간의 버퍼를 더해 recommendedGasLimit과 recommendedGasPrice를 결정. 서명이 유효할 시간(expiryTimestamp)도 설정함\nEIP-712 서명 생성: 검증된 파라미터들을 바탕으로 EIP-712 표준에 따라 구조화된 데이터를 만들고, 서버만 안전하게 보관하고 있는 개인키로 이 데이터에 서명함\n// 서버에서 EIP-712 타입에 맞춰 서명할 데이터를 구성 const domain = { name: \u0026#34;SignatureBasedPaymaster\u0026#34;, version: \u0026#34;1\u0026#34;, chainId: chainId, verifyingContract: PAYMASTER_ADDRESS }; const types = { SignatureBasedPaymaster: [ { name: \u0026#39;userAddress\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;expiryTimestamp\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasLimit\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasPrice\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] }; const value = { /* userAddress, expiryTimestamp 등 실제 값 */ }; // 서버의 개인키로 서명 생성 const signature = await signerWallet.signTypedData(domain, types, value); 이 서명값과 관련 파라미터들을 클라이언트에 반환하면, 클라이언트는 이 데이터를 트랜잭션과 함께 zkSync 네트워크로 전송함\n2. 컨트랙트 (On-chain): 서명 검증 단계 사용자의 트랜잭션은 zkSync 부트로더(Bootloader)를 통해 페이마스터 컨트랙트의 validateAndPayForPaymasterTransaction 함수를 호출함. 이 함수는 서명 검증의 핵심임\n데이터 재구성: 트랜잭션에 포함된 userAddress, expiryTimestamp, recommendedGasLimit 등의 파라미터를 가져와 서버가 서명했던 것과 완벽히 동일한 구조와 순서로 해시(hash)를 다시 만듦\n서명자 복원: 재구성한 해시와 트랜잭션에 포함된 서명(signature)을 이용해 암호학적 함수(ecrecover)를 호출. 이를 통해 이 서명을 생성한 주소를 역으로 계산해냄\n서명자 검증: 복원된 주소가 컨트랙트에 미리 저장해 둔 우리 서버의 주소(signer)와 일치하는지 확인. 일치해야만 서버가 허가한 유효한 요청으로 간주함\n만약 누군가 서버로부터 받은 서명을 그대로 두고 파라미터(ex: 가스비)를 변경하려 시도하면, 1번 단계에서 생성되는 해시값이 달라져 3번 검증 단계에서 실패하게 됨. 이를 통해 데이터의 무결성과 서명자의 신뢰성을 동시에 확보함\n// 1. 서버가 서명했을 데이터의 해시를 컨트랙트에서 동일하게 재구성 bytes32 digest = hashTypedDataV4(keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice ))); // 2. 서명과 재구성된 해시를 사용해 서명자 주소를 복원 address recoveredSigner = digest.recover(signature); // 3. 복원된 주소가 우리가 신뢰하는 서버의 주소(signer)와 일치하는지 확인 require( signer == recoveredSigner, \u0026#34;Paymaster: Invalid signer\u0026#34; ); // ... 검증 통과 후 가스비 대납 로직 실행 결론 및 회고 zkSync의 페이마스터는 사용자의 가스비를 대신 지불하는 기능을 손쉽게 구현할 수 있는 강력한 기반을 제공함 개발자는 이를 통해 사용자의 진입 장벽을 낮추고 UX를 크게 개선할 수 있음\n하지만 여기에 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 결합함으로써, 단순한 가스비 대납을 넘어 정교한 권한 제어가 가능해짐 서버에서 각 요청을 사전에 검증하고 서명을 발급하는 방식은 다음과 같은 명확한 이점을 가져왔음\n운영 안정성: 누가, 언제, 어떤 트랜잭션의 가스비를 지원받을지 서버단에서 유연하게 제어할 수 있어, 무분별한 비용 소모를 막고 예측 가능한 운영이 가능\n보안 강화: 허가된 주체만이 서명을 통해 가스비를 사용할 수 있으므로, 초기 모델의 가장 큰 문제였던 자금 고갈 공격과 의도치 않은 트랜잭션 허용을 원천적으로 차단할 수 있었음\n결론적으로, zkSync의 편리한 온체인 기능과 서버의 오프체인 로직을 결합한 이 접근법은 보안과 운영 안정성을 모두 확보하는 효과적인 해결책이었음 이를 통해 시스템의 자산을 안전하게 보호하며 지속 가능한 서비스를 운영할 수 있는 견고한 토대를 마련하게 되었음\n","permalink":"https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 \u003cstrong\u003e가스비\u003c/strong\u003e(Gas Fee)임\n아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임\n이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 \u003cstrong\u003e가스리스 트랜잭션\u003c/strong\u003e(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\u003c/p\u003e\n\u003cp\u003ezkSync Era는 이를 위해 \u003cstrong\u003e페이마스터\u003c/strong\u003e(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\u003c/p\u003e","title":"안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)"},{"content":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026amp; 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u0026gt;\u0026gt;= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","permalink":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e머클트리는 블록체인에서 거래 집합을 \u003cstrong\u003e안전하고 효율적으로 요약·검증\u003c/strong\u003e하기 위해 쓰이는 핵심 자료구조임\n블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 \u003cstrong\u003e고정 크기 해시 하나\u003c/strong\u003e로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임\n이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-구조\"\u003e핵심 개념과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e머클트리는 보통 \u003cstrong\u003e이진 트리\u003c/strong\u003e 형태로 구현함\u003c/li\u003e\n\u003cli\u003e거래들을 \u003cstrong\u003e리프(leaf)\u003c/strong\u003e 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 \u003cstrong\u003e루트 해시\u003c/strong\u003e를 얻음\u003c/li\u003e\n\u003cli\u003e해시 함수는 체인별로 다르며 비트코인은 \u003cstrong\u003e더블 SHA‑256\u003c/strong\u003e, 이더리움은 트라이 구조에서 \u003cstrong\u003eKeccak‑256\u003c/strong\u003e 을 사용함\u003c/li\u003e\n\u003cli\u003e최상단 해시를 \u003cstrong\u003e머클루트(Merkle root)\u003c/strong\u003e 라 부르며 크기는 해시 함수에 따라 고정됨\u003c/li\u003e\n\u003cli\u003e리프 수가 홀수일 때는 마지막 리프를 \u003cstrong\u003e복제해 짝을 맞추는 방식\u003c/strong\u003e이 일반적이며 비트코인은 이 규칙을 사용함\u003c/li\u003e\n\u003cli\u003e트리 깊이는 리프 수 N에 대해 \u003cstrong\u003e⌈log₂ N⌉\u003c/strong\u003e 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-장점\"\u003e동작 원리와 장점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인접 노드 해시 \u003cstrong\u003eH_left || H_right\u003c/strong\u003e 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e무결성 검증\u003c/strong\u003e\n단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적 포함 증명\u003c/strong\u003e\n특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 \u003cstrong\u003e형제 해시들만\u003c/strong\u003e 있으면 됨\n필요한 해시 개수는 \u003cstrong\u003eO(log N)\u003c/strong\u003e 으로 작아 대역폭과 검증 비용이 작음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장성 보조\u003c/strong\u003e\n리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"블록-헤더와-경량-노드spv\"\u003e블록 헤더와 경량 노드(SPV)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함\u003c/li\u003e\n\u003cli\u003e경량 노드(SPV)는 \u003cstrong\u003e블록 전체가 아니라 헤더 체인만\u003c/strong\u003e 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 \u003cstrong\u003e머클 증명\u003c/strong\u003e 을 받아 포함 여부를 검증함\u003c/li\u003e\n\u003cli\u003e이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨\u003c/li\u003e\n\u003cli\u003e이더리움은 전통적인 이진 머클트리 대신 \u003cstrong\u003e머클‑패트리샤 트라이(MPT)\u003c/strong\u003e 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"구현-세부와-체인별-차이\"\u003e구현 세부와 체인별 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비트코인\u003c/strong\u003e\u003c/p\u003e","title":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"},{"content":"개요 이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함 개념 정의에 그치지 않고 운영 시 주의점, 보상·출금 흐름, 짧은 체인 재구성(Reorg) 원인과 완화책까지 다룸\n개념과 배경 PoS는 PoW의 에너지 경쟁을 대체해 예치된 지분을 바탕으로 검증자를 선정하는 합의 메커니즘임 이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 검증자 기반 보안 모델로 이행함\n주요 속성 요약\n에너지 소비 대폭 축소 스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨 위반 시 슬래싱과 페널티로 예치금이 감소함 계층 분리와 Beacon Chain의 역할 이더리움은 합의 계층(Beacon Chain) 과 실행 계층(Execution Layer) 를 분리해 설계함\n실행 계층은 트랜잭션 처리와 EVM 실행을 담당함 Beacon Chain은 시간 관리와 역할 배정, 투표 집계, 최종성 판단을 담당함 Beacon Chain의 핵심 기능\n슬롯과 에포크라는 통일된 시간 프레임 제공 매 슬롯의 블록 제안자와 증명자 배정 증명자 투표를 집계해 정당한 체인과 최종성을 결정함 이 분리는 클라이언트 다양성 확보와 확장 로드맵에 유리한 아키텍처 선택임\n시간 구조와 동작 단위 슬롯(slot)\n블록 제안이 가능한 최소 시간 단위 1 슬롯 = 12초 슬롯마다 1명의 제안자만 지정됨 제안자가 제때 블록을 제안하지 못하면 슬롯 미스로 간주하고 빈 슬롯이 될 수 있음 에포크(epoch)\n1 에포크 = 32 슬롯 ≈ 6분 24초 에포크 단위로 위원회 재편성, 랜덤 시드 갱신, 최종성 관련 집계가 이뤄짐 에포크는 체크포인트 역할을 하며 최종성 로직의 기준 단위로 사용됨 검증자와 스테이킹 규칙 최소 32 ETH를 예치해야 정식 검증자가 됨 한 검증자 계정에 반영되는 유효 예치 상한은 32 ETH임 더 많은 ETH를 운용하려면 32 ETH 단위로 여러 검증자를 운영해야 함 검증자 활성·비활성 전환에는 대기 큐와 지연이 존재함 보상 기회는 전체 검증자 대비 보유 검증자 수에 비례해 증가함 예를 들어 64 ETH로 두 검증자를 운영하면 제안·투표 참여 기회가 대략 두 배가 됨\n제안자(Proposer)와 증명자(Attester) 매 슬롯 한 명의 제안자가 블록을 제안함 다수의 증명자가 해당 블록에 대해 attestation 을 제출함 검증자들은 여러 위원회(committee) 로 무작위 배정되어 병렬로 검증을 수행함 집계된 투표는 포크 선택과 최종성 판단에 사용됨 위원회 구조의 목적은 검증 부담 분산 과 독립 다중 관측 을 통해 안전성과 처리량을 동시에 확보하는 것임\n무작위성과 검증자 배정 이더리움은 RANDAO 믹스 를 사용해 예측이 어렵고 조작에 강한 난수를 생성함 역사적으로 VRF나 VDF 같은 대안이 거론되었으나 현재 메인넷은 RANDAO 기반을 사용함 생성된 난수는 차기 에포크의 제안자·위원회 배정에 활용됨 특정 주체가 지속 우선 선정되는 편향을 줄이는 것이 목표임 포크 선택과 최종성 개요 포크 선택은 LMD‑GHOST 를 기반으로 하며 최신 메시지를 반영해 가장 무거운 서브트리를 선택함 짧은 지연으로 더 나은 블록을 선택하도록 proposer boost 가 도입되어 reorg 위험을 줄임 최종성은 Casper FFG 를 통해 에포크 수준 체크포인트를 정당화·최종화함 일정 이상 검증자 참여가 확보되면 체크포인트가 finalized 상태가 되어 경제적으로 되돌리기 매우 어려워짐 보상과 벌칙의 구조 보상 항목\n블록 제안 보상 제안자가 유효 블록을 포함할 때 수취 증명 보상 attestation을 정확하고 신속하게 제출한 검증자에게 지급 동기화 위원회 보상 라이트 클라이언트 지원을 위한 서명 참여 검증자에게 지급 벌칙과 슬래싱\n오프라인이나 지연 제출 등에는 경미한 페널티 가 부과됨 체인이 장기간 미파이널리티 상태에 빠지면 inactivity leak 이 발생해 페널티가 점진적으로 커짐 슬래싱 은 이중 제안 혹은 이중·감싸기 투표 같은 안전성 위반에 적용되며 금액과 네트워크 상황에 따라 손실이 커질 수 있음 동일 키를 여러 노드에서 가동하면 슬래싱 위험이 급증하므로 금지해야 함 보상 규모와 페널티는 전체 활성 예치 규모와 참여율 등 네트워크 상태에 따라 동적으로 변함\n출금과 인출 흐름 2023년 상반기 업그레이드 이후 출금 기능 이 활성화됨 부분 출금 은 32 ETH 초과분이 자동으로 실행 계층의 출금 주소로 전달됨 완전 출금 은 검증자가 정상 종료를 통해 활성 집합에서 빠진 뒤 전 잔액을 인출하는 흐름임 출금 처리는 블록당 포함 가능한 수가 제한되어 있어 대기 지연이 발생할 수 있음 출금 주소 유형과 자격 전환이 올바르게 설정되어 있어야 자동 처리가 가능함 운영 포인트\n출금 대기 시간과 큐 상태를 모니터링해 유동성을 관리함 출금 주소 관리 실수를 방지하기 위해 변경 절차를 문서화하고 검증 절차를 둠 Reorg가 발생하는 이유와 완화책 Reorg는 PoS에서도 짧은 길이 로 발생할 수 있음 주요 원인\n블록·attestation 전파 지연으로 노드 간 관측 차이가 발생함 슬롯 미스 이후 후속 제안자가 다른 선행 상태를 기준으로 블록을 만들 수 있음 노드 시간 동기화 불량이나 리소스 병목으로 처리 지연이 발생함 완화책\n시간 동기화는 chrony 등으로 정확히 유지함 고품질 피어 확보와 충분한 피어 수를 유지하고 네트워크 지연을 최소화함 최신 클라이언트와 다양한 클라이언트 조합으로 클라이언트 다양성 을 보장함 proposer boost와 attest 포함 지연 지표를 모니터링해 파라미터와 인프라를 튜닝함 대부분의 reorg는 1~2 블록에서 수렴하며 최종성 규칙으로 빠르게 안정화됨\n운영 체크리스트 노드와 인프라\n최신 합의·실행 클라이언트 유지 피어 수·지연·대역폭·디스크 IOPS 모니터링 장애를 분리하기 위해 실행·합의 클라이언트의 조합을 다양화함 키 관리\n슬래싱 방지 파일과 원격 서명기 사용 시 중복 서명 방지 설정 확인 단일 실패 지점 제거를 위해 핫·백업 구성과 자동 페일오버를 명확히 구분함 키 백업과 복구 절차를 오프라인으로 주기 점검함 운영 정책\n32 ETH 단위로 검증자를 수평 확장해 장애 격리와 보상 변동성을 줄임 모니터링 지표를 표준화함 참여율, attestation 포함 거리, 미스 슬롯, reorg 발생률, 동기화 위원회 가동률, 출금 큐 길이 등 MEV‑Boost 사용 시 릴레이 다양화와 로컬 빌더 폴백을 준비해 가용성과 검열 리스크를 낮춤 위험과 중앙화 고려 거대 스테이킹 풀과 커스터디 집중은 검열·단일 실패 지점 위험을 키움 클라이언트 다양성 부족은 버그 발생 시 네트워크 안정성을 해칠 수 있음 리퀴드 스테이킹 파생상품은 유동성을 제공하지만 의사결정 집중과 딜레마를 유발할 수 있음 정책과 거버넌스, 릴레이·빌더 다양화, 커뮤니티 모니터링으로 리스크를 분산해야 함 마무리 이더리움 PoS는 RANDAO 기반 무작위성, LMD‑GHOST 포크 선택, Casper FFG 최종성, 검증자 보상·벌칙 체계 를 결합해 에너지 효율과 보안을 동시에 달성하려는 설계임 운영자는 시간 동기화와 피어 품질, 키 관리, 클라이언트 다양성, 보상·출금 파이프라인을 지속적으로 점검해야 함 짧은 reorg는 네트워크 현실에서 발생할 수 있으나 적절한 인프라와 파라미터 튜닝, 최신 클라이언트 운용으로 빈도와 영향을 최소화할 수 있음\n참고자료 이더리움 PoS 개요 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos 합의 사양과 가스퍼 개요 https://github.com/ethereum/consensus-specs EIP‑4895 출금과 Capella 업그레이드 참고 https://eips.ethereum.org/EIPS/eip-4895 합의 계층 클라이언트와 실행 계층 클라이언트 목록 https://ethereum.org/en/developers/docs/nodes-and-clients MEV‑Boost 운영 가이드 참고 https://www.flashbots.net ","permalink":"https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함\n개념 정의에 그치지 않고 \u003cstrong\u003e운영 시 주의점\u003c/strong\u003e, \u003cstrong\u003e보상·출금 흐름\u003c/strong\u003e, \u003cstrong\u003e짧은 체인 재구성(Reorg) 원인과 완화책\u003c/strong\u003e까지 다룸\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003ePoS는 PoW의 에너지 경쟁을 대체해 \u003cstrong\u003e예치된 지분을 바탕으로 검증자를 선정\u003c/strong\u003e하는 합의 메커니즘임\n이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 \u003cstrong\u003e검증자 기반 보안 모델\u003c/strong\u003e로 이행함\u003c/p\u003e\n\u003cp\u003e주요 속성 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에너지 소비 대폭 축소\u003c/li\u003e\n\u003cli\u003e스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨\u003c/li\u003e\n\u003cli\u003e위반 시 슬래싱과 페널티로 예치금이 감소함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"계층-분리와-beacon-chain의-역할\"\u003e계층 분리와 Beacon Chain의 역할\u003c/h3\u003e\n\u003cp\u003e이더리움은 \u003cstrong\u003e합의 계층(Beacon Chain)\u003c/strong\u003e 과 \u003cstrong\u003e실행 계층(Execution Layer)\u003c/strong\u003e 를 분리해 설계함\u003c/p\u003e","title":"이더리움 PoS(Proof of Stake) 소개"},{"content":"개요 NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 리빌, 에어드롭, 화이트리스트, 마켓플레이스를 실무 관점으로 정리함 핵심은 개념 이해를 넘어 운영 체크리스트, 보안 리스크, 가격 형성 메커니즘까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\n공통 전제와 기본 개념 NFT 표준 주로 ERC‑721과 ERC‑1155를 사용함 721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\n메타데이터와 저장소 토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장 중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\n로열티 EIP‑2981 표준이 존재하나 집행은 마켓별 정책에 의존하는 경향이 있음 창작자 수익 분배 구조를 미리 확인 필요\n리빌 Reveal 정의 민팅 직후에는 공통 플레이스홀더 이미지를 노출하고, 이후 시점에 각 토큰의 최종 속성·이미지를 공개하는 절차를 말함\n왜 쓰는가\n판매 초기의 기대감 형성과 공정한 희소성 배분 유도 초반 스니핑을 줄이고 커뮤니티 이벤트와 연동하기 위함 가격 형성상 특징\n리빌 전에는 외형과 속성이 같아 보여 가격 수렴이 발생하기 쉬움 리빌 후에는 속성 조합·희소성에 따라 재평가가 빠르게 진행됨 희귀 속성은 프리미엄이 붙고 평범 속성은 하방 압력이 커지는 패턴이 일반적임 공정성·신뢰 장치\n프로비넌스 해시 공개로 민팅 전 전체 순서를 커밋해 치환·조작 가능성을 낮춤 메타데이터 동결과 BaseURI 고정으로 리빌 후 임의 수정 리스크 축소 온체인 또는 영속 스토리지에 최종 자료 고정 운영 체크리스트\n리빌 시점, 방식(일괄·구간·랜덤 시프트), 프로비넌스 공개 여부 확인 메타데이터 저장소와 동결 계획 점검 리빌 직후 가격 변동성 대비 유동성 전략 수립 에어드롭 Airdrop 정의 NFT 또는 토큰을 무상 배포해 초기 유입과 참여 보상을 유도하는 방식\n유형\n푸시형 프로젝트가 직접 전송 클레임형 스냅샷 기준 자격자에게 기간 내 청구 권한 부여 조건형 소셜 참여, 보유 토큰, 온체인 행위 등 조건을 충족해야 함 비용과 유동성\n가스 부담 주체가 누구인지 확인 필요 수령 자산의 2차 유동성 가능성과 잠금 조건 여부 확인 보안 체크리스트\n개인키·시드 문구 요청은 100% 사기 setApprovalForAll 무제한 승인 요구, 임의 Permit 서명 요구, 낯선 도메인의 서명 팝업에 주의 의심 에어드롭은 더스팅 공격 가능성 고려, 상호작용 자체를 피하는 것이 안전한 경우 많음 현실적 기대치\n극소수 성공 사례를 제외하면 무료 배포물의 평균 가치는 시간 경과에 따라 하락하는 경향 로드맵, 팀 신뢰도, 파트너십, 토큰 설계까지 종합 평가 필요 화이트리스트 Allowlist 정의 특정 지갑에게 민팅 우선권을 부여하는 명단을 의미하며 줄여서 화리라 부름 포용적 표현으로 Allowlist 용어를 쓰는 프로젝트가 많음\n부여 방식\n커뮤니티 기여, 미션, 추천, 보유 토큰 기반 토큰 게이팅 온체인 머클 증명으로 명단을 검증해 가스·데이터 비용을 절감 타입\n보장형 배정량이 확정되어 민팅 시점에 구매 가능 경쟁형 FCFS나 시간 창을 두어 네트워크 상태·속도에 따라 성공 여부가 갈림 래플형 추첨으로 공정 배분 시도 실무 체크리스트\n1인당 구매 한도, 민팅가, 시간 창, 체인·네트워크 확인 가스 워 방지 장치 유무 확인(쿨다운, 랜덤 시프트, 캡) 어뷰징·봇 통제 정책 확인, 위반 시 박탈 규정 숙지 주의\nAllowlist를 과다 남발하는 프로젝트는 민팅 종료 후 가격 하락 리스크가 크므로 유통 설계와 수요 검증 필요 NFT 마켓플레이스 역할 NFT의 가시화, 매매, 오더북을 제공하는 플랫폼을 의미함 글로벌로 OpenSea, Blur, Rarible 등이 대표적이며 국내에는 Klip Drops, 업비트 NFT 등이 존재함\n거래 방식\n고정가 리스팅 판매자가 원하는 가격 제시 경매형 영국식 상승 경매, 더치 경매 등 변형 포함 오퍼 특정 토큰 혹은 전체 컬렉션에 대한 구매 제안 접수 집계기가 여러 거래소의 유동성을 묶어 더 나은 가격·체결 속도를 제공하기도 함 핵심 지표와 해석 요령\n바닥가 Floor 컬렉션 내 최저 매물가이나 거래된 가격이 아님 얕은 호가에 의해 왜곡 가능하므로 체결 이력, 호가 두께, 분포를 함께 보아야 함 체결량·보유 분포 단기 매물 출회 압력과 고래 집중도 파악에 유용함 워시 트레이딩 자기계약 간 거래로 볼륨 부풀리기가 발생할 수 있어 탐지 지표 참고 필요 수수료와 로열티\n마켓 수수료와 창작자 로열티 정책이 거래소마다 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 선택적인 경우가 많아 실제 지급 여부를 확인해야 함 보안과 권한 관리\n판매 전 부여한 무제한 승인은 거래 후 revoke 툴로 회수 권장 피싱 도메인과 서명 위임 요청에 대한 교육이 필수 플랫폼 선택 기준\n유동성 규모, 수수료 구조, 지원 체인, 커뮤니티 활성도, 집계기 연동 여부, 로열티 정책 일관성 확인 빠른 판단 가이드 리빌 일정과 프로비넌스 공개, 메타데이터 동결 계획을 먼저 확인 에어드롭 은 개인키·시드·무제한 승인 요구 시 즉시 중단 화이트리스트 는 한도·가격·시간 창과 검증 방식(머클) 확인 마켓플레이스 는 바닥가만 보지 말고 체결 이력·호가 두께·수수료·로열티 정책까지 함께 판단 예시 시나리오 개인 사용자 민팅 직후 리빌 전 거래는 변동성 대비 효익이 낮을 수 있어 리빌 일정 확인 후 접근 수령한 에어드롭은 승인 요청이 없는지 먼저 점검하고 필요 시 상호작용을 피함 프로젝트 운영자 머클 기반 Allowlist와 프로비넌스 커밋으로 신뢰 확보 메타데이터 동결과 영속 스토리지 사용으로 변경 리스크 최소화 워시 트레이딩 방지 메시지와 리스팅 교육 자료를 함께 제공 마무리 리빌은 가치 재평가의 계기 에어드롭은 초기 분배와 참여 보상 수단 화이트리스트는 수요 조절과 공정 배분 장치 마켓플레이스는 가격 발견과 유동성의 장 각 제도의 의도·설계·리스크를 이해하고 보안 수칙을 지키면 의사결정의 품질을 높일 수 있음\n참고자료 ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 OpenZeppelin Merkle 증명 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography Ethereum 개발자 문서 NFT 개요 https://ethereum.org/en/developers/docs/standards/tokens/ 추가 읽을거리 https://magazine.cheil.com/51780 ","permalink":"https://handsupmin.github.io/posts/nft-23q12akw/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 \u003cstrong\u003e리빌\u003c/strong\u003e, \u003cstrong\u003e에어드롭\u003c/strong\u003e, \u003cstrong\u003e화이트리스트\u003c/strong\u003e, \u003cstrong\u003e마켓플레이스\u003c/strong\u003e를 실무 관점으로 정리함\n핵심은 개념 이해를 넘어 \u003cstrong\u003e운영 체크리스트\u003c/strong\u003e, \u003cstrong\u003e보안 리스크\u003c/strong\u003e, \u003cstrong\u003e가격 형성 메커니즘\u003c/strong\u003e까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"공통-전제와-기본-개념\"\u003e공통 전제와 기본 개념\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNFT 표준\u003c/strong\u003e\n주로 ERC‑721과 ERC‑1155를 사용함\n721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메타데이터와 저장소\u003c/strong\u003e\n토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장\n중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\u003c/p\u003e","title":"NFT 핵심 용어 정리"},{"content":"서문 NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움 이 글은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고 구매·발행·보관 시 유의사항과 운영 관행을 담는 것을 목표로 함\n개념과 배경 NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함 동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 고유 식별자와 속성을 가져 상호 교환 시 동일 가치를 보장하지 않음 블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음 온체인 소유권이 저작권·초상권 등 법적 권리와 자동 동치가 아님에 유의해야 함\nNFT는 보통 세 요소로 이해하면 실무에 유리함\n디지털 미디어 이미지·영상·음원·게임 아이템 등 사용자에게 보이는 대상 메타데이터 이름·설명·속성·미디어 링크를 담은 JSON 문서 스마트컨트랙트 발행·이전 규칙을 구현한 코드로 표준은 주로 ERC‑721과 ERC‑1155를 사용함 대부분의 프로젝트는 미디어 파일을 체인 밖에 보관하고 메타데이터에 링크를 넣는 오프체인 저장을 택함 장기 보존성을 위해 IPFS·Arweave 같은 영속형 스토리지 사용과 메타데이터 동결 계획이 중요함\n메인넷과 인프라 이해 NFT는 이더리움·폴리곤·솔라나·클레이튼 등 메인넷 혹은 L2 위에서 발행·거래됨 거래 실행에는 가스비가 들며 이더리움은 EIP‑1559 기반의 베이스피와 우선순위 팁 구조를 가짐 네트워크 상태와 우선순위 설정에 따라 체결 속도와 비용이 크게 달라짐 거래와 토큰 상태는 블록 탐색기에서 확인 가능하며 예시는 이더스캔과 클레이튼 스코프 등이 있음\n체인별 계약 주소·체인 ID가 다르므로 피싱 사이트가 제시하는 계약을 탐색기에서 교차 확인하는 습관이 필요함 브리징과 크로스체인 전송 시에는 락 앤 민트 모델·메시지 지연·브리지 보안을 이해하고 한도·대기 시간을 고려해야 함\n지갑과 보안 지갑은 주소와 그 주소를 통제하는 프라이빗 키·시드 문구를 관리함 메타마스크·카이카스 같은 브라우저 확장형은 편리하지만 핫월렛이라 위험 노출이 큼 대액·장기 보관 자산은 하드웨어 지갑에 두고 일상 거래는 별도 소액용 지갑을 쓰는 분리 보관이 권장됨\n시드 문구 보관 원칙\n오프라인 백업과 물리 분산 보관 사진·클라우드·메신저 업로드 금지 테스트 복구 절차를 정기 수행 권한과 서명 보안\n웹사이트 연결 시 도메인·체인·요청 권한을 확인하고 setApprovalForAll 무제한 승인은 꼭 필요한 범위에만 부여 거래가 아닌 서명 요청도 자산 이전 권한을 위임할 수 있으니 상세를 읽고 필요 시 거부 사용이 끝난 승인 권한은 권한 취소 도구로 주기적으로 회수 민팅 Minting 실무 절차 민팅은 메타데이터와 미디어 링크를 컨트랙트에 기록해 토큰을 새로 발행하는 행위 민팅이 체인에 포함되면 이벤트 로그에서 Transfer 이벤트의 From 주소가 0x0000000000000000000000000000000000000000 로 표시되는 것이 일반적임\n두 가지 맥락을 구분하면 혼동이 줄어듦\n프로젝트 관점 컨트랙트를 배포하고 토큰을 생성하는 개발·운영 작업 구매자 관점 민팅 페이지에서 최초 구매에 참여하는 행위 민팅 유형과 운영 포인트\n퍼블릭 민팅 누구나 가능하며 인기 컬렉션은 즉시 매진되므로 가스 전략과 자동화 대비가 필요 프라이빗 민팅 Allowlist 사전 등록 지갑만 참여 가능하며 일반적으로 가격·수량·시간 창이 별도로 정의됨 무료 민팅 민팅가는 0이지만 가스비가 들며 사후 로열티·수수료 구조를 확인해야 함 민팅 전 체크리스트\n계약 주소·체인·민팅가·한도·시간 창을 공지와 탐색기에서 이중 확인 메타데이터 저장 방식과 리빌·프로비넌스 계획을 확인 페이지가 제시하는 컨트랙트 소스 공개·감사 여부 확인 가스비 상한과 우선순위 팁을 과도하게 올려 불필요한 낭비가 없도록 시뮬레이션 마켓플레이스와 2차 거래 오픈씨·블러·라리블 등 마켓플레이스에 지갑을 연결해 리스팅과 오퍼를 관리함 주요 거래 방식은 고정가 리스팅·경매·컬렉션 오퍼 등이 있으며 유동성은 거래소마다 상이함\n가격 해석과 유의점\n바닥가 floor 는 현재 최저 매물가일 뿐 실제 체결가가 아님 체결 이력·호가 두께·보유 분포를 함께 봐야 수급을 판단할 수 있음 워시 트레이딩 으로 볼륨이 부풀려질 수 있으므로 비정상 패턴에 주의 로열티와 수수료\n마켓 수수료 와 크리에이터 로열티 정책은 플랫폼별로 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 거래소 정책에 의존하는 경우가 많음 실제 로열티 지급 여부와 비율을 거래 전 확인 필요 권한과 보안\n리스팅 과정에서 부여한 무제한 승인은 판매 종료 후 회수 권장 낯선 도메인의 서명 팝업과 필드가 비정상적으로 긴 메시지는 피싱 징후일 수 있음 메타데이터·저장·리빌 운영 메타데이터 는 ERC‑721 메타데이터 스펙의 name·description·image·attributes 필드를 따르는 것이 일반적 저장소 는 IPFS·Arweave 같이 링크 무결성과 장기 보존에 유리한 방식을 권장 리빌 은 발행 직후 플레이스홀더를 제공하고 이후 속성을 공개하는 절차로 가격 재평가가 일어남 조작 의심을 줄이기 위해 프로비넌스 해시 공개·랜덤 시드·베이스 URI 잠금 같은 신뢰 장치를 제공하는 것이 실무 베스트 프랙티스임 운영·커뮤니티 관행과 실무 팁 프로젝트 운영자 관점\n컨트랙트 소스 공개와 보안 감사 진행 Allowlist를 머클 증명으로 검증해 가스와 데이터 비용을 절감 봇 완화를 위한 레이트 리밋·쿨다운·인증을 설계 리빌 일정·기준·랜덤 방식과 메타데이터 동결 계획을 사전 공지 로열티 정책을 명확히 하고 플랫폼별 집행 차이에 대한 안내 제공 구매자·보유자 관점\n리빌 전후의 가격 변동성과 유동성 얕음에 대비 권한 관리와 피싱 방지 교육을 습관화 브리지·체인 전환 전에는 수수료·지연·보안 리스크를 점검 에어드롭·민팅 DM은 대부분 피싱일 가능성이 높으므로 공식 채널만 신뢰 빠른 점검 체크리스트 계약 주소·체인·민팅가·수량 한도·시간 창 교차 확인 메타데이터 저장소와 리빌·프로비넌스 공개 여부 확인 마켓 수수료·로열티 정책·체결 이력과 호가 두께 확인 권한 부여 최소화와 사용 후 권한 회수 습관 유지 시드 문구 오프라인 분산 보관과 정기 복구 테스트 수행 마무리 NFT는 표준·메타데이터·컨트랙트 권한·저장 전략이 서로 맞물려 동작하는 생태계임 개념을 이해하는 것만으로는 부족하며 보안과 운영 절차를 마련해야 실전에서 손실을 줄일 수 있음 민팅·거래·보관 단계별로 위의 체크리스트를 적용하면 의사결정 품질을 안정적으로 끌어올릴 수 있음\n참고자료 Etherscan 블록 탐색기 https://etherscan.io Klaytn Scope 블록 탐색기 https://scope.klaytn.com OpenSea 마켓플레이스 https://opensea.io MetaMask 지갑 https://metamask.io ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 Ethereum 개발자 문서 토큰 표준 개요 https://ethereum.org/en/developers/docs/standards/tokens Klaytn 개발자 문서 https://docs.klaytn.foundation ","permalink":"https://handsupmin.github.io/posts/nft-concept-20gd0fl/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003eNFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움\n이 글은 \u003cstrong\u003e실무자 관점\u003c/strong\u003e에서 NFT의 핵심 개념을 단계적으로 정리하고 \u003cstrong\u003e구매·발행·보관 시 유의사항\u003c/strong\u003e과 \u003cstrong\u003e운영 관행\u003c/strong\u003e을 담는 것을 목표로 함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eNFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함\n동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 \u003cstrong\u003e고유 식별자와 속성\u003c/strong\u003e을 가져 상호 교환 시 동일 가치를 보장하지 않음\n블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음\n온체인 소유권이 \u003cstrong\u003e저작권·초상권 등 법적 권리와 자동 동치가 아님\u003c/strong\u003e에 유의해야 함\u003c/p\u003e","title":"NFT란? NFT 핵심 개념 정리"},{"content":"서문 pnpm은 npm과 유사한 CLI를 제공하면서 의존성 저장 구조를 혁신해 디스크 중복을 줄이고 설치 성능을 높인 패키지 매니저임 대규모 모노레포와 여러 프로젝트를 동시에 운영할 때 중복 패키지 최소화·설치 속도 개선·일관된 잠금 파일 관리를 목표로 함 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용법을 실무 관점에서 정리함\n개념 및 배경 핵심 아이디어는 사용자 단위의 콘텐츠 주소 기반 저장소(Content‑Addressable Store) 와 하드링크 + 심볼릭 링크 조합임\n패키지 실제 파일은 사용자 스토어에 한 번만 저장됨 각 프로젝트의 node_modules에는 스토어의 파일을 하드링크로 연결하고, 패키지 간 의존 관계는 심볼릭 링크로 구성함 결과적으로 동일 버전 패키지가 여러 프로젝트에서 필요해도 물리 복제가 발생하지 않음 스토어 기본 위치는 OS와 설정에 따라 달라지므로 명령으로 확인하는 것이 정확함\npnpm store path 로 실제 스토어 경로 확인 pnpm config get store-dir 로 명시적 설정 여부 확인 링크 구조 정확히 이해하기 pnpm의 node_modules는 표준 Node 해석 규칙을 유지하면서도 디스크 효율을 극대화하는 가상 스토어 구조를 가짐\n예시 디렉터리 구조\nmy-project ├─ node_modules │ ├─ .pnpm │ │ └─ express@4.19.2/node_modules/express │ └─ express -\u0026gt; .pnpm/express@4.19.2/node_modules/express ├─ package.json └─ pnpm-lock.yaml .pnpm/express@4.19.2/node_modules/express 내부 파일은 사용자 스토어에서 하드링크로 제공됨 상위 node_modules/express 는 해당 디렉터리로 심볼릭 링크되어 해석됨 이 구조 덕분에 디스크 사용량 감소와 빠른 설치가 가능함 설치 명령 정확히 쓰기 의존성 추가는 pnpm add \u0026lt;패키지\u0026gt; 사용\n예시 pnpm add express 개발 의존성은 -D 또는 --save-dev 설치 재현은 pnpm install 사용\npnpm-lock.yaml 을 기준으로 설치하며 업데이트를 금지하려면 --frozen-lockfile 권장 오프라인 또는 캐시 우선 설치는 --offline 또는 --prefer-offline 검토 글로벌 설치는 pnpm add -g \u0026lt;패키지\u0026gt;\n글로벌 바이너리 경로는 pnpm bin -g 로 확인 일회성 실행은 글로벌 설치 대신 pnpm dlx \u0026lt;패키지\u0026gt; \u0026lt;args\u0026gt; 권장 워크스페이스 기본 루트에 pnpm-workspace.yaml 을 두고 패키지 글롭을 정의함\npackages: - \u0026#34;packages/*\u0026#34; 실무 포인트\n내부 패키지 간 의존은 workspace: 프로토콜로 명시해 레지스트리 출고물 대신 로컬 소스를 링크함\n예시 workspace:* workspace:^1.2.0 등 버전 범위 지정 가능 루트에 공통 스크립트를 두고 전체 실행은 pnpm -r run \u0026lt;script\u0026gt; 또는 타깃 실행은 pnpm --filter \u0026lt;패키지\u0026gt; run \u0026lt;script\u0026gt; 사용\n특정 패키지에 의존성 추가는 pnpm --filter \u0026lt;패키지\u0026gt; add \u0026lt;모듈\u0026gt; 로 정확히 지정\n실무에 바로 쓰는 명령 스니펫 # 스토어 경로 확인 pnpm store path # 프로젝트 전 패키지 설치 재현 pnpm install --frozen-lockfile # 워크스페이스 전역 빌드 pnpm -r run build # 특정 패키지만 테스트 pnpm --filter @org/api run test # 루트에 공통 도구 추가 pnpm add -w -D typescript eslint # 일회성 실행으로 글로벌 오염 방지 pnpm dlx tsx scripts/generate.ts 성능·디스크 최적화 팁 프리페치 서버 환경에서 pnpm fetch 로 패키지를 미리 가져와 네트워크 변동성을 줄임\n스토어 청소 오래된 아카이브 제거는 pnpm store prune\n사이드 이펙트 캐시 네이티브 빌드 산출물 캐시를 켜면 재설치가 빨라짐\npnpm config set side-effects-cache true OS·CPU 아키텍처별 격리가 필요하므로 CI 매트릭스에 맞춰 관리 권장 CI 캐시 전략\n스토어 경로 pnpm store path 결과를 캐시 pnpm-lock.yaml 을 캐시 키에 포함해 결정적 설치를 보장 호이스팅 호환성 다루기 pnpm은 엄격한 격리를 기본값으로 하여 잘못된 모듈 해석을 줄임 레거시 도구가 루트에 평평하게 호이스트된 구조를 가정할 경우 아래 옵션을 검토함\npublic-hoist-pattern 으로 특정 패턴만 루트로 호이스트 최후의 수단으로 shamefully-hoist=true 를 설정해 전반 호이스팅 가능하면 패키지 자체를 수정하거나 packageExtensions 로 누락된 peerDeps를 보완하는 접근을 우선 고려함 의존성 해상도와 품질 보증 pnpm은 peerDependencies 충돌에 엄격해 문제를 조기에 드러내는 장점이 있음 조직 차원의 버전 강제는 overrides 를 사용해 하위 트리의 특정 버전을 고정 잠금 파일은 워크스페이스 루트의 pnpm-lock.yaml 하나만 커밋해 결정적 빌드를 유지 트러블슈팅 체크리스트 패키지 탐색 실패\n잘못된 상대 임포트나 평평한 구조 가정 여부 점검 임시 우회는 public-hoist-pattern 으로 부분 호이스팅 네이티브 모듈 빌드 지연\nside-effects-cache 활성화와 CI 캐시 확인 전역 명령 인식 실패\npnpm bin -g 를 PATH에 추가했는지 점검 디스크 급증\n스토어 경로 확인 후 pnpm store prune 실행 마무리 pnpm은 스토어 단일화 + 하드링크 를 바탕으로 설치 시간을 낮추고 디스크 중복을 제거하는 실전형 패키지 매니저임 워크스페이스와 workspace: 프로토콜을 활용하면 모노레포 개발 경험과 CI 안정성을 동시에 끌어올릴 수 있음 레거시 호이스팅 가정만 주의하면 npm 사용 습관에서 큰 이질감 없이 도입이 가능함\n참고자료 pnpm 공식 문서 https://pnpm.io pnpm 워크스페이스 https://pnpm.io/workspaces side-effects cache 설정 https://pnpm.io/cli/config#side-effects-cache overrides와 의존성 관리 https://pnpm.io/package_json#pnpmoverrides ","permalink":"https://handsupmin.github.io/posts/pnpm-92fmw2/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003epnpm은 npm과 유사한 CLI를 제공하면서 \u003cstrong\u003e의존성 저장 구조\u003c/strong\u003e를 혁신해 디스크 중복을 줄이고 설치 성능을 높인 패키지 매니저임\n대규모 모노레포와 여러 프로젝트를 동시에 운영할 때 \u003cstrong\u003e중복 패키지 최소화·설치 속도 개선·일관된 잠금 파일 관리\u003c/strong\u003e를 목표로 함\n이 글은 pnpm의 \u003cstrong\u003e설치 동작 원리\u003c/strong\u003e와 \u003cstrong\u003e워크스페이스 활용법\u003c/strong\u003e을 실무 관점에서 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념-및-배경\"\u003e개념 및 배경\u003c/h3\u003e\n\u003cp\u003e핵심 아이디어는 \u003cstrong\u003e사용자 단위의 콘텐츠 주소 기반 저장소(Content‑Addressable Store)\u003c/strong\u003e 와 \u003cstrong\u003e하드링크 + 심볼릭 링크\u003c/strong\u003e 조합임\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패키지 실제 파일은 사용자 스토어에 \u003cstrong\u003e한 번만\u003c/strong\u003e 저장됨\u003c/li\u003e\n\u003cli\u003e각 프로젝트의 \u003ccode\u003enode_modules\u003c/code\u003e에는 스토어의 파일을 \u003cstrong\u003e하드링크\u003c/strong\u003e로 연결하고, 패키지 간 의존 관계는 \u003cstrong\u003e심볼릭 링크\u003c/strong\u003e로 구성함\u003c/li\u003e\n\u003cli\u003e결과적으로 동일 버전 패키지가 여러 프로젝트에서 필요해도 물리 복제가 발생하지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스토어 기본 위치는 OS와 설정에 따라 달라지므로 명령으로 확인하는 것이 정확함\u003c/p\u003e","title":"pnpm이란? pnpm의 개념과 사용방법 총정리"}]