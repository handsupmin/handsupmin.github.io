[{"content":"개념과 배경 스마트 컨트랙트는 체인 내부 상태만 신뢰하고 외부 네트워크에 직접 접근하지 않음 가격 정보나 날씨, 게임 결과 같은 외부 데이터를 참조하려면 중간자 역할이 필요함 오라클은 외부 데이터를 온체인으로 들여오거나 온체인 이벤트를 외부 시스템에 전달하는 인터페이스 역할 수행 이 연결이 제대로 설계되지 않으면 스마트 컨트랙트의 무결성이 오라클 신뢰도에 종속되는 구조적 한계 발생\n핵심 개념과 정의 오라클 정의 블록체인과 외부 세계 간 데이터 브리지 인바운드 오라클 외부 데이터를 온체인으로 주입 아웃바운드 오라클 온체인 이벤트를 외부 서비스나 장치로 전달 중앙화 오라클 단일 주체가 데이터 제공 간단하고 빠르나 단일 실패 지점과 조작 리스크 존재 탈중앙화 오라클 다수 노드와 다중 소스 집계 신뢰성과 가용성 강화 대신 비용과 설계 복잡도 상승 소프트웨어 오라클 API 기반 웹 데이터 공급 하드웨어 오라클 센서·IoT 장치에서 물리 정보 수집 오라클 문제 체인은 합의로 안전하지만 외부 세계의 진실성은 합의 밖에 있음 신뢰 경계가 오라클로 이동하는 문제를 어떻게 통제할지의 과제\n동작 원리와 구조 요청 응답 패턴 컨트랙트가 요청을 생성하고 오라클 네트워크가 수집·검증 후 결과를 콜백으로 전달 퍼블리시 패턴 오라클이 주기적으로 데이터를 온체인에 게시 컨슈머는 읽기만 수행 집계 방식 다중 소스 수집 후 중앙값 또는 가중 평균 산출 이상치 제거 규칙 포함 검증 기법 서명 기반 인증, 다중 서명 임계치, 커밋 리빌, 신뢰 실행 환경 증명, TLS 증빙, 메르클 증명 등 선택지 존재 데이터 신선도 관리 하트비트 주기, 변경 폭 임계치 기반 갱신 트리거, 지연 한도 설정 전달 보안 콜백 함수를 제한하고 액세스 제어로 임의 호출 차단 리플레이 보호와 논스 사용 비용 모델 온체인 저장과 콜백 호출은 가스 비용 증가 업데이트 주기와 보안 강도를 목적에 맞춰 절충 필요\n실무 포인트와 베스트 프랙티스 신뢰 모델 명시 데이터 출처, 집계 노드 수, 실패 시 동작을 사전 정의 신선도와 정확도 기준 설정 최대 허용 지연, 허용 오차, 최소 유효 소스 수를 상수로 명문화 폴백 전략 기본 피드 실패 시 대체 피드, 마지막 정상값 고정, 기능 제한 모드 진입 같은 단계적 폴백 설계 가용성과 정합성의 균형 업데이트 주기 단축은 비용 증가 주기와 임계값의 조합으로 비용 대비 민감도 최적화 보안 오라클 콜백 접근 제어, 인풋 검증, 재진입 방지, 타임스탬프 신뢰 한계 고려 블록 타임을 현실 세계의 시간으로 오용하지 않기 시장 조작 및 MEV 대응 단일 거래에 의존한 급격한 값 반영 금지 여러 블록에 걸친 확인, 지수 이동평균, 스프레드 상한 도입 모니터링과 SLA 누락 업데이트, 값 급변, 지연 초과 알림 온체인 지표와 오프체인 로그를 함께 수집 테스트 전략 시뮬레이션으로 지연·이상치·네트워크 분할 상황 재현 주기 변경과 폴백 경로에 대한 회귀 방지 테스트 포함\n간단 예시 가격 피드를 읽고 오래된 값은 거부하는 최소 구현 예시\ninterface IOracle { function latestValue() external view returns (int256 value, uint256 updatedAt); } contract UsesOracle { IOracle public oracle; uint256 public maxStale = 5 minutes; constructor(address oracleAddr) { oracle = IOracle(oracleAddr); } function price() public view returns (int256) { (int256 v, uint256 t) = oracle.latestValue(); require(block.timestamp - t \u0026lt;= maxStale, \u0026#34;stale\u0026#34;); return v; } } 확장 포인트 다중 오라클로부터 값을 수집해 중앙값 계산 업데이트 주기와 최대 지연을 스토리지 파라미터로 설정 관리자 키 없이 거버넌스로 갱신\n대표 사용 사례 디파이 담보 청산과 대출 한도 계산에 외부 가격 피드 사용 보험 기상 데이터 트리거로 자동 청구 처리 자동화 결제 특정 지표가 기준치 도달 시 결제 실행 게임과 NFT 오프체인 경기 결과나 난수의 온체인 반영 검증 가능한 난수 생성기 활용 권장 IoT 센서 측정치 기록 또는 온체인 조건에 따른 장비 제어\n오라클의 장점 확장성 온체인 로직이 외부 정보에 기반한 의사결정 가능 자동화 조건 충족 시 트랜잭션 자동 실행 데이터 다양성 금융, 기상, 물류, 위치 등 다양한 도메인 연계\n한계와 트레이드오프 신뢰 문제 중앙화는 단일 실패 지점 탈중앙화는 비용과 복잡도 상승 데이터 지연과 가용성 실시간성 한계 존재 네트워크 혼잡과 가스 급등 시 업데이트 누락 가능 경제적 공격 가격 조작, 세기의 장난감화 방지 필요 다중 소스와 완화 규칙 도입 권장 거버넌스와 업그레이드 운영 키 관리 리스크 롤백 계획과 투명한 변경 절차 필요\n마무리 오라클은 스마트 컨트랙트를 현실 세계와 연결하는 핵심 인프라 설계의 본질은 신뢰 경계 관리와 비용 대비 안전성 최적화에 있음 신뢰 모델을 명시하고, 신선도와 폴백, 모니터링과 테스트 체계를 포함한 전체 운영 전략을 준비할 때 오라클 리스크를 통제 가능한 수준으로 낮출 수 있음\n참고자료 https://en.wikipedia.org/wiki/Oracle_(blockchain) https://docs.chain.link/ https://docs.api3.org/ https://docs.bandchain.org/ https://vitalik.ca/general/2021/05/05/voting.html ","permalink":"https://handsupmin.github.io/posts/blockchain-oracle-guide-91a3d2/","summary":"\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003e스마트 컨트랙트는 체인 내부 상태만 신뢰하고 외부 네트워크에 직접 접근하지 않음\n가격 정보나 날씨, 게임 결과 같은 외부 데이터를 참조하려면 중간자 역할이 필요함\n오라클은 외부 데이터를 온체인으로 들여오거나 온체인 이벤트를 외부 시스템에 전달하는 인터페이스 역할 수행\n이 연결이 제대로 설계되지 않으면 스마트 컨트랙트의 무결성이 오라클 신뢰도에 종속되는 구조적 한계 발생\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cp\u003e오라클 정의  블록체인과 외부 세계 간 데이터 브리지\n인바운드 오라클  외부 데이터를 온체인으로 주입\n아웃바운드 오라클  온체인 이벤트를 외부 서비스나 장치로 전달\n중앙화 오라클  단일 주체가 데이터 제공  간단하고 빠르나 단일 실패 지점과 조작 리스크 존재\n탈중앙화 오라클  다수 노드와 다중 소스 집계  신뢰성과 가용성 강화 대신 비용과 설계 복잡도 상승\n소프트웨어 오라클  API 기반 웹 데이터 공급\n하드웨어 오라클  센서·IoT 장치에서 물리 정보 수집\n오라클 문제  체인은 합의로 안전하지만 외부 세계의 진실성은 합의 밖에 있음  신뢰 경계가 오라클로 이동하는 문제를 어떻게 통제할지의 과제\u003c/p\u003e","title":"블록체인 오라클 개념, 유형, 동작 원리와 실무 가이드"},{"content":"개요 OpenZeppelin Contracts 5.0으로 올라가면서 토큰 표준 구현 방식이 크게 바뀜 핵심은 ERC20·ERC721·ERC1155에서 _beforeTokenTransfer와 _afterTokenTransfer 훅이 제거되고 내부 상태 갱신 진입점이 _update 하나로 통합된 것 또한 ERC777과 ERC1820Implementer가 제거됨 이 글은 4.6 계열에서 5.1까지 마이그레이션할 때 알아야 할 변경점과 안전한 이전 절차를 정리함\n핵심 변경 사항 ERC20·ERC721·ERC1155의 전송 수명주기 훅 제거 및 _update 도입 기존 훅 기반 커스터마이징은 _update 오버라이드로 이전 필요 민트와 번 포함 모든 잔액 변경 경로가 _update로 수렴 _transfer, _mint, _burn 비가상 처리 더 이상 이 함수들을 직접 오버라이드 불가 일관성 보장을 위해 상태 변경 경로를 고정 ERC777 및 ERC1820Implementer 제거 4.9에서 폐기 예고되었고 5.0에서 실제 삭제 해당 표준 인터페이스는 별도 레포에서 유지되나 구현체 제공하지 않음 동작 원리와 의도 단일 진입점 설계 모든 잔액 및 공급 변화가 _update에서 처리됨 확장과 커스터마이징은 _update를 단일 오버라이드 포인트로 사용 불변식 강화 _transfer, _mint, _burn을 잠그고 내부 루팅으로만 호출되게 하여 상태 불일치 리스크 감소 확장 간 상호작용 일관화 투표, 스냅샷, 소각 수수료, 중지 등 다양한 확장을 _update 체인으로 연결 마이그레이션 가이드 훅 사용 여부 점검 _beforeTokenTransfer, _afterTokenTransfer 오버라이드 코드 존재 여부 확인 각 훅에서 하던 검증, 제한, 회계 처리 항목을 목록화 _update 오버라이드로 이전 훅에 있던 로직을 _update에 통합 검증은 상태 갱신 전 수행 권장 필수로 super._update 호출 필요 기존 _transfer, _mint, _burn 오버라이드 삭제 5.0에서는 오버라이드 자체가 불가 커스터마이징은 _update 단일 경로로 정리 민트와 번 경계값 처리 확인 from 또는 to가 address(0)인 경우를 민트와 번으로 해석 수수료, 제한, 공급 상한과 같은 정책에서 제로 주소 여부 분기 필요 테스트와 이벤트 검증 강화 Transfer 이벤트는 여전히 발생하므로 기존 테스트 자산 가능 단, 커스터마이징이 이벤트 순서나 재진입 가능성에 영향 주지 않게 확인 최소 예시 아래는 기존 _beforeTokenTransfer에서 하던 검증을 _update로 옮기는 형태의 최소 패턴 예시\n// 상태 갱신 전 검증 수행 후 super 호출 권장 function _update(address from, address to, uint256 amount) internal virtual override { if (paused()) revert TokenPaused(); require(!blacklisted[from] \u0026amp;\u0026amp; !blacklisted[to], \u0026#34;restricted\u0026#34;); super._update(from, to, amount); } 포인트\n상태 변경 이전에 정책 검증 실행 super._update 호출로 잔액, 총공급, 이벤트 방출 등을 보장 재정의 시 외부 호출이나 콜백 삽입 지양 실무 체크리스트 오버라이드 경로 단일화 _update만 오버라이드하는지 확인 super 호출 누락 방지 잔액이나 총공급가 틀어지면 모든 기능이 연쇄 실패 민트와 번 분기 정확성 from == address(0) 민트, to == address(0) 번로 처리 Pausable, AccessControl, Snapshot, Votes 등 확장 조합 검증 오버라이드 체인 순서와 super 호출 위치 점검 이벤트 일관성 기존 프론트엔드와 인덱서가 기대하는 Transfer, Approval 이벤트 흐름 유지 확인 가스 영향 가상 함수 수 감소에 따른 소폭 변화 가능성, 기준 가스 측정으로 회귀 테스트 구축 ERC777 및 ERC1820 관련 이전 전략 ERC777 제거 대응 신규 토큰은 ERC20 기반 설계 권장 오퍼레이터 기능 필요 시 권한 제어와 메타트랜잭션 조합으로 대체 설계 검토 ERC1820Implementer 제거 대응 컨트랙트 간 인터페이스 등록에 ERC1820에 의존하던 부분 제거 또는 별도 레지스트리 재설계 필요 레거시 자산 연동 외부에서 ERC777을 계속 사용할 경우 어댑터 컨트랙트로 ERC20 인터페이스 노출 고려 자주 만나는 이슈와 원인 전송이 영구 중지되는 문제 _update에서 super 호출 누락으로 잔액 미변경 민트가 번으로 처리되는 문제 제로 주소 분기 누락 또는 반대로 작성한 조건식 확장 간 충돌 다중 상속에서 오버라이드 체인 정렬 미흡, super 호출 순서 오류 이벤트 기반 인덱싱 실패 이벤트가 여전히 발생하나 테스트에서 커스텀 리버트 후 상태 롤백을 감안하지 못한 경우 검증 전략과 회귀 방지 경계 케이스 퍼징 from 또는 to가 제로 주소인 케이스, 동일 주소 전송, 최대 공급 근접 상황 불변식 기반 테스트 총공급 = 모든 계정 잔액 합계, 전후 차액 = amount 이벤트 시퀀스 단언 Transfer 발생 여부와 파라미터 검증 가스 스냅샷 4.6 대비 변동 폭 기록으로 비정상 증가 탐지 마무리 5.0의 가장 큰 변화는 전송 수명주기 진입점을 _update로 단순화한 것 훅 기반 커스터마이징은 모두 _update로 이동해야 하며 super 호출과 분기 처리를 엄격히 지키는 것이 핵심 ERC777과 ERC1820Implementer 제거에 따른 대체 설계까지 검토하면 5.x 라인으로의 이전 리스크를 크게 줄일 수 있음\n참고자료 https://docs.openzeppelin.com/contracts/5.x/ https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v5.0.0 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3838 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3876 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377 https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066 https://docs.openzeppelin.com/contracts/5.x/upgrade ","permalink":"https://handsupmin.github.io/posts/openzeppelin-contracts-5-migration-erc20-erc721-erc1155-update-erc777-removal-73e149/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eOpenZeppelin Contracts 5.0으로 올라가면서 토큰 표준 구현 방식이 크게 바뀜\n핵심은 ERC20·ERC721·ERC1155에서 _beforeTokenTransfer와 _afterTokenTransfer 훅이 제거되고 내부 상태 갱신 진입점이 _update 하나로 통합된 것\n또한 ERC777과 ERC1820Implementer가 제거됨\n이 글은 4.6 계열에서 5.1까지 마이그레이션할 때 알아야 할 변경점과 안전한 이전 절차를 정리함\u003c/p\u003e\n\u003ch3 id=\"핵심-변경-사항\"\u003e핵심 변경 사항\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eERC20·ERC721·ERC1155의 전송 수명주기 훅 제거 및 _update 도입\n\u003cul\u003e\n\u003cli\u003e기존 훅 기반 커스터마이징은 _update 오버라이드로 이전 필요\u003c/li\u003e\n\u003cli\u003e민트와 번 포함 모든 잔액 변경 경로가 _update로 수렴\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e_transfer, _mint, _burn 비가상 처리\n\u003cul\u003e\n\u003cli\u003e더 이상 이 함수들을 직접 오버라이드 불가\u003c/li\u003e\n\u003cli\u003e일관성 보장을 위해 상태 변경 경로를 고정\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eERC777 및 ERC1820Implementer 제거\n\u003cul\u003e\n\u003cli\u003e4.9에서 폐기 예고되었고 5.0에서 실제 삭제\u003c/li\u003e\n\u003cli\u003e해당 표준 인터페이스는 별도 레포에서 유지되나 구현체 제공하지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"동작-원리와-의도\"\u003e동작 원리와 의도\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단일 진입점 설계\n\u003cul\u003e\n\u003cli\u003e모든 잔액 및 공급 변화가 _update에서 처리됨\u003c/li\u003e\n\u003cli\u003e확장과 커스터마이징은 _update를 단일 오버라이드 포인트로 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e불변식 강화\n\u003cul\u003e\n\u003cli\u003e_transfer, _mint, _burn을 잠그고 내부 루팅으로만 호출되게 하여 상태 불일치 리스크 감소\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e확장 간 상호작용 일관화\n\u003cul\u003e\n\u003cli\u003e투표, 스냅샷, 소각 수수료, 중지 등 다양한 확장을 _update 체인으로 연결\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"마이그레이션-가이드\"\u003e마이그레이션 가이드\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e훅 사용 여부 점검\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e_beforeTokenTransfer, _afterTokenTransfer 오버라이드 코드 존재 여부 확인\u003c/li\u003e\n\u003cli\u003e각 훅에서 하던 검증, 제한, 회계 처리 항목을 목록화\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e_update 오버라이드로 이전\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e훅에 있던 로직을 _update에 통합\u003c/li\u003e\n\u003cli\u003e검증은 상태 갱신 전 수행 권장\u003c/li\u003e\n\u003cli\u003e필수로 super._update 호출 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e기존 _transfer, _mint, _burn 오버라이드 삭제\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e5.0에서는 오버라이드 자체가 불가\u003c/li\u003e\n\u003cli\u003e커스터마이징은 _update 단일 경로로 정리\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e민트와 번 경계값 처리 확인\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003efrom 또는 to가 address(0)인 경우를 민트와 번으로 해석\u003c/li\u003e\n\u003cli\u003e수수료, 제한, 공급 상한과 같은 정책에서 제로 주소 여부 분기 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e테스트와 이벤트 검증 강화\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eTransfer 이벤트는 여전히 발생하므로 기존 테스트 자산 가능\u003c/li\u003e\n\u003cli\u003e단, 커스터마이징이 이벤트 순서나 재진입 가능성에 영향 주지 않게 확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"최소-예시\"\u003e최소 예시\u003c/h3\u003e\n\u003cp\u003e아래는 기존 _beforeTokenTransfer에서 하던 검증을 _update로 옮기는 형태의 최소 패턴 예시\u003c/p\u003e","title":"OpenZeppelin Contracts 5.0 마이그레이션 가이드 — ERC20·ERC721·ERC1155 _update 전환과 ERC777 제거"},{"content":"개념 및 배경 Off‑chain은 블록체인 외부에서 연산·저장을 수행하고 필요한 증명 또는 요약만 온체인에 게시하는 접근을 말함 목표는 가스비 절감, 처리량 확대, 데이터 활용 유연성 확보임 온체인은 합의와 정산의 최소 핵심만 유지하고, 나머지는 오프체인 시스템으로 이전하는 설계 철학임\n핵심 개념과 정의 Off‑chain 처리 트랜잭션 집계·상태 채널 업데이트·인덱싱·분석 등을 체인 밖에서 수행하고 결과 요약만 온체인에 커밋하는 방식임\nOff‑chain Data Availability DA 트랜잭션 본문은 오프체인에 보관하고 온체인에는 검증용 최소 데이터와 유효성 또는 사기 증명만 올리는 모델임 데이터 보관자나 분산 스토리지의 지속 제공을 신뢰하거나 경제적 인센티브로 강제하는 설계가 필요함\nOn‑chain DA 대비 위치 on‑chain DA는 calldata나 EIP‑4844 블롭으로 데이터를 L1에 올려 누구나 상태를 재현할 수 있게 함 off‑chain DA는 데이터를 외부에 두고 L1에는 커밋·증명만 올려 비용을 크게 줄임\n동작 원리와 데이터 생애주기 오프체인 엔진이 다수 트랜잭션을 수집·정렬·실행 상태 차분과 루트를 계산하고 필요 시 증명 생성을 수행 L1에 상태 루트·커밋·증명 등 검증 메타데이터만 게시 원본 데이터는 오프체인 DA 레이어 또는 저장소에 보관하며 재현 요청에 응답 L1 컨트랙트는 커밋·증명을 검증하고 브릿지·정산 로직을 진행함 이 파이프라인은 L1 저장 비용과 합의 병목을 줄이는 데 효과적임\n기술 스펙트럼 맵 State Channels 개별 당사자 간 다중 결제를 오프체인으로 처리하고 개시·종료만 온체인에 기록 최종 정산과 분쟁 해결을 위한 증거 제출 경로가 핵심임\nRollups with On‑chain DA Optimistic 또는 ZK 방식으로 실행은 오프체인, 데이터는 L1에 게시해 누구나 재현 가능을 보장함\nValidium ZK + Off‑chain DA 상태의 유효성은 ZK 증명으로 보장하되 데이터는 오프체인에 보관 비용·TPS에 유리하지만 데이터 가용성 제공자 신뢰가 필요함\nOptimium AnyTrust 등 OR + Off‑chain DA 옵티미스틱 검증에 오프체인 DA를 결합한 형태로 비용을 낮추되 위원회 가용성 보장에 의존함\nIndexers Oracles 질의 응답이나 외부 사실을 체인으로 반영하는 오프체인 서비스 정확도·시빌 방지·서명 검증이 신뢰 모델의 핵심임\n장점과 주의사항 장점 요약\n비용 절감 L1에 올리는 데이터량이 줄어 가스비가 감소함 성능 개선 합의 병목을 피하고 높은 TPS를 달성하기 쉬움 데이터 유연성 민감 정보 비공개 보관과 대규모 분석·인덱싱에 유리함 주요 리스크와 대응\n데이터 가용성 위험 오프체인 데이터 손실·중단 시 상태 재현·강제 출금이 어려울 수 있음 다중 복제·위원회 서명 임계값·감사 가능한 저장 포맷과 주기 검증을 도입함\n신뢰 모델 도입 DA 제공자·위원회·운영사에 대한 신뢰가 포함됨 오프보딩·키 교체·부정행위 슬래싱·감사 로그 공개로 책임 경합을 설계함\n검열·중단 대응 시퀀서 중단·검열에 대비해 L1 강제 포함 큐와 탈출 루트를 마련함 이 경로가 DA 레이어 의존 없이 작동하는지 확인함\n검증과 보안 관점 유효성 Validity vs 가용성 Availability 를 분리해 사고를 설계하는 것이 핵심임 ZK 증명은 상태 전이의 정당성을 보장하지만 데이터 접근성은 별개임 사용자가 독립적으로 상태를 재현할 수 있도록 커밋 포맷·해시 체계·증거 경로를 문서화하고 오픈소스로 제공함 DA 장애 시를 가정한 안전 정지 모드와 강제 출금 절차를 온체인에 내장함 예시 패턴 결제 채널 채널 오픈·종료만 온체인 기록, 중간 결제는 오프체인 교환 분쟁 시 최신 서명 상태를 제출해 정산함\n인덱서 서비스 이벤트·상태를 오프체인 DB에 색인해 빠른 질의를 제공 오염 방지용으로 스냅샷 루트를 주기적으로 온체인에 커밋해 검증 가능성을 보강함\nOff‑chain DA 상세 비교 zkRollup vs Validium zkRollup on‑chain DA\n트랜잭션 데이터를 압축해 L1에 게시하고 ZK 증명을 함께 제출함 누구나 데이터를 내려받아 상태를 완전 재현 가능 비용은 데이터 게시량에 비례해 높게 책정될 수 있음 EIP‑4844 블롭 사용 시 데이터 단가가 낮아져 운영 비용을 크게 절감할 수 있음 Validium off‑chain DA\nZK 증명만 L1에 제출하고 데이터는 외부에 보관함 가스비와 TPS에 유리하지만 DA 제공자의 불능·검열이 치명적임 강제 출금·재현 경로가 DA 위원회 서명 또는 가용성 보증에 의존함 결정 기준\n검열 저항·자가 재현성 이 우선이면 zkRollup을 우선 고려 비용·처리량 이 우선이면 Validium을 고려하되 DA 보장과 탈출 경로를 온체인 명세로 고정함 유동적 요구가 섞이면 Volition 같이 토큰 단위로 on‑chain DA와 off‑chain DA를 선택하는 하이브리드도 검토함 신뢰 모델 매트릭스 모델 실행 검증 데이터 가용성 재현 가능성 주된 위험 zkRollup on‑chain DA ZK 증명 L1 블롭·calldata 전 노드 가능 데이터 비용 부담 Validium off‑chain DA ZK 증명 위원회·DA 레이어 위원회 장애 시 제한 데이터 중단·검열 Optimium AnyTrust 사기 증명 위원회·DA 레이어 도전 전제 도전 실패·위원회 리스크 State Channel 서명 증거 참여자 보관 당사자 간 제한 오프라인·분쟁 지연 표의 각 셀은 구현에 따라 달라질 수 있으니 프로토콜 명세로 확정하는 것이 중요함\n실무 체크리스트 설계 단계\n신뢰 경계 정의 운영자·위원회·사용자 역할과 실패 가정 명확화 커밋 스키마 정의 상태 루트·이벤트 루트·증명 포맷과 해시 규칙 고정 탈출 로직 정의 시퀀서 불능·DA 장애 시 강제 포함·강제 출금 경로 설계 운영 단계\nTTI TTP TTF 포함 지표 모니터링 포함 지연·증명 지연·최종성 도달 시간 추적 DA 가용성 모니터링 응답 지연·결함률·복제 카운트·위원회 서명 실패율 추적 키·권한 관리 위원회 키 교체·슬래싱·감사 로그를 주기 공개 보안·거버넌스\n업그레이드 권한 최소화와 타임락·멀티시그 적용 비상 스위치 남용 방지 조건 명문화와 온체인 공시 감사·버그바운티·재현 도구 공개로 검증 가능성 제고 오해 방지 팁 ZK 증명이 있으면 모든 리스크가 사라진다는 오해는 금물 ZK는 정당성을 보장하지만 가용성·검열 문제는 별개임 오프체인 인덱서가 반환하는 값은 편의 결과물임 신뢰 최소화를 원하면 커밋된 루트와 머클 증명을 함께 검증해야 함 마무리 Off‑chain 패턴은 확장성의 실질 해법이지만 신뢰·가용성·유효성 사이의 선택을 요구함 zkRollup과 Validium은 검증 방식은 유사하게 ZK 를 쓰되 데이터 위치에서 다른 트레이드오프를 가짐 제품 요구에 맞춰 DA 보장책·탈출 경로·운영 지표를 명확히 설계하면 비용과 성능을 확보하면서도 안전성을 유지할 수 있음\n참고자료 Ethereum Layer 2 개요 https://ethereum.org/en/developers/docs/layer-2 ZK Rollups 개요 https://ethereum.org/en/developers/docs/scaling/zk-rollups EIP‑4844 Proto‑Danksharding 블롭 https://eips.ethereum.org/EIPS/eip-4844 ","permalink":"https://handsupmin.github.io/posts/off-chain-data-availability-zkrollup-validium-274b74/","summary":"\u003ch3 id=\"개념-및-배경\"\u003e개념 및 배경\u003c/h3\u003e\n\u003cp\u003eOff‑chain은 블록체인 \u003cstrong\u003e외부\u003c/strong\u003e에서 연산·저장을 수행하고 \u003cstrong\u003e필요한 증명 또는 요약만 온체인에 게시\u003c/strong\u003e하는 접근을 말함\n목표는 \u003cstrong\u003e가스비 절감\u003c/strong\u003e, \u003cstrong\u003e처리량 확대\u003c/strong\u003e, \u003cstrong\u003e데이터 활용 유연성 확보\u003c/strong\u003e임\n온체인은 합의와 정산의 최소 핵심만 유지하고, 나머지는 오프체인 시스템으로 이전하는 설계 철학임\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOff‑chain 처리\u003c/strong\u003e\n트랜잭션 집계·상태 채널 업데이트·인덱싱·분석 등을 체인 밖에서 수행하고 결과 요약만 온체인에 커밋하는 방식임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eOff‑chain Data Availability DA\u003c/strong\u003e\n트랜잭션 본문은 오프체인에 보관하고 온체인에는 검증용 최소 데이터와 \u003cstrong\u003e유효성 또는 사기 증명\u003c/strong\u003e만 올리는 모델임\n데이터 보관자나 분산 스토리지의 \u003cstrong\u003e지속 제공\u003c/strong\u003e을 신뢰하거나 경제적 인센티브로 강제하는 설계가 필요함\u003c/p\u003e","title":"Off-chain 개념과 데이터 가용성: zkRollup vs Validium 비교"},{"content":"개요 이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함 목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것\n주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요\n배경과 목적 배경: L1(예: 이더리움)의 처리량·가스비 제약을 보완하기 위해 L2 도입이 필요 ZK Rollup의 목적: 메인넷 보안성을 활용하면서 트랜잭션 처리량을 확대하고 온체인 비용을 절감. 유효성 증명(validity proof) 으로 상태 전이가 올바름을 보장해 도전 기간 없이 빠른 확정을 지향 핵심 개념과 정의 ZK Rollup: 트랜잭션을 L2에서 실행·집계하고, 그 결과에 대한 유효성 증명을 L1로 제출해 상태 변경을 확정하는 확장 방식 ZK Stack(일반): ZK Rollup 구축을 위한 회로/프루버/런타임/배포 도구의 모음(구현체별 상이) Sequencer: L2 트랜잭션을 수신·정렬·블록화하고, 배치를 생성하는 컴포넌트(중앙/탈중앙 설계 가능) Prover / Verifier: Prover가 증인(witness) 을 생성하고 회로를 실행해 증명을 만들면, L1의 Verifier(스마트 컨트랙트)가 이를 검증 네이티브 Account Abstraction(AA): 모든 계정이 컨트랙트 계정으로 동작(예: zkSync·Starknet 스타일). EIP-4337과는 별개 경로의 네이티브 모델일 수 있음 아키텍처 개요 Sequencer 영역\nRPC 게이트웨이: 트랜잭션 제출·조회 API 제공(JSON-RPC 호환/확장) 시퀀싱/실행: 멤풀에서 트랜잭션을 읽어 정렬·블록화, 실행 결과를 즉시 반환할 수 있음(체인별 정책) L1 동기화: 입출금 브리지, 시스템 이벤트 추적 Prover \u0026amp; Verifier 영역\n증인 생성 → 회로 실행 → 증명 생성/집계 → (선택) 재귀 증명 일부 구현은 STARK → SNARK 래핑 또는 재귀 SNARK로 L1 검증 비용 최적화(구현체별 다름) L1 Rollup Contracts\n배치 커밋(DA 확립), 증명 검증, 상태 루트 업데이트, 크로스체인 메시지 처리(Inbox/Outbox) 데이터 가용성(DA)\nEIP-4844 블롭을 활용해 Rollup 데이터(입력/차분)를 저비용으로 게시. 블롭은 EVM에서 직접 읽히지 않으며 일정 기간 후 가비지 컬렉션될 수 있으므로, L2 재현성은 블롭 + 노드 아카이빙 조합으로 확보 트랜잭션 생명주기(일반화) 제출: 클라이언트가 JSON-RPC로 트랜잭션 전송 → L2 멤풀 적재 시퀀싱 \u0026amp; 실행: Sequencer가 트랜잭션을 정렬·실행. 결과(성공/실패, tx hash)를 즉시 응답 가능(정책에 따름) 배치 생성: 특정 주기/조건에 따라 블록들을 묶어 배치(batch) 구성 증명 준비: Prover가 배치에 대한 witness 생성 → 회로 실행 → 유효성 증명 생성(필요 시 재귀/집계) L1 게시(DA) \u0026amp; 증명 제출: 블롭(EIP-4844) 등으로 데이터 가용성 확보 후, 증명을 Rollup Verifier에 제출 검증·확정: L1에서 증명 검증 성공 시 해당 배치의 상태 루트가 확정(finality). 브리지 메시지 처리 등 후속 로직 실행 용어 주의: 구현 문서에 나오는 proveBatches, finalize/executeBatches 등 함수명은 예시적 표현이며, 실제 명칭·시맨틱은 스택별로 다름\n증명 파이프라인(좀 더 구체적으로) witness 생성: VM 실행 트레이스, 스토리지 읽기/쓰기, precompile 호출 등을 회로 입력으로 변환\n회로 구성: 범용 VM 회로(예: RISC-V/LLVM IR 스타일) 또는 EVM 친화 회로, Merkle/KZG 등 커밋먼트 검증 서브회로 포함\n재귀·집계: 여러 증명을 트리 형태로 합성(aggregation)해 L1 검증 비용을 상수/로그 수준으로 유도\n성능 팁(운영):\n배치 크기/가짓수, 회로 분해(granularity) 설정으로 TTP(Time-To-Proof) 최적화 프루버 팜(HW 가속: GPU/FPGA/ASIC)과 큐 동시성으로 증명 처리량 보장 L1 가스/블롭 비용 변동에 맞춘 배치 시점/크기 튜닝 데이터 가용성(DA) \u0026amp; EIP-4844 블롭(Blob): EVM에 직접 접근 불가한 대용량 데이터 영역. KZG 커밋먼트로 무결성 보장 장점: calldata 대비 저렴한 데이터 게시. 롤업 비용 구조의 핵심 운영 포인트: 블롭 보존 기간 이후를 대비해 오프체인 아카이브·재생성 전략 필요. 프루닝 정책과 동기화 도구 점검 L1 Rollup Contract 주요 기능(일반화) commitBatch: 입력 데이터/상태 요약을 게시(DA) verifyBatch: 제출된 증명의 유효성 검증 finalizeBatch: 상태 루트 업데이트 및 교차메시지 확정 Bridge(입·출금): L1↔L2 메시지 박스(Inbox/Outbox), 강제 포함(Force Inclusion) 메커니즘으로 검열 대응 네이티브 계정 추상화(AA) 개요 핵심: EOA 없이 모든 계정이 컨트랙트로 동작 → 서명 검증·nonce·가스 지불 로직을 계정이 스스로 정의 장점: 키 회전/멀티시그/세션키/소셜 복구/가스 대납 등 유연한 UX 주의: mempool 정책, 부트로더/시스템 컨트랙트 인터페이스, 가스 회계 방식이 EIP-4337과 다를 수 있음 (예시) 네이티브 AA 처리 흐름 (zkSync 계열 유사 개념, 체인별 상이) 제출: JSON-RPC로 트랜잭션 제출(from이 컨트랙트 주소) 부트로더/시스템: 멤풀→배치, nonce 검증·서명 검증·가스 계산 계정 훅: validate* → execute* → paymaster/fee settlement 순으로 훅 호출 페이마스터: 정책에 맞춰 가스 대납/토큰 지불 결정, 사후 정산 훅 실행 EIP-4337(번들러/EntryPoint 기반)과 동일하지 않음. “네이티브 AA”는 프로토콜 레벨에서 계정이 컨트랙트로 정의되는 모델임\n페이마스터(가스 대납) 설계 포인트 정책: 허용 토큰·한도·쿨다운·화이트리스트/블랙리스트 검증: 오프체인 서명·쿼터 점검·리플레이 방지(nonce·만료) 리스크 관리: 불로소득(arbitrage) 악용·스팸 방지(예: 최소 잔액·인증)·실패 시 롤백 범위 최소화 스마트 컨트랙트 지갑 설계(일반) 배포 패턴: 팩토리+프록시(미니멀 프록시)로 가스 절감·업그레이드 용이 키 관리: 멀티시그·세션키(권한·만료)·키 회전·소셜 복구 서명 표준: 온체인 서명 검증은 EIP-1271 구현 권장 // 30줄 미만 예시 contract ERC1271 { bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature(bytes32 _hash, bytes memory _sig) public view returns (bytes4) { // 구현부는 지갑 정책에 맞게 작성 return MAGICVALUE; } } 보안 모델 및 리스크 유효성 증명 안전성: 회로 사운드니스, 트러스트 설정(예: SRS), 업그레이드 키 관리 시퀀서 리스크: 다운타임/검열 → 강제 포함 경로(L1 큐), 시퀀서 탈중앙화 로드맵 검토 브리지 안전성: L1 검증 완료 전 출금 불가. 메시지 재생성·체인 재조직(Reorg) 처리 방침 명확화 AA·페이마스터 남용: 스팸·사기 유입을 계정/페이마스터 레벨에서 선제 차단 운영·모니터링 지표(KPI) TTI(Time-To-Inclusion): 제출→L2 포함까지 지연 TTP(Time-To-Proof): 배치→증명 생성 완료까지 지연 TTF(Time-To-Finality): L1 검증 완료까지 전체 시간 비용 지표: L1 데이터(블롭/칼데이터) 비용, 증명 가스/수수료, L2 가스 신뢰도: 시퀀서 가용성, 강제 포함 성공률, 브리지 처리 성공률 성능·운영 베스트 프랙티스 배치 전략: 가스 시황·트래픽 패턴에 맞춘 동적 배치 크기/주기 프루버 팜: GPU/FPGA 활용·큐 병렬화·증명 집계로 지연 단축 비용 최적화: EIP-4844 블롭 우선 활용, 상태 쓰기 최소화, 재귀 증명으로 L1 검증 상수화 개발자 경험(DX): JSON-RPC 차이점 문서화, 트레이스/디버깅 도구 제공, 에러 코드 일관성 간단 운영 시나리오(요약) 사용자가 트랜잭션 제출 → Sequencer가 실행 결과를 빠르게 응답 → 일정 주기마다 배치 생성 → Prover가 증명 생성 및 집계 → L1에 블롭 데이터 게시 + 증명 제출 → Verifier가 검증하면 상태 확정 → 브리지 메시지 처리 자주 헷갈리는 포인트 교정 “ZK Rollup은 항상 STARK→SNARK 압축을 한다” → 체인별로 다름. SNARK만 쓰거나, STARK 검증을 L1에서 직접 하거나, 재귀 SNARK만 쓰는 경우도 있음 “네이티브 AA = EIP-4337” → 아님. 네이티브 AA는 프로토콜 계정 모델 자체가 컨트랙트 기반. 4337은 EOA 유지 + 번들러/EntryPoint 레이어임 “블롭 데이터는 영구 상태” → 아님. 블롭은 일시적 보존이며 EVM에서 바로 읽을 수 없음. KZG 커밋먼트로 무결성만 보장 “증명 올라가면 즉시 확정” → L1 검증 트랜잭션 확정(재조직 위험 해소)까지 감안해야 운영상 최종 확정으로 처리 마무리 본 문서는 Abstract 계열 ZK Rollup L2를 염두에 둔 일반적 아키텍처와 AA·지갑·페이마스터 동작을 설명했음\n실제 배포·운영 시에는 다음을 우선 검토 권장\n증명 백엔드 설계(회로 범위·재귀·프루버 팜) 배치·DA 전략(블롭 활용, 비용·지연 균형점) AA/페이마스터 보안 정책(남용·스팸 방지) 브리지 \u0026amp; 강제 포함 경로(검열/다운타임 대비) 체인·스택 문서를 병행하여 용어·함수명·정책 차이를 확인하고, 위 원칙을 현장에 맞게 보수적으로 적용할 것\n참고자료 EIP-1271: https://eips.ethereum.org/EIPS/eip-1271 EIP-4844(Proto-Danksharding): https://eips.ethereum.org/EIPS/eip-4844 롤업 설계 원리(Buterin): https://vitalik.ca/general/2021/06/15/rollups.html ","permalink":"https://handsupmin.github.io/posts/abstract-chain-overview-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 글은 ‘Abstract’로 지칭되는 \u003cstrong\u003eZK Rollup 기반 L2 체인\u003c/strong\u003e의 구조와 핵심 컴포넌트를 \u003cstrong\u003e실무 관점\u003c/strong\u003e에서 정리함\n목표는 \u003cstrong\u003e트랜잭션 흐름\u003c/strong\u003e, \u003cstrong\u003e증명 생성·검증 파이프라인\u003c/strong\u003e, \u003cstrong\u003e데이터 가용성(DA)\u003c/strong\u003e, \u003cstrong\u003e네이티브 계정 추상화(AA)\u003c/strong\u003e, \u003cstrong\u003e스마트 컨트랙트 지갑\u003c/strong\u003e의 동작 방식과 \u003cstrong\u003e운영·보안·성능 관점의 실무 포인트\u003c/strong\u003e를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 \u003cstrong\u003e정확성\u003c/strong\u003e을 보강하는 것\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e주의: 본 문서는 \u003cstrong\u003e일반적인 ZK Rollup 아키텍처\u003c/strong\u003e를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 \u003cstrong\u003e구현체 문서\u003c/strong\u003e를 병행 참고 필요\u003c/p\u003e","title":"Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리"},{"content":"개요 프라이빗키 관리 방식에 따라 암호화폐 월렛은 커스토디얼(custodial) 과 논커스토디얼(noncustodial) 로 구분됨 각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 초보자도 이해할 수 있게 정리하면서 실무자가 바로 적용할 수 있는 체크리스트까지 제시함\n핵심 개념 커스토디얼 월렛 제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조 로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\n논커스토디얼 월렛 사용자가 프라이빗키를 직접 보유·관리하는 구조 브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\n핵심 차이 한 줄 정리 키의 소유·통제 주체가 제3자인가 사용자 본인인가의 차이\n모델별 동작 원리와 구성 커스토디얼 키 보관 중앙화된 키 보관소와 접근제어 체계를 운용 보통 핫월렛 과 콜드월렛 을 분리해 즉시성 vs 보관 안정성을 균형 있게 설계함 운영 통제 권한 분리, 변경 이력 추적, 승인 워크플로, 이상 징후 모니터링을 포함 유저 경험 계정 비밀번호·2FA 등 웹서비스 UX에 가깝고 분실 시 고객지원으로 복구 가능성이 있음 논커스토디얼 키 생성·저장·복구를 사용자 단말 또는 전용 기기에서 수행 하드웨어 지갑은 기기 내 보안영역에서 서명 연산을 수행해 키를 외부로 노출하지 않음 시드 문구(BIP‑39) 와 HD 지갑(BIP‑32, BIP‑44) 로 여러 주소를 파생해 사용함 분실·도난·손상에 대비한 백업·복구 절차가 필수임 하이브리드 접근 멀티시그 N개 중 M개 서명이 있어야 지출 가능 운영자 간 책임 분산과 단일 키 손실 리스크 완화에 효과적 키 분할과 복구 Shamir Secret Sharing 은 백업·복구에 적합하나 서명 자체는 수행하지 않음 임계값 서명(MPC/TSS) 여러 파티가 키 조각을 재조합 없이 공동 서명 단일 실패 지점 제거와 유연한 권한 정책이 장점 보안·규제·운영 관점 비교 구분 커스토디얼 논커스토디얼 키 소유 서비스 사업자 사용자 복구 용이성 계정 기반 복구 지원 가능 사용자가 책임, 백업 실패 시 복구 불가 보안 초점 내부자 위협·핫월렛 침해·운영 취약점 피싱·악성코드·물리 분실·백업 실패 컴플라이언스 관할에 따라 수탁 라이선스·KYC/AML 등 요구 가능 개인 사용은 상대적으로 자유, 조직은 회계·규정 준수 정책 필요 확장성/운영 기업 통제·감사 로그·승인 워크플로에 유리 사용자 자율성 최상, 표준화된 기업 통제는 구현 난이도 존재 일반 용도 거래소·커스터디 업체·핀테크 개인 보관·DAO 금고·개별 팀 지갑 위협 모델 수립 가이드 가치와 빈도 소액·빈번 결제는 접근성·자동화 우선, 대액·장기 보관은 보존·격리가 우선 공격면 피싱 링크·악성 확장프로그램·사기 승인 서명, 내부자 오남용, 인프라 취약점, 물리적 분실 복구 요구 사람 교체·기기 손상·지역 재해 등 현실 시나리오에서 얼마나 빨리 복구 가능한지 평가 감사 가능성 로그 불변성·승인 이력·역활분리와 규정 준수 증빙 가능성 점검 커스토디얼 선택 체크리스트 운영 보안 핫·콜드 분리, 다중인증, 권한 분리, 변경관리, 침해사고 대응 계획 보유 여부 키 관리 체계 HSM 또는 동급 보안 모듈 사용, 키 생성·보관·회전 절차 문서화, 접근 통제 로그 유지 감사·인증 SOC 2 Type II, ISO/IEC 27001, 취약점 스캐닝·모의침투 주기 운영 여부 재무·보험 보험 범위와 면책 조항을 명확히 공개하는지, 준비금·준법 체계 확인 규제 준수 관할 내 라이선스·KYC/AML 의무 이행, 제재 대응 정책 보유 논커스토디얼 선택 체크리스트 백업·복구 시드 문구 오프라인 보관, 금고·내화 금속 플레이트 등 물리 보안, 복구 리허설 정기 수행 기기 보안 하드웨어 지갑 사용, 펌웨어 서명 검증, 기기 PIN·패스프레이즈 사용, 분실 시 스스로 wipe 가능한지 확인 트랜잭션 안전 서명 전 도메인 분리 정보를 기기 화면에서 직접 확인, 승인 범위·스팸 토큰·허가 영속성 점검 멀티시그·MPC 병용 단일 키 실패 지점 제거, 역할 기반 승인 정책 적용 자동화 요구 스케줄 결제·트리거 송금 등 자동화는 지갑 권한 최소화와 일회성 권한 부여로 제한 운영 베스트 프랙티스 핵심 원칙 최소 권한, 강한 인증, 분리 보관, 반복 검증 지출 정책 금액 구간별 다른 승인 경로 적용, 시간지연 타임락과 알림으로 오탐·오남용 방지 주소 화이트리스트 높은 금액은 사전 등록 주소로만 송금 모니터링 대기열 이상, 실패율 급증, 신규 승인 요청 급증, 지출 한도 임계 접근 알림 키 수명주기 관리 생성·배포·사용·보관·회수·폐기 전 과정 문서화와 정기 점검 사고 대응 유출 의심 즉시 키 회전, 멀티시그 참여자 교체, 브리지·거래소 연락망 업데이트, 법무·준법 협업 라인 확보 시나리오별 권장 아키텍처 개인 사용자 데일리 소액은 모바일 지갑 사용 장기 보관·대액은 하드웨어 지갑과 오프라인 백업 병행 승인 내역 정기 점검과 피싱 훈련 연습 권장\n소규모 팀/스타트업 운영비 지출용 커스토디얼 핫월렛 + 멀티시그 콜드 보관 회계·승인 로그를 공유 드라이브가 아닌 전용 감사 시스템에 적재\n기업·DAO 금고 MPC 기반 금고 또는 다중 하드웨어 지갑 멀티시그 역할 기반 접근제어와 오프보딩 절차, 비상 시나리오의 대체 서명자 지정\n자주 하는 실수와 교정 Shamir 분할 = 안전한 서명이라고 오해 Shamir는 복구용 비밀 분할 기법이고 서명은 수행하지 않음 서명 분산은 MPC/TSS 를 사용함 하드웨어 지갑이면 무조건 안전 펌웨어 진위 검증, 공급망 위협, 화면 검증 습관 없으면 위험이 남음 보험이 있으니 안심 보험은 조건과 면책이 많아 모든 손실을 보장하지 않음 범위·상한·예외를 반드시 확인해야 함 커스토디얼은 모두 동일 보안 수준·감사 성숙도·규제 준수·재무 건전성에 큰 차이가 있음 최소 보안 기준 가이드 개인 하드웨어 지갑 1대 이상, 시드 문구 오프라인 백업 2곳, 패스프레이즈 병행, 피싱 훈련 팀 멀티시그 M‑of‑N, 변경 승인 워크플로, 월간 복구 리허설, 화이트리스트 송금 기업 MPC 금고 또는 멀티시그 금고, HSM 또는 동급 보안 모듈, SOC 2 Type II·침투테스트, 사고 대응 플레이북 운영 간단 권장 흐름 1 단계 자산 규모 분류와 위협 모델 정의 2 단계 논커스토디얼·커스토디얼·하이브리드 중 적합 아키텍처 선정 3 단계 백업·복구 문서화와 정기 리허설 시행 4 단계 멀티시그 또는 MPC로 단일 실패 지점 제거 5 단계 지출 정책·화이트리스트·모니터링·사고 대응 체계 운영\n결론 프라이빗키 소유·통제가 보안과 편의의 출발점임 대액·장기 자산은 논커스토디얼과 멀티시그·MPC 조합이 유리하고 업무 자동화·고객 지원이 중요한 경우 커스토디얼이 효율적일 수 있음 모든 선택은 위협 모델·규정 준수·복구 요구를 기준으로 문서화하고 정기적으로 검증해야 함\n참고자료 BIP‑32 계층적 결정성 지갑 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP‑39 니모닉 문구 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP‑44 파생 경로 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki Torus Key Infrastructure 개요 https://docs.tor.us/key-infrastructure/overview NIST SP 800‑57 Part 1 키 관리 권고 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final FIPS 140‑3 암호 모듈 보안 요구사항 https://csrc.nist.gov/publications/detail/fips/140/3/final AICPA SOC 2 안내 https://www.aicpa-cima.com/resources/article/what-is-soc-2 ","permalink":"https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e프라이빗키 관리 방식에 따라 암호화폐 월렛은 \u003cstrong\u003e커스토디얼(custodial)\u003c/strong\u003e 과 \u003cstrong\u003e논커스토디얼(noncustodial)\u003c/strong\u003e 로 구분됨\n각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 \u003cstrong\u003e초보자도 이해할 수 있게\u003c/strong\u003e 정리하면서 \u003cstrong\u003e실무자가 바로 적용할 수 있는 체크리스트\u003c/strong\u003e까지 제시함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e커스토디얼 월렛\u003c/strong\u003e\n제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조\n로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e논커스토디얼 월렛\u003c/strong\u003e\n사용자가 프라이빗키를 직접 보유·관리하는 구조\n브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e핵심 차이 한 줄 정리\u003c/strong\u003e\n키의 \u003cstrong\u003e소유·통제 주체\u003c/strong\u003e가 제3자인가 사용자 본인인가의 차이\u003c/p\u003e","title":"커스토디얼 vs 논커스토디얼 월렛 비교"},{"content":"개요 블록체인은 중앙 기관 없이 참여자들이 거래를 기록·검증·공유하는 분산 원장 기술임 이 글은 블록체인을 초보자 친화적으로 설명하고, 실무 체크리스트까지 정리함\n큰 그림: 시스템 구성 노드(Node): 블록체인 소프트웨어 실행 주체\n풀노드: 모든 블록·트랜잭션 검증·저장 라이트 클라이언트: 헤더·머클 증명 기반 최소 검증 (참고) 아카이브 노드: 오래된 상태 포함 전체 상태 유지(필수 아님) 블록(Block): 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\n합의(Consensus): 어떤 블록이 정식 이력인지 네트워크가 공동으로 결정하는 규칙\nPoW: 작업증명(연산 경쟁) PoS: 지분증명(검증자·보증금 기반) 해시(Hash)와 위·변조 방지 해시 함수(SHA-256, Keccak-256 등): 입력을 고정 길이로 압축하는 일방향 함수임\n충돌 가능성은 이론상 존재하나 실무적으로 극히 낮음 입력이 조금만 바뀌어도 출력이 크게 달라져 무결성 검증에 적합 체인 무결성: 각 블록 헤더에 이전 블록의 해시가 포함됨 → 중간 블록 하나만 바꿔도 이후 전체를 재계산해야 하므로 변조 난이도 매우 높음\n블록헤더와 머클트리(데이터 구조) 블록헤더 대표 필드(비트코인 예시)\nversion, prev_block_hash, merkle_root, timestamp, bits(난이도), nonce 헤더 전체를 해시한 값이 블록 ID 역할을 함 머클트리(Merkle Tree)\n트랜잭션 목록을 해시 이진트리로 요약 → 머클루트(루트 해시) 로 대표 라이트 클라이언트는 머클 증명만 받아 특정 트랜잭션 포함 여부를 검증 가능(SPV) 거래 흐름: 생성 → 서명 → 전파 → 블록 포함 → 확정 생성: 송신자가 수신자 주소·금액으로 트랜잭션 생성 서명: 개인키로 전자서명(비대칭키: ECDSA/secp256k1 등) 전파: P2P 네트워크로 브로드캐스트 → 각 노드의 mempool 에 적재 블록 포함: 합의 규칙에 따라 트랜잭션이 블록에 포함 확정(Finality/확인수): 후속 블록이 더해질수록 되돌리기 어려움 비트코인: 평균 블록 간격 ≈ 10분, 확인수 6 관행(사용처·금액 따라 상이) 이더리움(현행 PoS): 슬롯 ≈ 12초, 체크포인트·파이널리티 개념 사용(정상 시 약 2 에폭에서 최종화, 대략 10~15분 수준). “N 블록이면 충분” 같은 단정 대신 파이널리티 달성 여부 확인이 안전함 상태 모델: UTXO vs 계정(Account) UTXO(비트코인 계열)\n“사용하지 않은 트랜잭션 출력(코인)”을 조합해 지불, 잔돈은 새 UTXO로 생성 장점: 병렬화에 유리, 프라이버시 패턴 일부 이점 유의: 선택/잔돈 전략, 수수료(단위: sat/vByte) 최적화 필요 계정 모델(이더리움 계열)\n계정 잔액·컨트랙트 상태(State) 갱신 장점: 스마트 컨트랙트·상태머신 구현 용이 유의: 상태 증가(State bloat)·가스 비용·리플레이 방지(EIP-155) 등 고려 PoW(작업증명): 난이도·보상·보안 원리: 헤더 + nonce 바꿔가며 목표값(난이도) 이하 해시 찾기 난이도 조정: 네트워크 해시파워 변화에 맞춰 목표 평균 블록 시간 유지(예: 비트코인 2016블록마다 ≈ 2주 간격 조정) 보상: 블록 보상(반감기 존재) + 수수료 보안성: 공격자는 네트워크 해시의 과반수 수준 필요 → 대형 체인에서는 경제적·물리적 비용 거대 간단 PoW 의사코드(개념 학습용)\ntarget = difficulty_to_target(bits) nonce = 0 while True: header = serialize(version, prev_hash, merkle_root, timestamp, bits, nonce) h = sha256d(header) # SHA256(SHA256(header)) if h \u0026lt; target: print(\u0026#34;Found!\u0026#34;, nonce, h.hex()) break nonce += 1 실무 팁\n해시 라이브러리·엔디언 처리·직렬화 포맷(가변 길이 정수 등) 정확도 중요 반감기 이벤트는 채굴 수익성·해시파워·보안에 직격 영향 PoS(지분증명): 검증자·파이널리티·리스크 원리: 토큰 스테이킹 으로 검증자 선정(무작위 + 지분 가중 + 추가 규칙)\n블록·어테스테이션: 검증자가 블록 제안·감사(투표) 수행\n파이널리티: 일정 조건(예: ≥ 2/3 가중치가 찬성) 만족 시 체크포인트 최종화\n위협 모델\nNothing-at-Stake: 여러 체인에 동시 투표 유혹 → 슬래싱 으로 억제 롱레인지 공격: 과거부터 조용히 대체 체인 생성 → 약한 주관성(weak subjectivity)·체크포인트·동기화 규칙으로 방어 수수료와 가스: Bitcoin vs Ethereum Bitcoin: 수수료 = 바이트 크기 × 단가(sat/vByte)\n수수료 추정은 mempool 혼잡도·정책 영향 큼 Ethereum(EIP-1559)\nBase Fee(블록에 의해 자동 조정, 소각) + Priority Fee(팁) + gas_used 사용자 입장: 예상 가능한 수수료 + 혼잡 시 팁으로 우선순위 확보 컨트랙트 호출은 가스 한도 내에서만 실행됨(한도 부족 시 revert) 포크(Fork)와 체인 재조직(Reorg) 소프트 포크: 규칙 강화로 하위 호환 유지(예: SegWit 트랜잭션 가변성 해결, 블록 용량 효율화) 하드 포크: 규칙 불일치 → 미업데이트 노드와 체인 분리 가능(예: ETH/ETC) 운영 유의\n포크 전후 송금 보수적 운영(리플레이·정책 불확실성) 거래소·지갑 대응 계획 사전 확인 자연스런 재조직(reorg) 는 드물지만 발생 가능 → 높은 가치 송금은 여유 확인수/파이널리티 확보 보안 메커니즘·공격 모델 51% 공격(PoW): 과반 해시파워로 더 긴 체인을 만들어 이중지불 가능\n대형 체인: 비용·탐지 리스크 막대 중소 체인: 실질 리스크 존재 → 심도 있는 모니터링·안전 확인수 확대 권장 네트워크 공격: 이클립스(Eclipse)·Sybil·시간 왜곡 등 → 피어 다양화·시계 동기화·피어 밴 정책 필요\n지갑·키 관리\n개인키 유출 = 자금 유출 권장: 하드웨어 지갑, 멀티시그, 콜드월렛, 백업 시 BIP39 시드 문구 별도·오프라인 보관 확장성: 온체인 한계와 오프체인/Layer2 온체인 한계: 블록 크기·주기 제약 → TPS 제한, 탈중앙화·보안·확장성(블록체인 트릴레마) 간 트레이드오프 존재\n오프체인 결제(라이트닝 네트워크)\n양자 간 결제 채널 열고 다수 거래를 오프체인 처리, 최종 상태만 온체인 정산 핵심 메커니즘: 타임락, 페널티 트랜잭션, 경로 탐색 장점: 속도·수수료 우수 / 과제: UX·유동성·라우팅 Rollup(이더리움 L2)\nOptimistic Rollup: 사기 증명 기반, 이의제기 기간 후 확정 ZK Rollup: 영지식 증명 기반, 검증 빠름(증명 생성 비용·지연 고려) 데이터 가용성(DA): L1에 핵심 데이터 또는 블롭(EIP-4844) 으로 게시 → L2 상태 재구성 가능성 확보 로드맵: 프로토-덴크샤딩(EIP-4844) → 데이터 비용 절감, 장기적으론 완전 덴크샤딩으로 확장성 개선 MEV \u0026amp; PBS(이더리움)\nMEV: 거래 재배치·추출을 통한 가치 → 사용성·공정성 이슈 PBS: 제안자/빌더 분리로 역할 분담, 중앙화·검열 리스크 완화 시도 실무 체크리스트(운영·보안·개발) 노드 운영\n최신 클라이언트·보안 패치 적용, 피어 다변화 모니터링: 블록 지연, reorg, mempool 혼잡, 디스크/네트워크 지표 지갑·키 관리\n하드웨어 지갑·멀티시그·콜드스토리지 적용 시드 백업(오프라인), 접근 통제(2인 승인 등) 스마트 컨트랙트(이더리움)\n감사(Audit)·포멀 검증·테스트넷 충분 운용 가스 최적화: 저장소 쓰기 최소화, 재진입·정수 오버플로 방지, 최신 컴파일러 사용 업그레이드 전략: 프록시 패턴·권한 관리(Owner/Role)·타임락 수수료 전략\nBitcoin: sat/vByte 동적 설정, 급행·보통·저속 정책 분리 Ethereum: EIP-1559의 maxFeePerGas/maxPriorityFeePerGas 합리 설정 포크·네트워크 이벤트 대응\n공지 수집, 송금 동결/완화 기준, 고객 안내 시나리오 준비 간단 비교 표 항목 비트코인(PoW) 이더리움(PoS, Merge 이후) 블록 간격 ~10분 슬롯 ~12초(에폭=32 슬롯) 최종성 확률적(확인수↑) 체크포인트 최종성(정상 시 2 에폭 내외) 수수료 바이트 기준(sat/vByte) EIP-1559(BaseFee 소각 + Tip) 상태 모델 UTXO 계정 + 스마트 컨트랙트 확장성 방향 SegWit·Taproot·Lightning Rollup(Optimistic/ZK) + EIP-4844 자주 틀리는 포인트 “이더리움은 N 블록이면 안전” → (X) 현재는 파이널리티 달성 여부로 판단하는 게 정확함 “PoS는 그냥 코인 많이 가진 사람 승리” → (X) 무작위성·메시지 투표·슬래싱·최종성 규칙이 결합된 프로토콜 전체가 보안 근거임 “SegWit은 리플레이 공격 방지” → (부분 부정확) 핵심 목적은 트랜잭션 가변성(malleability) 해결 및 용량 효율화임 결론 블록체인은 암호학(해시·서명), 분산합의(PoW/PoS), 네트워크 설계가 맞물린 시스템임 설계 선택(PoW vs PoS, UTXO vs 계정, 온체인 vs 오프체인)이 보안·성능·분산화에 직접 영향 실무 핵심은 키 관리·노드 보안·포크/이벤트 대응·수수료 전략·컨트랙트 품질 보증임 확장성은 Layer2 + 데이터 가용성 + 프로토콜 개선을 병행하는 다층 해법이 현실적임 참고자료 비트코인 개요: https://bitcoin.org/ko/how-it-works 비트코인 개발자 가이드(데이터 구조·프로토콜): https://developer.bitcoin.org/devguide/ 이더리움 화이트페이퍼: https://ethereum.org/en/whitepaper/ 이더리움 PoS/합의 문서: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ EIP-1559(수수료 시장): https://eips.ethereum.org/EIPS/eip-1559 EIP-4844(프로토-덴크샤딩/블롭): https://eips.ethereum.org/EIPS/eip-4844 Lightning BOLT 사양: https://github.com/lightning/bolts SegWit 개요(트랜잭션 가변성 개선): https://bitcoinops.org/en/topics/segwit/ ","permalink":"https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인은 \u003cstrong\u003e중앙 기관 없이\u003c/strong\u003e 참여자들이 거래를 기록·검증·공유하는 \u003cstrong\u003e분산 원장\u003c/strong\u003e 기술임\n이 글은 블록체인을 \u003cstrong\u003e초보자 친화적으로\u003c/strong\u003e 설명하고, \u003cstrong\u003e실무 체크리스트\u003c/strong\u003e까지 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"큰-그림-시스템-구성\"\u003e큰 그림: 시스템 구성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e노드(Node)\u003c/strong\u003e: 블록체인 소프트웨어 실행 주체\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e풀노드\u003c/strong\u003e: 모든 블록·트랜잭션 검증·저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트 클라이언트\u003c/strong\u003e: 헤더·머클 증명 기반 최소 검증\u003c/li\u003e\n\u003cli\u003e(참고) \u003cstrong\u003e아카이브 노드\u003c/strong\u003e: 오래된 상태 포함 전체 상태 유지(필수 아님)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e블록(Block)\u003c/strong\u003e: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e합의(Consensus)\u003c/strong\u003e: 어떤 블록이 정식 이력인지 네트워크가 \u003cstrong\u003e공동으로\u003c/strong\u003e 결정하는 규칙\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoW: 작업증명(연산 경쟁)\u003c/li\u003e\n\u003cli\u003ePoS: 지분증명(검증자·보증금 기반)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해시hash와-위변조-방지\"\u003e해시(Hash)와 위·변조 방지\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 함수(SHA-256, Keccak-256 등)\u003c/strong\u003e: 입력을 고정 길이로 압축하는 일방향 함수임\u003c/p\u003e","title":"블록체인이란? 블록체인 개념 총정리"},{"content":"개요 스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음 블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림 이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\n문제 정의와 영향 배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함 예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식 가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가 공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음 RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임 핵심 개념과 대안 1) 매핑으로 존재 여부 O(1) 검사 저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\nmapping(address =\u0026gt; bool) public users; function register(address user) public { require(!users[user], \u0026#34;already registered\u0026#34;); users[user] = true; } 장점 고정 비용으로 존재 확인이 가능 주의 매핑은 온체인 열거 불가이므로 조회 인덱스는 별도로 설계해야 함\n2) 배열 + 매핑 병행 패턴 배열에 값, 매핑에 인덱스 정보를 저장해 추가·삭제·조회 O(1) 과 열거 가능을 동시에 달성함 삭제는 스왑 후 pop으로 상수 시간 처리함\n간단 라이브러리 예시\n// 24줄 예시 라이브러리 library AddressSet { struct Set { address[] _list; mapping(address =\u0026gt; uint256) _index; } function contains(Set storage s, address a) internal view returns (bool) { return s._index[a] != 0; } function add(Set storage s, address a) internal returns (bool) { if (contains(s, a)) return false; s._list.push(a); s._index[a] = s._list.length; return true; } function remove(Set storage s, address a) internal returns (bool) { uint256 i = s._index[a]; if (i == 0) return false; uint256 li = s._list.length; address last = s._list[li - 1]; s._list[i - 1] = last; s._index[last] = i; s._list.pop(); delete s._index[a]; return true; } function length(Set storage s) internal view returns (uint256) { return s._list.length; } function at(Set storage s, uint256 i) internal view returns (address) { return s._list[i]; } } 3) 루프 상한이 명확한 배치 패턴 무제한 루프가 아니라 상한이 보장된 반복만 허용하고 나머지는 다음 호출로 미룸 예 require(batch.length \u0026lt;= MAX_BATCH) 와 체크포인트 저장\n4) 온체인 최소화·오프체인 인덱싱 상태 변경만 온체인에 기록하고 열거·검색은 이벤트 기반 인덱서에 위임함 The Graph 같은 인덱서 또는 백엔드 DB를 사용해 조회 성능을 확보함\n5) 푸시 대신 풀 패턴 N명에게 한 번에 분배하는 푸시 루프 대신 각 수령자가 claim으로 가져가게 해 루프를 제거함 머클 드롭처럼 증명 기반 청구를 쓰면 대량 분배에서도 O(1) per user 달성 가능\n동작 원리 상세 배열 + 매핑 배열에 값 저장, 매핑에 값 → 배열 인덱스+1 저장으로 0을 미존재로 활용 삭제 시 타깃 인덱스에 마지막 요소를 스왑하고 pop, 스왑된 요소의 인덱스를 갱신 삽입·삭제·존재 확인이 모두 상수 시간으로 동작하며 length·at로 열거 가능 실무 포인트 주의·한계·베스트 프랙티스 금기는 무제한 반복이며 루프 자체 금지는 아님 반복의 상한이 코드로 보장되면 안전하게 사용할 수 있음 매핑은 열거가 불가 온체인 열거가 필요하면 배열을 병행하거나 이벤트 인덱싱을 설계함 배열+매핑 병행은 상태 동기화가 생명 삽입·삭제마다 두 구조를 함께 갱신하고 실패 시 일관성 유지를 보장해야 함 대량 작업은 오프체인에서 사전 계산하고 온체인에는 커밋·증명만 올림 함수는 최악 케이스 가스 기준으로 설계하고 배포 전 시뮬레이션으로 수렴 여부를 확인함 관리자 권한으로 아카이빙·프루닝을 허용하면 장기적으로 가스 추세를 안정화할 수 있음 검증된 구현 사용을 우선 고려 OpenZeppelin EnumerableSet 같은 표준 라이브러리는 경계 사례가 잘 다듬어져 있음 추가 최적화 팁 가스·안정성 SSTORE 비용 상식 신규 슬롯 기록은 매우 비싸고 기존 값 업데이트가 상대적으로 저렴하며 가스 환급은 최근 제안들로 크게 축소됨 많은 슬롯을 자주 비우는 설계는 기대만큼 환급이 일어나지 않을 수 있음 콜드·웜 접근 처음 접근하는 저장소·계정은 콜드 비용이 높고 같은 트랜잭션 내 재접근은 웜으로 저렴해짐 같은 키를 여러 번 읽는다면 한 번 읽어 메모리에 캐시하고 사용함 데이터 모델 집합이 ID 기반이면 mapping(uint256 =\u0026gt; uint256) 비트맵으로 압축해 SSTORE 개수를 줄일 수 있음 루프 미세 최적화 상한이 작은 루프에서 unchecked { ++i } 로 증가 비용을 절감할 수 있으나 오버플로 안전성을 스스로 보장해야 함 외부 호출은 풀 패턴 루프 안에서 외부 호출을 하지 말고 사용자가 개별 청구하는 풀 모델로 전환해 재진입·가스 폭탄 리스크를 줄임 EIP‑2930 접근 리스트 가스 민감 트랜잭션은 Access List로 콜드 비용을 일부 완화하는 방식을 검토함 간단한 설계 대안 조회 전용 인덱스 오프체인 위임 온체인은 상태 변경과 이벤트만 발행 페이지네이션 제공 한 호출당 처리량을 제한해 UX와 가스 안정성을 동시에 확보 상한·쿼터·할당량 도입 최대 원소 수나 1회 배치 한도를 프로토콜 상수로 명시하고 초과 시 아카이빙 트리거 검증과 회귀 방지 가스 예산 테스트 최대 예상 n에 대해 단위·통합 테스트로 가스 사용량을 프로파일링 일관성 테스트 배열·매핑 동기화가 항상 유지되는지 경계 케이스로 검증 모니터링 트랜잭션 실패율, 가스 사용 추세, out of gas 류 에러 알람을 운영 대시보드에 포함 프로퍼티 기반 테스트 삽입·삭제·재삽입을 무작위 시퀀스로 실행해 인버리언트를 검증 감사 체크리스트 사용자 입력에 의해 루프 길이가 통제 불가한 경로가 있는지 외부 호출이 루프 내부에 존재하는지 반복 상한을 보장하는 require 검사가 있는지 로컬 캐시 없이 동일 SLOAD를 반복하는지 상태 구조가 장기적으로 가스가 비단조 증가하도록 설계됐는지 실패 시 롤백으로 상태 일관성이 유지되는지 마무리 스마트 컨트랙트의 O(n) 루프는 단순한 비효율이 아니라 운영 불능으로 연결될 수 있는 위험 요소임 매핑과 배열+매핑 패턴으로 상수 시간 검사를 확보하고, 배치·풀·오프체인 인덱싱을 결합해 열거와 성능을 균형 있게 달성할 것 배포 전에는 최악 케이스 가스를 기준으로 테스트하고, 배포 후에는 모니터링과 프루닝 정책으로 장기 안정성을 유지할 것\n참고자료 OpenZeppelin EnumerableSet https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol EIP‑2929 Gas cost increases for state access https://eips.ethereum.org/EIPS/eip-2929 EIP‑3529 Reduction in refunds https://eips.ethereum.org/EIPS/eip-3529 The Graph 문서 인덱싱 개요 https://thegraph.com/docs MerkleProof 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography ","permalink":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 \u003cstrong\u003e실행 불가\u003c/strong\u003e로 이어질 수 있음\n블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 \u003cstrong\u003e가스 한도 초과\u003c/strong\u003e를 일으켜 서비스 가용성을 떨어뜨림\n이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"문제-정의와-영향\"\u003e문제 정의와 영향\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함\n예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식\u003c/li\u003e\n\u003cli\u003e가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가\u003c/li\u003e\n\u003cli\u003e공격자가 \u003cstrong\u003e가스 그리핑\u003c/strong\u003e을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 \u003cstrong\u003eDoS\u003c/strong\u003e가 될 수 있음\u003c/li\u003e\n\u003cli\u003eRPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 \u003cstrong\u003e미포함·리버트\u003c/strong\u003e임\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-대안\"\u003e핵심 개념과 대안\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e1) 매핑으로 존재 여부 O(1) 검사\u003c/strong\u003e\n저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\u003c/p\u003e","title":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"},{"content":"개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\n쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\n이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\n1. 핵심 용어 정리 오프체인 서명 (Off-chain Signature) 블록체인 외부(주로 백엔드 서버)에서 생성된 디지털 서명을 의미함 이 방식은 서명을 생성하는 과정에서 가스비가 들지 않고, 서버의 다양한 로직과 결합할 수 있는 장점이 있음\n메타 트랜잭션 (Meta-transaction) 사용자가 가스비를 직접 내지 않고, 트랜잭션에 대한 의도만 \u0026lsquo;서명\u0026rsquo;으로 표현하면, 제3의 대리인(Relayer)이 이를 대신 실행하고 수수료를 지불하는 패턴임 오프체인 서명은 이 메타 트랜잭션을 구현하는 핵심 기술임\n가스리스 트랜잭션 (Gasless Transaction) 메타 트랜잭션을 통해 사용자가 느끼기에 가스비 없이 트랜잭션을 처리하는 경험을 의미함 서비스 제공자가 페이마스터 등을 통해 가스비를 대납함으로써 구현됨\nEIP-712 단순 문자열이 아닌, 구조화된 데이터에 대한 서명 표준임 이 표준을 사용하면 사용자가 자신이 무엇에 서명하는지 명확히 알 수 있으며, 다른 체인이나 다른 컨트랙트에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지할 수 있어 보안성이 매우 높음\n2. 오프체인 서명 검증의 전체 흐름 서버, 사용자, 그리고 컨트랙트 간의 상호작용은 다음과 같은 단계로 이루어짐\n사용자 요청 사용자의 클라이언트(웹/앱)는 트랜잭션을 바로 블록체인에 보내는 대신, 트랜잭션에 필요한 정보들을 백엔드 서버에 API 요청으로 보냄\n서버 검증 및 서명 서버는 요청이 유효한지 검증함 (예: 우리 서비스의 정식 사용자인가? 요청 내용이 합당한가?) 검증이 완료되면, 서버는 EIP-712 표준에 따라 트랜잭션 파라미터가 담긴 메시지를 만들고, 서버의 개인키로 이 메시지에 서명함\n사용자 트랜잭션 제출 서버는 생성된 서명(signature)과 관련 데이터들을 사용자에게 다시 응답으로 보내줌 사용자의 클라이언트는 이 서명 데이터를 포함하여 트랜잭션를 구성하고, 최종적으로 블록체인(스마트 컨트랙트)에 제출함\n컨트랙트 검증 스마트 컨트랙트는 제출된 트랜잭션을 받아 서명이 유효한지 검증함 검증에 성공하면, 컨트랙트는 약속된 작업을 수행함 (예: 가스비 대납, 아이템 지급 등)\n3. 핵심 원리: 컨트랙트의 서명 검증 과정 컨트랙트는 서버의 개인키를 모르는데, 어떻게 서버가 서명했다는 것을 신뢰할 수 있을까? 이 과정은 암호학적 원리를 이용해 세 단계로 진행됨\n1단계: 데이터 해시(Hash) 재구성 컨트랙트는 사용자가 제출한 파라미터들(userAddress, expiryTimestamp 등)을 받아, 서버가 서명을 생성했을 때와 완벽히 동일한 구조와 순서로 이 데이터들을 조합하여 해시(hash) 값을 다시 계산함\n이때 EIP-712 표준에 따라 컨트랙트의 이름, 버전, 체인 ID 등이 포함된 도메인 분리자(Domain Separator)가 해시와 함께 사용되어 다른 컨트랙트에서 서명이 재사용되는 것을 막음\n// 1. 전달받은 파라미터로 해시 재계산 bytes32 hash = keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice )); bytes32 digest = hashTypedDataV4(hash); // 도메인 분리자와 결합 2단계: 서명자 주소 복원 ecrecover라는 암호학적 함수는 메시지 해시(digest)와 서명값(signature), 이 두 가지를 입력받아 해당 서명을 만들 수 있는 유일한 공개키, 즉 서명자의 주소를 역으로 계산해냄 이 과정에서 서버의 개인키는 절대 노출되지 않음\n// 2. 서명에서 주소 복원 address recoveredAddress = digest.recover(signature); 3단계: 서명자 주소 비교 마지막으로, 2단계에서 복원된 주소가 스마트 컨트랙트에 미리 저장된 신뢰할 수 있는 서버의 주소(signer)와 일치하는지 비교함 두 주소가 일치한다면, 이 서명은 우리가 신뢰하는 서버가 생성한 유효한 서명임이 증명된 것임\n// 3. 복원된 주소가 signer와 일치하는지 확인 require(signer == recoveredAddress, \u0026#34;Paymaster: Invalid signer\u0026#34;); 4. 데이터 무결성: 서명된 데이터는 어떻게 신뢰하는가? \u0026ldquo;만약 사용자가 유효한 서명을 받은 뒤, 파라미터 값만 몰래 바꿔서 제출하면 어떡하지?\u0026rdquo; 결론부터 말하면, 불가능함\n서명 검증 과정 자체가 데이터의 무결성을 보장하기 때문임 만약 사용자가 파라미터를 1비트라도 변경하면, 1단계에서 재구성되는 해시값이 원래의 해시값과 완전히 달라짐 결과적으로 2단계에서 주소 복원에 실패하거나 엉뚱한 주소를 반환하게 되어, 3단계의 주소 비교에서 반드시 실패하게 됨\n이처럼, 서명은 데이터의 해시와 한 쌍으로 묶여있기 때문에 데이터가 조금이라도 변조되면 서명은 즉시 무효가 됨 이 원리 덕분에 우리는 데이터가 서버가 승인한 원본 그대로임을 신뢰할 수 있음\n마무리 오프체인 서명 검증은 온체인의 신뢰성과 오프체인의 유연성을 결합한 강력한 패턴임 이를 통해 가스비 소모 없이 복잡한 비즈니스 로직을 온체인 시스템에 안전하게 적용할 수 있음 서명 검증 과정 자체가 데이터의 무결성과 서명자의 신뢰성을 동시에 보장하므로, 다양한 분야에서 보안성과 효율성을 높이는 데 활용될 수 있음\n","permalink":"https://handsupmin.github.io/posts/off-chain-signature-verification-542a33/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음\n이때 \u003cstrong\u003e오프체인 서명 검증\u003c/strong\u003e(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\u003c/p\u003e\n\u003cp\u003e쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음\n가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\u003c/p\u003e\n\u003cp\u003e이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\u003c/p\u003e","title":"오프체인 서명 검증(Off-chain Signature Verification)이란?"},{"content":"개요 재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임 목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음\n왜 필요한가 트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함 재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함 롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림 핵심 개념 내부 증명 Inner proofs 원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\n합성 회로 Aggregator 이전 단계 증명들의 검증 로직을 회로로 구현하고 그 결과가 참임을 나타내는 새 증명을 생성\n최종 증명 Outer proof 여러 단계를 거쳐 하나로 압축된 최상위 증명 온체인은 이 증명 하나만 확인하면 전체 집합의 유효성을 신뢰할 수 있음\n공개 입력 바인딩 Public input binding 어떤 증명들을 합쳤는지, 어떤 데이터 루트에 대해 성립하는지 루트 커밋·메타데이터를 공개 입력에 포함해 무결성을 보장함\n동작 흐름 개별 증명 생성 L2에서 트랜잭션 또는 배치 단위로 증명 생성 1차 합성 합성 회로가 증명 A, B를 회로 내부에서 검증하고 A∧B가 참임을 증명 반복 합성 결과들을 다시 쌍으로 묶어 트리 형태로 합성해 증명 개수를 절반씩 축소 최종 합성 1개 증명으로 수렴 온체인 검증 L1은 최종 증명 1개만 검증해 전체 유효성에 도달 직관은 증명을 검증하는 회로에 대해 다시 증명을 만든다는 생각으로 이해하면 됨\n설계 선택지와 트레이드오프 증명 시스템 선택\nGroth16 on BN254 검증이 빠르고 EVM 프리컴파일 지원이 좋아 온체인 비용이 낮은 편이나 회로 변경 시 신뢰 설정이 필요하고 공개 입력 크기에 민감함 PLONK류 KZG 커밋 유연한 회로 합성과 대규모 회로에 적합하나 온체인 검증은 곡선·프리컴파일 제약을 받음 Halo2·IPA 계열 신뢰 설정 없이 동일 곡선 내 재귀가 용이해 깊은 재귀에 유리하나 구현 난이도와 상수 계수가 큼 Nova·SuperNova 폴딩 스킴 증명 크기와 재귀 성능이 우수하고 스트리밍 합성에 적합하나 온체인 검증 경로는 추가 압축 단계가 필요한 설계가 일반적임 곡선 전략\n페어링 재귀는 보통 곡선 사이클 MNT4/6, BLS12‑377 ↔ BW6‑761 등을 활용하거나 서로 다른 곡선 간 검증기를 회로화함 EVM에서 직접 검증할 최종 증명은 BN254 프리컴파일을 활용하는 구성이 실무적으로 유리함 집계 토폴로지\n이진 트리 단순하고 지연 균형이 좋음 k‑ary 트리 폭을 늘려 재귀 깊이를 더 줄이되 각 단계 회로가 커짐 스트리밍 합성 입력이 도착하는 대로 누적하는 PCD·폴딩 기반 경로가 실시간 파이프라인에 유리함 정확성·사운드니스 포인트 공개 입력 바인딩 합성 대상 집합을 명확히 커밋 머클 루트·배치 루트·VK 해시 등으로 고정해 혼합 공격을 차단함\n검증기 회로의 완전성 내부 검증 로직은 검증 키 VK와 증명 π의 결합을 정확히 구현해야 함 VK 해시를 공개 입력에 포함해 검증 키 스와핑을 방지함\n도메인 분리와 RNG 각 재귀 단계의 트랜스크립트 도메인을 분리해 Fiat‑Shamir 충돌을 방지함\n사운드니스 누수 관리 여러 단계 합성 시 오류 누적을 고려해 보안 파라미터를 충분히 잡고, 필요 시 최종 단계에서 재압축 증명으로 마무리함\n온체인 검증과 가스 감각 이더리움 메인넷은 BN254 페어링 프리컴파일 EIP‑196/197을 제공하므로 Groth16 BN254 최종 증명 검증이 일반적으로 가장 경제적임 BLS12‑381 프리컴파일은 메인넷에 기본 탑재되어 있지 않으므로 해당 곡선 기반 증명은 직접 검증 비용이 큼 실무 감각으로 단일 Groth16 검증은 수십만 가스 수준이며 다수 증명을 개별 검증하는 것 대비 재귀 한 번으로 크게 절감 가능함 L2에서는 프리컴파일·유효성 브릿지 정책이 다를 수 있으므로 대상 체인의 가스 모델과 프리미티브를 우선 확인 필요함 합성 스케줄 예시 코드 스니펫 # n개의 내부 증명을 이진 트리로 재귀 합성하는 스케줄 개념 예시 def aggregate(proofs): level = proofs while len(level) \u0026gt; 1: nxt = [] for i in range(0, len(level), 2): a = level[i] b = level[i+1] if i+1 \u0026lt; len(level) else level[i] nxt.append(prove_verify(a, b)) # \u0026#34;a와 b를 검증하는 회로\u0026#34;에 대한 새 증명 생성 level = nxt return level[0] # 최종 증명 위 스니펫은 구조 설명용이며 실제 구현은 증명 시스템·곡선·검증기 회로에 따라 상이함\n운영 가드레일과 파이프라인 배치 크기 캡 증명 생성기 큐 길이와 메모리를 감안해 단계별 최대 입력을 제한 타임아웃·재시도 각 단계별 SLA를 두고 실패 시 병렬 재스케줄 또는 부분 재구성 적용 관측성 TTI 포함 지연, TTP 증명 생성 지연, TTF 최종성 도달 시간, 실패율, 메모리 피크를 모니터링 키·파라미터 롤오버 VK·SRS 교체 절차를 정의하고 공개 입력에 버전을 바인딩 테스트·검증 체크리스트 재귀 깊이 스윕 1→2→4→… 단계별로 증명 시간·메모리·최종 증명 크기 프로파일링 경계 케이스 빈 배치, 1개 배치, 홀수 개 입력, 순서 섞임, 공개 입력 미스매치, VK 변경 등 실패 경로 검증 스냅샷·해시 고정 동일 입력 집합에 대해 루트와 최종 증명이 안정적으로 재현되는지 확인 온체인 리허설 가스 한도와 calldata 한도를 기준으로 최종 증명 크기와 검증 호출이 수렴하는지 점검 Aggregation vs Recursion vs Batching Aggregation 여러 증명을 함께 검증하도록 한 번에 묶는 기법으로 비재귀적 접근까지 포함해 쓰이는 넓은 용어 Recursion 검증기를 회로화하고 그에 대한 또 다른 증명을 생성하는 계층적 접근 Batching 입력을 모아 처리하는 운영 기법으로 재귀·집계와 결합하면 시너지가 큼 활용 시나리오 롤업 L2에서 다수 배치 증명을 합성해 L1에 최종 1개 증명만 제출 프라이버시 애플리케이션 여러 단계 정책 만족을 하나의 최종 증명으로 제시 데이터 가용성·보관 증명 여러 청크 검증을 합성해 단일 확인 단계로 축소 언제 재귀를 쓰지 말지 내부 증명 수가 적고 온체인에서 직접 검증해도 가스 절감 효과가 미미한 경우 지연 민감 워크로드에서 재귀 단계가 P99 지연을 악화시키는 경우 증명 시스템 이질성으로 회로 복잡도가 과도하게 커지는 경우 마무리 재귀적 ZKP의 본질은 증명을 다시 증명해 검증 부담을 한 점으로 수렴시키는 데 있음 실전에서는 증명 시스템·곡선·집계 토폴로지·가스 모델을 함께 설계하고, 공개 입력 바인딩·검증기 회로의 완전성·도메인 분리로 사운드니스를 확보하는 것이 핵심임 목표 TPS·지연·오프체인 리소스·온체인 가스 정책을 기준으로 배치와 재귀 깊이를 조율하면 비용과 안정성을 동시에 달성할 수 있음\n참고자료 EIP‑196 BN128 Curve Addition and Scalar Multiplication https://eips.ethereum.org/EIPS/eip-196 EIP‑197 BN128 Pairing https://eips.ethereum.org/EIPS/eip-197 Halo2 Book https://zcash.github.io/halo2 Nova Recursive Arguments https://eprint.iacr.org/2021/370 SuperNova https://eprint.iacr.org/2022/1758 SnarkPack Practical SNARK Aggregation https://eprint.iacr.org/2021/529 Plonky2 Fast Recursive Proofs https://github.com/mir-protocol/plonky2 ","permalink":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 \u003cstrong\u003e계층적으로 합성\u003c/strong\u003e해 \u003cstrong\u003e단일 증명\u003c/strong\u003e으로 만드는 기법임\n목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 \u003cstrong\u003e검증 비용을 상수 수준으로 수렴\u003c/strong\u003e시키는 데 있음\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"왜-필요한가\"\u003e왜 필요한가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e트랜잭션 단위로 개별 증명을 온체인 검증하면 \u003cstrong\u003e검증 비용이 선형 증가\u003c/strong\u003e함\u003c/li\u003e\n\u003cli\u003e재귀를 쓰면 n개의 증명을 \u003cstrong\u003e트리 형태로 합성\u003c/strong\u003e해 \u003cstrong\u003e한 번의 최종 검증\u003c/strong\u003e으로 대체 가능함\u003c/li\u003e\n\u003cli\u003e롤업·배치 처리·프라이버시 워크로드에서 \u003cstrong\u003e확장성\u003c/strong\u003e과 \u003cstrong\u003e최종성 지연 단축\u003c/strong\u003e을 동시에 노림\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e내부 증명 Inner proofs\u003c/strong\u003e\n원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\u003c/p\u003e","title":"재귀적 영지식 증명이란? (Recursion ZKP)"},{"content":"개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\nzkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\n문제 정의: 단순 설계 페이마스터의 명확한 한계 가장 먼저 검토한 toAddressPaymaster는 특정 컨트랙트로 향하는 트랜잭션의 가스비만 대납해주는 단순한 모델임. 하지만 이 방식은 두 가지 치명적인 허점을 가짐\n의도치 않은 트랜잭션 허용: 신규 사용자에게 지갑을 만들어주는 AccountFactory 컨트랙트 주소를 페이마스터에 등록할 경우, 우리 서비스와 무관한 모든 사용자가 이 팩토리를 사용할 때 발생하는 가스비를 우리가 전부 대납하게 됨. 페이마스터가 의도치 않게 공공재가 되어버리는 상황\n가스비 소모 공격에 취약: gasLimit을 검증하는 로직이 없어, 악의적 사용자가 가스비를 비정상적으로 높게 책정해 트랜잭션 한 번으로 페이마스터의 모든 자금을 고갈시킬 수 있는 위험이 존재함\n결론적으로 우리가 허용한 사용자가 우리가 의도한 작업을 할 때 발생하는 합리적인 수준의 가스비만을 선별적으로 대납할 똑똑한 방법이 필요했음\n해결의 실마리: Off-chain Signature Verification 이 문제의 해결책으로 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 도입하기로 결정함\n이 패턴은 블록체인 외부(서버)에서 생성된 디지털 서명을 블록체인 위(스마트 컨트랙트)에서 검증하는 방식임. 즉, 가스비 대납 여부를 컨트랙트가 단독으로 결정하는 게 아니라, 우리가 통제하는 서버의 \u0026lsquo;허가\u0026rsquo;를 받아 결정하게 만드는 것\n이 과정에서 다음과 같은 주요 개념들이 활용됨\n메타 트랜잭션(Meta-transaction): 사용자가 직접 트랜잭션을 생성하고 가스비를 지불하는 대신, 트랜잭션의 내용이 될 데이터에 서명만 함. 그러면 이 서명을 받은 대리인(Relayer)이 실제 트랜잭션으로 만들어 수수료를 대신 내고 블록체인에 제출하는 패턴. 우리가 구현할 페이마스터는 zkSync 시스템이 릴레이어 역할을 해주는 메타 트랜잭션의 일종임\nEIP-712: 단순 텍스트가 아닌, json처럼 구조화된 데이터에 대한 서명 표준. 사용자가 무엇에 서명하는지 명확히 인지할 수 있고, 다른 컨트랙트나 체인에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지하는 도메인 분리(Domain Separator) 기능을 포함하고 있어 페이마스터 서명에 필수적임\n구현 과정: 서명 기반 페이마스터 설계 및 개발 전체 흐름은 서버의 서명 생성(Off-chain)과 컨트랙트의 서명 검증(On-chain) 두 단계로 나뉨\n1. 서버 (Off-chain): 서명 생성 단계 사용자가 트랜잭션을 실행하기 직전, 클라이언트는 트랜잭션 데이터를 백엔드 서버로 전송함. 서버는 다음 절차를 수행\n요청 검증: 요청을 보낸 사용자가 우리 서비스의 유효한 사용자인지, 트랜잭션 내용이 비즈니스 로직에 부합하는지 등을 검증\n가스비 추정 및 파라미터 설정: 트랜잭션에 필요한 가스비를 추정하고, 여기에 약간의 버퍼를 더해 recommendedGasLimit과 recommendedGasPrice를 결정. 서명이 유효할 시간(expiryTimestamp)도 설정함\nEIP-712 서명 생성: 검증된 파라미터들을 바탕으로 EIP-712 표준에 따라 구조화된 데이터를 만들고, 서버만 안전하게 보관하고 있는 개인키로 이 데이터에 서명함\n// 서버에서 EIP-712 타입에 맞춰 서명할 데이터를 구성 const domain = { name: \u0026#34;SignatureBasedPaymaster\u0026#34;, version: \u0026#34;1\u0026#34;, chainId: chainId, verifyingContract: PAYMASTER_ADDRESS }; const types = { SignatureBasedPaymaster: [ { name: \u0026#39;userAddress\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;expiryTimestamp\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasLimit\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasPrice\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] }; const value = { /* userAddress, expiryTimestamp 등 실제 값 */ }; // 서버의 개인키로 서명 생성 const signature = await signerWallet.signTypedData(domain, types, value); 이 서명값과 관련 파라미터들을 클라이언트에 반환하면, 클라이언트는 이 데이터를 트랜잭션과 함께 zkSync 네트워크로 전송함\n2. 컨트랙트 (On-chain): 서명 검증 단계 사용자의 트랜잭션은 zkSync 부트로더(Bootloader)를 통해 페이마스터 컨트랙트의 validateAndPayForPaymasterTransaction 함수를 호출함. 이 함수는 서명 검증의 핵심임\n데이터 재구성: 트랜잭션에 포함된 userAddress, expiryTimestamp, recommendedGasLimit 등의 파라미터를 가져와 서버가 서명했던 것과 완벽히 동일한 구조와 순서로 해시(hash)를 다시 만듦\n서명자 복원: 재구성한 해시와 트랜잭션에 포함된 서명(signature)을 이용해 암호학적 함수(ecrecover)를 호출. 이를 통해 이 서명을 생성한 주소를 역으로 계산해냄\n서명자 검증: 복원된 주소가 컨트랙트에 미리 저장해 둔 우리 서버의 주소(signer)와 일치하는지 확인. 일치해야만 서버가 허가한 유효한 요청으로 간주함\n만약 누군가 서버로부터 받은 서명을 그대로 두고 파라미터(ex: 가스비)를 변경하려 시도하면, 1번 단계에서 생성되는 해시값이 달라져 3번 검증 단계에서 실패하게 됨. 이를 통해 데이터의 무결성과 서명자의 신뢰성을 동시에 확보함\n// 1. 서버가 서명했을 데이터의 해시를 컨트랙트에서 동일하게 재구성 bytes32 digest = hashTypedDataV4(keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice ))); // 2. 서명과 재구성된 해시를 사용해 서명자 주소를 복원 address recoveredSigner = digest.recover(signature); // 3. 복원된 주소가 우리가 신뢰하는 서버의 주소(signer)와 일치하는지 확인 require( signer == recoveredSigner, \u0026#34;Paymaster: Invalid signer\u0026#34; ); // ... 검증 통과 후 가스비 대납 로직 실행 결론 및 회고 zkSync의 페이마스터는 사용자의 가스비를 대신 지불하는 기능을 손쉽게 구현할 수 있는 강력한 기반을 제공함 개발자는 이를 통해 사용자의 진입 장벽을 낮추고 UX를 크게 개선할 수 있음\n하지만 여기에 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 결합함으로써, 단순한 가스비 대납을 넘어 정교한 권한 제어가 가능해짐 서버에서 각 요청을 사전에 검증하고 서명을 발급하는 방식은 다음과 같은 명확한 이점을 가져왔음\n운영 안정성: 누가, 언제, 어떤 트랜잭션의 가스비를 지원받을지 서버단에서 유연하게 제어할 수 있어, 무분별한 비용 소모를 막고 예측 가능한 운영이 가능\n보안 강화: 허가된 주체만이 서명을 통해 가스비를 사용할 수 있으므로, 초기 모델의 가장 큰 문제였던 자금 고갈 공격과 의도치 않은 트랜잭션 허용을 원천적으로 차단할 수 있었음\n결론적으로, zkSync의 편리한 온체인 기능과 서버의 오프체인 로직을 결합한 이 접근법은 보안과 운영 안정성을 모두 확보하는 효과적인 해결책이었음 이를 통해 시스템의 자산을 안전하게 보호하며 지속 가능한 서비스를 운영할 수 있는 견고한 토대를 마련하게 되었음\n","permalink":"https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 \u003cstrong\u003e가스비\u003c/strong\u003e(Gas Fee)임\n아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임\n이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 \u003cstrong\u003e가스리스 트랜잭션\u003c/strong\u003e(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\u003c/p\u003e\n\u003cp\u003ezkSync Era는 이를 위해 \u003cstrong\u003e페이마스터\u003c/strong\u003e(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\u003c/p\u003e","title":"안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)"},{"content":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026amp; 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u0026gt;\u0026gt;= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","permalink":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e머클트리는 블록체인에서 거래 집합을 \u003cstrong\u003e안전하고 효율적으로 요약·검증\u003c/strong\u003e하기 위해 쓰이는 핵심 자료구조임\n블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 \u003cstrong\u003e고정 크기 해시 하나\u003c/strong\u003e로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임\n이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-구조\"\u003e핵심 개념과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e머클트리는 보통 \u003cstrong\u003e이진 트리\u003c/strong\u003e 형태로 구현함\u003c/li\u003e\n\u003cli\u003e거래들을 \u003cstrong\u003e리프(leaf)\u003c/strong\u003e 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 \u003cstrong\u003e루트 해시\u003c/strong\u003e를 얻음\u003c/li\u003e\n\u003cli\u003e해시 함수는 체인별로 다르며 비트코인은 \u003cstrong\u003e더블 SHA‑256\u003c/strong\u003e, 이더리움은 트라이 구조에서 \u003cstrong\u003eKeccak‑256\u003c/strong\u003e 을 사용함\u003c/li\u003e\n\u003cli\u003e최상단 해시를 \u003cstrong\u003e머클루트(Merkle root)\u003c/strong\u003e 라 부르며 크기는 해시 함수에 따라 고정됨\u003c/li\u003e\n\u003cli\u003e리프 수가 홀수일 때는 마지막 리프를 \u003cstrong\u003e복제해 짝을 맞추는 방식\u003c/strong\u003e이 일반적이며 비트코인은 이 규칙을 사용함\u003c/li\u003e\n\u003cli\u003e트리 깊이는 리프 수 N에 대해 \u003cstrong\u003e⌈log₂ N⌉\u003c/strong\u003e 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-장점\"\u003e동작 원리와 장점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인접 노드 해시 \u003cstrong\u003eH_left || H_right\u003c/strong\u003e 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e무결성 검증\u003c/strong\u003e\n단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적 포함 증명\u003c/strong\u003e\n특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 \u003cstrong\u003e형제 해시들만\u003c/strong\u003e 있으면 됨\n필요한 해시 개수는 \u003cstrong\u003eO(log N)\u003c/strong\u003e 으로 작아 대역폭과 검증 비용이 작음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장성 보조\u003c/strong\u003e\n리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"블록-헤더와-경량-노드spv\"\u003e블록 헤더와 경량 노드(SPV)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함\u003c/li\u003e\n\u003cli\u003e경량 노드(SPV)는 \u003cstrong\u003e블록 전체가 아니라 헤더 체인만\u003c/strong\u003e 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 \u003cstrong\u003e머클 증명\u003c/strong\u003e 을 받아 포함 여부를 검증함\u003c/li\u003e\n\u003cli\u003e이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨\u003c/li\u003e\n\u003cli\u003e이더리움은 전통적인 이진 머클트리 대신 \u003cstrong\u003e머클‑패트리샤 트라이(MPT)\u003c/strong\u003e 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"구현-세부와-체인별-차이\"\u003e구현 세부와 체인별 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비트코인\u003c/strong\u003e\u003c/p\u003e","title":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"},{"content":"개요 이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함 개념 정의에 그치지 않고 운영 시 주의점, 보상·출금 흐름, 짧은 체인 재구성(Reorg) 원인과 완화책까지 다룸\n개념과 배경 PoS는 PoW의 에너지 경쟁을 대체해 예치된 지분을 바탕으로 검증자를 선정하는 합의 메커니즘임 이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 검증자 기반 보안 모델로 이행함\n주요 속성 요약\n에너지 소비 대폭 축소 스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨 위반 시 슬래싱과 페널티로 예치금이 감소함 계층 분리와 Beacon Chain의 역할 이더리움은 합의 계층(Beacon Chain) 과 실행 계층(Execution Layer) 를 분리해 설계함\n실행 계층은 트랜잭션 처리와 EVM 실행을 담당함 Beacon Chain은 시간 관리와 역할 배정, 투표 집계, 최종성 판단을 담당함 Beacon Chain의 핵심 기능\n슬롯과 에포크라는 통일된 시간 프레임 제공 매 슬롯의 블록 제안자와 증명자 배정 증명자 투표를 집계해 정당한 체인과 최종성을 결정함 이 분리는 클라이언트 다양성 확보와 확장 로드맵에 유리한 아키텍처 선택임\n시간 구조와 동작 단위 슬롯(slot)\n블록 제안이 가능한 최소 시간 단위 1 슬롯 = 12초 슬롯마다 1명의 제안자만 지정됨 제안자가 제때 블록을 제안하지 못하면 슬롯 미스로 간주하고 빈 슬롯이 될 수 있음 에포크(epoch)\n1 에포크 = 32 슬롯 ≈ 6분 24초 에포크 단위로 위원회 재편성, 랜덤 시드 갱신, 최종성 관련 집계가 이뤄짐 에포크는 체크포인트 역할을 하며 최종성 로직의 기준 단위로 사용됨 검증자와 스테이킹 규칙 최소 32 ETH를 예치해야 정식 검증자가 됨 한 검증자 계정에 반영되는 유효 예치 상한은 32 ETH임 더 많은 ETH를 운용하려면 32 ETH 단위로 여러 검증자를 운영해야 함 검증자 활성·비활성 전환에는 대기 큐와 지연이 존재함 보상 기회는 전체 검증자 대비 보유 검증자 수에 비례해 증가함 예를 들어 64 ETH로 두 검증자를 운영하면 제안·투표 참여 기회가 대략 두 배가 됨\n제안자(Proposer)와 증명자(Attester) 매 슬롯 한 명의 제안자가 블록을 제안함 다수의 증명자가 해당 블록에 대해 attestation 을 제출함 검증자들은 여러 위원회(committee) 로 무작위 배정되어 병렬로 검증을 수행함 집계된 투표는 포크 선택과 최종성 판단에 사용됨 위원회 구조의 목적은 검증 부담 분산 과 독립 다중 관측 을 통해 안전성과 처리량을 동시에 확보하는 것임\n무작위성과 검증자 배정 이더리움은 RANDAO 믹스 를 사용해 예측이 어렵고 조작에 강한 난수를 생성함 역사적으로 VRF나 VDF 같은 대안이 거론되었으나 현재 메인넷은 RANDAO 기반을 사용함 생성된 난수는 차기 에포크의 제안자·위원회 배정에 활용됨 특정 주체가 지속 우선 선정되는 편향을 줄이는 것이 목표임 포크 선택과 최종성 개요 포크 선택은 LMD‑GHOST 를 기반으로 하며 최신 메시지를 반영해 가장 무거운 서브트리를 선택함 짧은 지연으로 더 나은 블록을 선택하도록 proposer boost 가 도입되어 reorg 위험을 줄임 최종성은 Casper FFG 를 통해 에포크 수준 체크포인트를 정당화·최종화함 일정 이상 검증자 참여가 확보되면 체크포인트가 finalized 상태가 되어 경제적으로 되돌리기 매우 어려워짐 보상과 벌칙의 구조 보상 항목\n블록 제안 보상 제안자가 유효 블록을 포함할 때 수취 증명 보상 attestation을 정확하고 신속하게 제출한 검증자에게 지급 동기화 위원회 보상 라이트 클라이언트 지원을 위한 서명 참여 검증자에게 지급 벌칙과 슬래싱\n오프라인이나 지연 제출 등에는 경미한 페널티 가 부과됨 체인이 장기간 미파이널리티 상태에 빠지면 inactivity leak 이 발생해 페널티가 점진적으로 커짐 슬래싱 은 이중 제안 혹은 이중·감싸기 투표 같은 안전성 위반에 적용되며 금액과 네트워크 상황에 따라 손실이 커질 수 있음 동일 키를 여러 노드에서 가동하면 슬래싱 위험이 급증하므로 금지해야 함 보상 규모와 페널티는 전체 활성 예치 규모와 참여율 등 네트워크 상태에 따라 동적으로 변함\n출금과 인출 흐름 2023년 상반기 업그레이드 이후 출금 기능 이 활성화됨 부분 출금 은 32 ETH 초과분이 자동으로 실행 계층의 출금 주소로 전달됨 완전 출금 은 검증자가 정상 종료를 통해 활성 집합에서 빠진 뒤 전 잔액을 인출하는 흐름임 출금 처리는 블록당 포함 가능한 수가 제한되어 있어 대기 지연이 발생할 수 있음 출금 주소 유형과 자격 전환이 올바르게 설정되어 있어야 자동 처리가 가능함 운영 포인트\n출금 대기 시간과 큐 상태를 모니터링해 유동성을 관리함 출금 주소 관리 실수를 방지하기 위해 변경 절차를 문서화하고 검증 절차를 둠 Reorg가 발생하는 이유와 완화책 Reorg는 PoS에서도 짧은 길이 로 발생할 수 있음 주요 원인\n블록·attestation 전파 지연으로 노드 간 관측 차이가 발생함 슬롯 미스 이후 후속 제안자가 다른 선행 상태를 기준으로 블록을 만들 수 있음 노드 시간 동기화 불량이나 리소스 병목으로 처리 지연이 발생함 완화책\n시간 동기화는 chrony 등으로 정확히 유지함 고품질 피어 확보와 충분한 피어 수를 유지하고 네트워크 지연을 최소화함 최신 클라이언트와 다양한 클라이언트 조합으로 클라이언트 다양성 을 보장함 proposer boost와 attest 포함 지연 지표를 모니터링해 파라미터와 인프라를 튜닝함 대부분의 reorg는 1~2 블록에서 수렴하며 최종성 규칙으로 빠르게 안정화됨\n운영 체크리스트 노드와 인프라\n최신 합의·실행 클라이언트 유지 피어 수·지연·대역폭·디스크 IOPS 모니터링 장애를 분리하기 위해 실행·합의 클라이언트의 조합을 다양화함 키 관리\n슬래싱 방지 파일과 원격 서명기 사용 시 중복 서명 방지 설정 확인 단일 실패 지점 제거를 위해 핫·백업 구성과 자동 페일오버를 명확히 구분함 키 백업과 복구 절차를 오프라인으로 주기 점검함 운영 정책\n32 ETH 단위로 검증자를 수평 확장해 장애 격리와 보상 변동성을 줄임 모니터링 지표를 표준화함 참여율, attestation 포함 거리, 미스 슬롯, reorg 발생률, 동기화 위원회 가동률, 출금 큐 길이 등 MEV‑Boost 사용 시 릴레이 다양화와 로컬 빌더 폴백을 준비해 가용성과 검열 리스크를 낮춤 위험과 중앙화 고려 거대 스테이킹 풀과 커스터디 집중은 검열·단일 실패 지점 위험을 키움 클라이언트 다양성 부족은 버그 발생 시 네트워크 안정성을 해칠 수 있음 리퀴드 스테이킹 파생상품은 유동성을 제공하지만 의사결정 집중과 딜레마를 유발할 수 있음 정책과 거버넌스, 릴레이·빌더 다양화, 커뮤니티 모니터링으로 리스크를 분산해야 함 마무리 이더리움 PoS는 RANDAO 기반 무작위성, LMD‑GHOST 포크 선택, Casper FFG 최종성, 검증자 보상·벌칙 체계 를 결합해 에너지 효율과 보안을 동시에 달성하려는 설계임 운영자는 시간 동기화와 피어 품질, 키 관리, 클라이언트 다양성, 보상·출금 파이프라인을 지속적으로 점검해야 함 짧은 reorg는 네트워크 현실에서 발생할 수 있으나 적절한 인프라와 파라미터 튜닝, 최신 클라이언트 운용으로 빈도와 영향을 최소화할 수 있음\n참고자료 이더리움 PoS 개요 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos 합의 사양과 가스퍼 개요 https://github.com/ethereum/consensus-specs EIP‑4895 출금과 Capella 업그레이드 참고 https://eips.ethereum.org/EIPS/eip-4895 합의 계층 클라이언트와 실행 계층 클라이언트 목록 https://ethereum.org/en/developers/docs/nodes-and-clients MEV‑Boost 운영 가이드 참고 https://www.flashbots.net ","permalink":"https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함\n개념 정의에 그치지 않고 \u003cstrong\u003e운영 시 주의점\u003c/strong\u003e, \u003cstrong\u003e보상·출금 흐름\u003c/strong\u003e, \u003cstrong\u003e짧은 체인 재구성(Reorg) 원인과 완화책\u003c/strong\u003e까지 다룸\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003ePoS는 PoW의 에너지 경쟁을 대체해 \u003cstrong\u003e예치된 지분을 바탕으로 검증자를 선정\u003c/strong\u003e하는 합의 메커니즘임\n이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 \u003cstrong\u003e검증자 기반 보안 모델\u003c/strong\u003e로 이행함\u003c/p\u003e\n\u003cp\u003e주요 속성 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에너지 소비 대폭 축소\u003c/li\u003e\n\u003cli\u003e스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨\u003c/li\u003e\n\u003cli\u003e위반 시 슬래싱과 페널티로 예치금이 감소함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"계층-분리와-beacon-chain의-역할\"\u003e계층 분리와 Beacon Chain의 역할\u003c/h3\u003e\n\u003cp\u003e이더리움은 \u003cstrong\u003e합의 계층(Beacon Chain)\u003c/strong\u003e 과 \u003cstrong\u003e실행 계층(Execution Layer)\u003c/strong\u003e 를 분리해 설계함\u003c/p\u003e","title":"이더리움 PoS(Proof of Stake) 소개"},{"content":"개요 NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 리빌, 에어드롭, 화이트리스트, 마켓플레이스를 실무 관점으로 정리함 핵심은 개념 이해를 넘어 운영 체크리스트, 보안 리스크, 가격 형성 메커니즘까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\n공통 전제와 기본 개념 NFT 표준 주로 ERC‑721과 ERC‑1155를 사용함 721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\n메타데이터와 저장소 토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장 중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\n로열티 EIP‑2981 표준이 존재하나 집행은 마켓별 정책에 의존하는 경향이 있음 창작자 수익 분배 구조를 미리 확인 필요\n리빌 Reveal 정의 민팅 직후에는 공통 플레이스홀더 이미지를 노출하고, 이후 시점에 각 토큰의 최종 속성·이미지를 공개하는 절차를 말함\n왜 쓰는가\n판매 초기의 기대감 형성과 공정한 희소성 배분 유도 초반 스니핑을 줄이고 커뮤니티 이벤트와 연동하기 위함 가격 형성상 특징\n리빌 전에는 외형과 속성이 같아 보여 가격 수렴이 발생하기 쉬움 리빌 후에는 속성 조합·희소성에 따라 재평가가 빠르게 진행됨 희귀 속성은 프리미엄이 붙고 평범 속성은 하방 압력이 커지는 패턴이 일반적임 공정성·신뢰 장치\n프로비넌스 해시 공개로 민팅 전 전체 순서를 커밋해 치환·조작 가능성을 낮춤 메타데이터 동결과 BaseURI 고정으로 리빌 후 임의 수정 리스크 축소 온체인 또는 영속 스토리지에 최종 자료 고정 운영 체크리스트\n리빌 시점, 방식(일괄·구간·랜덤 시프트), 프로비넌스 공개 여부 확인 메타데이터 저장소와 동결 계획 점검 리빌 직후 가격 변동성 대비 유동성 전략 수립 에어드롭 Airdrop 정의 NFT 또는 토큰을 무상 배포해 초기 유입과 참여 보상을 유도하는 방식\n유형\n푸시형 프로젝트가 직접 전송 클레임형 스냅샷 기준 자격자에게 기간 내 청구 권한 부여 조건형 소셜 참여, 보유 토큰, 온체인 행위 등 조건을 충족해야 함 비용과 유동성\n가스 부담 주체가 누구인지 확인 필요 수령 자산의 2차 유동성 가능성과 잠금 조건 여부 확인 보안 체크리스트\n개인키·시드 문구 요청은 100% 사기 setApprovalForAll 무제한 승인 요구, 임의 Permit 서명 요구, 낯선 도메인의 서명 팝업에 주의 의심 에어드롭은 더스팅 공격 가능성 고려, 상호작용 자체를 피하는 것이 안전한 경우 많음 현실적 기대치\n극소수 성공 사례를 제외하면 무료 배포물의 평균 가치는 시간 경과에 따라 하락하는 경향 로드맵, 팀 신뢰도, 파트너십, 토큰 설계까지 종합 평가 필요 화이트리스트 Allowlist 정의 특정 지갑에게 민팅 우선권을 부여하는 명단을 의미하며 줄여서 화리라 부름 포용적 표현으로 Allowlist 용어를 쓰는 프로젝트가 많음\n부여 방식\n커뮤니티 기여, 미션, 추천, 보유 토큰 기반 토큰 게이팅 온체인 머클 증명으로 명단을 검증해 가스·데이터 비용을 절감 타입\n보장형 배정량이 확정되어 민팅 시점에 구매 가능 경쟁형 FCFS나 시간 창을 두어 네트워크 상태·속도에 따라 성공 여부가 갈림 래플형 추첨으로 공정 배분 시도 실무 체크리스트\n1인당 구매 한도, 민팅가, 시간 창, 체인·네트워크 확인 가스 워 방지 장치 유무 확인(쿨다운, 랜덤 시프트, 캡) 어뷰징·봇 통제 정책 확인, 위반 시 박탈 규정 숙지 주의\nAllowlist를 과다 남발하는 프로젝트는 민팅 종료 후 가격 하락 리스크가 크므로 유통 설계와 수요 검증 필요 NFT 마켓플레이스 역할 NFT의 가시화, 매매, 오더북을 제공하는 플랫폼을 의미함 글로벌로 OpenSea, Blur, Rarible 등이 대표적이며 국내에는 Klip Drops, 업비트 NFT 등이 존재함\n거래 방식\n고정가 리스팅 판매자가 원하는 가격 제시 경매형 영국식 상승 경매, 더치 경매 등 변형 포함 오퍼 특정 토큰 혹은 전체 컬렉션에 대한 구매 제안 접수 집계기가 여러 거래소의 유동성을 묶어 더 나은 가격·체결 속도를 제공하기도 함 핵심 지표와 해석 요령\n바닥가 Floor 컬렉션 내 최저 매물가이나 거래된 가격이 아님 얕은 호가에 의해 왜곡 가능하므로 체결 이력, 호가 두께, 분포를 함께 보아야 함 체결량·보유 분포 단기 매물 출회 압력과 고래 집중도 파악에 유용함 워시 트레이딩 자기계약 간 거래로 볼륨 부풀리기가 발생할 수 있어 탐지 지표 참고 필요 수수료와 로열티\n마켓 수수료와 창작자 로열티 정책이 거래소마다 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 선택적인 경우가 많아 실제 지급 여부를 확인해야 함 보안과 권한 관리\n판매 전 부여한 무제한 승인은 거래 후 revoke 툴로 회수 권장 피싱 도메인과 서명 위임 요청에 대한 교육이 필수 플랫폼 선택 기준\n유동성 규모, 수수료 구조, 지원 체인, 커뮤니티 활성도, 집계기 연동 여부, 로열티 정책 일관성 확인 빠른 판단 가이드 리빌 일정과 프로비넌스 공개, 메타데이터 동결 계획을 먼저 확인 에어드롭 은 개인키·시드·무제한 승인 요구 시 즉시 중단 화이트리스트 는 한도·가격·시간 창과 검증 방식(머클) 확인 마켓플레이스 는 바닥가만 보지 말고 체결 이력·호가 두께·수수료·로열티 정책까지 함께 판단 예시 시나리오 개인 사용자 민팅 직후 리빌 전 거래는 변동성 대비 효익이 낮을 수 있어 리빌 일정 확인 후 접근 수령한 에어드롭은 승인 요청이 없는지 먼저 점검하고 필요 시 상호작용을 피함 프로젝트 운영자 머클 기반 Allowlist와 프로비넌스 커밋으로 신뢰 확보 메타데이터 동결과 영속 스토리지 사용으로 변경 리스크 최소화 워시 트레이딩 방지 메시지와 리스팅 교육 자료를 함께 제공 마무리 리빌은 가치 재평가의 계기 에어드롭은 초기 분배와 참여 보상 수단 화이트리스트는 수요 조절과 공정 배분 장치 마켓플레이스는 가격 발견과 유동성의 장 각 제도의 의도·설계·리스크를 이해하고 보안 수칙을 지키면 의사결정의 품질을 높일 수 있음\n참고자료 ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 OpenZeppelin Merkle 증명 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography Ethereum 개발자 문서 NFT 개요 https://ethereum.org/en/developers/docs/standards/tokens/ 추가 읽을거리 https://magazine.cheil.com/51780 ","permalink":"https://handsupmin.github.io/posts/nft-23q12akw/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 \u003cstrong\u003e리빌\u003c/strong\u003e, \u003cstrong\u003e에어드롭\u003c/strong\u003e, \u003cstrong\u003e화이트리스트\u003c/strong\u003e, \u003cstrong\u003e마켓플레이스\u003c/strong\u003e를 실무 관점으로 정리함\n핵심은 개념 이해를 넘어 \u003cstrong\u003e운영 체크리스트\u003c/strong\u003e, \u003cstrong\u003e보안 리스크\u003c/strong\u003e, \u003cstrong\u003e가격 형성 메커니즘\u003c/strong\u003e까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"공통-전제와-기본-개념\"\u003e공통 전제와 기본 개념\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNFT 표준\u003c/strong\u003e\n주로 ERC‑721과 ERC‑1155를 사용함\n721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메타데이터와 저장소\u003c/strong\u003e\n토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장\n중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\u003c/p\u003e","title":"NFT 핵심 용어 정리"},{"content":"서문 NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움 이 글은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고 구매·발행·보관 시 유의사항과 운영 관행을 담는 것을 목표로 함\n개념과 배경 NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함 동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 고유 식별자와 속성을 가져 상호 교환 시 동일 가치를 보장하지 않음 블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음 온체인 소유권이 저작권·초상권 등 법적 권리와 자동 동치가 아님에 유의해야 함\nNFT는 보통 세 요소로 이해하면 실무에 유리함\n디지털 미디어 이미지·영상·음원·게임 아이템 등 사용자에게 보이는 대상 메타데이터 이름·설명·속성·미디어 링크를 담은 JSON 문서 스마트컨트랙트 발행·이전 규칙을 구현한 코드로 표준은 주로 ERC‑721과 ERC‑1155를 사용함 대부분의 프로젝트는 미디어 파일을 체인 밖에 보관하고 메타데이터에 링크를 넣는 오프체인 저장을 택함 장기 보존성을 위해 IPFS·Arweave 같은 영속형 스토리지 사용과 메타데이터 동결 계획이 중요함\n메인넷과 인프라 이해 NFT는 이더리움·폴리곤·솔라나·클레이튼 등 메인넷 혹은 L2 위에서 발행·거래됨 거래 실행에는 가스비가 들며 이더리움은 EIP‑1559 기반의 베이스피와 우선순위 팁 구조를 가짐 네트워크 상태와 우선순위 설정에 따라 체결 속도와 비용이 크게 달라짐 거래와 토큰 상태는 블록 탐색기에서 확인 가능하며 예시는 이더스캔과 클레이튼 스코프 등이 있음\n체인별 계약 주소·체인 ID가 다르므로 피싱 사이트가 제시하는 계약을 탐색기에서 교차 확인하는 습관이 필요함 브리징과 크로스체인 전송 시에는 락 앤 민트 모델·메시지 지연·브리지 보안을 이해하고 한도·대기 시간을 고려해야 함\n지갑과 보안 지갑은 주소와 그 주소를 통제하는 프라이빗 키·시드 문구를 관리함 메타마스크·카이카스 같은 브라우저 확장형은 편리하지만 핫월렛이라 위험 노출이 큼 대액·장기 보관 자산은 하드웨어 지갑에 두고 일상 거래는 별도 소액용 지갑을 쓰는 분리 보관이 권장됨\n시드 문구 보관 원칙\n오프라인 백업과 물리 분산 보관 사진·클라우드·메신저 업로드 금지 테스트 복구 절차를 정기 수행 권한과 서명 보안\n웹사이트 연결 시 도메인·체인·요청 권한을 확인하고 setApprovalForAll 무제한 승인은 꼭 필요한 범위에만 부여 거래가 아닌 서명 요청도 자산 이전 권한을 위임할 수 있으니 상세를 읽고 필요 시 거부 사용이 끝난 승인 권한은 권한 취소 도구로 주기적으로 회수 민팅 Minting 실무 절차 민팅은 메타데이터와 미디어 링크를 컨트랙트에 기록해 토큰을 새로 발행하는 행위 민팅이 체인에 포함되면 이벤트 로그에서 Transfer 이벤트의 From 주소가 0x0000000000000000000000000000000000000000 로 표시되는 것이 일반적임\n두 가지 맥락을 구분하면 혼동이 줄어듦\n프로젝트 관점 컨트랙트를 배포하고 토큰을 생성하는 개발·운영 작업 구매자 관점 민팅 페이지에서 최초 구매에 참여하는 행위 민팅 유형과 운영 포인트\n퍼블릭 민팅 누구나 가능하며 인기 컬렉션은 즉시 매진되므로 가스 전략과 자동화 대비가 필요 프라이빗 민팅 Allowlist 사전 등록 지갑만 참여 가능하며 일반적으로 가격·수량·시간 창이 별도로 정의됨 무료 민팅 민팅가는 0이지만 가스비가 들며 사후 로열티·수수료 구조를 확인해야 함 민팅 전 체크리스트\n계약 주소·체인·민팅가·한도·시간 창을 공지와 탐색기에서 이중 확인 메타데이터 저장 방식과 리빌·프로비넌스 계획을 확인 페이지가 제시하는 컨트랙트 소스 공개·감사 여부 확인 가스비 상한과 우선순위 팁을 과도하게 올려 불필요한 낭비가 없도록 시뮬레이션 마켓플레이스와 2차 거래 오픈씨·블러·라리블 등 마켓플레이스에 지갑을 연결해 리스팅과 오퍼를 관리함 주요 거래 방식은 고정가 리스팅·경매·컬렉션 오퍼 등이 있으며 유동성은 거래소마다 상이함\n가격 해석과 유의점\n바닥가 floor 는 현재 최저 매물가일 뿐 실제 체결가가 아님 체결 이력·호가 두께·보유 분포를 함께 봐야 수급을 판단할 수 있음 워시 트레이딩 으로 볼륨이 부풀려질 수 있으므로 비정상 패턴에 주의 로열티와 수수료\n마켓 수수료 와 크리에이터 로열티 정책은 플랫폼별로 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 거래소 정책에 의존하는 경우가 많음 실제 로열티 지급 여부와 비율을 거래 전 확인 필요 권한과 보안\n리스팅 과정에서 부여한 무제한 승인은 판매 종료 후 회수 권장 낯선 도메인의 서명 팝업과 필드가 비정상적으로 긴 메시지는 피싱 징후일 수 있음 메타데이터·저장·리빌 운영 메타데이터 는 ERC‑721 메타데이터 스펙의 name·description·image·attributes 필드를 따르는 것이 일반적 저장소 는 IPFS·Arweave 같이 링크 무결성과 장기 보존에 유리한 방식을 권장 리빌 은 발행 직후 플레이스홀더를 제공하고 이후 속성을 공개하는 절차로 가격 재평가가 일어남 조작 의심을 줄이기 위해 프로비넌스 해시 공개·랜덤 시드·베이스 URI 잠금 같은 신뢰 장치를 제공하는 것이 실무 베스트 프랙티스임 운영·커뮤니티 관행과 실무 팁 프로젝트 운영자 관점\n컨트랙트 소스 공개와 보안 감사 진행 Allowlist를 머클 증명으로 검증해 가스와 데이터 비용을 절감 봇 완화를 위한 레이트 리밋·쿨다운·인증을 설계 리빌 일정·기준·랜덤 방식과 메타데이터 동결 계획을 사전 공지 로열티 정책을 명확히 하고 플랫폼별 집행 차이에 대한 안내 제공 구매자·보유자 관점\n리빌 전후의 가격 변동성과 유동성 얕음에 대비 권한 관리와 피싱 방지 교육을 습관화 브리지·체인 전환 전에는 수수료·지연·보안 리스크를 점검 에어드롭·민팅 DM은 대부분 피싱일 가능성이 높으므로 공식 채널만 신뢰 빠른 점검 체크리스트 계약 주소·체인·민팅가·수량 한도·시간 창 교차 확인 메타데이터 저장소와 리빌·프로비넌스 공개 여부 확인 마켓 수수료·로열티 정책·체결 이력과 호가 두께 확인 권한 부여 최소화와 사용 후 권한 회수 습관 유지 시드 문구 오프라인 분산 보관과 정기 복구 테스트 수행 마무리 NFT는 표준·메타데이터·컨트랙트 권한·저장 전략이 서로 맞물려 동작하는 생태계임 개념을 이해하는 것만으로는 부족하며 보안과 운영 절차를 마련해야 실전에서 손실을 줄일 수 있음 민팅·거래·보관 단계별로 위의 체크리스트를 적용하면 의사결정 품질을 안정적으로 끌어올릴 수 있음\n참고자료 Etherscan 블록 탐색기 https://etherscan.io Klaytn Scope 블록 탐색기 https://scope.klaytn.com OpenSea 마켓플레이스 https://opensea.io MetaMask 지갑 https://metamask.io ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 Ethereum 개발자 문서 토큰 표준 개요 https://ethereum.org/en/developers/docs/standards/tokens Klaytn 개발자 문서 https://docs.klaytn.foundation ","permalink":"https://handsupmin.github.io/posts/nft-concept-20gd0fl/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003eNFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움\n이 글은 \u003cstrong\u003e실무자 관점\u003c/strong\u003e에서 NFT의 핵심 개념을 단계적으로 정리하고 \u003cstrong\u003e구매·발행·보관 시 유의사항\u003c/strong\u003e과 \u003cstrong\u003e운영 관행\u003c/strong\u003e을 담는 것을 목표로 함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eNFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함\n동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 \u003cstrong\u003e고유 식별자와 속성\u003c/strong\u003e을 가져 상호 교환 시 동일 가치를 보장하지 않음\n블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음\n온체인 소유권이 \u003cstrong\u003e저작권·초상권 등 법적 권리와 자동 동치가 아님\u003c/strong\u003e에 유의해야 함\u003c/p\u003e","title":"NFT란? NFT 핵심 개념 정리"},{"content":"서문 pnpm은 npm과 유사한 CLI를 제공하면서 의존성 저장 구조를 혁신해 디스크 중복을 줄이고 설치 성능을 높인 패키지 매니저임 대규모 모노레포와 여러 프로젝트를 동시에 운영할 때 중복 패키지 최소화·설치 속도 개선·일관된 잠금 파일 관리를 목표로 함 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용법을 실무 관점에서 정리함\n개념 및 배경 핵심 아이디어는 사용자 단위의 콘텐츠 주소 기반 저장소(Content‑Addressable Store) 와 하드링크 + 심볼릭 링크 조합임\n패키지 실제 파일은 사용자 스토어에 한 번만 저장됨 각 프로젝트의 node_modules에는 스토어의 파일을 하드링크로 연결하고, 패키지 간 의존 관계는 심볼릭 링크로 구성함 결과적으로 동일 버전 패키지가 여러 프로젝트에서 필요해도 물리 복제가 발생하지 않음 스토어 기본 위치는 OS와 설정에 따라 달라지므로 명령으로 확인하는 것이 정확함\npnpm store path 로 실제 스토어 경로 확인 pnpm config get store-dir 로 명시적 설정 여부 확인 링크 구조 정확히 이해하기 pnpm의 node_modules는 표준 Node 해석 규칙을 유지하면서도 디스크 효율을 극대화하는 가상 스토어 구조를 가짐\n예시 디렉터리 구조\nmy-project ├─ node_modules │ ├─ .pnpm │ │ └─ express@4.19.2/node_modules/express │ └─ express -\u0026gt; .pnpm/express@4.19.2/node_modules/express ├─ package.json └─ pnpm-lock.yaml .pnpm/express@4.19.2/node_modules/express 내부 파일은 사용자 스토어에서 하드링크로 제공됨 상위 node_modules/express 는 해당 디렉터리로 심볼릭 링크되어 해석됨 이 구조 덕분에 디스크 사용량 감소와 빠른 설치가 가능함 설치 명령 정확히 쓰기 의존성 추가는 pnpm add \u0026lt;패키지\u0026gt; 사용\n예시 pnpm add express 개발 의존성은 -D 또는 --save-dev 설치 재현은 pnpm install 사용\npnpm-lock.yaml 을 기준으로 설치하며 업데이트를 금지하려면 --frozen-lockfile 권장 오프라인 또는 캐시 우선 설치는 --offline 또는 --prefer-offline 검토 글로벌 설치는 pnpm add -g \u0026lt;패키지\u0026gt;\n글로벌 바이너리 경로는 pnpm bin -g 로 확인 일회성 실행은 글로벌 설치 대신 pnpm dlx \u0026lt;패키지\u0026gt; \u0026lt;args\u0026gt; 권장 워크스페이스 기본 루트에 pnpm-workspace.yaml 을 두고 패키지 글롭을 정의함\npackages: - \u0026#34;packages/*\u0026#34; 실무 포인트\n내부 패키지 간 의존은 workspace: 프로토콜로 명시해 레지스트리 출고물 대신 로컬 소스를 링크함\n예시 workspace:* workspace:^1.2.0 등 버전 범위 지정 가능 루트에 공통 스크립트를 두고 전체 실행은 pnpm -r run \u0026lt;script\u0026gt; 또는 타깃 실행은 pnpm --filter \u0026lt;패키지\u0026gt; run \u0026lt;script\u0026gt; 사용\n특정 패키지에 의존성 추가는 pnpm --filter \u0026lt;패키지\u0026gt; add \u0026lt;모듈\u0026gt; 로 정확히 지정\n실무에 바로 쓰는 명령 스니펫 # 스토어 경로 확인 pnpm store path # 프로젝트 전 패키지 설치 재현 pnpm install --frozen-lockfile # 워크스페이스 전역 빌드 pnpm -r run build # 특정 패키지만 테스트 pnpm --filter @org/api run test # 루트에 공통 도구 추가 pnpm add -w -D typescript eslint # 일회성 실행으로 글로벌 오염 방지 pnpm dlx tsx scripts/generate.ts 성능·디스크 최적화 팁 프리페치 서버 환경에서 pnpm fetch 로 패키지를 미리 가져와 네트워크 변동성을 줄임\n스토어 청소 오래된 아카이브 제거는 pnpm store prune\n사이드 이펙트 캐시 네이티브 빌드 산출물 캐시를 켜면 재설치가 빨라짐\npnpm config set side-effects-cache true OS·CPU 아키텍처별 격리가 필요하므로 CI 매트릭스에 맞춰 관리 권장 CI 캐시 전략\n스토어 경로 pnpm store path 결과를 캐시 pnpm-lock.yaml 을 캐시 키에 포함해 결정적 설치를 보장 호이스팅 호환성 다루기 pnpm은 엄격한 격리를 기본값으로 하여 잘못된 모듈 해석을 줄임 레거시 도구가 루트에 평평하게 호이스트된 구조를 가정할 경우 아래 옵션을 검토함\npublic-hoist-pattern 으로 특정 패턴만 루트로 호이스트 최후의 수단으로 shamefully-hoist=true 를 설정해 전반 호이스팅 가능하면 패키지 자체를 수정하거나 packageExtensions 로 누락된 peerDeps를 보완하는 접근을 우선 고려함 의존성 해상도와 품질 보증 pnpm은 peerDependencies 충돌에 엄격해 문제를 조기에 드러내는 장점이 있음 조직 차원의 버전 강제는 overrides 를 사용해 하위 트리의 특정 버전을 고정 잠금 파일은 워크스페이스 루트의 pnpm-lock.yaml 하나만 커밋해 결정적 빌드를 유지 트러블슈팅 체크리스트 패키지 탐색 실패\n잘못된 상대 임포트나 평평한 구조 가정 여부 점검 임시 우회는 public-hoist-pattern 으로 부분 호이스팅 네이티브 모듈 빌드 지연\nside-effects-cache 활성화와 CI 캐시 확인 전역 명령 인식 실패\npnpm bin -g 를 PATH에 추가했는지 점검 디스크 급증\n스토어 경로 확인 후 pnpm store prune 실행 마무리 pnpm은 스토어 단일화 + 하드링크 를 바탕으로 설치 시간을 낮추고 디스크 중복을 제거하는 실전형 패키지 매니저임 워크스페이스와 workspace: 프로토콜을 활용하면 모노레포 개발 경험과 CI 안정성을 동시에 끌어올릴 수 있음 레거시 호이스팅 가정만 주의하면 npm 사용 습관에서 큰 이질감 없이 도입이 가능함\n참고자료 pnpm 공식 문서 https://pnpm.io pnpm 워크스페이스 https://pnpm.io/workspaces side-effects cache 설정 https://pnpm.io/cli/config#side-effects-cache overrides와 의존성 관리 https://pnpm.io/package_json#pnpmoverrides ","permalink":"https://handsupmin.github.io/posts/pnpm-92fmw2/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003epnpm은 npm과 유사한 CLI를 제공하면서 \u003cstrong\u003e의존성 저장 구조\u003c/strong\u003e를 혁신해 디스크 중복을 줄이고 설치 성능을 높인 패키지 매니저임\n대규모 모노레포와 여러 프로젝트를 동시에 운영할 때 \u003cstrong\u003e중복 패키지 최소화·설치 속도 개선·일관된 잠금 파일 관리\u003c/strong\u003e를 목표로 함\n이 글은 pnpm의 \u003cstrong\u003e설치 동작 원리\u003c/strong\u003e와 \u003cstrong\u003e워크스페이스 활용법\u003c/strong\u003e을 실무 관점에서 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념-및-배경\"\u003e개념 및 배경\u003c/h3\u003e\n\u003cp\u003e핵심 아이디어는 \u003cstrong\u003e사용자 단위의 콘텐츠 주소 기반 저장소(Content‑Addressable Store)\u003c/strong\u003e 와 \u003cstrong\u003e하드링크 + 심볼릭 링크\u003c/strong\u003e 조합임\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패키지 실제 파일은 사용자 스토어에 \u003cstrong\u003e한 번만\u003c/strong\u003e 저장됨\u003c/li\u003e\n\u003cli\u003e각 프로젝트의 \u003ccode\u003enode_modules\u003c/code\u003e에는 스토어의 파일을 \u003cstrong\u003e하드링크\u003c/strong\u003e로 연결하고, 패키지 간 의존 관계는 \u003cstrong\u003e심볼릭 링크\u003c/strong\u003e로 구성함\u003c/li\u003e\n\u003cli\u003e결과적으로 동일 버전 패키지가 여러 프로젝트에서 필요해도 물리 복제가 발생하지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스토어 기본 위치는 OS와 설정에 따라 달라지므로 명령으로 확인하는 것이 정확함\u003c/p\u003e","title":"pnpm이란? pnpm의 개념과 사용방법 총정리"}]