[{"content":"개요 TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임 여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐 실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함 이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함\n핵심 개념과 정의 enum 값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김 const enum enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성 as const const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장 여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임 enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음 as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함\nenum 동작 원리와 구조 멤버 종류 상수 멤버와 계산된 멤버로 구분됨\n상수 멤버 컴파일 타임에 확정 가능한 값 계산된 멤버 표현식을 평가해야 정해지는 값, const enum에서는 허용되지 않음 값 타입별 분류\n숫자형 enum 기본값 0부터 1씩 자동 증가, 역매핑 지원 문자열형 enum 문자열 상수 부여, 역매핑은 키에서 값 방향만 성립 혼합형 enum 숫자와 문자열 혼재, 특별한 이유가 없다면 권장하지 않음 자동 할당 규칙\n첫 멤버 초기화가 없으면 0 할당 직전 멤버가 숫자 상수면 다음 멤버는 +1 증가 값 부여 양방향 매핑\n숫자형 enum은 키→값과 값→키 모두 접근 가능 런타임 객체로 역참조가 가능해 디버깅에는 편하지만 코드가 늘어나고 tree-shaking에 불리함 제약\n멤버 이름은 숫자 식별자 불가 라이브러리 배포 시 번들 크기 영향 고려 필요 enum의 장단점 장점\n의도 표현력이 좋음 열거형이라는 도메인 모델을 바로 드러냄 안전성 향상 지정한 값 집합만 허용되는 형태로 오입력 방지에 유리함 숫자형의 역매핑이 디버깅과 로그 판독에 편리 단점\n코드 팽창 즉시 실행 패턴과 역매핑 테이블로 번들 크기 증가 가능성 tree-shaking에 불리 선언만 해도 구현 코드가 남아 죽은 코드 제거가 어려움 문자열형만 필요할 때도 런타임 테이블을 유지해야 하는 비용 발생 const enum의 목적과 제약 목적\nenum 접근 비용과 추가 생성 코드를 제거하여 가벼운 산출물 확보 사용 지점에 값이 inlined되어 역참조 테이블 자체를 만들지 않음 제약과 주의\n계산된 멤버 금지 상수 표현식만 허용 툴체인 호환성 이슈 빈번 Babel 등 타입 지우기 전용 트랜스파일러는 const enum을 지원하지 않거나 그대로 통과시키는 경우가 있어 런타임 에러 유발 위험 존재 isolatedModules 옵션 사용 시 모듈 단일 변환 제약으로 const enum이 막히거나 preserveConstEnums 설정과 충돌 가능성 라이브러리 배포 시 소비자 환경에 따라 의미가 달라질 수 있음 선언 파일 d.ts에 const enum을 노출하면 소비자 컴파일러 설정과 상호작용이 필요해 파편화 가능성 발생 요약하면, const enum은 산출물 최적화에 유리하지만, 빌드 파이프라인과 배포 경로가 단순하지 않으면 리스크가 큼\nas const의 의도와 효과 의도\n값의 리터럴 타입화와 readonly 부여를 통해 상수성을 보장하고 타입 좁히기 수행 객체 키를 통한 값 집합 설계 후 해당 값들의 유니온 타입을 간단히 얻을 수 있음 효과\n값 그 자체가 타입으로 추론됨 문자열은 문자열 리터럴 타입, 숫자는 숫자 리터럴 타입으로 고정 객체 단위 as const는 모든 프로퍼티를 readonly로 바꾸어 재할당 차단 런타임 오버헤드 없음 단순한 객체와 배열 그대로 유지되어 tree-shaking에도 유리 실무 포인트\nenum의 역매핑이 꼭 필요하지 않다면 as const 기반의 객체 열거가 가장 무난 선언과 타입 획득을 분리해 재사용성과 트리셰이킹을 확보 가능 최소 예시 스니펫 스니펫 1 숫자형 enum의 역매핑\nenum Direction { Up, Down, } Direction.Up // 0 Direction[0] // \u0026#39;Up\u0026#39; 스니펫 2 as const로 값 유니온 타입 얻기\nconst Status = { Ready: \u0026#39;ready\u0026#39;, Done: \u0026#39;done\u0026#39;, } as const type Status = typeof Status[keyof typeof Status] // \u0026#39;ready\u0026#39; | \u0026#39;done\u0026#39; 위 두 가지로 enum의 역매핑 유무와 as const의 리터럴 타입화를 직관적으로 비교 가능\nDiscriminated Union과 as const 상태를 안전하게 분기하려면 판별 가능한 공통 필드를 두는 것이 핵심\n공통 필드 kind 같은 것을 문자열 리터럴로 고정 각 변형에 고유 속성을 부여하고 분기 시 kind로 좁히기 이때 as const로 kind 값을 리터럴 타입으로 확정하면 분기 안전성이 올라감 Discriminated Union은 넓은 유니온 타입에서 특정 필드의 리터럴 값 비교로 타입 가드를 자동 유도함 리터럴 타입화가 불완전하면 존재할 수도 없을 수도 있는 속성으로 판단해 접근 시 에러가 날 수 있음 as const를 적용해 판별 키를 리터럴로 고정하면 분기 후 속성 접근이 안전해짐\nconst enum의 함정 정리 Babel 트랜스파일 TypeScript 구문 제거 위주로 동작하여 const enum을 컴파일하지 않음 결과적으로 사용 지점에서 값이 남지 않고 식별자 자체가 유지되어 런타임 에러 가능 SWC 등 대체 트랜스파일러 사용 시에도 설정 차이에 따라 const enum이 보존되거나 잘못 처리될 수 있음 tsconfig의 isolatedModules가 켜진 환경에서는 모듈 단위 변환 제약으로 const enum 사용이 제한되거나 preserveConstEnums와 상충 가능 라이브러리 d.ts에 const enum을 노출하면 소비자 빌드가 동일한 규칙으로 inlining해야 하므로 빌드 파이프라인 결속이 필요해짐 이런 리스크로 인해 팀 규칙으로 const enum 금지, as const 권장으로 정하는 경우가 많음\n선택 가이드라인 다음 체크리스트로 결정\n역매핑이 꼭 필요함 숫자값에서 이름을 역으로 알아야 하는 요구가 명확함\n예 바이너리 프로토콜 디버깅에서 숫자코드를 사람 읽는 문자열로 즉시 확인 필요 선택 enum 고려 번들 크기와 tree-shaking이 중요함 런타임 테이블 생성 비용을 피하고 싶음\n선택 as const 기반 객체 열거 권장 빌드 파이프라인이 단순함 tsc 단독 빌드, const enum을 안전하게 inline 가능하다고 확신함\n선택 const enum 사용 가능하나 팀 규칙으로 명시하고 도구 호환성 테스트 필수 라이브러리 배포 소비자 환경 다양, 선언 파일 안정성이 최우선\n선택 const enum 지양, as const + 타입 유니온 익스포트 권장 값 집합을 타입으로 바로 얻고 싶음, 리터럴 타입화와 readonly가 필요함\n선택 as const로 객체를 선언하고 typeof와 keyof 조합으로 유니온 타입 획득 베스트 프랙티스 팀 규칙 정의 enum은 역매핑이 실질적 이득을 줄 때에만 사용, 기본값은 as const 빌드 파이프라인 점검 Babel 사용 시 const enum 금지, tsc emit 환경에서만 제한적 허용 선언과 타입 분리 as const 객체를 런타임 값으로 노출하고, 타입은 typeof와 keyof로 파생 문자열형만 필요한 경우 enum 대신 문자열 리터럴 유니온 또는 as const 객체 사용 공개 API의 안정성 확보 라이브러리 환경에서는 상수 집합을 값과 타입으로 동시에 노출하되 const enum 회피 자동 증가 규칙에 의존하지 않기 enum 숫자값이 외부 계약이라면 명시적으로 값 지정 트레이드오프 요약 enum 의도 표현력과 역매핑 편의 제공, 대신 런타임 테이블과 번들 팽창 감수 const enum 매우 가벼운 산출물 확보, 대신 빌드 호환성 리스크와 계산된 멤버 제한 수용 as const 타입 안전과 tree-shaking 친화성 확보, 대신 역매핑 등 런타임 편의는 직접 구현 필요 실무 기본값은 as const, 명확한 필요가 있을 때만 enum, const enum은 파이프라인이 보장될 때 선택\n참고로 알아두면 좋은 설정과 패턴 tsconfig preserveConstEnums true로 두면 const enum을 제거하지 않고 남김 라이브러리 소비자 측에서 inlining을 기대하는 형태가 되어 호환성 이슈가 더 커질 수 있음 tsconfig isolatedModules 각 파일을 독립적으로 변환하므로 const enum 사용이 제한되는 경우가 있음 Discriminated Union의 판별 키는 문자열 리터럴 타입으로 고정 as const 적극 활용 값에서 타입 뽑기 패턴 typeof Obj[keyof typeof Obj] 조합으로 값 유니온 타입 생성 마무리 양방향 매핑이 기능 요구사항에 포함되어 있는지, 빌드 파이프라인이 const enum을 안전하게 처리하는지, 번들 크기 최적화의 우선순위가 높은지부터 판단하면 선택이 단순해짐 대부분의 프런트엔드와 서버 사이드 TypeScript 코드에서는 as const 기반 상수 객체와 리터럴 유니온이 안전하고 유지보수 친화적임 역매핑이 명백한 가치를 제공할 때만 enum을 채택하고, const enum은 도구 체인이 이를 보장할 때 제한적으로 사용함 목적에 맞춘 선택이 코드의 명료성과 산출물 품질을 동시에 끌어올림\n참고자료 https://www.typescriptlang.org/docs/handbook/enums.html https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions https://www.typescriptlang.org/tsconfig#preserveConstEnums https://www.typescriptlang.org/tsconfig#isolatedModules https://babeljs.io/docs/babel-plugin-transform-typescript ","permalink":"https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eTypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임\n여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐\n실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함\n이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eenum  값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김\u003c/li\u003e\n\u003cli\u003econst enum  enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성\u003c/li\u003e\n\u003cli\u003eas const  const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임\nenum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음\nas const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함\u003c/p\u003e","title":"TypeScript enum, const enum, as const의 차이와 선택 가이드"},{"content":"블록체인 인덱서 가이드 인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임 디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\n왜 인덱서가 필요한가 블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼 디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함 전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임 핵심 개념 인덱싱 대상 데이터 유형 블록 헤더와 트랜잭션 메타데이터\n블록번호, 타임스탬프, 가스 사용량, 트랜잭션 해시 등 스마트 컨트랙트 이벤트 로그\n토픽과 데이터 필드, 인덱스드 파라미터, 로그 인덱스 등 컨트랙트 상태 스냅샷 또는 파생 지표\n잔액 스냅샷, 포지션 지표, 시계열 집계 등 용어 정리 서브그래프\n특정 도메인을 위한 스키마형 인덱싱 단위 최종성 Finality\n블록이 되돌려지지 않을 확률이 충분히 낮은 상태를 의미함 재구성 Reorg\n더 긴 체인이 나타나 일부 블록이 교체되는 현상으로 인덱서가 롤백과 재처리를 수행해야 함 백필 Backfill\n과거 블록 범위를 대량으로 인덱싱하는 작업이며 라이브 스트림과 병행 운영 필요함 아키텍처 구성 요소 수집기 Ingestor\n풀노드 또는 게이트웨이에 구독 혹은 폴링으로 연결해 새 블록과 트랜잭션, 로그 수신 블록 범위 큐와 재시도, 속도 제한 제어 포함 권장 파서 Parser\nABI 기반 디코딩으로 이벤트와 함수 호출 입력을 구조화함 주소, 체인ID, 블록번호, 트랜잭션 해시를 기본 정규화 키로 포함 인덱서 Indexer\n예상 질의 패턴에 맞춘 보조 인덱스와 머티리얼라이즈드 뷰 생성 멱등 처리로 중복 입력에 안전해야 함 저장소 Storage\n관계형 SQL, 문서형, 키밸류, 시계열 중 워크로드에 맞게 혼합 선택 쓰기 집중 구간과 읽기 집중 구간을 분리 설계 권장 서비스 API\nGraphQL 또는 REST 제공 캐시, 커서 기반 페이지네이션, 레이트 리밋, 다중 리전 배포 포함 권장 동작 원리 1) 데이터 수집 최신 블록 스트림 수신 토픽 기반 필터로 관심 이벤트만 선별 가능 블록 범위 작업 단위를 설정해 재시도와 병렬 처리 제어 2) 정리와 저장 ABI로 이벤트 파싱 후 표준 스키마로 정규화\n파티셔닝 키 설계 예시\n주소별 파티션, 컨트랙트별 파티션, 체인ID별 샤딩 스토리지 선택 가이드\nSQL은 조인과 강한 정합성 강점 NoSQL은 쓰기 성능과 수평 확장 강점 혼합 접근으로 원본 로그 테이블과 조회 최적화 테이블을 분리 3) 제공과 캐싱 핫 키에 인메모리 캐시와 세그먼트 캐시 적용 커서 기반 페이지네이션으로 대량 스캔 방지 지표성 데이터는 사전 집계 테이블이나 머티리얼라이즈드 뷰 사용 4) 최종성과 재처리 N 컨펌 이후 확정 마킹으로 Reorg 영향 최소화 Reorg 발생 시 영향 범위만 역인덱스 삭제 후 재인덱싱 백필 잡과 라이브 스트림의 경계 관리로 중복 작업 방지 데이터 모델과 스키마 예시 원본 이벤트 로그 테이블 예시 CREATE TABLE ev_raw ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, log_index INT NOT NULL, topic0 VARBINARY(32) NOT NULL, topic1 VARBINARY(32) NULL, topic2 VARBINARY(32) NULL, topic3 VARBINARY(32) NULL, data BLOB NOT NULL, PRIMARY KEY (chain_id, block_number, tx_hash, log_index) ) 조회 최적화 테이블 예시 CREATE TABLE nft_transfers ( chain_id INT NOT NULL, contract_address VARBINARY(20) NOT NULL, token_id DECIMAL(78,0) NOT NULL, from_address VARBINARY(20) NOT NULL, to_address VARBINARY(20) NOT NULL, block_number BIGINT NOT NULL, block_time TIMESTAMP NOT NULL, tx_hash VARBINARY(32) NOT NULL, PRIMARY KEY (chain_id, contract_address, token_id, block_number, tx_hash), INDEX idx_owner_history (chain_id, to_address, block_number DESC) ) GraphQL 질의 예시 query { transfers(first: 10, where: { from: \u0026#34;0xaaaa...\u0026#34;, to: null }) { id from to value blockNumber txHash } } 핵심은 애플리케이션이 자주 묻는 질문을 스키마와 인덱스로 선제 정의하는 것임 원장 재탐색 없이 즉시 응답 가능한 형태로 데이터를 재구성하는 것이 목표임\n일관성 모델 확정 상태와 미확정 상태를 명시 구분\n응답 필드에 finality_level 또는 confirmations 포함 권장 API 파라미터로 최종성 레벨 허용\n예시로 minConfirmations=12 전달 시 해당 기준 충족 데이터만 반환 읽기 스냅샷 일관성 유지로 동일 요청 내 시간축 안정성 보장\n재처리와 멱등성 블록 범위 단위의 재인덱싱이 가능하도록 범위 메타 유지\n멱등 키 설계\n(chain_id, tx_hash, log_index) 또는 이벤트 고유 해시로 중복 삽입 방지 업서트 기반 로딩으로 재처리 안전성 확보\nINSERT INTO nft_transfers (...) VALUES (...) ON DUPLICATE KEY UPDATE block_time = VALUES(block_time) 성능과 비용 최적화 백필은 대역폭 우선, 라이브는 지연 우선으로 튜닝 파티션 핫스팟 회피를 위해 주소 해싱 또는 범위 셔플링 적용 대규모 이벤트의 경우 배치 크기와 커밋 간격을 체계적으로 설정 스키마 버저닝을 통해 마이그레이션 시 이중 기록 전략 적용 권장 운영과 관측성 필수 지표\n블록 지연, 수집 지연, 처리 라그, 오류율, 재시도율, 큐 적체량 알람 기준\n라그 급증, Reorg 빈도 증가, 특정 컨트랙트 오류 급증 롤백과 재시작\n저장소에 체크포인트와 커밋 오프셋 기록으로 안전 복구 가능하게 설계 보안과 무결성 데이터 출처 이중화와 교차 검증 적용\n서로 다른 노드나 공급자에서 샘플 검증 수행 권장 서명 검증 가능한 데이터는 파이프라인 내 즉시 검증\n민감 메타데이터는 암호화 저장과 접근 통제 적용\n주요 플랫폼 비교 요약 The Graph\nGraphQL 기반 서브그래프 모델과 커스텀 스키마, 매핑 지원 이벤트 중심 도메인 모델링이 단순함 Covalent\n멀티체인 통합 API와 공통 스키마 제공 빠른 프로토타이핑과 대시보드 연동 용이 QuickNode\n노드와 인덱싱 API 조합으로 고성능 엔드포인트 제공 Moralis\n멀티체인 디앱 백엔드 도구로 지갑과 NFT 중심 인덱싱 제공 자체 구축\n유연성과 데이터 소유권 강점 운영 복잡성과 비용 증가 단점 존재 대표 사용 사례 지갑 화면에서 주소 기준 트랜잭션과 토큰 잔액 즉시 조회 디파이 포지션 수익률과 담보 상태를 실시간 계산 NFT 소유 목록, 전송 이력, 메타데이터 동기화 제공 온체인 데이터 기반 분석과 알림 트리거 생성 베스트 프랙티스 체크리스트 스키마 설계 상위 핵심 질의 세 가지를 먼저 정하고 파티셔닝과 보조 인덱스를 결정 원본 로그 테이블과 조회 최적화 테이블을 분리 운영 시간 기반 파티셔닝과 주소 기반 인덱스를 함께 고려 재처리 전략 블록 범위 메타를 보관해 부분 재인덱싱 가능하게 유지 멱등 키와 업서트로 중복 삽입 방지 일관성과 최종성 확정과 미확정 데이터를 응답에서 구분 API에 최종성 파라미터 제공 성능과 비용 백필 파이프라인은 대역폭과 병렬성 극대화 라이브 스트림은 지연과 안정성 최적화 핫 파티션 회피를 위한 해싱 또는 샤딩 적용 운영과 관측성 라그와 오류 지표를 1급 시민으로 모니터링 스키마 버저닝과 롤백 계획을 문서화 보안과 무결성 공급자 이중화와 교차검증 구성 서명 검증 가능한 지표는 수집 단계에서 검증 안티 패턴 WHERE 절에 함수 연산을 남발해 인덱스를 무력화하는 패턴 원본 로그 테이블 하나로만 모든 질의를 처리하려는 단일 스키마 고집 Reorg 가정 부재로 롤백 경로가 없는 파이프라인 커서 대신 페이지 오프셋을 사용해 심각한 스캔을 유발하는 페이지네이션 간단 레퍼런스 이더리움 JSON-RPC eth_getLogs로 토픽 필터링 수집 가능 Solidity 이벤트는 ABI로 디코딩해 구조화 가능 GraphQL은 선택적 필드 조회와 관계 탐색에 유리함 query WalletView($owner: String!, $first: Int!, $cursor: String) { erc20Balances(owner: $owner, first: $first, after: $cursor) { edges { node { contract symbol decimals balance updatedAt } cursor } pageInfo { hasNextPage endCursor } } } 마무리 인덱서는 제품이 자주 묻는 질문을 데이터 구조로 먼저 표현하는 도구임 초기 단계에서 질의 패턴과 최종성 전략을 분명히 하고 재처리, 관측성, 비용의 트레이드오프를 문서화할 것 관리형 서비스와 자체 구축을 혼합해 민첩성과 통제력을 균형 있게 가져갈 것 참고자료 https://thegraph.com/docs/en/ https://www.covalenthq.com/docs/ https://www.quicknode.com/docs https://docs.moralis.io/ https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs https://docs.soliditylang.org/en/latest/contracts.html#events ","permalink":"https://handsupmin.github.io/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/","summary":"\u003ch1 id=\"블록체인-인덱서-가이드\"\u003e블록체인 인덱서 가이드\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임\n디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"왜-인덱서가-필요한가\"\u003e왜 인덱서가 필요한가\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼\u003c/li\u003e\n\u003cli\u003e디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함\u003c/li\u003e\n\u003cli\u003e전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"핵심-개념\"\u003e핵심 개념\u003c/h2\u003e\n\u003ch3 id=\"인덱싱-대상-데이터-유형\"\u003e인덱싱 대상 데이터 유형\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e블록 헤더와 트랜잭션 메타데이터\u003c/p\u003e","title":"블록체인 인덱서 가이드"},{"content":"개요 퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함 이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름 합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함 PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임 실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\n합의가 필요한 이유와 기준 안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음 활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨 최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨 시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요 성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건 탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요 PoW 작업증명 핵심 정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조 구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요 난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행 보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미 장점\n단순한 검증 경량 노드도 헤더 체인과 작업 증명만으로 유효성 확인 가능 시빌 내성 경제적 비용이 명확하며 물리 자원 기반 보안 단점 에너지 비용 과다 전력과 하드웨어 비용이 지속적으로 소모됨 처리 지연 블록 간격 확대와 오프라인 확률로 인해 확률적 최종성에 의존함 여러 컨펌 대기가 필요 중앙화 유인 대규모 채굴 인프라와 풀 집중 경향 존재 운영 팁 블록 간격과 크기 설정은 고아 블록 비율을 고려해 네트워크 전파 지연을 상회하도록 보수적으로 설정 난이도 조정 주기는 급격한 난이도 스윙을 줄이도록 이동 평균이나 클리핑 적용 수수료 시장 안정화를 위해 기본 수수료 규칙과 대역폭 관리 병행 PoS 지분증명 핵심 정의 토큰 지분을 예치한 검증자가 블록 제안 및 투표 권한을 획득하는 방식 에너지 소모를 낮추고 결정적 최종성 또는 짧은 확률적 최종성을 지향 선정 방식 난수 또는 가중 무작위 선택 VRF 위원회 선출 라운드별 리더 로테이션 등 다양함 안전 장치 슬래싱 이중 제안 또는 상충 투표에 대해 지분 일부 소각해 부정 행위 억제 체크포인트와 파이널라이저로 최종성 확보 대표적 이슈\n아무 것도 걸지 않기 문제 포크마다 비용 없이 투표 가능 설계 시 슬래싱과 보상 구조로 해결 롱레인지 공격 오래된 키로 과거부터 새로운 체인을 위조 가능 약한 주관성 체크포인트 동기화와 키 회수 정책으로 대응 지분 집중 대량 보유의 복리 효과로 중앙화 경향 완화 위해 보상 곡선과 위임 구조 설계 필요 장점 저전력 고효율 일반 하드웨어로 검증 가능해 참여 문턱 완화 빠른 확정 위원회 기반 투표와 파이널리티 가젯으로 블록 확정 지연 축소 단점 프로토콜 복잡도 증가 상태 관리 키 보안 슬래싱 운영 리스크 존재 경제 보안은 토큰 가치에 의존 가격 급락 시 보안 예산 저하 가능 운영 팁 검증자 키 관리 분리 서명 키와 위임 키 분리하고 온라인 노출 최소화 모니터링 필수 가용성 저하와 네트워크 분할 시 슬래싱 위험에 대비해 자동 장애 조치와 경보 체계 구축 업그레이드 경로 사전 예고와 버전 롤링 전략으로 네트워크 분리 리스크 완화 영지식증명 기본 개념 요약 목적 특정 명제가 참임을 비밀 자체를 드러내지 않고 증명 핵심 성질 세 가지\n완전성 증명자가 정당하면 검증자는 수용 건전성 증명자가 거짓이면 들킴 확률이 무시 가능 수준으로 낮음 영지식성 검증 과정에서 비밀에 대한 추가 정보 누설 없음 직관적 비유 알리바바 동굴 이야기 증명자는 비밀번호를 알려주지 않지만 검증자가 무작위로 요구한 출구를 반복해서 만족시킴으로써 지식을 입증함 반복 횟수를 늘릴수록 속임수 성공 확률이 기하급수적으로 줄어듦 zk-SNARK와 zk-STARK 한눈에 정리 zk-SNARK 짧은 증명 크기와 빠른 검증 장점 신뢰 설정이 필요한 설계가 일반적이며 곡선 쌍선형 연산 의존 zk-STARK 신뢰 설정 불필요 투명성 확보 해시 중심 구성 대규모 산술화에 강점 단 증명 크기가 다소 큼 검증도 상수항이 큰 편 최근 동향 순환 증명과 집계 증명으로 대량 트랜잭션을 하나의 짧은 증명으로 압축하는 기술 발전 중 블록체인에서 영지식증명이 유용한 지점 프라이버시 보호 거래 금액과 주소를 숨기면서도 보유액과 보존 법칙을 증명 가능 프라이버시 코인과 선택적 공개 기능에 활용 경량 검증과 확장성 체인 외부에서 상태 전이의 올바름을 증명하고 온체인에서는 짧은 증명만 검증 레이어2 유효성 롤업과 브리지에서 핵심 역할 탈중앙 신원 DID 자격증명 내용을 공개하지 않고 특정 속성 보유 여부를 증명 가능 최소 정보 공개 원칙 준수 합의 검증 비용 절감 블록 제안자가 트랜잭션 집합의 유효성에 대한 증명을 첨부하면 검증자의 부하 감소 가능 특히 대규모 검증 집합에서 효과적 PoW와 ZKP의 접점 경량 노드 강화 SPV 유사 모델을 한 단계 더 줄여 거래와 상태 전이를 영지식 증명으로 요약 검증 데이터 요구량 감소 데이터 가용성과의 분리 증명으로 계산의 정당성을 담보하고 실제 데이터는 샘플링 기반 가용성 검증으로 처리 조합 시 대역폭 부담 경감 현실 제약 PoW 체인에 직접 ZKP를 의무화하면 블록 생성 지연과 수수료 급등 가능 선택적 채택 또는 L2에서 사용 후 앵커링 전략이 실용적 PoS와 ZKP의 접점 빠른 최종성 보조 확정 투표와 함께 블록 유효성에 대한 유효성 증명을 첨부하면 재검증 비용 감소와 상태 동기화 속도 향상 기대 경계 조건 롱레인지 공격 방지 로직과 ZKP의 신뢰 설정 문제가 충돌하지 않도록 설계 필요 검증 키 관리와 프로빙 공격 대응 필수 레이어2 조합 PoS L1은 데이터 가용성과 보안에 집중 L2는 ZKP 기반 유효성 증명으로 대량 처리 규모 확장 구조가 주류로 이동 중 간단 예시 시나리오 전송자 A가 금액 x를 보유하고 있고 x의 일부 y를 B에게 보낸다는 명제를 산술 회로로 구성 A는 입력 금액과 잔액을 숨긴 채 보존 법칙과 서명 유효성 이중 지불 방지 조건을 모두 만족한다는 zk 증명을 생성 블록 제안자는 거래 본문이 아니라 증명과 최소한의 커밋먼트만 포함해 블록을 구성 검증자는 모든 트랜잭션을 재연산하지 않고 증명만 검증해 유효성 확인 네트워크 전체의 검증 비용과 데이터 노출이 줄어듦 주의 사항과 한계 PoW\n에너지 비용과 환경 부담 현실적 고려 필요 정책 변화와 전력 시장 리스크 반영 채굴 풀 집중 위험 수수료 변동성과 수익 불안정성으로 해시 파워 급변 가능 PoS 슬래싱 운영 리스크 네트워크 분할 장애나 키 누출 시 손실 발생 가능 기계적 가용성과 이중 서명 방지 자동화 필수 지분 집중 완화 필요 보상 곡선 설계 위임 한도 분산 인센티브 도입 고려 ZKP 구현 난도 높음 회로 설계와 산술화 최적화에 고도의 전문성 요구 사소한 변경으로도 보안 성질이 깨질 수 있음 신뢰 설정 이슈 TTP를 요구하는 시스템은 설정 자료 유출에 대한 위협 모델을 명확화해야 함 멀티 파티 설정과 폐기 의식 같은 절차 필요 성능 비용 증명 생성 시간이 길고 메모리 사용량이 큼 온체인 검증 가스 비용과 트레이드오프 존재 규제와 프라이버시 충돌 익명성 기능은 규제 요구와 충돌 가능 선택적 공개와 감사 권한 설계 필요 설계와 운영 베스트 프랙티스 체크리스트 요구사항 정렬 최종성 목표 지연 허용치 처리량과 비용 한도를 수치로 정의 보안 예산 추적 PoW는 전력 단가와 장비 감가 PoS는 시가총액과 연간 인플레이션을 기반으로 경제 보안 측정 파라미터 거버넌스 난이도 조정 간격 파이널리티 임계치 슬래싱 파라미터를 온체인 거버넌스 또는 보호된 프로세스로 관리 롤백 규칙 사전 명시 경량 클라이언트 우선 누구나 검증 가능한 경량 노드 경로 제공 체크포인트와 ZKP 기반 동기화 옵션 검토 키 보안 모델 검증자 키 다중화 하드웨어 보안 모듈 사용 원격 서명 분리 공용 백업 절차 문서화 ZKP 도입 전략 파일럿을 레이어2나 특정 자산 유형에 적용 증명 생성 파이프라인과 회로 버전 관리 자동 테스트 구축 관측 가능성 메트릭 합의 파라미터 슬래싱 이벤트 고아 블록율 파이널리티 지연을 지속 수집 경보 기준 수립 마무리 합의 알고리즘 선택은 기술 취향이 아니라 시스템 목표와 제약에 대한 정량적 타협의 산물임 PoW는 단순하고 강인하지만 에너지 비용과 지연의 대가가 큼 PoS는 고성능과 유연성을 제공하지만 프로토콜 복잡도와 운영 리스크를 동반함 영지식증명은 프라이버시와 검증 비용을 동시에 다루는 실용 도구로 자리잡는 중이며 신뢰 설정과 성능 한계에 대한 공학적 해결이 빠르게 진행되고 있음 현실적인 접근은 L1 합의는 보안을 우선하고 L2에서 ZKP로 확장성과 프라이버시를 확보하는 계층화 설계임 명확한 목표 지표 설정과 파라미터 거버넌스 자동화된 검증과 관측 가능성을 갖춘 운영이 장기적 안정성을 보장함\n참고자료 https://bitcoin.org/bitcoin.pdf https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ https://arxiv.org/abs/1710.09437 https://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf https://z.cash/technology/zksnarks/ https://zkproof.org https://vitalik.ca/general/2021/12/06/pos2021.html https://www.lgcns.com/blog/cns-tech/security/29926/ ","permalink":"https://handsupmin.github.io/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함\n이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름\n합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함\nPoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임\n실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함\u003c/p\u003e\n\u003ch3 id=\"합의가-필요한-이유와-기준\"\u003e합의가 필요한 이유와 기준\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음\u003c/li\u003e\n\u003cli\u003e활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨\u003c/li\u003e\n\u003cli\u003e최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨\u003c/li\u003e\n\u003cli\u003e시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요\u003c/li\u003e\n\u003cli\u003e성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건\u003c/li\u003e\n\u003cli\u003e탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"pow-작업증명-핵심\"\u003ePoW 작업증명 핵심\u003c/h3\u003e\n\u003cp\u003e정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조\n구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요\n난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행\n보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미\n장점\u003c/p\u003e","title":"블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용"},{"content":"개요 채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임 역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음 이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨 아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\n핵심 개념과 정의 블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부 트랜잭션 계정 상태를 변화시키는 요청 또는 메시지 채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체 작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙 난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할 넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값 메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합 블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합 왜 채굴이 필요한가 탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음 예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함 채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함 PoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\n생성 어렵게 만들면 공격자가 과거를 마음대로 재구성하기 어려워짐 검증 쉽게 만들면 모든 노드가 빠르게 유효성 확인이 가능함 동작 원리와 절차 PoW 기반 네트워크에서 채굴자가 블록을 만드는 일반 흐름은 다음과 같음\n사용자가 지갑으로 트랜잭션에 서명하고 네트워크에 브로드캐스트함 노드가 트랜잭션을 수신해 로컬 메모리풀에 적재함 채굴자가 메모리풀에서 수수료가 유리하고 유효한 트랜잭션을 선별해 임시 블록 후보를 구성함, 블록 가스 한도 내에서 수익 최대화 목표 각 트랜잭션의 서명과 잔고 및 논리적 제약을 검증하고, 로컬 가상머신에서 실행하여 상태 전이를 시뮬레이션함 블록 헤더에 포함될 머클 루트, 이전 블록 해시, 타임스탬프, 난이도, 넌스 등을 조립함 채굴기가 넌스를 바꿔가며 헤더 해시가 목표 난이도 기준 이하가 되도록 반복 계산함, 목표를 만족하면 유효한 작업증명 완료 채굴자는 찾은 증명과 함께 블록을 전파함, 함께 전파되는 상태 요약은 다른 노드가 결과를 빠르게 확인하도록 돕는 용도 다른 노드는 증명 검증 후 로컬 실행으로 상태를 재현해 일치 여부 확인함 다수 노드가 유효하다고 인정하면 해당 블록이 체인에 연결되고 이전 블록 위에 최종성 확률이 쌓이기 시작함 블록을 제안한 채굴자는 보상과 포함된 트랜잭션 수수료를 수령함 보상 구조와 인센티브 채굴 보상은 크게 두 부분으로 구성됨\n기본 보상 새 블록 생성 보상, 네트워크 규칙에 의해 일정 주기로 조정될 수 있음 수수료 보상 블록에 포함된 트랜잭션이 지불하는 수수료의 합계, 수요와 혼잡도에 따라 변동 역사적으로 이더리움 PoW에서는 기본 보상이 네트워크 업그레이드를 거치며 5 → 3 → 2 단위로 축소된 바 있음, 혼잡 시에는 수수료 비중이 커져 채굴자 수익에 큰 영향을 줌 PoW의 경제적 설계는 보상을 통해 정직한 참여를 유도하고, 높은 계산 비용을 통해 악의적 재작성 비용을 크게 만듦 증명 생성은 계산적으로 어렵지만 검증은 매우 쉬움, 따라서 네트워크 전체가 빠르게 합의 상태를 공유할 수 있음 비용 구조와 수익성 판단 채굴 수익성은 단순 보상 규모가 아니라 총비용 대비 순이익으로 판단함\n하드웨어 비용 GPU 또는 ASIC 장비, 보조 부품, 예비 부품, 감가상각 전력 비용 소비 전력과 단가, 지역별 전력 정책, 피크 요금 운영 비용 냉각과 환기, 먼지 및 습도 대응, 전기 배선과 안정화 장치, 모니터링 시스템, 공간 임대, 유지보수 인력 네트워크 난이도와 코인 가격, 수수료 시장, 장비 효율이 동적으로 상호작용하기 때문에 손익분기점은 수시로 변함 개별 상황 가정 후 계산기를 활용해 해시레이트, 전력 소모, 전기요금, 난이도, 수수료를 넣고 일일 혹은 월간 예상 수익을 추정하는 접근 권장 가격 변동성, 난이도 조정, 장비 고장률, 가동률 저하, 네트워크 정책 변경 위험을 보수적으로 반영하는 것 중요 채굴 방식 비교 CPU 채굴 초기에는 가능했으나 현재는 연산 밀도가 낮아 경제성 부족 GPU 채굴 범용성과 병렬성 확보, 여러 장을 리그로 구성해 확장 가능, 시장 유통성과 중고 처분 용이성이 장점이나 전력 효율은 ASIC 대비 불리 ASIC 채굴 특정 알고리즘 전용 설계로 높은 해시당 전력 효율 제공, 다만 초기 투자비 크고 알고리즘 혹은 시장 변화에 취약, 세대 교체 주기가 짧아 감가상각 리스크 큼 클라우드 채굴 하드웨어 없이 해시레이트 임대, 초기 비용과 운영 부담 감소 장점이 있으나 계약 불투명성, 수익 분배 구조, 커스터디 리스크에 각별한 주의 필요 채굴 풀의 역할과 구조 개인이 단독으로 블록을 찾을 확률은 매우 낮음, 풀은 참여자의 해시 파워를 모아 변동성을 줄이고 보다 자주 보상을 획득하도록 함 풀 보상 분배는 기여도 기반으로 수행되며 PPS, PPLNS 등 다양한 정산 방식 존재, 각 방식의 리스크와 변동성 특성 상이함 풀 선택 시 고려 요소 운영 투명성, 수수료율, 지연시간, 서버 위치와 품질, 최소 출금 한도, 보안 공지 대응력, 탈중앙성에 미치는 영향 풀 집중화는 네트워크 보안에 부정적일 수 있으므로 단일 풀이 과도한 비중을 차지하는 상황은 경계 필요\n보안과 한계, 운영상의 베스트프랙티스 전력과 열 관리 과부하 차단기와 분산 배전, 항온항습과 적절한 배기 경로 설계, 화재 감시 시스템 구축 펌웨어와 드라이버 신뢰 가능한 소스만 사용, 자동 업데이트 비활성 후 검증 배포, 설정 백업 유지 물리 보안 장비 잠금과 출입 통제, 원격 전원 차단 장치 준비, 영상과 환경 센서 모니터링 풀 및 지갑 보안 출금 화이트리스트, 다중서명 혹은 하드웨어 월렛 사용, 풀 API 토큰 보호 재무 관리 변동성 헤지 전략, 정기적인 손익 분석, 감가상각과 현금 흐름 관리 규제와 환경 고려 지역 규제 준수, 소음 규제 대응, 재생에너지 사용 검토, 전력 계약 합법성 확인 PoW는 높은 에너지 비용과 장비 자본 집약이라는 구조적 한계를 가짐, 반면 공격 비용을 높여 보안을 확보한다는 장점 존재 간단 예시로 보는 합의와 순서 보장 순서1 Alice → Bob 1 단위 전송 요청 생성 및 서명 순서2 네트워크에 전파되어 메모리풀에 대기 순서3 채굴자가 유효성을 확인하고 블록 후보에 포함 순서4 채굴자가 유효한 작업증명을 먼저 찾으면 블록 전파 순서5 다른 노드가 빠르게 검증 후 채택, 전 세계가 동일한 순서로 상태를 갱신 이 흐름이 반복되며 이중지불 시도가 자연스럽게 배제됨, 잘못된 순서나 잔고 부족 요청은 유효성 검증에서 탈락함 이더리움 전환 사례에서 얻는 시사점 이더리움은 PoW에서 PoS로 전환하며 에너지 소비를 대폭 감소시키고 채굴 경제학에서 스테이킹 경제학으로 무게중심을 이동시켰음 PoW 채굴의 개념과 절차는 여전히 유효한 학습 주제이며, PoW 네트워크 운영과 보안 모델 이해에 핵심적임 네트워크 설계는 기술과 경제 인센티브의 균형 위에 서며, 보상 구조와 비용 구조를 함께 설계해야 지속 가능성이 확보됨\n마무리 채굴은 블록을 만드는 생산 행위이자 합의를 물리적으로 고정하는 보안 장치임 동작 원리를 이해하면 트랜잭션 순서 보장, 이중지불 방지, 경제 인센티브 설계를 하나의 체계로 연결해 볼 수 있음 실제 투자나 운영을 고려한다면 전력 단가, 장비 효율, 난이도, 수수료 시장, 규제 리스크를 보수적으로 평가하고, 풀 선택과 보안 운용에 표준 절차를 갖추는 것이 우선임 PoW와 PoS의 차이를 비교해 각 네트워크의 보안 가정을 명확히 이해하는 태도가 중요함\n참고자료 https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining/ https://ethereum.org/en/roadmap/merge/ https://en.wikipedia.org/wiki/Double-spending https://etherscan.io/ether-mining-calculator https://www.fidelity.com/learning-center/trading-investing/crypto/what-is-mining ","permalink":"https://handsupmin.github.io/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임\n역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음\n이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨\n아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부\u003c/li\u003e\n\u003cli\u003e트랜잭션 계정 상태를 변화시키는 요청 또는 메시지\u003c/li\u003e\n\u003cli\u003e채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체\u003c/li\u003e\n\u003cli\u003e작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙\u003c/li\u003e\n\u003cli\u003e난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할\u003c/li\u003e\n\u003cli\u003e넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값\u003c/li\u003e\n\u003cli\u003e메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합\u003c/li\u003e\n\u003cli\u003e블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"왜-채굴이-필요한가\"\u003e왜 채굴이 필요한가\u003c/h3\u003e\n\u003cp\u003e탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음\n예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함\n채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함\nPoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움\u003c/p\u003e","title":"블록체인 채굴 개념과 동작 원리 PoW 보상 구조 이더리움 전환 사례"},{"content":"개요 Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표 ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구 핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\n배경과 목적 이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼 저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적 L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것 ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\n핵심 개념 Layer 2\nL1의 합의와 보안을 상속받아 트랜잭션을 오프체인에서 처리한 후 압축된 증거를 L1에 제출하는 확장 계층 목표는 가스 비용 절감, TPS 증가, 빠른 최종성 확보 ZK Rollup\n트랜잭션 배치를 실행한 결과가 올바름을 증명하는 유효성 증명 제출 방식 모든 원시 트랜잭션 데이터를 L1에 게시하지 않고 상태 변화의 유효성만 증명하여 확정 가능 Optimistic Rollup 대비 사후 분쟁 윈도우 감소, 빠른 확정성 기대 ZK Stack\nZK Rollup을 구성하기 위한 오픈 프레임워크 시퀀서, 증명기, 검증 계약, 데이터 가용성, 브리징 등 구성요소를 모듈 단위로 조립하는 설계 지향 데이터 가용성과 EIP-4844\n상태 차이와 배치 관련 데이터를 블롭 형태로 게시하여 비용 효율을 높이는 전략 블롭 데이터는 일정 기간 보존되며, 검증과 재구성에 필요한 최소 요건 충족을 목표 동작 원리와 구조 트랜잭션 수명주기 개요 사용자가 JSON-RPC를 통해 L2 네트워크로 트랜잭션 제출, 멤풀 적재 시퀀서가 트랜잭션을 실행해 블록화 후 배치 생성 사용자에게 즉시 실행 응답 반환 가능, 최종성은 L1 커밋·검증 후 확보 배치가 L1로 전송되어 데이터 가용성 보장 상태로 커밋됨 ZK 증명이 생성되어 L1 검증 계약에서 확인됨 검증 완료 후 배치 실행 확정, 상태 루트와 로그가 온체인 기준으로 고정 L1 상호작용 단계 커밋 단계\n시퀀서가 L1 롤업 컨트랙트에 배치 커밋 호출 수행 EIP-4844 블롭을 통해 상태 차이 등 필요한 데이터의 가용성 보장 증명 단계\n배치 실행의 유효성을 ZK 증명으로 생성하여 L1에 제출 검증 계약이 증명을 확인하여 상태 전이의 정당성 확립 실행 단계\n검증 완료 즉시 배치가 확정 처리되며, L2 로그를 포함한 머클 구조가 저장됨 구성 요소 Sequencer 계층\nRPC 서비스: 트랜잭션 제출, 상태 조회 등 API 제공 Sequencer: 트랜잭션 정렬·실행·블록화, 검증 제약을 준수하는 실행 파이프라인 유지 L1 연동 오퍼레이터: 입금, 업그레이드 등 L1 이벤트 동기화 및 배치 커밋 전송 역할 Prover \u0026amp; Verifier 파이프라인\n증인 생성 단계: 거래 세부 공개 없이 유효함을 입증하기 위한 데이터 구성 회로 실행 단계: VM 실행의 정합성을 검증하는 회로를 기준으로 증명 생성 및 검증 수행 연산 코드, 스토리지 상호작용, 사전컴파일 통합 등을 포함하는 실행 정합성 보장 목표 배치 전체를 순회하며 최종 상태 루트까지의 업데이트 일관성 확인 증명 압축 단계: L2에서 생성된 큰 STARK류 증명을 소형 SNARK류로 압축하여 L1 검증 비용 절감 L1 Rollup Contracts\n블롭을 사용해 상태 차이와 압축된 바이트코드 저장 유효성 증명 수신·검증 L1↔L2 메시징과 브리징 지원 네이티브 계정 추상화 Abstract의 모든 계정은 스마트 컨트랙트 계정으로 동작하며 동일한 트랜잭션 수명주기 준수 EOA와 CA 이원화 대신 IAccount 인터페이스 기반의 단일 모델 적용 EOA 지갑으로 서명해도 실행 경로에서는 기본 계정 구현체로 변환되어 처리됨 가스 지불은 본인 또는 페이마스터를 통해 유연하게 수행 가능\n트랜잭션 플로우 제출\nJSON-RPC로 트랜잭션 제출, 멤풀 적재 from 필드를 스마트 컨트랙트 계정 주소로 설정 가능 부트로더 처리\n멤풀에서 트랜잭션을 읽어 배치 단위로 처리 NonceHolder 시스템 컨트랙트 질의로 nonce 사용 여부 확인 from 주소에 코드가 없으면 기본 계정 구현으로 해석해 실행 경로 표준화 스마트 컨트랙트 계정 검증·실행\nvalidateTransaction 호출로 실행 허용 여부 판단 및 접근 제어 수행 executeTransaction 호출로 실제 실행 경로 진입 payForTransaction 또는 prepareForPaymaster 호출로 가스 지불 경로 선택 페이마스터 경로 선택적 수행\nvalidateAndPayForPaymasterTransaction 호출로 후원 여부 결정 및 가스 지불 집행 postTransaction 훅으로 사후 처리 로직 수행 가능 스마트 컨트랙트 지갑 설계 포인트 IAccount 인터페이스 구현 기반 표준 동작 확보 onlyBootloader 제약으로 부트로더 외 호출 차단 컨트랙트 배포는 시스템 컨트랙트를 통한 isSystemCall 경로 사용 효율적 실행을 위한 저수준 호출 라이브러리 활용 권장 가스 지불은 부트로더에 직접 지불 또는 페이마스터 입력 처리 함수 사용 Nonce 관리 트랜잭션 시작 전 NonceHolder 시스템 컨트랙트의 validateNonceUsage 호출로 중복 사용 방지 유효성 검사 단계에서 nonce를 소비 처리해야 함 옵션\nminNonce 증가로 해당 값 미만 nonce 일괄 사용 처리 setValueUnderNonce를 통해 특정 nonce 슬롯에 0이 아닌 값 기록 편의 메서드 incrementMinNonceIfEquals 사용 권장 NonceHolder 호출에는 트랜잭션의 isSystem 플래그 설정 필요, 시스템 호출 유틸 사용 권장 서명 검증과 EIP-1271 스마트 컨트랙트 계정은 EOA와 달리 고정 서명 검증 로직이 없으므로 EIP-1271 구현 권장 isValidSignature를 통해 임의 로직으로 서명 유효성 판단 가능, EIP-712 타입 데이터 서명과 결합 시 사용자 경험 및 보안 개선 기대\ncontract ERC1271 { // bytes4(keccak256(\u0026#34;isValidSignature(bytes32,bytes)\u0026#34;)) bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature( bytes32 _hash, bytes memory _signature ) public view returns (bytes4 magicValue) {} } Paymaster 개념 다른 계정을 대신해 가스비를 지불하는 스마트 컨트랙트 역할 IPaymaster 인터페이스 준수 필수 계정 소유자의 가스비 직접 지불을 대체해 비용 스폰서십, 토큰 기반 가스 지불 등 사용성 개선 제공 실행 경로에서는 prepareForPaymaster 이후 paymaster가 검증과 결제를 수행 오남용 방지를 위한 한도·쿨다운·화이트리스트 정책 필요\nAGW(Abstract Global Wallet) 개요 네이티브 계정 추상화를 전제로 한 사용자 온보딩 레이어 이메일, 소셜, 패스키 등 친숙한 로그인으로 최초 가입 후 동일 계정으로 트랜잭션 생성 가능 핵심은 서명자 관리와 복구, 다중 서명자, 가스 스폰서십 등 계정 수명주기 운영을 일관된 UX로 제공하는 것\nAGW 작동 방식 1단계 EOA 생성 사용자 로그인 방식을 통해 내부적으로 EOA 생성 2단계 스마트 컨트랙트 지갑 배포 배포 초기화 시 1단계 EOA를 승인된 서명자로 등록 이후 단계 서명자 추가·삭제, 패스키 기반 서명자 등록, 모듈 확장 등 계정 운영 기능 사용 스마트 컨트랙트 지갑은 네이티브 1급 시민으로 동작하며, 기본 곡선인 secp256k1 중심 운영 권장 패스키 확장 시 secp256r1 서명자 지원 가능, EIP-712 기반 서명 검증 로직 조합 권장\n스마트 지갑 기능 모듈 예 복구 모듈 이메일 복구, 가디언 복구 등 키 분실 시 계정 복원 경로 제공 페이마스터 연동 트랜잭션 가스비 후원, 특정 토큰 지불 라우팅 구성 다중 서명자 역할 기반 서명 정책, 임계값 승인 정책 확장 패스키 지원 FIDO 기반 기기 서명자를 지갑에 연결해 무서버 키 경험 제공 주의 사항과 트레이드오프 데이터 가용성 비용\n블롭 가격은 네트워크 수요에 따라 변동, 배치 크기와 커밋 주기 최적화 필요 증명 대기 시간\n증명 생성은 계산 집약적, 하드웨어와 회로 최적화 상태에 따라 지연 발생 가능 사용자 응답은 즉시성 확보 가능하나 L1 최종성은 증명 완료 이후 확보 시퀀서 검열 리스크\n단일 시퀀서 운영 시 트랜잭션 포함 지연 가능성 존재 추후 분산화 로드맵, 포크 선택 규칙, 포스 인클루전 메커니즘 고려 필요 브리징과 메시징 안전성\nL1 확정 전 교차체인 메시지 사용 시 미확정 리스크 존재 지연 큐, 취소·재시도 정책, 상태 증명 기반 수령 조건 명시 필요 페이마스터 남용 방지\n한도, 속도 제한, 수신자·함수 화이트리스트 운용 토큰 기반 가스 지불은 환산 레이트 변동과 유동성 부족 문제 고려 Nonce 경쟁과 재진행\n중복 제출 방지, 재전송 정책, minNonce 관리 정책 표준화 필요 간단 예시와 실무 팁 JSON-RPC 제출 시 from을 스마트 컨트랙트 계정 주소로 지정해 계정 자체 검증 로직 구동 검증 단계에서 nonce 소비를 먼저 처리해 재진입·중복 실행 방지 EIP-712 타입 데이터 서명 사용으로 서명 범위와 목적을 명확히 표현 부트로더 전용 함수는 onlyBootloader로 차단, 외부 호출 경로 executeTransactionFromOutside를 별도 제어 L1 상호작용은 commit → prove → execute 순서 준수, 운영 관점에서 배치 커밋 지표와 증명 큐 길이를 모니터링 운영 베스트 프랙티스 배치 정책\n수요에 따른 동적 배치 크기와 커밋 주기 조정, 블롭 단가와 증명 대기 시간의 균형 추구 가시성 확보\n시퀀서 지연, 증명 생성 시간, 실패율, 큐 길이, L1 가스 단가, 블롭 단가 대시보드화 계정 추상화 보안\nvalidateTransaction에서 호출자·서명·정책 일관성 검증, 실패 시 명시적 에러 코드 반환 페이마스터 입력 파싱과 예산 검사 철저, 사후 훅에서 외부 호출 시 재진입 방지 릴리즈 전략\n테스트넷에서 계정·페이마스터·브리징 경로를 통합 리허설, 가스 상한과 오류 복구 시나리오 검증 회로와 증명 백엔드\n회로 업데이트는 롤링 업그레이드 전략 채택, 검증 키 교체와 컨트랙트 버전 호환성 체크리스트 운영 마무리 Abstract는 ZK Rollup과 EIP-4844를 결합해 확장성과 비용 효율을 확보하고, 네이티브 계정 추상화로 개발자와 사용자의 상호작용을 단순화하는 접근을 취함 시퀀서·증명 파이프라인·L1 계약 간 경계를 명확히 하고, 계정 추상화와 페이마스터 정책을 보안 우선으로 설계하면 운영 안정성을 크게 높일 수 있음 이 문서의 개념과 베스트 프랙티스를 기준으로 트랜잭션 수명주기, 지갑 모듈, 데이터 가용성 튜닝을 체계적으로 검토할 것을 권장함\n참고자료 https://abs.xyz/ https://eips.ethereum.org/EIPS/eip-4844 https://eips.ethereum.org/EIPS/eip-1271 https://era.zksync.io/docs/ https://vitalik.ca/general/2021/01/05/rollup.html https://ethereum.org/en/roadmap/danksharding/ ","permalink":"https://handsupmin.github.io/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eAbstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표\nZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구\n핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음\u003c/p\u003e\n\u003ch3 id=\"배경과-목적\"\u003e배경과 목적\u003c/h3\u003e\n\u003cp\u003e이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼\n저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적\nL2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것\nZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공\u003c/p\u003e","title":"Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW"},{"content":"개요 Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임 ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음 프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\n핵심 개념과 정의 Public Client\n퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트 블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당 Wallet Client\n개인키를 보유한 계정에 대해 트랜잭션 서명과 전송을 수행하는 클라이언트 시뮬레이션, 가스 추정, nonce 처리, write 컨트랙트 호출 담당 Transport\nHTTP나 WebSocket 등 JSON-RPC 통신 방법 추상화 계층 성능과 안정성에 영향을 주는 핵심 요소 Chain 구성\nchain 객체에 chainId, 네트워크 이름, 기본 RPC 엔드포인트, 네이티브 통화 단위 등의 메타데이터 포함 올바른 체인 설정이 시뮬레이션과 서명, 전송의 전제 조건 ABI 기반 타입 안전성\nABI를 바탕으로 함수 이름, 파라미터, 반환형에 대한 타입 추론 제공 런타임 이전에 오타나 파라미터 타입 오류를 차단하는 효과 데이터 타입\n금액, 블록 번호, 가스 등 정수 값은 BigInt 반환이 기본 주소, 바이트 데이터는 0x 프리픽스 hex 문자열 사용 동작 원리와 구조 읽기 흐름\nPublic Client가 RPC 호출을 통해 블록이나 상태를 조회함 컨트랙트 읽기 시 getContract 또는 readContract 유틸을 사용하여 call 실행 쓰기 흐름\nWallet Client가 계정을 보유하고 시뮬레이션으로 가스와 파라미터를 검증한 뒤 트랜잭션 전송 simulateContract 결과를 writeContract에 그대로 전달하는 패턴이 안전하고 권장됨 분리의 이점\n읽기와 쓰기 책임이 분리되어 보안 경계와 테스트 용이성 향상 서버 환경에서는 Public Client만 배포해 민감 키가 없는 조회 전용 API 제공 가능 설치와 환경 준비 패키지 설치\nnpm install viem 필수 준비물\n신뢰 가능한 RPC 엔드포인트 URL 준비 테스트넷에서는 faucet로 ETH 확보 환경 변수로 개인키, RPC URL 등 민감정보 관리 권장 사용법 1: 네트워크 연결과 블록 조회 아래 스니펫은 메인넷에 연결하고 최신 블록과 블록 번호를 조회하는 최소 예시임\nimport { createPublicClient, http } from \u0026#39;viem\u0026#39; import { mainnet } from \u0026#39;viem/chains\u0026#39; const publicClient = createPublicClient({ chain: mainnet, transport: http(process.env.RPC_URL) }) const run = async () =\u0026gt; { const block = await publicClient.getBlock() const blockNumber = await publicClient.getBlockNumber() // block 해시, 타임스탬프, 가스 사용량 등 핵심 필드 사용 console.log(block.hash, block.timestamp, block.gasUsed) console.log(blockNumber) } run() blockNumber는 BigInt 반환값임 gas, 수수료, 블록 번호 등 정수 값 처리 시 숫자 오버플로 방지를 위해 BigInt 유지 또는 명시적 변환 필요 http 전송 대신 웹소켓 전송도 가능하나 서버 환경 안정성, 프록시 구성, 리밸런싱 전략 고려 필요 사용법 2: 컨트랙트 읽기와 쓰기 한 스니펫에서 읽기와 쓰기를 묶어 핵심 흐름만 정리함\nimport { getContract, createPublicClient, createWalletClient, http } from \u0026#39;viem\u0026#39; import { sepolia } from \u0026#39;viem/chains\u0026#39; import { privateKeyToAccount } from \u0026#39;viem/accounts\u0026#39; const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.RPC_URL) }) const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`) const walletClient = createWalletClient({ account, chain: sepolia, transport: http(process.env.RPC_URL) }) // 읽기 예시 const contract = getContract({ address: \u0026#39;0xYourContractAddress\u0026#39;, abi: YourAbi, client: publicClient }) const name = await contract.read.name() // 쓰기 예시 const { request } = await publicClient.simulateContract({ address: \u0026#39;0xYourContractAddress\u0026#39;, abi: YourAbi, functionName: \u0026#39;store\u0026#39;, args: [100n], account }) const txHash = await walletClient.writeContract(request) console.log(name, txHash) address에는 목표 컨트랙트 주소 입력 abi에는 실제 ABI 배열 주입 read 호출은 call을 사용하므로 가스 소모 없음 write 호출은 시뮬레이션으로 가스, 인자, 권한 문제를 사전 검증한 뒤 전송 txHash로 익스플로러에서 상태 확인 가능 동작 살펴보기와 실전 팁 getContract와 read\ngetContract는 ABI를 바탕으로 타입 안전한 메서드 집합 생성 contract.read.balanceOf(\u0026lsquo;0x\u0026hellip;\u0026rsquo;)처럼 각 함수가 자동 완성되며 잘못된 함수명이나 인자 타입을 컴파일 타임에 차단 simulateContract와 writeContract\n시뮬레이션 단계에서 revert 이유와 디코딩된 오류를 확인 가능 request에는 to, data, value, gas, maxFeePerGas 등 전송에 필요한 필드가 완성되어 포함됨 writeContract에 request를 그대로 넘겨 불일치 위험 최소화 가스 수수료와 EIP-1559\n대부분 체인은 baseFee 기반의 maxFeePerGas, maxPriorityFeePerGas 조합 사용 시뮬레이션 결과를 그대로 쓰거나, 트래픽이 많은 시간대에는 우선순위 수수료를 다소 상향해 확정 속도 확보 BigInt와 단위 처리\nERC-20 amount, 수수료 모두 BigInt로 다룸 parseUnits, formatUnits 유틸 사용으로 10진 문자열과 wei 단위 간 변환 안정화 체인 불일치와 계정 네트워크\nwalletClient와 simulateContract의 chain은 동일해야 함 RPC URL이 다른 체인을 가리키면 nonce, 수수료, 시뮬레이션 결과가 어긋나 실패 가능 주의사항과 한계 개인키 보호\nPRIVATE_KEY는 서버 비밀 변수 관리 또는 HSM, KMS 연동 고려 프런트엔드 환경에 개인키 하드코딩 금지 RPC 신뢰도와 레이트 리밋\n공용 RPC는 속도와 가용성이 낮을 수 있음 상용 환경은 신뢰 가능한 제공자와 백업 엔드포인트 구성 권장 재시도와 오류 처리\n네트워크 에러, 서버 오류, 체인 재구성 등 다양한 실패 케이스 존재 지수 백오프, idempotency 고려, 트랜잭션 재전송 시 nonce 관리 필요 테스트넷과 가스\n테스트넷은 faucet 지급 지연, 빈 블록, 비활성 노드 등 특성이 존재 가스 부족, 체인 혼잡에 따른 확정 지연을 정상 동작 범위로 간주할 수 있어야 함 ABI 신뢰성\n오타 또는 잘못된 ABI는 런타임 revert를 유발함 배포된 바이트코드와 ABI 매칭 검증 권장 베스트 프랙티스 시뮬레이션 우선 전략\n모든 write 호출 전 simulateContract로 가스와 인자 검증 환경 변수 분리\nRPC_URL, PRIVATE_KEY, CONTRACT_ADDRESS를 환경 변수로 분리해 배포 환경별 설정 편의 확보 블록 간 일관성\n이벤트나 상태를 조합해 읽을 때는 동일 블록 높이 기준을 유지하는 스냅샷 전략 고려 멀티콜 활용\n여러 read를 묶어 왕복 비용 절감 가능 로깅과 관찰성\ntxHash, nonce, gasUsed, effectiveFeePerGas, 블록 번호를 구조화 로그로 남겨 운영 이슈 분석 용이성 확보 간단 예시로 보는 검증 흐름 writeContract에서 반환된 txHash 확인 체인 익스플로러에서 해당 txHash 조회로 블록 포함 여부, 리시트 상태, 이벤트 로그 검증 컨트랙트의 view 함수로 최종 상태 교차 확인 이 흐름을 자동화해 배치나 백엔드 작업에서 신뢰도 있는 완료 판정 기준으로 사용 가능\n마무리 Viem은 읽기와 쓰기 클라이언트 분리, 시뮬레이션 중심의 전송 흐름, 타입 안전한 ABI 접근이라는 명확한 철학을 가짐 이 기본기만 갖추면 블록 조회, 컨트랙트 읽기, 트랜잭션 생성이라는 세 가지 축을 빠르게 실무에 적용 가능 개인키와 RPC 관리, 시뮬레이션과 가스 전략, 오류 처리라는 운영 디테일을 함께 설계하면 프로덕션에서도 일관된 안정성을 확보할 수 있음\n참고자료 https://viem.sh/docs https://viem.sh/docs/clients/public https://viem.sh/docs/clients/wallet https://viem.sh/docs/actions/public/getBlock https://viem.sh/docs/contract/readContract https://viem.sh/docs/contract/writeContract https://ethereum.org/en/developers/docs/apis/json-rpc https://etherscan.io https://docs.alchemy.com/reference/ethereum-apis ","permalink":"https://handsupmin.github.io/posts/viem-ethereum-read-write-guide-4a5336/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eViem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임\nethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음\n프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리\u003c/p\u003e\n\u003ch3 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePublic Client\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트\u003c/li\u003e\n\u003cli\u003e블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWallet Client\u003c/p\u003e","title":"Viem으로 이더리움 읽기·쓰기 시작하기 가이드"},{"content":"개요 영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함 블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임 이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\n목적과 맥락 비밀을 공개하지 않고 유효성만 검증하려는 요구 증가 퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대 오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구 핵심 개념과 정의 Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체 Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체 Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식 Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명 Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제 Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립 영지식 증명의 세 가지 성질 완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨 건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤 영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함 직관적 예시 알리바바 동굴 동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음 검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함 Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2 k회 독립 반복하면 모두 속일 확률 2^-k로 급감 검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함 핵심 포인트\n비밀 노출 없이 유효성만 확인 가능 무작위 도전과 반복으로 사기 가능성 급감 대화 기록만으로 비밀 자체를 유추 불가 형식적 관점과 시뮬레이터 대화형 증명은 Prover P와 Verifier V가 커밋-챌린지-리스폰스 구조로 상호작용함 Transcript는 도전값과 응답 및 공개 상태를 포함하는 관찰 기록을 의미함 영지식성은 시뮬레이터 S가 비밀 없이도 실제와 분포가 같은 Transcript를 생성할 수 있음을 요구함 의미는 검증자가 얻은 정보가 공개 난수로도 재현 가능한 수준에 한정됨을 보장한다는 것임 사전 공모 이슈와 설계 포인트 대화형 프로토콜에선 검증자와 Prover가 사전 공모했다면 제3자는 배제 불가 이슈가 생김 이 경우를 지정 검증자 영지식 designated-verifier ZK로 분류 가능 공개 검증이 필요하면 비대화형 영지식 NIZK 또는 공개 검증 가능한 Σ-프로토콜 조합을 사용해 누구나 검증 가능하게 설계 필요 Fiat–Shamir 변환으로 도전값을 해시로 결정하면 제3자도 단일 증명을 검증 가능 운영 시 검증자의 내부 시드나 도전값 생성 과정을 과도하게 공개하면 지정 검증자 시나리오의 영지식성이 약화될 수 있음 대화형과 비대화형 대화형 Interactive 실시간으로 도전과 응답을 주고받는 구조. 장점은 단순성과 강한 보안 모델. 단점은 왕복 상호작용과 제3자 설득 한계 가능 비대화형 Non-Interactive 하나의 짧은 증명을 생성해 누구나 검증. Fiat–Shamir로 대화형 도전을 해시로 대체. SNARK와 STARK 등에서 표준 사용 트레이드오프 네트워크 왕복 제거와 공개 검증 가능성 vs 해시를 랜덤 오라클로 보는 가정과 경우에 따라 신뢰 설정 필요 디지털 서명과의 차이 신원 노출 서명은 공개키로 서명자 신원이 구조적으로 드러남. ZK는 신원과 비밀 모두 숨기고 유효성만 증명 가능 제3자 설득 서명은 메시지-서명 쌍을 누구나 검증 가능해 완전 설득 지향. ZK도 NIZK나 공개 검증 가능한 구성에선 제3자 설득 가능. 다만 지정 검증자 ZK에선 제3자 설득이 제한됨 프록시 릴레이 공격 대화형 식별 프로토콜은 중간자 릴레이 공격 위험 존재. 세션 바인딩과 채널 인증, 도전값 바인딩으로 완화 필요. 서명은 보통 프로토콜 레벨 인증과 채널 보안으로 대응 연결 고리 Σ-프로토콜에 Fiat–Shamir를 적용하면 서명 스킴으로 전환 가능. 대표가 Schnorr 서명임 ZKP Under the Hood 이산로그 기반 Σ-프로토콜 가장 고전적인 지식증명은 이산로그 가정 위에서 동작함 공통 입력 y = g^x mod p에서 x가 비밀이며 Prover는 x를 안다는 사실을 증명함\n기본 설정 큰 소수 p와 생성원 g를 가진 소수 차수 q 부분군 선택. 연산은 지수에서 mod q로 수행 공통 값 y = g^x mod p는 공개. x는 Prover만 아는 비밀 1비트 챌린지 버전 직관 커밋 Prover가 임의의 r를 뽑아 C = g^r mod p 전송 챌린지 Verifier가 z ∈ {0,1} 전송 응답 z = 0이면 r 공개. z = 1이면 s = r + x mod q 공개 검증 z = 0이면 g^r ≟ C 확인. z = 1이면 g^s ≟ C · y 확인 Prover가 x를 모르면 두 경우를 동시에 만족시키는 응답을 준비 불가. 1회 속임 확률 1/2. k회 반복 시 2^-k로 감소 일반화된 Schnorr 식별 프로토콜 도전값 c를 Z_q에서 무작위 선택 커밋 C = g^r 응답 s = r + c·x mod q 검증 g^s ≟ C · y^c 비대화형으로는 c = H(domain, context, g, y, C)로 정하고 단일 증명을 생성함. 여기서 H는 도메인 분리와 컨텍스트 바인딩을 포함한 해시 함수이며 랜덤 오라클 가정 하에서 분석함 주의사항 안전한 구현은 군 차수 q 기준으로 지수 연산 수행 필요 r은 CSPRNG로 매 증명마다 새로 생성. r 재사용은 즉시 비밀 유출로 이어짐 해시 입력엔 도메인 분리 태그와 세션 ID, 검증자 식별 등 컨텍스트를 바인딩해 재생 공격과 교차 프로토콜 간섭을 방지 필요 간단 검증 스니펫 예시 아래는 원리 전달용 최소 형태임. 실제 구현에선 안전한 군 선택, 상수시간 연산, 에러 처리 포함 필요\n## 공개 파라미터 p, g, y와 커밋 C, 도전 z, 응답 resp를 검증하는 예시 def verify_one_bit(p, g, y, C, z, resp): if z == 0: ## resp == r return pow(g, resp, p) == C else: ## resp == s = r + x mod q return pow(g, resp, p) == (C * y) % p def verify_schnorr(p, g, y, C, c, s): ## 일반형 검증식 g^s == C * y^c mod p left = pow(g, s, p) right = (C * pow(y, c, p)) % p return left == right 확률적 보장과 파라미터 선택 1회 속임 확률은 1 / |ChallengeSpace| 임 1비트 도전이면 1/2. k회 독립 반복 시 2^-k로 수렴 NIZK나 공개 검증에서는 도전 공간을 128비트 이상으로 설정해 단일 증명으로 충분한 사운드니스 확보 권장 블록체인 환경에서는 검증 비용과 증명 크기, 사운드니스 비트를 함께 고려해 회로 크기와 파라미터를 선택 필요 설계 포인트와 운영 수칙 그룹과 곡선 선택 secp256k1, P-256, BLS12-381, Bandersnatch, ristretto255 등 표준 계열 우선 고려 난수 생성 CSPRNG 필수. 커밋 nonce r 재사용 금지. 시스템 RNG 품질 모니터링 필요 파라미터 바인딩 도전 해시에 프로토콜 식별자, 세션 ID, 검증자 식별 또는 채널 특성 포함해 세션 고정 효과 확보 트랜스크립트 관리 지정 검증자 시나리오에서는 불필요한 내부 난수 공개를 줄임. 공개 검증 목표면 처음부터 NIZK 또는 SNARK류 선택 부채널 대응 타이밍 누수와 캐시 기반 누수에 대비해 상수시간 구현과 블라인딩 적용 리플레이 및 릴레이 방지 세션 바인딩, nonce, 타임스탬프, 채널 인증 적용 회귀 방지 회로나 명세 변경 시 검증 규칙에 대한 테스트 자동화와 호환성 체크 필요 SNARK vs STARK vs Bulletproofs 한눈 비교 항목 SNARK STARK Bulletproofs 설정 일부 시스템 신뢰 설정 필요. Plonk류는 범용 SRS 가능 투명 설정. 신뢰 설정 불요 신뢰 설정 불요 증명 크기 매우 작음 수십 바이트 수준까지 가능 비교적 큼 수십 KB 이상 로그 크기. 범위증명은 수 KB 수준 검증 비용 빠름. 온체인 친화적 보통에서 빠름. 해시 중심 검증 비용 큼. 집계로 완화 가능 보안 가정 페어링과 다항식 약속 등 수학적 가정 해시 기반 IOP와 FRI. 포스트 양자 내성 기대 내적 논증 기반. 일반군 가정 활용 예 zkEVM, 롤업, 영지식 브리지 투명한 롤업, 대규모 추적 증명 범위증명, UTXO 프라이버시 각 계열의 실제 성능은 구현과 회로 구조, 하드웨어에 크게 의존함\n블록체인 적용 예 잔액과 금액을 숨긴 비공개 전송과 감사 가능성 확보 신원 속성 최소 공개 KYC 예 나이 이상 여부만 증명 영지식 롤업 상태 전개 증명과 데이터 가용성 보완 오라클 입력의 유효성 증명과 오프체인 계산 검증 MPC와 결합한 다자 프라이버시 계산의 결과 정합성 증명 자주 묻는 질문 ZK면 항상 제3자 설득 불가임? 아님. NIZK나 공개 검증 가능한 구성에선 누구나 검증 가능함 STARK는 포스트 양자 보안 보장임? 양자에 대해 알려진 공격이 약하다는 의미의 내성 기대 수준임. 수학적 증명된 보장은 아님 왜 r 재사용이 위험함? 서로 다른 도전에 같은 r을 쓰면 x가 선형식으로 노출됨 왜 q 모듈러를 강조함? 안전한 지수 연산의 정의역은 군 차수 q이기 때문임. p-1 전역 모듈러는 안전하지 않을 수 있음 검증과 회귀 방지 체크리스트 사운드니스 목표 비트와 도전 공간이 요구 수준 충족하는지 점검 난수 생성 모듈 품질과 시드 관리 상태 감사 도메인 분리 태그와 세션 ID가 해시 입력에 포함되는지 확인 재생 공격과 프록시 릴레이 가능성에 대한 테스트와 채널 인증 적용 상수시간 연산 준수 여부와 메모리 접근 패턴 누수 점검 회로 변경 시 검증 규칙 스냅샷과 회귀 테스트 자동화 마무리 영지식 증명은 비밀을 드러내지 않고도 유효성을 설득하는 체계임 완전성-건전성-영지식성의 삼각을 이해하고 대화형과 비대화형의 차이를 파악하면 설계 선택이 명확해짐 실무에서는 안전한 군 선택과 난수, 도전 공간 크기, 세션 및 채널 바인딩, 신뢰 설정과 부채널 대응을 종합적으로 관리 필요 목표는 비밀을 지키면서도 누구나 또는 지정된 상대가 납득할 수 있는 검증 가능한 시스템을 만드는 것임\n참고 링크 https://en.wikipedia.org/wiki/Zero-knowledge_proof https://en.wikipedia.org/wiki/Interactive_proof_system https://en.wikipedia.org/wiki/Schnorr_identification https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic https://en.wikipedia.org/wiki/SNARK https://en.wikipedia.org/wiki/STARK_(cryptography) https://en.wikipedia.org/wiki/Bulletproofs https://hyun-jeong.medium.com ","permalink":"https://handsupmin.github.io/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함\n블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임\n이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함\u003c/p\u003e\n\u003ch2 id=\"목적과-맥락\"\u003e목적과 맥락\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e비밀을 공개하지 않고 유효성만 검증하려는 요구 증가\u003c/li\u003e\n\u003cli\u003e퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대\u003c/li\u003e\n\u003cli\u003e오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"핵심-개념과-정의\"\u003e핵심 개념과 정의\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eProver 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체\u003c/li\u003e\n\u003cli\u003eVerifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체\u003c/li\u003e\n\u003cli\u003eWitness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식\u003c/li\u003e\n\u003cli\u003eStatement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명\u003c/li\u003e\n\u003cli\u003eChallenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제\u003c/li\u003e\n\u003cli\u003eTranscript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"영지식-증명의-세-가지-성질\"\u003e영지식 증명의 세 가지 성질\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨\u003c/li\u003e\n\u003cli\u003e건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤\u003c/li\u003e\n\u003cli\u003e영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"직관적-예시-알리바바-동굴\"\u003e직관적 예시 알리바바 동굴\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음\u003c/li\u003e\n\u003cli\u003e검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함\u003c/li\u003e\n\u003cli\u003eProver가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2\u003c/li\u003e\n\u003cli\u003ek회 독립 반복하면 모두 속일 확률 2^-k로 급감\u003c/li\u003e\n\u003cli\u003e검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e핵심 포인트\u003c/p\u003e","title":"영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이"},{"content":"개념과 배경 Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함 짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨 노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\n핵심 용어 정리 스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\n오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\n리오그 깊이 교체되는 블록의 개수로 측정함\n메인 체인 선택 규칙\nPoW에선 누적 작업량이 큰 체인이 우선됨 이더리움 PoS에선 LMD-GHOST 포크초이스를 따르되 마지막 최종화 지점 하위만 후보가 됨 왜 리오그가 생김 네트워크 지연이나 전파 경합으로 같은 높이의 블록이 동시에 생성됨 일부 노드는 A를, 다른 노드는 B를 바탕으로 다음 블록을 쌓음 시간이 지나 우세한 체인이 결정되면 노드가 그 체인으로 교체함 버려진 체인의 트랜잭션은 소실되는 게 아니라 다시 메모풀로 돌아가 재포함을 기다림 합의별 리오그의 차이 PoW 계열 직관 우세 체인 기준은 블록 수가 아니라 누적 작업량임 자연 발생 리오그는 보통 깊이 1에서 끝남 보안 관례로 비트코인은 6컨펌 정도를 사람·서비스가 안전 구간으로 삼는 경우가 많음 다수 해시 파워를 가진 상대는 더 깊은 리오그를 인위적으로 만들 수 있으므로 고가치 결제일수록 더 많은 컨펌을 기다리는 전략이 쓰임 이더리움 PoS 직관 슬롯은 12초, 32슬롯이 1에폭이며 포크초이스는 LMD-GHOST와 FFG 최종화 규칙을 함께 사용함 헤드는 가장 최근 가중치가 높은 체인 머리, 세이프 헤드는 보수적 추정, 파이널라이즈드는 FFG로 최종화된 체크포인트 아래 체인 상태를 뜻함 정상 조건에선 리오그 깊이가 작고 파이널라이즈드 이후로의 리오그는 대규모 비정상 행동 없이는 사실상 불가에 가까움 대략 두 개의 에폭이 지나면 보통 최종화되어 실사용에선 약 12분 남짓을 강한 확정 구간으로 본다는 관례가 있음 환경과 네트워크 상황에 따라 달라질 수 있음 L2에서의 리오그 관점 L2→L1 메시지는 L1에 기록되고 관련 규칙을 충족하면 재전송하지 않음 옵티미스틱 롤업은 챌린지 윈도우가 지나야 강한 확정으로 취급하며 그 전에는 지연을 감안해야 함 L1이 뒤집히는 아주 이례적인 상황을 제외하면 L1에 최종적으로 기록된 상태는 다시 뒤집히지 않는다는 점을 전제로 시스템을 설계함 리오그와 헷갈리기 쉬운 것들 RBF나 수수료 경쟁으로 인해 메모풀에서 트랜잭션이 교체되는 현상은 리오그와 별개임 프로토콜 업그레이드를 위한 하드포크는 합의 규칙 자체를 바꾸는 이벤트이며 자연 발생 리오그와는 범주가 다름 과거 이더리움 PoW 시절의 옴머 포함은 스테일 블록 보상 메커니즘일 뿐 리오그 자체가 아님 서비스 설계에 미치는 영향 결제와 출금\n자산·위험도·체인별로 컨펌 수 정책을 문서화해 운영함 고가치 결제는 더 많은 컨펌을 요구하고 저가치·소액은 사용자 경험을 위해 낮출 수 있음 데이터 처리\n인덱싱은 높이만 저장하지 말고 블록 해시와 부모 해시를 함께 저장 리오그 감지 시 롤백 가능한 저널을 두고 되감기 후 재처리 트랜잭션 처리\n멱등성 확보를 위해 논스·컨트랙트 상태·이벤트 ID를 함께 검증 재방송은 동일 논스로 수행해 중복 실행을 피함 UX\n잠정 상태 표시와 컨펌 카운터 제공 세이프 헤드와 파이널라이즈드의 차이를 사용자에게 명확히 안내 리오그 감지와 대응 패턴 헤드 해시 변화 모니터링과 특정 깊이 이상 변화시 경보\n최신 N개 블록의 체인ID·높이·해시·부모 해시·도착 시각을 원장과 별도 테이블에 윈도우로 관리\n확정 레벨별로 파이프라인을 분기\n헤드 기준 실시간 기능 세이프 기준 중요 알림 파이널 기준 영구 저장 간단 의사코드\nonNewBlock(b): save(b.height, b.hash, b.parent) if parentNotHead(): // reorg 발생 rollbackUntilCommonAncestor() replayFromAncestor() routePipelinesByCommitment(head, safe, finalized) 운영 체크리스트 컨펌 정책과 리오그 최대 허용 깊도가 문서화되어 있음 인덱서가 롤백과 재처리를 지원함 알림 시스템이 헤드 전환과 리오그 이벤트를 기록함 파이널라이즈드 구간만 영구 저장하거나 백그라운드 확정화 작업을 운영함 L2의 챌린지 윈도우와 브리지 지연을 고려해 타임라인을 설계함 간단 시나리오 한국과 미국에서 같은 높이 블록이 동시에 생성됨 각 지역 노드가 자신이 먼저 본 블록 위로 다음 블록을 쌓음 한쪽 체인이 한 블록 더 빨리 쌓이며 우세해지면 다른 쪽은 스테일 처리됨 스테일 체인에 있던 거래는 메모풀로 돌아가 메인 체인에 재포함을 기다림\n참고자료 https://en.bitcoin.it/wiki/Chain_Reorganization?utm_source=chatgpt.com https://learnmeabitcoin.com/technical/blockchain/chain-reorganization/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/?utm_source=chatgpt.com https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/?utm_source=chatgpt.com https://www.alchemy.com/overviews/ethereum-commitment-levels?utm_source=chatgpt.com ","permalink":"https://handsupmin.github.io/posts/blockchain-reorg-chain-reorganization-f4966a/","summary":"\u003ch2 id=\"개념과-배경\"\u003e개념과 배경\u003c/h2\u003e\n\u003cp\u003eReorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함\n짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨\n노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함\u003c/p\u003e\n\u003ch2 id=\"핵심-용어-정리\"\u003e핵심 용어 정리\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e스테일 블록 best chain에 편입되지 못한 정상 블록을 말함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음\u003c/p\u003e","title":"블록체인 Reorg(체인 재구성) 이해"},{"content":"개요 프라이빗키 관리 방식에 따라 암호화폐 월렛은 커스토디얼(custodial) 과 논커스토디얼(noncustodial) 로 구분됨 각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 초보자도 이해할 수 있게 정리하면서 실무자가 바로 적용할 수 있는 체크리스트까지 제시함\n핵심 개념 커스토디얼 월렛 제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조 로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\n논커스토디얼 월렛 사용자가 프라이빗키를 직접 보유·관리하는 구조 브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\n핵심 차이 한 줄 정리 키의 소유·통제 주체가 제3자인가 사용자 본인인가의 차이\n모델별 동작 원리와 구성 커스토디얼 키 보관 중앙화된 키 보관소와 접근제어 체계를 운용 보통 핫월렛 과 콜드월렛 을 분리해 즉시성 vs 보관 안정성을 균형 있게 설계함 운영 통제 권한 분리, 변경 이력 추적, 승인 워크플로, 이상 징후 모니터링을 포함 유저 경험 계정 비밀번호·2FA 등 웹서비스 UX에 가깝고 분실 시 고객지원으로 복구 가능성이 있음 논커스토디얼 키 생성·저장·복구를 사용자 단말 또는 전용 기기에서 수행 하드웨어 지갑은 기기 내 보안영역에서 서명 연산을 수행해 키를 외부로 노출하지 않음 시드 문구(BIP‑39) 와 HD 지갑(BIP‑32, BIP‑44) 로 여러 주소를 파생해 사용함 분실·도난·손상에 대비한 백업·복구 절차가 필수임 하이브리드 접근 멀티시그 N개 중 M개 서명이 있어야 지출 가능 운영자 간 책임 분산과 단일 키 손실 리스크 완화에 효과적 키 분할과 복구 Shamir Secret Sharing 은 백업·복구에 적합하나 서명 자체는 수행하지 않음 임계값 서명(MPC/TSS) 여러 파티가 키 조각을 재조합 없이 공동 서명 단일 실패 지점 제거와 유연한 권한 정책이 장점 보안·규제·운영 관점 비교 구분 커스토디얼 논커스토디얼 키 소유 서비스 사업자 사용자 복구 용이성 계정 기반 복구 지원 가능 사용자가 책임, 백업 실패 시 복구 불가 보안 초점 내부자 위협·핫월렛 침해·운영 취약점 피싱·악성코드·물리 분실·백업 실패 컴플라이언스 관할에 따라 수탁 라이선스·KYC/AML 등 요구 가능 개인 사용은 상대적으로 자유, 조직은 회계·규정 준수 정책 필요 확장성/운영 기업 통제·감사 로그·승인 워크플로에 유리 사용자 자율성 최상, 표준화된 기업 통제는 구현 난이도 존재 일반 용도 거래소·커스터디 업체·핀테크 개인 보관·DAO 금고·개별 팀 지갑 위협 모델 수립 가이드 가치와 빈도 소액·빈번 결제는 접근성·자동화 우선, 대액·장기 보관은 보존·격리가 우선 공격면 피싱 링크·악성 확장프로그램·사기 승인 서명, 내부자 오남용, 인프라 취약점, 물리적 분실 복구 요구 사람 교체·기기 손상·지역 재해 등 현실 시나리오에서 얼마나 빨리 복구 가능한지 평가 감사 가능성 로그 불변성·승인 이력·역활분리와 규정 준수 증빙 가능성 점검 커스토디얼 선택 체크리스트 운영 보안 핫·콜드 분리, 다중인증, 권한 분리, 변경관리, 침해사고 대응 계획 보유 여부 키 관리 체계 HSM 또는 동급 보안 모듈 사용, 키 생성·보관·회전 절차 문서화, 접근 통제 로그 유지 감사·인증 SOC 2 Type II, ISO/IEC 27001, 취약점 스캐닝·모의침투 주기 운영 여부 재무·보험 보험 범위와 면책 조항을 명확히 공개하는지, 준비금·준법 체계 확인 규제 준수 관할 내 라이선스·KYC/AML 의무 이행, 제재 대응 정책 보유 논커스토디얼 선택 체크리스트 백업·복구 시드 문구 오프라인 보관, 금고·내화 금속 플레이트 등 물리 보안, 복구 리허설 정기 수행 기기 보안 하드웨어 지갑 사용, 펌웨어 서명 검증, 기기 PIN·패스프레이즈 사용, 분실 시 스스로 wipe 가능한지 확인 트랜잭션 안전 서명 전 도메인 분리 정보를 기기 화면에서 직접 확인, 승인 범위·스팸 토큰·허가 영속성 점검 멀티시그·MPC 병용 단일 키 실패 지점 제거, 역할 기반 승인 정책 적용 자동화 요구 스케줄 결제·트리거 송금 등 자동화는 지갑 권한 최소화와 일회성 권한 부여로 제한 운영 베스트 프랙티스 핵심 원칙 최소 권한, 강한 인증, 분리 보관, 반복 검증 지출 정책 금액 구간별 다른 승인 경로 적용, 시간지연 타임락과 알림으로 오탐·오남용 방지 주소 화이트리스트 높은 금액은 사전 등록 주소로만 송금 모니터링 대기열 이상, 실패율 급증, 신규 승인 요청 급증, 지출 한도 임계 접근 알림 키 수명주기 관리 생성·배포·사용·보관·회수·폐기 전 과정 문서화와 정기 점검 사고 대응 유출 의심 즉시 키 회전, 멀티시그 참여자 교체, 브리지·거래소 연락망 업데이트, 법무·준법 협업 라인 확보 시나리오별 권장 아키텍처 개인 사용자 데일리 소액은 모바일 지갑 사용 장기 보관·대액은 하드웨어 지갑과 오프라인 백업 병행 승인 내역 정기 점검과 피싱 훈련 연습 권장\n소규모 팀/스타트업 운영비 지출용 커스토디얼 핫월렛 + 멀티시그 콜드 보관 회계·승인 로그를 공유 드라이브가 아닌 전용 감사 시스템에 적재\n기업·DAO 금고 MPC 기반 금고 또는 다중 하드웨어 지갑 멀티시그 역할 기반 접근제어와 오프보딩 절차, 비상 시나리오의 대체 서명자 지정\n자주 하는 실수와 교정 Shamir 분할 = 안전한 서명이라고 오해 Shamir는 복구용 비밀 분할 기법이고 서명은 수행하지 않음 서명 분산은 MPC/TSS 를 사용함 하드웨어 지갑이면 무조건 안전 펌웨어 진위 검증, 공급망 위협, 화면 검증 습관 없으면 위험이 남음 보험이 있으니 안심 보험은 조건과 면책이 많아 모든 손실을 보장하지 않음 범위·상한·예외를 반드시 확인해야 함 커스토디얼은 모두 동일 보안 수준·감사 성숙도·규제 준수·재무 건전성에 큰 차이가 있음 최소 보안 기준 가이드 개인 하드웨어 지갑 1대 이상, 시드 문구 오프라인 백업 2곳, 패스프레이즈 병행, 피싱 훈련 팀 멀티시그 M‑of‑N, 변경 승인 워크플로, 월간 복구 리허설, 화이트리스트 송금 기업 MPC 금고 또는 멀티시그 금고, HSM 또는 동급 보안 모듈, SOC 2 Type II·침투테스트, 사고 대응 플레이북 운영 간단 권장 흐름 1 단계 자산 규모 분류와 위협 모델 정의 2 단계 논커스토디얼·커스토디얼·하이브리드 중 적합 아키텍처 선정 3 단계 백업·복구 문서화와 정기 리허설 시행 4 단계 멀티시그 또는 MPC로 단일 실패 지점 제거 5 단계 지출 정책·화이트리스트·모니터링·사고 대응 체계 운영\n결론 프라이빗키 소유·통제가 보안과 편의의 출발점임 대액·장기 자산은 논커스토디얼과 멀티시그·MPC 조합이 유리하고 업무 자동화·고객 지원이 중요한 경우 커스토디얼이 효율적일 수 있음 모든 선택은 위협 모델·규정 준수·복구 요구를 기준으로 문서화하고 정기적으로 검증해야 함\n참고자료 BIP‑32 계층적 결정성 지갑 https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP‑39 니모닉 문구 https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP‑44 파생 경로 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki Torus Key Infrastructure 개요 https://docs.tor.us/key-infrastructure/overview NIST SP 800‑57 Part 1 키 관리 권고 https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final FIPS 140‑3 암호 모듈 보안 요구사항 https://csrc.nist.gov/publications/detail/fips/140/3/final AICPA SOC 2 안내 https://www.aicpa-cima.com/resources/article/what-is-soc-2 ","permalink":"https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e프라이빗키 관리 방식에 따라 암호화폐 월렛은 \u003cstrong\u003e커스토디얼(custodial)\u003c/strong\u003e 과 \u003cstrong\u003e논커스토디얼(noncustodial)\u003c/strong\u003e 로 구분됨\n각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 \u003cstrong\u003e초보자도 이해할 수 있게\u003c/strong\u003e 정리하면서 \u003cstrong\u003e실무자가 바로 적용할 수 있는 체크리스트\u003c/strong\u003e까지 제시함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념\"\u003e핵심 개념\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e커스토디얼 월렛\u003c/strong\u003e\n제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조\n로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e논커스토디얼 월렛\u003c/strong\u003e\n사용자가 프라이빗키를 직접 보유·관리하는 구조\n브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e핵심 차이 한 줄 정리\u003c/strong\u003e\n키의 \u003cstrong\u003e소유·통제 주체\u003c/strong\u003e가 제3자인가 사용자 본인인가의 차이\u003c/p\u003e","title":"커스토디얼 vs 논커스토디얼 월렛 비교"},{"content":"개요 블록체인은 중앙 기관 없이 참여자들이 거래를 기록·검증·공유하는 분산 원장 기술임 이 글은 블록체인을 초보자 친화적으로 설명하고, 실무 체크리스트까지 정리함\n큰 그림: 시스템 구성 노드(Node): 블록체인 소프트웨어 실행 주체\n풀노드: 모든 블록·트랜잭션 검증·저장 라이트 클라이언트: 헤더·머클 증명 기반 최소 검증 (참고) 아카이브 노드: 오래된 상태 포함 전체 상태 유지(필수 아님) 블록(Block): 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\n합의(Consensus): 어떤 블록이 정식 이력인지 네트워크가 공동으로 결정하는 규칙\nPoW: 작업증명(연산 경쟁) PoS: 지분증명(검증자·보증금 기반) 해시(Hash)와 위·변조 방지 해시 함수(SHA-256, Keccak-256 등): 입력을 고정 길이로 압축하는 일방향 함수임\n충돌 가능성은 이론상 존재하나 실무적으로 극히 낮음 입력이 조금만 바뀌어도 출력이 크게 달라져 무결성 검증에 적합 체인 무결성: 각 블록 헤더에 이전 블록의 해시가 포함됨 → 중간 블록 하나만 바꿔도 이후 전체를 재계산해야 하므로 변조 난이도 매우 높음\n블록헤더와 머클트리(데이터 구조) 블록헤더 대표 필드(비트코인 예시)\nversion, prev_block_hash, merkle_root, timestamp, bits(난이도), nonce 헤더 전체를 해시한 값이 블록 ID 역할을 함 머클트리(Merkle Tree)\n트랜잭션 목록을 해시 이진트리로 요약 → 머클루트(루트 해시) 로 대표 라이트 클라이언트는 머클 증명만 받아 특정 트랜잭션 포함 여부를 검증 가능(SPV) 거래 흐름: 생성 → 서명 → 전파 → 블록 포함 → 확정 생성: 송신자가 수신자 주소·금액으로 트랜잭션 생성 서명: 개인키로 전자서명(비대칭키: ECDSA/secp256k1 등) 전파: P2P 네트워크로 브로드캐스트 → 각 노드의 mempool 에 적재 블록 포함: 합의 규칙에 따라 트랜잭션이 블록에 포함 확정(Finality/확인수): 후속 블록이 더해질수록 되돌리기 어려움 비트코인: 평균 블록 간격 ≈ 10분, 확인수 6 관행(사용처·금액 따라 상이) 이더리움(현행 PoS): 슬롯 ≈ 12초, 체크포인트·파이널리티 개념 사용(정상 시 약 2 에폭에서 최종화, 대략 10~15분 수준). “N 블록이면 충분” 같은 단정 대신 파이널리티 달성 여부 확인이 안전함 상태 모델: UTXO vs 계정(Account) UTXO(비트코인 계열)\n“사용하지 않은 트랜잭션 출력(코인)”을 조합해 지불, 잔돈은 새 UTXO로 생성 장점: 병렬화에 유리, 프라이버시 패턴 일부 이점 유의: 선택/잔돈 전략, 수수료(단위: sat/vByte) 최적화 필요 계정 모델(이더리움 계열)\n계정 잔액·컨트랙트 상태(State) 갱신 장점: 스마트 컨트랙트·상태머신 구현 용이 유의: 상태 증가(State bloat)·가스 비용·리플레이 방지(EIP-155) 등 고려 PoW(작업증명): 난이도·보상·보안 원리: 헤더 + nonce 바꿔가며 목표값(난이도) 이하 해시 찾기 난이도 조정: 네트워크 해시파워 변화에 맞춰 목표 평균 블록 시간 유지(예: 비트코인 2016블록마다 ≈ 2주 간격 조정) 보상: 블록 보상(반감기 존재) + 수수료 보안성: 공격자는 네트워크 해시의 과반수 수준 필요 → 대형 체인에서는 경제적·물리적 비용 거대 간단 PoW 의사코드(개념 학습용)\ntarget = difficulty_to_target(bits) nonce = 0 while True: header = serialize(version, prev_hash, merkle_root, timestamp, bits, nonce) h = sha256d(header) # SHA256(SHA256(header)) if h \u0026lt; target: print(\u0026#34;Found!\u0026#34;, nonce, h.hex()) break nonce += 1 실무 팁\n해시 라이브러리·엔디언 처리·직렬화 포맷(가변 길이 정수 등) 정확도 중요 반감기 이벤트는 채굴 수익성·해시파워·보안에 직격 영향 PoS(지분증명): 검증자·파이널리티·리스크 원리: 토큰 스테이킹 으로 검증자 선정(무작위 + 지분 가중 + 추가 규칙)\n블록·어테스테이션: 검증자가 블록 제안·감사(투표) 수행\n파이널리티: 일정 조건(예: ≥ 2/3 가중치가 찬성) 만족 시 체크포인트 최종화\n위협 모델\nNothing-at-Stake: 여러 체인에 동시 투표 유혹 → 슬래싱 으로 억제 롱레인지 공격: 과거부터 조용히 대체 체인 생성 → 약한 주관성(weak subjectivity)·체크포인트·동기화 규칙으로 방어 수수료와 가스: Bitcoin vs Ethereum Bitcoin: 수수료 = 바이트 크기 × 단가(sat/vByte)\n수수료 추정은 mempool 혼잡도·정책 영향 큼 Ethereum(EIP-1559)\nBase Fee(블록에 의해 자동 조정, 소각) + Priority Fee(팁) + gas_used 사용자 입장: 예상 가능한 수수료 + 혼잡 시 팁으로 우선순위 확보 컨트랙트 호출은 가스 한도 내에서만 실행됨(한도 부족 시 revert) 포크(Fork)와 체인 재조직(Reorg) 소프트 포크: 규칙 강화로 하위 호환 유지(예: SegWit 트랜잭션 가변성 해결, 블록 용량 효율화) 하드 포크: 규칙 불일치 → 미업데이트 노드와 체인 분리 가능(예: ETH/ETC) 운영 유의\n포크 전후 송금 보수적 운영(리플레이·정책 불확실성) 거래소·지갑 대응 계획 사전 확인 자연스런 재조직(reorg) 는 드물지만 발생 가능 → 높은 가치 송금은 여유 확인수/파이널리티 확보 보안 메커니즘·공격 모델 51% 공격(PoW): 과반 해시파워로 더 긴 체인을 만들어 이중지불 가능\n대형 체인: 비용·탐지 리스크 막대 중소 체인: 실질 리스크 존재 → 심도 있는 모니터링·안전 확인수 확대 권장 네트워크 공격: 이클립스(Eclipse)·Sybil·시간 왜곡 등 → 피어 다양화·시계 동기화·피어 밴 정책 필요\n지갑·키 관리\n개인키 유출 = 자금 유출 권장: 하드웨어 지갑, 멀티시그, 콜드월렛, 백업 시 BIP39 시드 문구 별도·오프라인 보관 확장성: 온체인 한계와 오프체인/Layer2 온체인 한계: 블록 크기·주기 제약 → TPS 제한, 탈중앙화·보안·확장성(블록체인 트릴레마) 간 트레이드오프 존재\n오프체인 결제(라이트닝 네트워크)\n양자 간 결제 채널 열고 다수 거래를 오프체인 처리, 최종 상태만 온체인 정산 핵심 메커니즘: 타임락, 페널티 트랜잭션, 경로 탐색 장점: 속도·수수료 우수 / 과제: UX·유동성·라우팅 Rollup(이더리움 L2)\nOptimistic Rollup: 사기 증명 기반, 이의제기 기간 후 확정 ZK Rollup: 영지식 증명 기반, 검증 빠름(증명 생성 비용·지연 고려) 데이터 가용성(DA): L1에 핵심 데이터 또는 블롭(EIP-4844) 으로 게시 → L2 상태 재구성 가능성 확보 로드맵: 프로토-덴크샤딩(EIP-4844) → 데이터 비용 절감, 장기적으론 완전 덴크샤딩으로 확장성 개선 MEV \u0026amp; PBS(이더리움)\nMEV: 거래 재배치·추출을 통한 가치 → 사용성·공정성 이슈 PBS: 제안자/빌더 분리로 역할 분담, 중앙화·검열 리스크 완화 시도 실무 체크리스트(운영·보안·개발) 노드 운영\n최신 클라이언트·보안 패치 적용, 피어 다변화 모니터링: 블록 지연, reorg, mempool 혼잡, 디스크/네트워크 지표 지갑·키 관리\n하드웨어 지갑·멀티시그·콜드스토리지 적용 시드 백업(오프라인), 접근 통제(2인 승인 등) 스마트 컨트랙트(이더리움)\n감사(Audit)·포멀 검증·테스트넷 충분 운용 가스 최적화: 저장소 쓰기 최소화, 재진입·정수 오버플로 방지, 최신 컴파일러 사용 업그레이드 전략: 프록시 패턴·권한 관리(Owner/Role)·타임락 수수료 전략\nBitcoin: sat/vByte 동적 설정, 급행·보통·저속 정책 분리 Ethereum: EIP-1559의 maxFeePerGas/maxPriorityFeePerGas 합리 설정 포크·네트워크 이벤트 대응\n공지 수집, 송금 동결/완화 기준, 고객 안내 시나리오 준비 간단 비교 표 항목 비트코인(PoW) 이더리움(PoS, Merge 이후) 블록 간격 ~10분 슬롯 ~12초(에폭=32 슬롯) 최종성 확률적(확인수↑) 체크포인트 최종성(정상 시 2 에폭 내외) 수수료 바이트 기준(sat/vByte) EIP-1559(BaseFee 소각 + Tip) 상태 모델 UTXO 계정 + 스마트 컨트랙트 확장성 방향 SegWit·Taproot·Lightning Rollup(Optimistic/ZK) + EIP-4844 자주 틀리는 포인트 “이더리움은 N 블록이면 안전” → (X) 현재는 파이널리티 달성 여부로 판단하는 게 정확함 “PoS는 그냥 코인 많이 가진 사람 승리” → (X) 무작위성·메시지 투표·슬래싱·최종성 규칙이 결합된 프로토콜 전체가 보안 근거임 “SegWit은 리플레이 공격 방지” → (부분 부정확) 핵심 목적은 트랜잭션 가변성(malleability) 해결 및 용량 효율화임 결론 블록체인은 암호학(해시·서명), 분산합의(PoW/PoS), 네트워크 설계가 맞물린 시스템임 설계 선택(PoW vs PoS, UTXO vs 계정, 온체인 vs 오프체인)이 보안·성능·분산화에 직접 영향 실무 핵심은 키 관리·노드 보안·포크/이벤트 대응·수수료 전략·컨트랙트 품질 보증임 확장성은 Layer2 + 데이터 가용성 + 프로토콜 개선을 병행하는 다층 해법이 현실적임 참고자료 비트코인 개요: https://bitcoin.org/ko/how-it-works 비트코인 개발자 가이드(데이터 구조·프로토콜): https://developer.bitcoin.org/devguide/ 이더리움 화이트페이퍼: https://ethereum.org/en/whitepaper/ 이더리움 PoS/합의 문서: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ EIP-1559(수수료 시장): https://eips.ethereum.org/EIPS/eip-1559 EIP-4844(프로토-덴크샤딩/블롭): https://eips.ethereum.org/EIPS/eip-4844 Lightning BOLT 사양: https://github.com/lightning/bolts SegWit 개요(트랜잭션 가변성 개선): https://bitcoinops.org/en/topics/segwit/ ","permalink":"https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인은 \u003cstrong\u003e중앙 기관 없이\u003c/strong\u003e 참여자들이 거래를 기록·검증·공유하는 \u003cstrong\u003e분산 원장\u003c/strong\u003e 기술임\n이 글은 블록체인을 \u003cstrong\u003e초보자 친화적으로\u003c/strong\u003e 설명하고, \u003cstrong\u003e실무 체크리스트\u003c/strong\u003e까지 정리함\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"큰-그림-시스템-구성\"\u003e큰 그림: 시스템 구성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e노드(Node)\u003c/strong\u003e: 블록체인 소프트웨어 실행 주체\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e풀노드\u003c/strong\u003e: 모든 블록·트랜잭션 검증·저장\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이트 클라이언트\u003c/strong\u003e: 헤더·머클 증명 기반 최소 검증\u003c/li\u003e\n\u003cli\u003e(참고) \u003cstrong\u003e아카이브 노드\u003c/strong\u003e: 오래된 상태 포함 전체 상태 유지(필수 아님)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e블록(Block)\u003c/strong\u003e: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e합의(Consensus)\u003c/strong\u003e: 어떤 블록이 정식 이력인지 네트워크가 \u003cstrong\u003e공동으로\u003c/strong\u003e 결정하는 규칙\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePoW: 작업증명(연산 경쟁)\u003c/li\u003e\n\u003cli\u003ePoS: 지분증명(검증자·보증금 기반)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"해시hash와-위변조-방지\"\u003e해시(Hash)와 위·변조 방지\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 함수(SHA-256, Keccak-256 등)\u003c/strong\u003e: 입력을 고정 길이로 압축하는 일방향 함수임\u003c/p\u003e","title":"블록체인이란? 블록체인 개념 총정리"},{"content":"개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\n쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\n이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\n1. 핵심 용어 정리 오프체인 서명 (Off-chain Signature) 블록체인 외부(주로 백엔드 서버)에서 생성된 디지털 서명을 의미함 이 방식은 서명을 생성하는 과정에서 가스비가 들지 않고, 서버의 다양한 로직과 결합할 수 있는 장점이 있음\n메타 트랜잭션 (Meta-transaction) 사용자가 가스비를 직접 내지 않고, 트랜잭션에 대한 의도만 \u0026lsquo;서명\u0026rsquo;으로 표현하면, 제3의 대리인(Relayer)이 이를 대신 실행하고 수수료를 지불하는 패턴임 오프체인 서명은 이 메타 트랜잭션을 구현하는 핵심 기술임\n가스리스 트랜잭션 (Gasless Transaction) 메타 트랜잭션을 통해 사용자가 느끼기에 가스비 없이 트랜잭션을 처리하는 경험을 의미함 서비스 제공자가 페이마스터 등을 통해 가스비를 대납함으로써 구현됨\nEIP-712 단순 문자열이 아닌, 구조화된 데이터에 대한 서명 표준임 이 표준을 사용하면 사용자가 자신이 무엇에 서명하는지 명확히 알 수 있으며, 다른 체인이나 다른 컨트랙트에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지할 수 있어 보안성이 매우 높음\n2. 오프체인 서명 검증의 전체 흐름 서버, 사용자, 그리고 컨트랙트 간의 상호작용은 다음과 같은 단계로 이루어짐\n사용자 요청 사용자의 클라이언트(웹/앱)는 트랜잭션을 바로 블록체인에 보내는 대신, 트랜잭션에 필요한 정보들을 백엔드 서버에 API 요청으로 보냄\n서버 검증 및 서명 서버는 요청이 유효한지 검증함 (예: 우리 서비스의 정식 사용자인가? 요청 내용이 합당한가?) 검증이 완료되면, 서버는 EIP-712 표준에 따라 트랜잭션 파라미터가 담긴 메시지를 만들고, 서버의 개인키로 이 메시지에 서명함\n사용자 트랜잭션 제출 서버는 생성된 서명(signature)과 관련 데이터들을 사용자에게 다시 응답으로 보내줌 사용자의 클라이언트는 이 서명 데이터를 포함하여 트랜잭션를 구성하고, 최종적으로 블록체인(스마트 컨트랙트)에 제출함\n컨트랙트 검증 스마트 컨트랙트는 제출된 트랜잭션을 받아 서명이 유효한지 검증함 검증에 성공하면, 컨트랙트는 약속된 작업을 수행함 (예: 가스비 대납, 아이템 지급 등)\n3. 핵심 원리: 컨트랙트의 서명 검증 과정 컨트랙트는 서버의 개인키를 모르는데, 어떻게 서버가 서명했다는 것을 신뢰할 수 있을까? 이 과정은 암호학적 원리를 이용해 세 단계로 진행됨\n1단계: 데이터 해시(Hash) 재구성 컨트랙트는 사용자가 제출한 파라미터들(userAddress, expiryTimestamp 등)을 받아, 서버가 서명을 생성했을 때와 완벽히 동일한 구조와 순서로 이 데이터들을 조합하여 해시(hash) 값을 다시 계산함\n이때 EIP-712 표준에 따라 컨트랙트의 이름, 버전, 체인 ID 등이 포함된 도메인 분리자(Domain Separator)가 해시와 함께 사용되어 다른 컨트랙트에서 서명이 재사용되는 것을 막음\n// 1. 전달받은 파라미터로 해시 재계산 bytes32 hash = keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice )); bytes32 digest = hashTypedDataV4(hash); // 도메인 분리자와 결합 2단계: 서명자 주소 복원 ecrecover라는 암호학적 함수는 메시지 해시(digest)와 서명값(signature), 이 두 가지를 입력받아 해당 서명을 만들 수 있는 유일한 공개키, 즉 서명자의 주소를 역으로 계산해냄 이 과정에서 서버의 개인키는 절대 노출되지 않음\n// 2. 서명에서 주소 복원 address recoveredAddress = digest.recover(signature); 3단계: 서명자 주소 비교 마지막으로, 2단계에서 복원된 주소가 스마트 컨트랙트에 미리 저장된 신뢰할 수 있는 서버의 주소(signer)와 일치하는지 비교함 두 주소가 일치한다면, 이 서명은 우리가 신뢰하는 서버가 생성한 유효한 서명임이 증명된 것임\n// 3. 복원된 주소가 signer와 일치하는지 확인 require(signer == recoveredAddress, \u0026#34;Paymaster: Invalid signer\u0026#34;); 4. 데이터 무결성: 서명된 데이터는 어떻게 신뢰하는가? \u0026ldquo;만약 사용자가 유효한 서명을 받은 뒤, 파라미터 값만 몰래 바꿔서 제출하면 어떡하지?\u0026rdquo; 결론부터 말하면, 불가능함\n서명 검증 과정 자체가 데이터의 무결성을 보장하기 때문임 만약 사용자가 파라미터를 1비트라도 변경하면, 1단계에서 재구성되는 해시값이 원래의 해시값과 완전히 달라짐 결과적으로 2단계에서 주소 복원에 실패하거나 엉뚱한 주소를 반환하게 되어, 3단계의 주소 비교에서 반드시 실패하게 됨\n이처럼, 서명은 데이터의 해시와 한 쌍으로 묶여있기 때문에 데이터가 조금이라도 변조되면 서명은 즉시 무효가 됨 이 원리 덕분에 우리는 데이터가 서버가 승인한 원본 그대로임을 신뢰할 수 있음\n마무리 오프체인 서명 검증은 온체인의 신뢰성과 오프체인의 유연성을 결합한 강력한 패턴임 이를 통해 가스비 소모 없이 복잡한 비즈니스 로직을 온체인 시스템에 안전하게 적용할 수 있음 서명 검증 과정 자체가 데이터의 무결성과 서명자의 신뢰성을 동시에 보장하므로, 다양한 분야에서 보안성과 효율성을 높이는 데 활용될 수 있음\n","permalink":"https://handsupmin.github.io/posts/off-chain-signature-verification-542a33/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음\n이때 \u003cstrong\u003e오프체인 서명 검증\u003c/strong\u003e(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨\u003c/p\u003e\n\u003cp\u003e쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음\n가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨\u003c/p\u003e\n\u003cp\u003e이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄\u003c/p\u003e","title":"오프체인 서명 검증(Off-chain Signature Verification)이란?"},{"content":"개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\nzkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\n문제 정의: 단순 설계 페이마스터의 명확한 한계 가장 먼저 검토한 toAddressPaymaster는 특정 컨트랙트로 향하는 트랜잭션의 가스비만 대납해주는 단순한 모델임. 하지만 이 방식은 두 가지 치명적인 허점을 가짐\n의도치 않은 트랜잭션 허용: 신규 사용자에게 지갑을 만들어주는 AccountFactory 컨트랙트 주소를 페이마스터에 등록할 경우, 우리 서비스와 무관한 모든 사용자가 이 팩토리를 사용할 때 발생하는 가스비를 우리가 전부 대납하게 됨. 페이마스터가 의도치 않게 공공재가 되어버리는 상황\n가스비 소모 공격에 취약: gasLimit을 검증하는 로직이 없어, 악의적 사용자가 가스비를 비정상적으로 높게 책정해 트랜잭션 한 번으로 페이마스터의 모든 자금을 고갈시킬 수 있는 위험이 존재함\n결론적으로 우리가 허용한 사용자가 우리가 의도한 작업을 할 때 발생하는 합리적인 수준의 가스비만을 선별적으로 대납할 똑똑한 방법이 필요했음\n해결의 실마리: Off-chain Signature Verification 이 문제의 해결책으로 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 도입하기로 결정함\n이 패턴은 블록체인 외부(서버)에서 생성된 디지털 서명을 블록체인 위(스마트 컨트랙트)에서 검증하는 방식임. 즉, 가스비 대납 여부를 컨트랙트가 단독으로 결정하는 게 아니라, 우리가 통제하는 서버의 \u0026lsquo;허가\u0026rsquo;를 받아 결정하게 만드는 것\n이 과정에서 다음과 같은 주요 개념들이 활용됨\n메타 트랜잭션(Meta-transaction): 사용자가 직접 트랜잭션을 생성하고 가스비를 지불하는 대신, 트랜잭션의 내용이 될 데이터에 서명만 함. 그러면 이 서명을 받은 대리인(Relayer)이 실제 트랜잭션으로 만들어 수수료를 대신 내고 블록체인에 제출하는 패턴. 우리가 구현할 페이마스터는 zkSync 시스템이 릴레이어 역할을 해주는 메타 트랜잭션의 일종임\nEIP-712: 단순 텍스트가 아닌, json처럼 구조화된 데이터에 대한 서명 표준. 사용자가 무엇에 서명하는지 명확히 인지할 수 있고, 다른 컨트랙트나 체인에서 서명을 재사용하는 \u0026lsquo;재생 공격(Replay Attack)\u0026lsquo;을 방지하는 도메인 분리(Domain Separator) 기능을 포함하고 있어 페이마스터 서명에 필수적임\n구현 과정: 서명 기반 페이마스터 설계 및 개발 전체 흐름은 서버의 서명 생성(Off-chain)과 컨트랙트의 서명 검증(On-chain) 두 단계로 나뉨\n1. 서버 (Off-chain): 서명 생성 단계 사용자가 트랜잭션을 실행하기 직전, 클라이언트는 트랜잭션 데이터를 백엔드 서버로 전송함. 서버는 다음 절차를 수행\n요청 검증: 요청을 보낸 사용자가 우리 서비스의 유효한 사용자인지, 트랜잭션 내용이 비즈니스 로직에 부합하는지 등을 검증\n가스비 추정 및 파라미터 설정: 트랜잭션에 필요한 가스비를 추정하고, 여기에 약간의 버퍼를 더해 recommendedGasLimit과 recommendedGasPrice를 결정. 서명이 유효할 시간(expiryTimestamp)도 설정함\nEIP-712 서명 생성: 검증된 파라미터들을 바탕으로 EIP-712 표준에 따라 구조화된 데이터를 만들고, 서버만 안전하게 보관하고 있는 개인키로 이 데이터에 서명함\n// 서버에서 EIP-712 타입에 맞춰 서명할 데이터를 구성 const domain = { name: \u0026#34;SignatureBasedPaymaster\u0026#34;, version: \u0026#34;1\u0026#34;, chainId: chainId, verifyingContract: PAYMASTER_ADDRESS }; const types = { SignatureBasedPaymaster: [ { name: \u0026#39;userAddress\u0026#39;, type: \u0026#39;address\u0026#39; }, { name: \u0026#39;expiryTimestamp\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasLimit\u0026#39;, type: \u0026#39;uint256\u0026#39; }, { name: \u0026#39;recommendedGasPrice\u0026#39;, type: \u0026#39;uint256\u0026#39; } ] }; const value = { /* userAddress, expiryTimestamp 등 실제 값 */ }; // 서버의 개인키로 서명 생성 const signature = await signerWallet.signTypedData(domain, types, value); 이 서명값과 관련 파라미터들을 클라이언트에 반환하면, 클라이언트는 이 데이터를 트랜잭션과 함께 zkSync 네트워크로 전송함\n2. 컨트랙트 (On-chain): 서명 검증 단계 사용자의 트랜잭션은 zkSync 부트로더(Bootloader)를 통해 페이마스터 컨트랙트의 validateAndPayForPaymasterTransaction 함수를 호출함. 이 함수는 서명 검증의 핵심임\n데이터 재구성: 트랜잭션에 포함된 userAddress, expiryTimestamp, recommendedGasLimit 등의 파라미터를 가져와 서버가 서명했던 것과 완벽히 동일한 구조와 순서로 해시(hash)를 다시 만듦\n서명자 복원: 재구성한 해시와 트랜잭션에 포함된 서명(signature)을 이용해 암호학적 함수(ecrecover)를 호출. 이를 통해 이 서명을 생성한 주소를 역으로 계산해냄\n서명자 검증: 복원된 주소가 컨트랙트에 미리 저장해 둔 우리 서버의 주소(signer)와 일치하는지 확인. 일치해야만 서버가 허가한 유효한 요청으로 간주함\n만약 누군가 서버로부터 받은 서명을 그대로 두고 파라미터(ex: 가스비)를 변경하려 시도하면, 1번 단계에서 생성되는 해시값이 달라져 3번 검증 단계에서 실패하게 됨. 이를 통해 데이터의 무결성과 서명자의 신뢰성을 동시에 확보함\n// 1. 서버가 서명했을 데이터의 해시를 컨트랙트에서 동일하게 재구성 bytes32 digest = hashTypedDataV4(keccak256(abi.encode( SIGNATURE_TYPEHASH, userAddress, expiryTimestamp, recommendedGasLimit, recommendedGasPrice ))); // 2. 서명과 재구성된 해시를 사용해 서명자 주소를 복원 address recoveredSigner = digest.recover(signature); // 3. 복원된 주소가 우리가 신뢰하는 서버의 주소(signer)와 일치하는지 확인 require( signer == recoveredSigner, \u0026#34;Paymaster: Invalid signer\u0026#34; ); // ... 검증 통과 후 가스비 대납 로직 실행 결론 및 회고 zkSync의 페이마스터는 사용자의 가스비를 대신 지불하는 기능을 손쉽게 구현할 수 있는 강력한 기반을 제공함 개발자는 이를 통해 사용자의 진입 장벽을 낮추고 UX를 크게 개선할 수 있음\n하지만 여기에 오프체인 서명 검증(Off-chain Signature Verification) 패턴을 결합함으로써, 단순한 가스비 대납을 넘어 정교한 권한 제어가 가능해짐 서버에서 각 요청을 사전에 검증하고 서명을 발급하는 방식은 다음과 같은 명확한 이점을 가져왔음\n운영 안정성: 누가, 언제, 어떤 트랜잭션의 가스비를 지원받을지 서버단에서 유연하게 제어할 수 있어, 무분별한 비용 소모를 막고 예측 가능한 운영이 가능\n보안 강화: 허가된 주체만이 서명을 통해 가스비를 사용할 수 있으므로, 초기 모델의 가장 큰 문제였던 자금 고갈 공격과 의도치 않은 트랜잭션 허용을 원천적으로 차단할 수 있었음\n결론적으로, zkSync의 편리한 온체인 기능과 서버의 오프체인 로직을 결합한 이 접근법은 보안과 운영 안정성을 모두 확보하는 효과적인 해결책이었음 이를 통해 시스템의 자산을 안전하게 보호하며 지속 가능한 서비스를 운영할 수 있는 견고한 토대를 마련하게 되었음\n","permalink":"https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\u003cp\u003e블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 \u003cstrong\u003e가스비\u003c/strong\u003e(Gas Fee)임\n아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임\n이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 \u003cstrong\u003e가스리스 트랜잭션\u003c/strong\u003e(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음\u003c/p\u003e\n\u003cp\u003ezkSync Era는 이를 위해 \u003cstrong\u003e페이마스터\u003c/strong\u003e(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임\u003c/p\u003e","title":"안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)"},{"content":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026amp; 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u0026gt;\u0026gt;= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","permalink":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e머클트리는 블록체인에서 거래 집합을 \u003cstrong\u003e안전하고 효율적으로 요약·검증\u003c/strong\u003e하기 위해 쓰이는 핵심 자료구조임\n블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 \u003cstrong\u003e고정 크기 해시 하나\u003c/strong\u003e로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임\n이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"핵심-개념과-구조\"\u003e핵심 개념과 구조\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e머클트리는 보통 \u003cstrong\u003e이진 트리\u003c/strong\u003e 형태로 구현함\u003c/li\u003e\n\u003cli\u003e거래들을 \u003cstrong\u003e리프(leaf)\u003c/strong\u003e 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 \u003cstrong\u003e루트 해시\u003c/strong\u003e를 얻음\u003c/li\u003e\n\u003cli\u003e해시 함수는 체인별로 다르며 비트코인은 \u003cstrong\u003e더블 SHA‑256\u003c/strong\u003e, 이더리움은 트라이 구조에서 \u003cstrong\u003eKeccak‑256\u003c/strong\u003e 을 사용함\u003c/li\u003e\n\u003cli\u003e최상단 해시를 \u003cstrong\u003e머클루트(Merkle root)\u003c/strong\u003e 라 부르며 크기는 해시 함수에 따라 고정됨\u003c/li\u003e\n\u003cli\u003e리프 수가 홀수일 때는 마지막 리프를 \u003cstrong\u003e복제해 짝을 맞추는 방식\u003c/strong\u003e이 일반적이며 비트코인은 이 규칙을 사용함\u003c/li\u003e\n\u003cli\u003e트리 깊이는 리프 수 N에 대해 \u003cstrong\u003e⌈log₂ N⌉\u003c/strong\u003e 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"동작-원리와-장점\"\u003e동작 원리와 장점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e인접 노드 해시 \u003cstrong\u003eH_left || H_right\u003c/strong\u003e 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e무결성 검증\u003c/strong\u003e\n단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적 포함 증명\u003c/strong\u003e\n특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 \u003cstrong\u003e형제 해시들만\u003c/strong\u003e 있으면 됨\n필요한 해시 개수는 \u003cstrong\u003eO(log N)\u003c/strong\u003e 으로 작아 대역폭과 검증 비용이 작음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장성 보조\u003c/strong\u003e\n리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"블록-헤더와-경량-노드spv\"\u003e블록 헤더와 경량 노드(SPV)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함\u003c/li\u003e\n\u003cli\u003e경량 노드(SPV)는 \u003cstrong\u003e블록 전체가 아니라 헤더 체인만\u003c/strong\u003e 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 \u003cstrong\u003e머클 증명\u003c/strong\u003e 을 받아 포함 여부를 검증함\u003c/li\u003e\n\u003cli\u003e이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨\u003c/li\u003e\n\u003cli\u003e이더리움은 전통적인 이진 머클트리 대신 \u003cstrong\u003e머클‑패트리샤 트라이(MPT)\u003c/strong\u003e 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"구현-세부와-체인별-차이\"\u003e구현 세부와 체인별 차이\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e비트코인\u003c/strong\u003e\u003c/p\u003e","title":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"},{"content":"개요 이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함 개념 정의에 그치지 않고 운영 시 주의점, 보상·출금 흐름, 짧은 체인 재구성(Reorg) 원인과 완화책까지 다룸\n개념과 배경 PoS는 PoW의 에너지 경쟁을 대체해 예치된 지분을 바탕으로 검증자를 선정하는 합의 메커니즘임 이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 검증자 기반 보안 모델로 이행함\n주요 속성 요약\n에너지 소비 대폭 축소 스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨 위반 시 슬래싱과 페널티로 예치금이 감소함 계층 분리와 Beacon Chain의 역할 이더리움은 합의 계층(Beacon Chain) 과 실행 계층(Execution Layer) 를 분리해 설계함\n실행 계층은 트랜잭션 처리와 EVM 실행을 담당함 Beacon Chain은 시간 관리와 역할 배정, 투표 집계, 최종성 판단을 담당함 Beacon Chain의 핵심 기능\n슬롯과 에포크라는 통일된 시간 프레임 제공 매 슬롯의 블록 제안자와 증명자 배정 증명자 투표를 집계해 정당한 체인과 최종성을 결정함 이 분리는 클라이언트 다양성 확보와 확장 로드맵에 유리한 아키텍처 선택임\n시간 구조와 동작 단위 슬롯(slot)\n블록 제안이 가능한 최소 시간 단위 1 슬롯 = 12초 슬롯마다 1명의 제안자만 지정됨 제안자가 제때 블록을 제안하지 못하면 슬롯 미스로 간주하고 빈 슬롯이 될 수 있음 에포크(epoch)\n1 에포크 = 32 슬롯 ≈ 6분 24초 에포크 단위로 위원회 재편성, 랜덤 시드 갱신, 최종성 관련 집계가 이뤄짐 에포크는 체크포인트 역할을 하며 최종성 로직의 기준 단위로 사용됨 검증자와 스테이킹 규칙 최소 32 ETH를 예치해야 정식 검증자가 됨 한 검증자 계정에 반영되는 유효 예치 상한은 32 ETH임 더 많은 ETH를 운용하려면 32 ETH 단위로 여러 검증자를 운영해야 함 검증자 활성·비활성 전환에는 대기 큐와 지연이 존재함 보상 기회는 전체 검증자 대비 보유 검증자 수에 비례해 증가함 예를 들어 64 ETH로 두 검증자를 운영하면 제안·투표 참여 기회가 대략 두 배가 됨\n제안자(Proposer)와 증명자(Attester) 매 슬롯 한 명의 제안자가 블록을 제안함 다수의 증명자가 해당 블록에 대해 attestation 을 제출함 검증자들은 여러 위원회(committee) 로 무작위 배정되어 병렬로 검증을 수행함 집계된 투표는 포크 선택과 최종성 판단에 사용됨 위원회 구조의 목적은 검증 부담 분산 과 독립 다중 관측 을 통해 안전성과 처리량을 동시에 확보하는 것임\n무작위성과 검증자 배정 이더리움은 RANDAO 믹스 를 사용해 예측이 어렵고 조작에 강한 난수를 생성함 역사적으로 VRF나 VDF 같은 대안이 거론되었으나 현재 메인넷은 RANDAO 기반을 사용함 생성된 난수는 차기 에포크의 제안자·위원회 배정에 활용됨 특정 주체가 지속 우선 선정되는 편향을 줄이는 것이 목표임 포크 선택과 최종성 개요 포크 선택은 LMD‑GHOST 를 기반으로 하며 최신 메시지를 반영해 가장 무거운 서브트리를 선택함 짧은 지연으로 더 나은 블록을 선택하도록 proposer boost 가 도입되어 reorg 위험을 줄임 최종성은 Casper FFG 를 통해 에포크 수준 체크포인트를 정당화·최종화함 일정 이상 검증자 참여가 확보되면 체크포인트가 finalized 상태가 되어 경제적으로 되돌리기 매우 어려워짐 보상과 벌칙의 구조 보상 항목\n블록 제안 보상 제안자가 유효 블록을 포함할 때 수취 증명 보상 attestation을 정확하고 신속하게 제출한 검증자에게 지급 동기화 위원회 보상 라이트 클라이언트 지원을 위한 서명 참여 검증자에게 지급 벌칙과 슬래싱\n오프라인이나 지연 제출 등에는 경미한 페널티 가 부과됨 체인이 장기간 미파이널리티 상태에 빠지면 inactivity leak 이 발생해 페널티가 점진적으로 커짐 슬래싱 은 이중 제안 혹은 이중·감싸기 투표 같은 안전성 위반에 적용되며 금액과 네트워크 상황에 따라 손실이 커질 수 있음 동일 키를 여러 노드에서 가동하면 슬래싱 위험이 급증하므로 금지해야 함 보상 규모와 페널티는 전체 활성 예치 규모와 참여율 등 네트워크 상태에 따라 동적으로 변함\n출금과 인출 흐름 2023년 상반기 업그레이드 이후 출금 기능 이 활성화됨 부분 출금 은 32 ETH 초과분이 자동으로 실행 계층의 출금 주소로 전달됨 완전 출금 은 검증자가 정상 종료를 통해 활성 집합에서 빠진 뒤 전 잔액을 인출하는 흐름임 출금 처리는 블록당 포함 가능한 수가 제한되어 있어 대기 지연이 발생할 수 있음 출금 주소 유형과 자격 전환이 올바르게 설정되어 있어야 자동 처리가 가능함 운영 포인트\n출금 대기 시간과 큐 상태를 모니터링해 유동성을 관리함 출금 주소 관리 실수를 방지하기 위해 변경 절차를 문서화하고 검증 절차를 둠 Reorg가 발생하는 이유와 완화책 Reorg는 PoS에서도 짧은 길이 로 발생할 수 있음 주요 원인\n블록·attestation 전파 지연으로 노드 간 관측 차이가 발생함 슬롯 미스 이후 후속 제안자가 다른 선행 상태를 기준으로 블록을 만들 수 있음 노드 시간 동기화 불량이나 리소스 병목으로 처리 지연이 발생함 완화책\n시간 동기화는 chrony 등으로 정확히 유지함 고품질 피어 확보와 충분한 피어 수를 유지하고 네트워크 지연을 최소화함 최신 클라이언트와 다양한 클라이언트 조합으로 클라이언트 다양성 을 보장함 proposer boost와 attest 포함 지연 지표를 모니터링해 파라미터와 인프라를 튜닝함 대부분의 reorg는 1~2 블록에서 수렴하며 최종성 규칙으로 빠르게 안정화됨\n운영 체크리스트 노드와 인프라\n최신 합의·실행 클라이언트 유지 피어 수·지연·대역폭·디스크 IOPS 모니터링 장애를 분리하기 위해 실행·합의 클라이언트의 조합을 다양화함 키 관리\n슬래싱 방지 파일과 원격 서명기 사용 시 중복 서명 방지 설정 확인 단일 실패 지점 제거를 위해 핫·백업 구성과 자동 페일오버를 명확히 구분함 키 백업과 복구 절차를 오프라인으로 주기 점검함 운영 정책\n32 ETH 단위로 검증자를 수평 확장해 장애 격리와 보상 변동성을 줄임 모니터링 지표를 표준화함 참여율, attestation 포함 거리, 미스 슬롯, reorg 발생률, 동기화 위원회 가동률, 출금 큐 길이 등 MEV‑Boost 사용 시 릴레이 다양화와 로컬 빌더 폴백을 준비해 가용성과 검열 리스크를 낮춤 위험과 중앙화 고려 거대 스테이킹 풀과 커스터디 집중은 검열·단일 실패 지점 위험을 키움 클라이언트 다양성 부족은 버그 발생 시 네트워크 안정성을 해칠 수 있음 리퀴드 스테이킹 파생상품은 유동성을 제공하지만 의사결정 집중과 딜레마를 유발할 수 있음 정책과 거버넌스, 릴레이·빌더 다양화, 커뮤니티 모니터링으로 리스크를 분산해야 함 마무리 이더리움 PoS는 RANDAO 기반 무작위성, LMD‑GHOST 포크 선택, Casper FFG 최종성, 검증자 보상·벌칙 체계 를 결합해 에너지 효율과 보안을 동시에 달성하려는 설계임 운영자는 시간 동기화와 피어 품질, 키 관리, 클라이언트 다양성, 보상·출금 파이프라인을 지속적으로 점검해야 함 짧은 reorg는 네트워크 현실에서 발생할 수 있으나 적절한 인프라와 파라미터 튜닝, 최신 클라이언트 운용으로 빈도와 영향을 최소화할 수 있음\n참고자료 이더리움 PoS 개요 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos 합의 사양과 가스퍼 개요 https://github.com/ethereum/consensus-specs EIP‑4895 출금과 Capella 업그레이드 참고 https://eips.ethereum.org/EIPS/eip-4895 합의 계층 클라이언트와 실행 계층 클라이언트 목록 https://ethereum.org/en/developers/docs/nodes-and-clients MEV‑Boost 운영 가이드 참고 https://www.flashbots.net ","permalink":"https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함\n개념 정의에 그치지 않고 \u003cstrong\u003e운영 시 주의점\u003c/strong\u003e, \u003cstrong\u003e보상·출금 흐름\u003c/strong\u003e, \u003cstrong\u003e짧은 체인 재구성(Reorg) 원인과 완화책\u003c/strong\u003e까지 다룸\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003ePoS는 PoW의 에너지 경쟁을 대체해 \u003cstrong\u003e예치된 지분을 바탕으로 검증자를 선정\u003c/strong\u003e하는 합의 메커니즘임\n이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 \u003cstrong\u003e검증자 기반 보안 모델\u003c/strong\u003e로 이행함\u003c/p\u003e\n\u003cp\u003e주요 속성 요약\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에너지 소비 대폭 축소\u003c/li\u003e\n\u003cli\u003e스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨\u003c/li\u003e\n\u003cli\u003e위반 시 슬래싱과 페널티로 예치금이 감소함\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"계층-분리와-beacon-chain의-역할\"\u003e계층 분리와 Beacon Chain의 역할\u003c/h3\u003e\n\u003cp\u003e이더리움은 \u003cstrong\u003e합의 계층(Beacon Chain)\u003c/strong\u003e 과 \u003cstrong\u003e실행 계층(Execution Layer)\u003c/strong\u003e 를 분리해 설계함\u003c/p\u003e","title":"이더리움 PoS(Proof of Stake) 소개"},{"content":"개요 NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 리빌, 에어드롭, 화이트리스트, 마켓플레이스를 실무 관점으로 정리함 핵심은 개념 이해를 넘어 운영 체크리스트, 보안 리스크, 가격 형성 메커니즘까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\n공통 전제와 기본 개념 NFT 표준 주로 ERC‑721과 ERC‑1155를 사용함 721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\n메타데이터와 저장소 토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장 중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\n로열티 EIP‑2981 표준이 존재하나 집행은 마켓별 정책에 의존하는 경향이 있음 창작자 수익 분배 구조를 미리 확인 필요\n리빌 Reveal 정의 민팅 직후에는 공통 플레이스홀더 이미지를 노출하고, 이후 시점에 각 토큰의 최종 속성·이미지를 공개하는 절차를 말함\n왜 쓰는가\n판매 초기의 기대감 형성과 공정한 희소성 배분 유도 초반 스니핑을 줄이고 커뮤니티 이벤트와 연동하기 위함 가격 형성상 특징\n리빌 전에는 외형과 속성이 같아 보여 가격 수렴이 발생하기 쉬움 리빌 후에는 속성 조합·희소성에 따라 재평가가 빠르게 진행됨 희귀 속성은 프리미엄이 붙고 평범 속성은 하방 압력이 커지는 패턴이 일반적임 공정성·신뢰 장치\n프로비넌스 해시 공개로 민팅 전 전체 순서를 커밋해 치환·조작 가능성을 낮춤 메타데이터 동결과 BaseURI 고정으로 리빌 후 임의 수정 리스크 축소 온체인 또는 영속 스토리지에 최종 자료 고정 운영 체크리스트\n리빌 시점, 방식(일괄·구간·랜덤 시프트), 프로비넌스 공개 여부 확인 메타데이터 저장소와 동결 계획 점검 리빌 직후 가격 변동성 대비 유동성 전략 수립 에어드롭 Airdrop 정의 NFT 또는 토큰을 무상 배포해 초기 유입과 참여 보상을 유도하는 방식\n유형\n푸시형 프로젝트가 직접 전송 클레임형 스냅샷 기준 자격자에게 기간 내 청구 권한 부여 조건형 소셜 참여, 보유 토큰, 온체인 행위 등 조건을 충족해야 함 비용과 유동성\n가스 부담 주체가 누구인지 확인 필요 수령 자산의 2차 유동성 가능성과 잠금 조건 여부 확인 보안 체크리스트\n개인키·시드 문구 요청은 100% 사기 setApprovalForAll 무제한 승인 요구, 임의 Permit 서명 요구, 낯선 도메인의 서명 팝업에 주의 의심 에어드롭은 더스팅 공격 가능성 고려, 상호작용 자체를 피하는 것이 안전한 경우 많음 현실적 기대치\n극소수 성공 사례를 제외하면 무료 배포물의 평균 가치는 시간 경과에 따라 하락하는 경향 로드맵, 팀 신뢰도, 파트너십, 토큰 설계까지 종합 평가 필요 화이트리스트 Allowlist 정의 특정 지갑에게 민팅 우선권을 부여하는 명단을 의미하며 줄여서 화리라 부름 포용적 표현으로 Allowlist 용어를 쓰는 프로젝트가 많음\n부여 방식\n커뮤니티 기여, 미션, 추천, 보유 토큰 기반 토큰 게이팅 온체인 머클 증명으로 명단을 검증해 가스·데이터 비용을 절감 타입\n보장형 배정량이 확정되어 민팅 시점에 구매 가능 경쟁형 FCFS나 시간 창을 두어 네트워크 상태·속도에 따라 성공 여부가 갈림 래플형 추첨으로 공정 배분 시도 실무 체크리스트\n1인당 구매 한도, 민팅가, 시간 창, 체인·네트워크 확인 가스 워 방지 장치 유무 확인(쿨다운, 랜덤 시프트, 캡) 어뷰징·봇 통제 정책 확인, 위반 시 박탈 규정 숙지 주의\nAllowlist를 과다 남발하는 프로젝트는 민팅 종료 후 가격 하락 리스크가 크므로 유통 설계와 수요 검증 필요 NFT 마켓플레이스 역할 NFT의 가시화, 매매, 오더북을 제공하는 플랫폼을 의미함 글로벌로 OpenSea, Blur, Rarible 등이 대표적이며 국내에는 Klip Drops, 업비트 NFT 등이 존재함\n거래 방식\n고정가 리스팅 판매자가 원하는 가격 제시 경매형 영국식 상승 경매, 더치 경매 등 변형 포함 오퍼 특정 토큰 혹은 전체 컬렉션에 대한 구매 제안 접수 집계기가 여러 거래소의 유동성을 묶어 더 나은 가격·체결 속도를 제공하기도 함 핵심 지표와 해석 요령\n바닥가 Floor 컬렉션 내 최저 매물가이나 거래된 가격이 아님 얕은 호가에 의해 왜곡 가능하므로 체결 이력, 호가 두께, 분포를 함께 보아야 함 체결량·보유 분포 단기 매물 출회 압력과 고래 집중도 파악에 유용함 워시 트레이딩 자기계약 간 거래로 볼륨 부풀리기가 발생할 수 있어 탐지 지표 참고 필요 수수료와 로열티\n마켓 수수료와 창작자 로열티 정책이 거래소마다 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 선택적인 경우가 많아 실제 지급 여부를 확인해야 함 보안과 권한 관리\n판매 전 부여한 무제한 승인은 거래 후 revoke 툴로 회수 권장 피싱 도메인과 서명 위임 요청에 대한 교육이 필수 플랫폼 선택 기준\n유동성 규모, 수수료 구조, 지원 체인, 커뮤니티 활성도, 집계기 연동 여부, 로열티 정책 일관성 확인 빠른 판단 가이드 리빌 일정과 프로비넌스 공개, 메타데이터 동결 계획을 먼저 확인 에어드롭 은 개인키·시드·무제한 승인 요구 시 즉시 중단 화이트리스트 는 한도·가격·시간 창과 검증 방식(머클) 확인 마켓플레이스 는 바닥가만 보지 말고 체결 이력·호가 두께·수수료·로열티 정책까지 함께 판단 예시 시나리오 개인 사용자 민팅 직후 리빌 전 거래는 변동성 대비 효익이 낮을 수 있어 리빌 일정 확인 후 접근 수령한 에어드롭은 승인 요청이 없는지 먼저 점검하고 필요 시 상호작용을 피함 프로젝트 운영자 머클 기반 Allowlist와 프로비넌스 커밋으로 신뢰 확보 메타데이터 동결과 영속 스토리지 사용으로 변경 리스크 최소화 워시 트레이딩 방지 메시지와 리스팅 교육 자료를 함께 제공 마무리 리빌은 가치 재평가의 계기 에어드롭은 초기 분배와 참여 보상 수단 화이트리스트는 수요 조절과 공정 배분 장치 마켓플레이스는 가격 발견과 유동성의 장 각 제도의 의도·설계·리스크를 이해하고 보안 수칙을 지키면 의사결정의 품질을 높일 수 있음\n참고자료 ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 OpenZeppelin Merkle 증명 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography Ethereum 개발자 문서 NFT 개요 https://ethereum.org/en/developers/docs/standards/tokens/ 추가 읽을거리 https://magazine.cheil.com/51780 ","permalink":"https://handsupmin.github.io/posts/nft-23q12akw/","summary":"\u003ch3 id=\"개요\"\u003e개요\u003c/h3\u003e\n\u003cp\u003eNFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 \u003cstrong\u003e리빌\u003c/strong\u003e, \u003cstrong\u003e에어드롭\u003c/strong\u003e, \u003cstrong\u003e화이트리스트\u003c/strong\u003e, \u003cstrong\u003e마켓플레이스\u003c/strong\u003e를 실무 관점으로 정리함\n핵심은 개념 이해를 넘어 \u003cstrong\u003e운영 체크리스트\u003c/strong\u003e, \u003cstrong\u003e보안 리스크\u003c/strong\u003e, \u003cstrong\u003e가격 형성 메커니즘\u003c/strong\u003e까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"공통-전제와-기본-개념\"\u003e공통 전제와 기본 개념\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNFT 표준\u003c/strong\u003e\n주로 ERC‑721과 ERC‑1155를 사용함\n721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메타데이터와 저장소\u003c/strong\u003e\n토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장\n중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐\u003c/p\u003e","title":"NFT 핵심 용어 정리"},{"content":"서문 NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움 이 글은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고 구매·발행·보관 시 유의사항과 운영 관행을 담는 것을 목표로 함\n개념과 배경 NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함 동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 고유 식별자와 속성을 가져 상호 교환 시 동일 가치를 보장하지 않음 블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음 온체인 소유권이 저작권·초상권 등 법적 권리와 자동 동치가 아님에 유의해야 함\nNFT는 보통 세 요소로 이해하면 실무에 유리함\n디지털 미디어 이미지·영상·음원·게임 아이템 등 사용자에게 보이는 대상 메타데이터 이름·설명·속성·미디어 링크를 담은 JSON 문서 스마트컨트랙트 발행·이전 규칙을 구현한 코드로 표준은 주로 ERC‑721과 ERC‑1155를 사용함 대부분의 프로젝트는 미디어 파일을 체인 밖에 보관하고 메타데이터에 링크를 넣는 오프체인 저장을 택함 장기 보존성을 위해 IPFS·Arweave 같은 영속형 스토리지 사용과 메타데이터 동결 계획이 중요함\n메인넷과 인프라 이해 NFT는 이더리움·폴리곤·솔라나·클레이튼 등 메인넷 혹은 L2 위에서 발행·거래됨 거래 실행에는 가스비가 들며 이더리움은 EIP‑1559 기반의 베이스피와 우선순위 팁 구조를 가짐 네트워크 상태와 우선순위 설정에 따라 체결 속도와 비용이 크게 달라짐 거래와 토큰 상태는 블록 탐색기에서 확인 가능하며 예시는 이더스캔과 클레이튼 스코프 등이 있음\n체인별 계약 주소·체인 ID가 다르므로 피싱 사이트가 제시하는 계약을 탐색기에서 교차 확인하는 습관이 필요함 브리징과 크로스체인 전송 시에는 락 앤 민트 모델·메시지 지연·브리지 보안을 이해하고 한도·대기 시간을 고려해야 함\n지갑과 보안 지갑은 주소와 그 주소를 통제하는 프라이빗 키·시드 문구를 관리함 메타마스크·카이카스 같은 브라우저 확장형은 편리하지만 핫월렛이라 위험 노출이 큼 대액·장기 보관 자산은 하드웨어 지갑에 두고 일상 거래는 별도 소액용 지갑을 쓰는 분리 보관이 권장됨\n시드 문구 보관 원칙\n오프라인 백업과 물리 분산 보관 사진·클라우드·메신저 업로드 금지 테스트 복구 절차를 정기 수행 권한과 서명 보안\n웹사이트 연결 시 도메인·체인·요청 권한을 확인하고 setApprovalForAll 무제한 승인은 꼭 필요한 범위에만 부여 거래가 아닌 서명 요청도 자산 이전 권한을 위임할 수 있으니 상세를 읽고 필요 시 거부 사용이 끝난 승인 권한은 권한 취소 도구로 주기적으로 회수 민팅 Minting 실무 절차 민팅은 메타데이터와 미디어 링크를 컨트랙트에 기록해 토큰을 새로 발행하는 행위 민팅이 체인에 포함되면 이벤트 로그에서 Transfer 이벤트의 From 주소가 0x0000000000000000000000000000000000000000 로 표시되는 것이 일반적임\n두 가지 맥락을 구분하면 혼동이 줄어듦\n프로젝트 관점 컨트랙트를 배포하고 토큰을 생성하는 개발·운영 작업 구매자 관점 민팅 페이지에서 최초 구매에 참여하는 행위 민팅 유형과 운영 포인트\n퍼블릭 민팅 누구나 가능하며 인기 컬렉션은 즉시 매진되므로 가스 전략과 자동화 대비가 필요 프라이빗 민팅 Allowlist 사전 등록 지갑만 참여 가능하며 일반적으로 가격·수량·시간 창이 별도로 정의됨 무료 민팅 민팅가는 0이지만 가스비가 들며 사후 로열티·수수료 구조를 확인해야 함 민팅 전 체크리스트\n계약 주소·체인·민팅가·한도·시간 창을 공지와 탐색기에서 이중 확인 메타데이터 저장 방식과 리빌·프로비넌스 계획을 확인 페이지가 제시하는 컨트랙트 소스 공개·감사 여부 확인 가스비 상한과 우선순위 팁을 과도하게 올려 불필요한 낭비가 없도록 시뮬레이션 마켓플레이스와 2차 거래 오픈씨·블러·라리블 등 마켓플레이스에 지갑을 연결해 리스팅과 오퍼를 관리함 주요 거래 방식은 고정가 리스팅·경매·컬렉션 오퍼 등이 있으며 유동성은 거래소마다 상이함\n가격 해석과 유의점\n바닥가 floor 는 현재 최저 매물가일 뿐 실제 체결가가 아님 체결 이력·호가 두께·보유 분포를 함께 봐야 수급을 판단할 수 있음 워시 트레이딩 으로 볼륨이 부풀려질 수 있으므로 비정상 패턴에 주의 로열티와 수수료\n마켓 수수료 와 크리에이터 로열티 정책은 플랫폼별로 다름 EIP‑2981은 로열티 표준을 정의하지만 집행은 거래소 정책에 의존하는 경우가 많음 실제 로열티 지급 여부와 비율을 거래 전 확인 필요 권한과 보안\n리스팅 과정에서 부여한 무제한 승인은 판매 종료 후 회수 권장 낯선 도메인의 서명 팝업과 필드가 비정상적으로 긴 메시지는 피싱 징후일 수 있음 메타데이터·저장·리빌 운영 메타데이터 는 ERC‑721 메타데이터 스펙의 name·description·image·attributes 필드를 따르는 것이 일반적 저장소 는 IPFS·Arweave 같이 링크 무결성과 장기 보존에 유리한 방식을 권장 리빌 은 발행 직후 플레이스홀더를 제공하고 이후 속성을 공개하는 절차로 가격 재평가가 일어남 조작 의심을 줄이기 위해 프로비넌스 해시 공개·랜덤 시드·베이스 URI 잠금 같은 신뢰 장치를 제공하는 것이 실무 베스트 프랙티스임 운영·커뮤니티 관행과 실무 팁 프로젝트 운영자 관점\n컨트랙트 소스 공개와 보안 감사 진행 Allowlist를 머클 증명으로 검증해 가스와 데이터 비용을 절감 봇 완화를 위한 레이트 리밋·쿨다운·인증을 설계 리빌 일정·기준·랜덤 방식과 메타데이터 동결 계획을 사전 공지 로열티 정책을 명확히 하고 플랫폼별 집행 차이에 대한 안내 제공 구매자·보유자 관점\n리빌 전후의 가격 변동성과 유동성 얕음에 대비 권한 관리와 피싱 방지 교육을 습관화 브리지·체인 전환 전에는 수수료·지연·보안 리스크를 점검 에어드롭·민팅 DM은 대부분 피싱일 가능성이 높으므로 공식 채널만 신뢰 빠른 점검 체크리스트 계약 주소·체인·민팅가·수량 한도·시간 창 교차 확인 메타데이터 저장소와 리빌·프로비넌스 공개 여부 확인 마켓 수수료·로열티 정책·체결 이력과 호가 두께 확인 권한 부여 최소화와 사용 후 권한 회수 습관 유지 시드 문구 오프라인 분산 보관과 정기 복구 테스트 수행 마무리 NFT는 표준·메타데이터·컨트랙트 권한·저장 전략이 서로 맞물려 동작하는 생태계임 개념을 이해하는 것만으로는 부족하며 보안과 운영 절차를 마련해야 실전에서 손실을 줄일 수 있음 민팅·거래·보관 단계별로 위의 체크리스트를 적용하면 의사결정 품질을 안정적으로 끌어올릴 수 있음\n참고자료 Etherscan 블록 탐색기 https://etherscan.io Klaytn Scope 블록 탐색기 https://scope.klaytn.com OpenSea 마켓플레이스 https://opensea.io MetaMask 지갑 https://metamask.io ERC‑721 표준 https://eips.ethereum.org/EIPS/eip-721 ERC‑1155 표준 https://eips.ethereum.org/EIPS/eip-1155 ERC‑2981 NFT 로열티 표준 https://eips.ethereum.org/EIPS/eip-2981 Ethereum 개발자 문서 토큰 표준 개요 https://ethereum.org/en/developers/docs/standards/tokens Klaytn 개발자 문서 https://docs.klaytn.foundation ","permalink":"https://handsupmin.github.io/posts/nft-concept-20gd0fl/","summary":"\u003ch3 id=\"서문\"\u003e서문\u003c/h3\u003e\n\u003cp\u003eNFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움\n이 글은 \u003cstrong\u003e실무자 관점\u003c/strong\u003e에서 NFT의 핵심 개념을 단계적으로 정리하고 \u003cstrong\u003e구매·발행·보관 시 유의사항\u003c/strong\u003e과 \u003cstrong\u003e운영 관행\u003c/strong\u003e을 담는 것을 목표로 함\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"개념과-배경\"\u003e개념과 배경\u003c/h3\u003e\n\u003cp\u003eNFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함\n동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 \u003cstrong\u003e고유 식별자와 속성\u003c/strong\u003e을 가져 상호 교환 시 동일 가치를 보장하지 않음\n블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음\n온체인 소유권이 \u003cstrong\u003e저작권·초상권 등 법적 권리와 자동 동치가 아님\u003c/strong\u003e에 유의해야 함\u003c/p\u003e","title":"NFT란? NFT 핵심 개념 정리"}]