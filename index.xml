<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>HandsLog</title><link>https://handsupmin.github.io/</link><description>Recent content on HandsLog</description><generator>Hugo -- 0.146.0</generator><language>ko-kr</language><lastBuildDate>Thu, 25 Sep 2025 13:10:01 +0000</lastBuildDate><atom:link href="https://handsupmin.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Off-chain 개념과 데이터 가용성: zkRollup vs Validium 비교</title><link>https://handsupmin.github.io/posts/off-chain-data-availability-zkrollup-validium-274b74/</link><pubDate>Thu, 25 Sep 2025 13:10:01 +0000</pubDate><guid>https://handsupmin.github.io/posts/off-chain-data-availability-zkrollup-validium-274b74/</guid><description>&lt;h3 id="개념-및-배경">개념 및 배경.&lt;/h3>
&lt;p>Off-chain은 블록체인 외부에서 이루어지는 데이터 처리나 연산을 지칭함. 트랜잭션 원본이나 대량의 상태 변경을 메인넷에 전부 기록하지 않고, 체인 바깥의 별도 환경에서 처리한 뒤 필요한 증명이나 최종 결과만 온체인에 제출하는 방식. 목적은 비용 절감, 처리 속도 향상, 데이터 활용의 유연성 확보.&lt;/p>
&lt;h3 id="핵심-개념과-정의">핵심 개념과 정의.&lt;/h3>
&lt;ul>
&lt;li>Off-chain 처리: 트랜잭션 집계, 상태 채널 연산, 데이터 인덱싱 등 블록체인 외부에서 수행되는 연산 또는 저장 방식. 최종 정리본 또는 증명만 온체인에 올리는 구조.&lt;/li>
&lt;li>Off-chain Data Availability: 트랜잭션 데이터 자체는 외부 저장소에 보관하고, 온체인에는 검증에 필요한 최소한의 증명(예: ZK 증명)만 제출하는 모델. 데이터 가용성 제공자 또는 분산 스토리지에 대한 의존성 존재.&lt;/li>
&lt;/ul>
&lt;h3 id="동작-원리-및-구조">동작 원리 및 구조.&lt;/h3>
&lt;p>일반적인 흐름은 다음과 같음.&lt;/p></description></item><item><title>Abstract 체인 개요 및 핵심 구성 요소 정리</title><link>https://handsupmin.github.io/posts/abstract-chain-overview-274b74/</link><pubDate>Wed, 24 Sep 2025 13:09:24 +0000</pubDate><guid>https://handsupmin.github.io/posts/abstract-chain-overview-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>이 글은 &amp;lsquo;Abstract&amp;rsquo;로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리한 문서. 목적은 해당 체인의 트랜잭션 흐름, 증명 생성·검증 과정, 네이티브 계정 추상화와 스마트 컨트랙트 지갑(글로벌 지갑)의 동작 방식에 대한 명확한 이해 제공.&lt;/p>
&lt;h3 id="배경과-목적">배경과 목적&lt;/h3>
&lt;ul>
&lt;li>이더리움 기반의 확장성 한계(TPS, 가스비 부담) 보완을 위해 L2 솔루션 도입 필요성&lt;/li>
&lt;li>ZK Rollup 계열은 메인넷의 보안성 유지하면서 트랜잭션 처리량을 늘리고 온체인 비용을 낮추는 목적&lt;/li>
&lt;/ul>
&lt;h3 id="핵심-개념과-정의">핵심 개념과 정의&lt;/h3>
&lt;ul>
&lt;li>ZK Rollup: 오프체인에서 트랜잭션을 집계하고, 집계 결과에 대한 유효성 증명을 온체인에 제출하여 상태 변경을 최종화하는 기술&lt;/li>
&lt;li>ZK Stack: ZK Rollup 계열의 L2를 구축하기 위한 프레임워크 집합(증명 회로, 배포 파이프라인, 런타임 도구 등)&lt;/li>
&lt;li>Sequencer: L2 트랜잭션 수신 및 블록화 담당 서비스&lt;/li>
&lt;li>Prover/Verifier: 배치 단위의 트랜잭션 결과에 대해 영지식 증명을 생성하고, 온체인에서 검증하는 구성요소&lt;/li>
&lt;li>Account Abstraction(네이티브): 체인상의 모든 계정을 스마트 컨트랙트 계정으로 통일하여 트랜잭션 검증·유연한 결제 방식 지원&lt;/li>
&lt;/ul>
&lt;h3 id="동작-원리--트랜잭션-생명주기">동작 원리 / 트랜잭션 생명주기&lt;/h3>
&lt;ol>
&lt;li>트랜잭션 제출&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>사용자 또는 클라이언트가 JSON-RPC로 트랜잭션 제출. 트랜잭션은 L2 멤풀에 적재&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>시퀀싱 및 실행&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>시퀀서가 멤풀에서 트랜잭션을 읽어 블록 단위로 정리&lt;/li>
&lt;li>부트로더 또는 실행 환경이 각 트랜잭션을 실행하고 사용자에게 즉시 실행 결과(성공 여부, txId) 응답&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>배치 생성 및 증명 준비&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>시퀀서는 블록들을 prover에 전달하여 여러 블록을 포함하는 배치 생성&lt;/li>
&lt;li>Prover는 배치에 대한 증인(witness) 생성, 회로 실행, 증명 생성 과정을 수행&lt;/li>
&lt;li>생성된 증명은 크기가 클 수 있어 압축 과정을 거쳐 온체인 검증이 용이한 형태로 변환&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>L1에 배치 커밋 및 증명 제출&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>상태 변경만을 요약한 최적화된 데이터(예: blobs 형태, EIP-4844 표준)에 따라 L1에 배치 데이터 가용성 확보 및 커밋&lt;/li>
&lt;li>최종적으로 압축된 ZK-SNARK(또는 유사한 간결 증명)를 L1의 롤업 컨트랙트에 제출하여 proveBatches 호출&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>검증 및 실행 확정&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>L1 스마트 컨트랙트에서 증명 검증. 검증 완료 시 executeBatches 호출로 상태 최종 확정&lt;/li>
&lt;li>L2 로그 및 머클 트리 루트 저장&lt;/li>
&lt;/ul>
&lt;h3 id="구성요소-상세">구성요소 상세&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Sequencer 영역&lt;/p></description></item><item><title>커스토디얼 vs 논커스토디얼 월렛 비교 및 실무 포인트</title><link>https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/</link><pubDate>Tue, 23 Sep 2025 13:09:26 +0000</pubDate><guid>https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>프라이빗키 관리 방식에 따라 암호화폐 월렛은 크게 커스토디얼(custodial)과 논커스토디얼(noncustodial)로 구분됨. 각 방식의 차이와 실무에서 고려해야 할 보안·운영 포인트를 정리함.&lt;/p>
&lt;h3 id="핵심-개념과-정의">핵심 개념과 정의&lt;/h3>
&lt;ul>
&lt;li>커스토디얼 월렛: 제3자 서비스가 사용자의 프라이빗키를 보관하고 트랜잭션 서명을 대행하는 구조. 로그인·인출 등은 서비스 인증을 통해 이루어짐.&lt;/li>
&lt;li>논커스토디얼 월렛: 사용자가 직접 프라이빗키를 보유하고 서명 권한을 직접 행사하는 구조. 브라우저 확장 지갑이나 하드웨어 지갑이 해당됨.&lt;/li>
&lt;/ul>
&lt;p>정리: 관리는 제3자 대 사용자 직접 소유의 차이.&lt;/p>
&lt;h3 id="동작-원리-및-구조">동작 원리 및 구조&lt;/h3>
&lt;p>커스토디얼은 중앙화된 키 보관소와 인증·권한 시스템을 포함. 서비스는 핫월렛/콜드월렛 분리, 접근 제어, 키 관리 정책으로 운영됨. 논커스토디얼은 키 생성·저장·복구를 사용자 환경에서 수행. 하드웨어 지갑은 기기 내 안전영역에서 서명 연산을 처리함. 일부 솔루션은 키 분할 또는 다중 서명 구조를 도입하여 중간 형태 제공.&lt;/p></description></item><item><title>블록체인 원리 집중정리 — 채굴·해시·합의의 핵심</title><link>https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/</link><pubDate>Mon, 22 Sep 2025 13:10:11 +0000</pubDate><guid>https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/</guid><description>&lt;p>개요&lt;/p>
&lt;p>이 문서는 블록체인의 기본 원리와 거래가 실제로 어떻게 기록되는지, 채굴과 해시, 합의 알고리즘(PoW/PoS), 포크와 확장성 대책까지 실무 관점에서 정리한 글임. 기술적 배경이 필요하지만 복잡한 수식이나 그림 없이 핵심 개념과 운영 상 주의점을 중심으로 설명함.&lt;/p>
&lt;h3 id="개념과-맥락">개념과 맥락&lt;/h3>
&lt;p>블록체인은 분산 원장 기술로, 중앙 기관 없이 네트워크 참여자들이 거래 기록을 공유·검증하여 장부를 유지하는 방식. 블록 단위로 거래가 묶이고 블록들이 체인처럼 연결되어 불변성 유지가 용이한 구조를 가짐. 암호화폐는 이 구조 위에서 통화 또는 가치 전달 수단 역할을 하는 응용 사례.&lt;/p></description></item><item><title>스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법</title><link>https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/</link><pubDate>Sun, 21 Sep 2025 13:05:50 +0000</pubDate><guid>https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.&lt;/p>
&lt;h3 id="문제-정의와-영향">문제 정의와 영향&lt;/h3>
&lt;ul>
&lt;li>상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식&lt;/li>
&lt;li>문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험&lt;/li>
&lt;li>정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가&lt;/li>
&lt;/ul>
&lt;h3 id="핵심-개념과-대안">핵심 개념과 대안&lt;/h3>
&lt;ol>
&lt;li>매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1)&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-solidity" data-lang="solidity">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">mapping&lt;/span>(&lt;span style="color:#66d9ef">address&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>) &lt;span style="color:#66d9ef">public&lt;/span> users;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">register&lt;/span>(&lt;span style="color:#66d9ef">address&lt;/span> user) &lt;span style="color:#66d9ef">public&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(&lt;span style="color:#f92672">!&lt;/span>users[user], &lt;span style="color:#e6db74">&amp;#34;already registered&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> users[user] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)&lt;/p></description></item><item><title>재귀적 영지식 증명이란?(Recursion ZKP)</title><link>https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/</link><pubDate>Sun, 21 Sep 2025 02:33:25 +0000</pubDate><guid>https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/</guid><description>&lt;h2 id="개요">개요&lt;/h2>
&lt;ul>
&lt;li>재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 &lt;strong>계층적으로 합성&lt;/strong>해 &lt;strong>단일 증명&lt;/strong>으로 만드는 기법임.&lt;/li>
&lt;li>목적: 온체인(예: L1)에서 &lt;strong>검증 횟수/비용을 줄임&lt;/strong>. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음.&lt;/li>
&lt;/ul>
&lt;h2 id="왜-필요한가">왜 필요한가&lt;/h2>
&lt;ul>
&lt;li>단일 트랜잭션마다 증명 검증하면 &lt;strong>검증 비용이 선형 증가&lt;/strong>함.&lt;/li>
&lt;li>재귀를 쓰면 n개의 증명을 &lt;strong>로그/계층 구조&lt;/strong>로 합쳐 &lt;strong>한 번만 검증&lt;/strong>하면 됨.&lt;/li>
&lt;li>롤업/배치 처리/프라이버시 워크로드에서 &lt;strong>확장성&lt;/strong> 확보에 유리함.&lt;/li>
&lt;/ul>
&lt;h2 id="핵심-개념">핵심 개념&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>내부 증명(Inner proofs)&lt;/strong>: 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들.&lt;/li>
&lt;li>&lt;strong>합성 회로/Aggregator&lt;/strong>: 이전 단계의 증명들을 &lt;strong>검증하는 로직을 포함&lt;/strong>한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦.&lt;/li>
&lt;li>&lt;strong>최종 증명(Outer proof)&lt;/strong>: 여러 단계를 거쳐 &lt;strong>하나&lt;/strong>로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨.&lt;/li>
&lt;li>&lt;strong>공개 입력 바인딩(Public input binding)&lt;/strong>: 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 &lt;strong>무결성&lt;/strong> 보장함.&lt;/li>
&lt;/ul>
&lt;h2 id="동작-흐름">동작 흐름&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>개별 증명 생성&lt;/strong>: L2에서 트랜잭션/배치 단위로 증명들 생성함.&lt;/li>
&lt;li>&lt;strong>1차 합성&lt;/strong>: 합성 회로가 증명 A·B를 &lt;strong>내부에서 검증&lt;/strong> → “A와 B 모두 올바름”을 나타내는 &lt;strong>새 증명&lt;/strong> 생성.&lt;/li>
&lt;li>&lt;strong>반복 합성&lt;/strong>: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임.&lt;/li>
&lt;li>&lt;strong>최종 합성&lt;/strong>: 최종 1개 증명 도출.&lt;/li>
&lt;li>&lt;strong>온체인 검증&lt;/strong>: L1은 &lt;strong>최종 증명 1개만&lt;/strong> 검증 → 전체 집합이 유효하다는 결론에 도달.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름.&lt;/p></description></item><item><title>오프체인 서명 검증 페이마스터 (in ZkSync Era)</title><link>https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</link><pubDate>Sun, 21 Sep 2025 02:14:08 +0000</pubDate><guid>https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>주의&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>아래는 “핵심 동작만 이해할 수 있는” &lt;strong>부분 스니펫&lt;/strong>과 설명임.&lt;/li>
&lt;li>실제 배포 전에는 보안 리뷰·테스트 필수.&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;hr>
&lt;h2 id="개요">개요&lt;/h2>
&lt;p>오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 &lt;strong>가스비 대납(paymaster)&lt;/strong> 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. &lt;strong>ZkSync Era&lt;/strong> 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.&lt;/p>
&lt;hr>
&lt;h2 id="문제-정의--설계-의도">문제 정의 &amp;amp; 설계 의도&lt;/h2>
&lt;h3 id="내가-당면한-문제">내가 당면한 문제&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>가스비 대납&lt;/strong> 필요함&lt;/li>
&lt;li>&lt;strong>제한된 대상만&lt;/strong> 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함)&lt;/li>
&lt;li>&lt;strong>가스 낭비/잔고 소진&lt;/strong> 리스크 최소화해야 함 (악용·오구성·스팸 대비)&lt;/li>
&lt;/ul>
&lt;h3 id="단순-대안toaddresspaymaster에서-드러난-한계">단순 대안(toAddressPaymaster)에서 드러난 한계&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>신규 유저 온보딩 흐름과 충돌&lt;/strong>&lt;/p></description></item><item><title>머클트리(Merkle Tree) 개념과 블록체인에서의 역할</title><link>https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/</link><pubDate>Sat, 20 Sep 2025 17:15:26 +0000</pubDate><guid>https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 자료구조입니다. 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 한 번에 대표하는 고정 크기 요약을 제공하기 때문입니다. 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미를 중심으로 설명합니다.&lt;/p>
&lt;h3 id="개념구조">개념·구조&lt;/h3>
&lt;p>머클트리는 일반적으로 이진트리 형태로 구현됩니다. 거래(트랜잭션)들을 리프(leaf)로 두고, 인접한 두 리프의 해시를 결합해 부모 노드의 해시를 생성하는 과정을 반복해 최종 루트 해시를 얻습니다. 해시 함수는 보통 SHA-256 계열이 쓰이지만 체인에 따라 다를 수 있습니다. 최상단의 해시를 머클루트(Merkle Root)라 부르며, 머클루트의 크기는 해시 함수에 따라 고정됩니다(예: SHA-256 기준 32바이트).&lt;/p></description></item><item><title>이더리움 PoS(Proof of Stake) 구조와 운영 원리</title><link>https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/</link><pubDate>Sat, 20 Sep 2025 17:04:48 +0000</pubDate><guid>https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>이 글은 이더리움의 PoS(Proof of Stake) 합의 구조와 그것을 구성하는 주요 요소들을 실무 중심으로 정리한 문서입니다. 개념적 정의뿐 아니라 운영 시 주의할 점, 보상·출금 흐름, 그리고 네트워크 레벨에서 발생하는 짧은 체인 재구성(Reorg)의 원인까지 다룹니다. 배경 지식은 PoW 기반 이더리움을 알고 있다는 전제하에 기술함.&lt;/p>
&lt;h3 id="개념과-배경">개념과 배경&lt;/h3>
&lt;p>PoS는 기존 PoW(Proof of Work)의 에너지 집약적 경쟁 방식을 대신하여, 코인을 예치(스테이킹)한 참여자를 검증자로 선발해 블록 생성과 검증에 참여시키는 합의 메커니즘입니다. 이더리움은 2022년 9월 머지(The Merge)를 통해 PoW에서 PoS로 전환했으며, 그 결과 전력 소비가 크게 감소하고 검증자 기반의 보안 모델로 전환되었습니다.&lt;/p></description></item><item><title>NFT 핵심 용어 정리: 리빌·에어드롭·화이트리스트·마켓플레이스</title><link>https://handsupmin.github.io/posts/nft/</link><pubDate>Sat, 20 Sep 2025 16:56:17 +0000</pubDate><guid>https://handsupmin.github.io/posts/nft/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>NFT 커뮤니티에 처음 들어가면 낯선 용어들이 장벽이 된다. 실제로 개념은 단순한 경우가 많다. 핵심 용어를 실무 관점에서 정리하면 프로젝트 참여와 거래 판단에 도움이 된다. 이 글은 리빌, 에어드롭, 화이트리스트, 마켓플레이스 네 가지를 중심으로 설명함.&lt;/p>
&lt;h3 id="리빌reveal">리빌(Reveal)&lt;/h3>
&lt;p>리빌은 민팅 이후에 NFT의 최종 이미지를 공개하는 과정. 미공개 상태로 초기 발행해 판매를 마친 뒤, 일정 시점에 각 토큰의 속성이 드러나는 방식이다. 장난감 뽑기 기계처럼 무엇이 나올지 모르는 구조이며, 리빌 전에는 컬렉션의 대표 이미지로 대체되어 보임.&lt;/p></description></item><item><title>pnpm 설치 방식과 워크스페이스 사용법</title><link>https://handsupmin.github.io/posts/pnpm/</link><pubDate>Sat, 20 Sep 2025 16:44:51 +0000</pubDate><guid>https://handsupmin.github.io/posts/pnpm/</guid><description>&lt;h3 id="서문">서문&lt;/h3>
&lt;p>pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.&lt;/p>
&lt;h3 id="개념-및-배경">개념 및 배경&lt;/h3>
&lt;p>pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음.&lt;/p></description></item><item><title>NFT 개념: 핵심 구성·메인넷·민팅·지갑 가이드</title><link>https://handsupmin.github.io/posts/nft/</link><pubDate>Sat, 20 Sep 2025 16:41:07 +0000</pubDate><guid>https://handsupmin.github.io/posts/nft/</guid><description>&lt;h3 id="서문">서문&lt;/h3>
&lt;p>NFT는 몇 년 새 대중의 관심을 끌면서도 개념적으로는 혼동을 주는 주제다. 단어 자체가 기술적이고, 생태계에 필요한 요소들이 분산돼 있어 처음 접하는 사람에게는 용어 해석부터 거래 절차까지 장애물이 많다. 본문은 실무자 관점에서 NFT의 핵심 개념을 단계적으로 정리하고, 구매·발행·보관 시 유의할 점과 운영 관행을 설명함을 목표로 한다.&lt;/p>
&lt;h3 id="개념과-배경">개념과 배경&lt;/h3>
&lt;p>NFT는 Non-Fungible Token의 약자이며, 대체 불가능한 토큰을 의미한다. 토큰(Token)은 블록체인에서 가치나 권리를 표현하는 단위로, 화폐처럼 동일한 단위끼리 서로 교환 가능한 경우를 &amp;lsquo;Fungible&amp;rsquo;이라 한다. 반면 NFT는 각 토큰이 고유한 식별자(토큰 ID)를 가지며 상호 교환 시 동일 가치를 보장하지 않는 구조. 때문에 디지털 자산의 고유성·소유권 증빙에 적합하다. 블록체인에 기록된 소유권은 변경·위변조가 어렵고 거래 내역의 투명성 확보가 가능하다는 기술적 장점이 있다.&lt;/p></description></item></channel></rss>