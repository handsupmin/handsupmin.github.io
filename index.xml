<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HandsLog</title>
    <link>https://handsupmin.github.io/</link>
    <description>Recent content on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 28 Oct 2025 13:10:28 +0000</lastBuildDate>
    <atom:link href="https://handsupmin.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자</title>
      <link>https://handsupmin.github.io/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</link>
      <pubDate>Tue, 28 Oct 2025 13:10:28 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma의 findMany는 다중 레코드 조회용 메서드
기본값은 대상 모델의 모든 레코드 반환
where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원
옵션 조합으로 조건 기반 조회를 간결하게 구성 가능&lt;/p&gt;
&lt;h3 id=&#34;기본-사용법&#34;&gt;기본 사용법&lt;/h3&gt;
&lt;p&gt;가장 단순한 호출 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prisma&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;findMany&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주요-옵션&#34;&gt;주요 옵션&lt;/h3&gt;
&lt;p&gt;옵션은 필요한 것만 선택적으로 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where: 조건 필터링&lt;/li&gt;
&lt;li&gt;select: 필드 서브셋 선택&lt;/li&gt;
&lt;li&gt;include: 관계 데이터 로드&lt;/li&gt;
&lt;li&gt;orderBy: 정렬 기준 지정&lt;/li&gt;
&lt;li&gt;skip, take: 오프셋 기반 페이징&lt;/li&gt;
&lt;li&gt;distinct: 특정 필드 기준 중복 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where로-조건-필터링&#34;&gt;where로 조건 필터링&lt;/h3&gt;
&lt;p&gt;단일 조건부터 복합 조건까지 표현 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript 함수는 왜 일급 객체인가 — 의미와 활용</title>
      <link>https://handsupmin.github.io/posts/javascript-first-class-functions-5dcc7e/</link>
      <pubDate>Mon, 27 Oct 2025 13:11:11 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/javascript-first-class-functions-5dcc7e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;JavaScript에서 함수는 일급 객체로 취급됨
이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함
이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;변수에 할당 가능&lt;/li&gt;
&lt;li&gt;다른 함수의 인수로 전달 가능&lt;/li&gt;
&lt;li&gt;다른 함수의 반환값으로 사용 가능&lt;/li&gt;
&lt;li&gt;객체의 프로퍼티로 저장 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;변수에 할당&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`Hello, &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;인수로 전달&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fn&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;반환값으로 사용 및 클로저&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</title>
      <link>https://handsupmin.github.io/posts/innodb-pk-less-tables-trade-offs-2dc695/</link>
      <pubDate>Sun, 26 Oct 2025 13:07:10 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/innodb-pk-less-tables-trade-offs-2dc695/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임
대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함
사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함
이때 결정 규칙이 존재함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용&lt;/li&gt;
&lt;li&gt;그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함
따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함&lt;/p&gt;</description>
    </item>
    <item>
      <title>SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)</title>
      <link>https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</link>
      <pubDate>Sat, 25 Oct 2025 13:06:24 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</guid>
      <description>&lt;h1 id=&#34;sseserver-sent-events란-무엇인가&#34;&gt;SSE(Server-Sent Events)란 무엇인가&lt;/h1&gt;
&lt;p&gt;SSE는 &lt;strong&gt;Server-Sent Events&lt;/strong&gt;의 약자로, 서버가 클라이언트로 &lt;strong&gt;실시간 데이터를 단방향으로 푸시&lt;/strong&gt;(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임&lt;/p&gt;
&lt;p&gt;주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sse-vs-웹소켓-그리고-한계&#34;&gt;SSE vs 웹소켓, 그리고 한계&lt;/h2&gt;
&lt;p&gt;SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 환경에서 디버깅하기</title>
      <link>https://handsupmin.github.io/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</link>
      <pubDate>Thu, 23 Oct 2025 13:11:27 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함&lt;/p&gt;
&lt;h3 id=&#34;문제를-명확히-하기&#34;&gt;문제를 명확히 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작성한 코드의 기대 동작 정의&lt;/li&gt;
&lt;li&gt;실제 관측된 동작과의 차이 정리&lt;/li&gt;
&lt;li&gt;실패 조건과 재현 절차 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL InnoDB 장단점과 운영 시 주의사항 정리</title>
      <link>https://handsupmin.github.io/posts/mysql-innodb-pros-cons-and-cautions-4b2d90/</link>
      <pubDate>Wed, 22 Oct 2025 13:12:18 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/mysql-innodb-pros-cons-and-cautions-4b2d90/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;MySQL InnoDB는 ACID 트랜잭션을 기본으로 지원하는 스토리지 엔진으로 데이터 무결성과 동시성 보장을 목표로 설계됨
Row-level lock, MVCC, 클러스터형 인덱스, 외래 키, 크래시 리커버리 등 기능을 통해 OLTP 환경에서 안정적인 처리 성능 제공
아래는 InnoDB의 장단점과 운영 시 주의사항을 정리한 내용임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클러스터형 인덱스 기반 저장 구조
&lt;ul&gt;
&lt;li&gt;기본 키(PK) 순서대로 데이터 페이지에 정렬 저장&lt;/li&gt;
&lt;li&gt;보조 인덱스는 리프에 PK를 포함하여 PK 탐색으로 실제 레코드 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MVCC와 일관 읽기
&lt;ul&gt;
&lt;li&gt;Undo 로그 기반 버전 관리로 일관 읽기 제공&lt;/li&gt;
&lt;li&gt;쓰기와 읽기 동시 처리 시 경합을 줄여 높은 동시성 달성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;트랜잭션과 크래시 리커버리
&lt;ul&gt;
&lt;li&gt;Redo 로그로 커밋 데이터의 내구성 확보&lt;/li&gt;
&lt;li&gt;Doublewrite 버퍼로 부분 쓰기 방지&lt;/li&gt;
&lt;li&gt;비정상 종료 후 복구 경로 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점&#34;&gt;장점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;트랜잭션 ACID 보장&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;COMMIT, ROLLBACK, SAVEPOINT로 안전한 트랜잭션 경계 관리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Row-level lock 기반 높은 동시성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;필요한 행만 잠금으로 쓰기 경합을 최소화&lt;/li&gt;
&lt;li&gt;테이블 락 기반 엔진 대비 OLTP에 유리&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;외래 키 제약으로 참조 무결성 유지&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;부모 자식 간 참조 일관성 DB 레벨에서 강제&lt;/li&gt;
&lt;li&gt;애플리케이션 측 검증 부담 감소&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;크래시 리커버리 안정성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Redo/Undo 로그와 Doublewrite로 장애 상황에서도 데이터 무결성 유지&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;클러스터형 인덱스의 빠른 PK 접근과 범위 스캔 효율&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;PK 기반 조회 및 순차 범위 스캔에서 강점&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;MVCC로 읽기 일관성과 동시 처리 성능 확보&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;롱 리드와 빈번한 쓰기가 공존하는 시나리오에 적합&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;대규모 OLTP 워크로드에 적합&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;대량의 INSERT/UPDATE/DELETE 처리에서 일관된 성능과 안정성 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점&#34;&gt;단점&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;메모리 사용량 큼&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Buffer Pool 등 캐시 구조로 메모리 요구량 높음&lt;/li&gt;
&lt;li&gt;메모리 부족 시 디스크 I/O 증가로 성능 저하 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;클러스터형 인덱스 특성에 따른 PK 설계 민감도 높음&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;PK 업데이트는 물리 재배치와 페이지 분할 유발 가능&lt;/li&gt;
&lt;li&gt;긴 문자열 PK 사용 시 저장 비효율 및 분할 증가 위험&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;디스크 공간 사용량 상대적으로 큼&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Undo/Redo, Doublewrite, 각종 메타데이터로 파일 규모 증가 가능&lt;/li&gt;
&lt;li&gt;대량 갱신 후 조각화 우려&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;파라미터가 많아 운영 난이도 존재&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;innodb_buffer_pool_size, innodb_log_file_size, innodb_flush_method 등 튜닝 필요&lt;/li&gt;
&lt;li&gt;부적절한 설정 시 기대 성능 미달 위험&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;외래 키로 인한 잠금 경합과 데드락 리스크 증가&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다중 FK 검증 경로가 얽히면 경합 심화&lt;/li&gt;
&lt;li&gt;삽입·삭제 순서 제약으로 트랜잭션 복잡도 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Read-heavy 분석형 워크로드 적합성 한계&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;대규모 단순 조회 중심 OLAP 성격은 컬럼 지향 분석 시스템이 유리한 경우 존재&lt;/li&gt;
&lt;li&gt;과거 일부 읽기 패턴에서 MyISAM이 빠른 사례가 있었으나 현재는 InnoDB가 기본 선택지로 자리함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;운영-시-주의사항과-베스트-프랙티스&#34;&gt;운영 시 주의사항과 베스트 프랙티스&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;명시적 PK 또는 고유 인덱스 필수&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;명시적 PK 없으면 숨은 Row ID 사용으로 비효율 발생 가능&lt;/li&gt;
&lt;li&gt;변경이 드문 짧은 정수형 PK 선호 예) INT AUTO_INCREMENT, BIGINT&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Buffer Pool 사이즈 적정화&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;innodb_buffer_pool_size는 핵심 파라미터&lt;/li&gt;
&lt;li&gt;가능한 많은 데이터 페이지를 메모리에 유지할수록 I/O 절감 효과 큼&lt;/li&gt;
&lt;li&gt;서버 메모리 대비 높은 비중 할당 권장하나 워크로드와 여유 메모리 고려하여 점진 조정&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;FK 사용 최소화 및 인덱스 정합성 확보&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;꼭 필요한 관계에만 FK 적용&lt;/li&gt;
&lt;li&gt;FK 컬럼에 적절한 인덱스 부여로 잠금 경합과 테이블 스캔 방지&lt;/li&gt;
&lt;li&gt;트랜잭션 내 잠금 순서 일관성 유지로 데드락 확률 낮추기&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Row format과 페이지 전략 선택&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ROW_FORMAT=DYNAMIC 등으로 긴 TEXT/BLOB를 오프페이지화하여 저장 효율 개선&lt;/li&gt;
&lt;li&gt;크게 보이지 않는 설정이라도 대규모 테이블에서 성능과 공간 효율에 영향 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Auto-increment 충돌 방지&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;레플리케이션 또는 멀티 라이터 시나리오에서 키 충돌 방지 전략 필요&lt;/li&gt;
&lt;li&gt;innodb_autoinc_lock_mode 값 검토 및 키 공간 분할 또는 시퀀스 전략 병행&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;통계 갱신과 조각화 대응&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ANALYZE TABLE로 옵티마이저 통계 최신화&lt;/li&gt;
&lt;li&gt;OPTIMIZE TABLE 또는 테이블 리빌드로 심한 조각화 해소와 공간 회수 검토&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;데드락 모니터링 루틴화&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;SHOW ENGINE INNODB STATUS와 information_schema의 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS로 원인 추적&lt;/li&gt;
&lt;li&gt;쿼리 접근 순서 정렬, 트랜잭션 단위 축소, 적절한 인덱싱으로 예방&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;로그 크기와 플러시 정책의 트레이드오프 이해&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;innodb_log_file_size, innodb_flush_log_at_trx_commit, sync_binlog 설정이 지연 시간과 내구성에 직접 영향&lt;/li&gt;
&lt;li&gt;허용 가능한 데이터 손실 범위와 지연 요구사항에 맞춰 설정 조정&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;장점 요약
&lt;ul&gt;
&lt;li&gt;ACID 트랜잭션, Row-level lock, MVCC, FK, 클러스터형 인덱스, 안정적 크래시 리커버리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점 요약
&lt;ul&gt;
&lt;li&gt;메모리와 디스크 사용량 큼, 설정 복잡도 존재, PK 설계 민감, FK로 인한 경합과 데드락 리스크&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;운영 체크리스트
&lt;ul&gt;
&lt;li&gt;짧은 정수형 명시적 PK 설계&lt;/li&gt;
&lt;li&gt;Buffer Pool 및 로그 정책 튜닝&lt;/li&gt;
&lt;li&gt;FK 최소화와 인덱스 정합성 확보&lt;/li&gt;
&lt;li&gt;정기 통계 갱신과 조각화 관리, 데드락 모니터링
적절한 설정과 스키마 설계를 병행하면 OLTP 환경에서 높은 안정성과 성능을 동시에 달성 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-file-system-architecture.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-file-system-architecture.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-optimizing-innodb-operations.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-optimizing-innodb-operations.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>TypeScript enum, const enum, as const 차이와 선택 기준</title>
      <link>https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-3817af/</link>
      <pubDate>Tue, 21 Oct 2025 13:12:21 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-3817af/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임
각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음&lt;/p&gt;
&lt;h3 id=&#34;enum-개념과-동작&#34;&gt;enum 개념과 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;열거형 타입을 선언하는 문법&lt;/li&gt;
&lt;li&gt;숫자 기반과 문자열 기반 모두 지원&lt;/li&gt;
&lt;li&gt;컴파일 결과로 양방향 매핑을 담은 JS 객체 생성
&lt;ul&gt;
&lt;li&gt;키로 값 조회, 값으로 키 역조회 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BooleanType&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;False&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;True&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징</title>
      <link>https://handsupmin.github.io/posts/sql-limit-offset-basics-4a9880/</link>
      <pubDate>Mon, 20 Oct 2025 13:10:30 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/sql-limit-offset-basics-4a9880/</guid>
      <description>&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;p&gt;LIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문
WHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치&lt;/p&gt;
&lt;p&gt;두 가지 형태 사용&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;개수&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;개수&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;OFFSET&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;시작&lt;/span&gt;_인덱스
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;일부 dialect에서는 아래 축약형도 존재&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- MySQL, SQLite
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;시작&lt;/span&gt;_인덱스, &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;개수&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;1-limit-개수&#34;&gt;1. LIMIT 개수&lt;/h3&gt;
&lt;p&gt;LIMIT 뒤 숫자는 인덱스가 아닌 개수&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; Book
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;현재 정렬 기준에서 맨 위 행 1개만 반환
ORDER BY가 없으면 반환되는 행은 비결정적일 수 있음&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법</title>
      <link>https://handsupmin.github.io/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</link>
      <pubDate>Sun, 19 Oct 2025 13:06:18 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음
Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 &amp;ndash;debug는 폐기, &amp;ndash;inspect로 통일됨
CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함&lt;/p&gt;
&lt;p&gt;이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v8-inspector 프로토콜
&lt;ul&gt;
&lt;li&gt;V8이 노출하는 디버깅 프로토콜&lt;/li&gt;
&lt;li&gt;Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect vs &amp;ndash;inspect-brk
&lt;ul&gt;
&lt;li&gt;&amp;ndash;inspect는 바로 실행하면서 디버거 접속 대기&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;포트
&lt;ul&gt;
&lt;li&gt;기본 포트 9229 사용&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect=PORT, &amp;ndash;inspect-brk=PORT 형태로 변경 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프론트엔드
&lt;ul&gt;
&lt;li&gt;Chromium 기반 개발자도구로 연결 가능&lt;/li&gt;
&lt;li&gt;chrome://inspect 에서 Node 대상 탐색 및 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;node-inspect
&lt;ul&gt;
&lt;li&gt;Node 내장 CLI 디버거&lt;/li&gt;
&lt;li&gt;동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;크롬-개발자도구로-디버깅&#34;&gt;크롬 개발자도구로 디버깅&lt;/h3&gt;
&lt;p&gt;Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교</title>
      <link>https://handsupmin.github.io/posts/kubernetes-control-plane-eks-2af164/</link>
      <pubDate>Sat, 18 Oct 2025 13:06:16 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/kubernetes-control-plane-eks-2af164/</guid>
      <description>&lt;p&gt;컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음
조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함&lt;/p&gt;
&lt;h3 id=&#34;개념과-정의&#34;&gt;개념과 정의&lt;/h3&gt;
&lt;p&gt;컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층
사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴&lt;/p&gt;
&lt;h3 id=&#34;핵심-구성요소&#34;&gt;핵심 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://handsupmin.github.io/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes 핵심 구성요소와 동작 흐름</title>
      <link>https://handsupmin.github.io/posts/kubernetes-core-components-and-flow-915d3a/</link>
      <pubDate>Thu, 16 Oct 2025 13:10:58 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/kubernetes-core-components-and-flow-915d3a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템
핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프
각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능&lt;/p&gt;
&lt;h3 id=&#34;구성요소-관계-한눈에&#34;&gt;구성요소 관계 한눈에&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl / CI
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube-apiserver ──&amp;gt; etcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │  ▲
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │  └(상태 영속)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├─ kube-scheduler(어디 배치할지 결정)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[각 워커 노드]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubelet ──(CRI gRPC)──&amp;gt; container runtime ──(OCI)──&amp;gt; runc/crun ──&amp;gt; cgroup 설정 + 컨테이너 시작
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │                                        │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├─(CNI 호출) 네트워크/IP 할당            └─ 네임스페이스/마운트 등 격리
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └─ kube-proxy(서비스 라우팅: iptables/ipvs)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;모든 컴포넌트의 권위자이자 입구는 apiserver&lt;/li&gt;
&lt;li&gt;etcd와 직접 통신하는 주체는 apiserver만 존재&lt;/li&gt;
&lt;li&gt;kubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지&lt;/li&gt;
&lt;li&gt;container runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pod-생성에서-running까지&#34;&gt;Pod 생성에서 Running까지&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화&lt;/li&gt;
&lt;li&gt;controller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등&lt;/li&gt;
&lt;li&gt;scheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩&lt;/li&gt;
&lt;li&gt;대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지&lt;/li&gt;
&lt;li&gt;kubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당&lt;/li&gt;
&lt;li&gt;kubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달&lt;/li&gt;
&lt;li&gt;runtime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행&lt;/li&gt;
&lt;li&gt;kubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고&lt;/li&gt;
&lt;li&gt;kube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립&lt;/li&gt;
&lt;li&gt;클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cgroup과-리소스-제한-연결&#34;&gt;cgroup과 리소스 제한 연결&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정&lt;/li&gt;
&lt;li&gt;CPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여&lt;/li&gt;
&lt;li&gt;메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제&lt;/li&gt;
&lt;li&gt;쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장애스케일자체-복구-흐름&#34;&gt;장애·스케일·자체 복구 흐름&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행&lt;/li&gt;
&lt;li&gt;노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택&lt;/li&gt;
&lt;li&gt;HPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;용어-핵심-정리&#34;&gt;용어 핵심 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;control plane  apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소&lt;/li&gt;
&lt;li&gt;worker node  파드를 실제로 실행하는 머신 풀&lt;/li&gt;
&lt;li&gt;kubelet  각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당&lt;/li&gt;
&lt;li&gt;container runtime  kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수&lt;/li&gt;
&lt;li&gt;cgroup  컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;apiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL EXPLAIN 실행 계획 해석 가이드</title>
      <link>https://handsupmin.github.io/posts/mysql-explain-execution-plan-guide-b7fb65/</link>
      <pubDate>Wed, 15 Oct 2025 13:10:54 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/mysql-explain-execution-plan-guide-b7fb65/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구
병목 파악과 인덱스 전략 점검에 사용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select_type
&lt;ul&gt;
&lt;li&gt;SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음&lt;/li&gt;
&lt;li&gt;PRIMARY 가장 바깥쪽 SELECT&lt;/li&gt;
&lt;li&gt;SUBQUERY 서브쿼리&lt;/li&gt;
&lt;li&gt;DERIVED FROM 절의 서브쿼리&lt;/li&gt;
&lt;li&gt;UNION UNION의 두 번째 이후 SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 실행 품질 지표, 위에서 아래로 유리
&lt;ul&gt;
&lt;li&gt;system 테이블에 단 하나의 행&lt;/li&gt;
&lt;li&gt;const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회&lt;/li&gt;
&lt;li&gt;eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭&lt;/li&gt;
&lt;li&gt;ref 인덱스를 사용한 동등 조건 검색&lt;/li&gt;
&lt;li&gt;range 인덱스를 사용한 범위 검색&lt;/li&gt;
&lt;li&gt;index 인덱스 전체 스캔&lt;/li&gt;
&lt;li&gt;ALL 테이블 전체 스캔, 최악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음&lt;/li&gt;
&lt;li&gt;key 실제 사용된 인덱스, NULL이면 인덱스 미사용&lt;/li&gt;
&lt;li&gt;rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리&lt;/li&gt;
&lt;li&gt;filtered 조건 후 남는 행 비율 추정치, 높을수록 유리&lt;/li&gt;
&lt;li&gt;Extra 추가 단서
&lt;ul&gt;
&lt;li&gt;Using index 커버링 인덱스 사용, 유리&lt;/li&gt;
&lt;li&gt;Using where WHERE 조건으로 필터링 수행&lt;/li&gt;
&lt;li&gt;Using filesort 추가 정렬 필요, 비용 큼&lt;/li&gt;
&lt;li&gt;Using temporary 임시 테이블 사용, 비용 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해석-기준&#34;&gt;해석 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type이 const, ref, range 범주에 위치&lt;/li&gt;
&lt;li&gt;key가 NULL이 아니고 적절한 인덱스 선택&lt;/li&gt;
&lt;li&gt;rows 추정치가 작고 filtered 비율이 높음&lt;/li&gt;
&lt;li&gt;Extra에 Using filesort, Using temporary 부재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시와-해석&#34;&gt;예시와 해석&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;type: ALL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;possible_keys: NULL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rows: 3527425
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Extra: Using where; Using filesort
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;테이블 전체 스캔으로 많은 행을 읽게 됨&lt;/li&gt;
&lt;li&gt;인덱스 후보와 실제 사용 인덱스가 없음&lt;/li&gt;
&lt;li&gt;WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승&lt;/li&gt;
&lt;li&gt;현재 계획은 인덱스 설계와 조건식 재검토 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rows와 filtered는 통계 기반 추정치라 실제와 오차 가능&lt;/li&gt;
&lt;li&gt;filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용&lt;/li&gt;
&lt;li&gt;Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려&lt;/li&gt;
&lt;li&gt;커버링 인덱스 구성 시 Extra의 Using index로 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기
위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 인덱서 가이드</title>
      <link>https://handsupmin.github.io/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/</link>
      <pubDate>Mon, 13 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/</guid>
      <description>&lt;h1 id=&#34;블록체인-인덱서-가이드&#34;&gt;블록체인 인덱서 가이드&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임
디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;왜-인덱서가-필요한가&#34;&gt;왜 인덱서가 필요한가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼&lt;/li&gt;
&lt;li&gt;디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함&lt;/li&gt;
&lt;li&gt;전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;인덱싱-대상-데이터-유형&#34;&gt;인덱싱 대상 데이터 유형&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;블록 헤더와 트랜잭션 메타데이터&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용</title>
      <link>https://handsupmin.github.io/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</link>
      <pubDate>Sat, 11 Oct 2025 13:05:12 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함
이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름
합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함
PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임
실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함&lt;/p&gt;
&lt;h3 id=&#34;합의가-필요한-이유와-기준&#34;&gt;합의가 필요한 이유와 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음&lt;/li&gt;
&lt;li&gt;활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨&lt;/li&gt;
&lt;li&gt;최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨&lt;/li&gt;
&lt;li&gt;시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요&lt;/li&gt;
&lt;li&gt;성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건&lt;/li&gt;
&lt;li&gt;탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pow-작업증명-핵심&#34;&gt;PoW 작업증명 핵심&lt;/h3&gt;
&lt;p&gt;정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조
구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요
난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행
보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미
장점&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 채굴 개념과 동작 원리 PoW 보상 구조 이더리움 전환 사례</title>
      <link>https://handsupmin.github.io/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/</link>
      <pubDate>Mon, 06 Oct 2025 13:09:34 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임
역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음
이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨
아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부&lt;/li&gt;
&lt;li&gt;트랜잭션 계정 상태를 변화시키는 요청 또는 메시지&lt;/li&gt;
&lt;li&gt;채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체&lt;/li&gt;
&lt;li&gt;작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙&lt;/li&gt;
&lt;li&gt;난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할&lt;/li&gt;
&lt;li&gt;넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값&lt;/li&gt;
&lt;li&gt;메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합&lt;/li&gt;
&lt;li&gt;블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;왜-채굴이-필요한가&#34;&gt;왜 채굴이 필요한가&lt;/h3&gt;
&lt;p&gt;탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음
예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함
채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함
PoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움&lt;/p&gt;</description>
    </item>
    <item>
      <title>Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW</title>
      <link>https://handsupmin.github.io/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/</link>
      <pubDate>Fri, 03 Oct 2025 13:07:57 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표
ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구
핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음&lt;/p&gt;
&lt;h3 id=&#34;배경과-목적&#34;&gt;배경과 목적&lt;/h3&gt;
&lt;p&gt;이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼
저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적
L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것
ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공&lt;/p&gt;</description>
    </item>
    <item>
      <title>Viem으로 이더리움 읽기·쓰기 시작하기 가이드</title>
      <link>https://handsupmin.github.io/posts/viem-ethereum-read-write-guide-4a5336/</link>
      <pubDate>Thu, 02 Oct 2025 13:07:56 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/viem-ethereum-read-write-guide-4a5336/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임
ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음
프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Public Client&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트&lt;/li&gt;
&lt;li&gt;블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wallet Client&lt;/p&gt;</description>
    </item>
    <item>
      <title>영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이</title>
      <link>https://handsupmin.github.io/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</link>
      <pubDate>Mon, 29 Sep 2025 13:10:22 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함
블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임
이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함&lt;/p&gt;
&lt;h2 id=&#34;목적과-맥락&#34;&gt;목적과 맥락&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비밀을 공개하지 않고 유효성만 검증하려는 요구 증가&lt;/li&gt;
&lt;li&gt;퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대&lt;/li&gt;
&lt;li&gt;오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체&lt;/li&gt;
&lt;li&gt;Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체&lt;/li&gt;
&lt;li&gt;Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식&lt;/li&gt;
&lt;li&gt;Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명&lt;/li&gt;
&lt;li&gt;Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제&lt;/li&gt;
&lt;li&gt;Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;영지식-증명의-세-가지-성질&#34;&gt;영지식 증명의 세 가지 성질&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨&lt;/li&gt;
&lt;li&gt;건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤&lt;/li&gt;
&lt;li&gt;영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;직관적-예시-알리바바-동굴&#34;&gt;직관적 예시 알리바바 동굴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음&lt;/li&gt;
&lt;li&gt;검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함&lt;/li&gt;
&lt;li&gt;Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2&lt;/li&gt;
&lt;li&gt;k회 독립 반복하면 모두 속일 확률 2^-k로 급감&lt;/li&gt;
&lt;li&gt;검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심 포인트&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 Reorg(체인 재구성) 이해</title>
      <link>https://handsupmin.github.io/posts/blockchain-reorg-chain-reorganization-f4966a/</link>
      <pubDate>Sun, 28 Sep 2025 13:05:58 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/blockchain-reorg-chain-reorganization-f4966a/</guid>
      <description>&lt;h2 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h2&gt;
&lt;p&gt;Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함
짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨
노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함&lt;/p&gt;
&lt;h2 id=&#34;핵심-용어-정리&#34;&gt;핵심 용어 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스테일 블록 best chain에 편입되지 못한 정상 블록을 말함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음&lt;/p&gt;</description>
    </item>
    <item>
      <title>커스토디얼 vs 논커스토디얼 월렛 비교</title>
      <link>https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/</link>
      <pubDate>Tue, 23 Sep 2025 13:09:26 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/custodial-vs-noncustodial-wallets-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;프라이빗키 관리 방식에 따라 암호화폐 월렛은 &lt;strong&gt;커스토디얼(custodial)&lt;/strong&gt; 과 &lt;strong&gt;논커스토디얼(noncustodial)&lt;/strong&gt; 로 구분됨
각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 &lt;strong&gt;초보자도 이해할 수 있게&lt;/strong&gt; 정리하면서 &lt;strong&gt;실무자가 바로 적용할 수 있는 체크리스트&lt;/strong&gt;까지 제시함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;커스토디얼 월렛&lt;/strong&gt;
제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조
로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;논커스토디얼 월렛&lt;/strong&gt;
사용자가 프라이빗키를 직접 보유·관리하는 구조
브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;핵심 차이 한 줄 정리&lt;/strong&gt;
키의 &lt;strong&gt;소유·통제 주체&lt;/strong&gt;가 제3자인가 사용자 본인인가의 차이&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인이란? 블록체인 개념 총정리</title>
      <link>https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/</link>
      <pubDate>Mon, 22 Sep 2025 13:10:11 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/blockchain-principles-mining-hash-274b74/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인은 &lt;strong&gt;중앙 기관 없이&lt;/strong&gt; 참여자들이 거래를 기록·검증·공유하는 &lt;strong&gt;분산 원장&lt;/strong&gt; 기술임
이 글은 블록체인을 &lt;strong&gt;초보자 친화적으로&lt;/strong&gt; 설명하고, &lt;strong&gt;실무 체크리스트&lt;/strong&gt;까지 정리함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;큰-그림-시스템-구성&#34;&gt;큰 그림: 시스템 구성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;노드(Node)&lt;/strong&gt;: 블록체인 소프트웨어 실행 주체&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;풀노드&lt;/strong&gt;: 모든 블록·트랜잭션 검증·저장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;라이트 클라이언트&lt;/strong&gt;: 헤더·머클 증명 기반 최소 검증&lt;/li&gt;
&lt;li&gt;(참고) &lt;strong&gt;아카이브 노드&lt;/strong&gt;: 오래된 상태 포함 전체 상태 유지(필수 아님)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;블록(Block)&lt;/strong&gt;: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;합의(Consensus)&lt;/strong&gt;: 어떤 블록이 정식 이력인지 네트워크가 &lt;strong&gt;공동으로&lt;/strong&gt; 결정하는 규칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PoW: 작업증명(연산 경쟁)&lt;/li&gt;
&lt;li&gt;PoS: 지분증명(검증자·보증금 기반)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;해시hash와-위변조-방지&#34;&gt;해시(Hash)와 위·변조 방지&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;해시 함수(SHA-256, Keccak-256 등)&lt;/strong&gt;: 입력을 고정 길이로 압축하는 일방향 함수임&lt;/p&gt;</description>
    </item>
    <item>
      <title>오프체인 서명 검증(Off-chain Signature Verification)이란?</title>
      <link>https://handsupmin.github.io/posts/off-chain-signature-verification-542a33/</link>
      <pubDate>Sun, 21 Sep 2025 03:11:23 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/off-chain-signature-verification-542a33/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음
이때 &lt;strong&gt;오프체인 서명 검증&lt;/strong&gt;(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨&lt;/p&gt;
&lt;p&gt;쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음
가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨&lt;/p&gt;
&lt;p&gt;이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄&lt;/p&gt;</description>
    </item>
    <item>
      <title>안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)</title>
      <link>https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</link>
      <pubDate>Sun, 21 Sep 2025 02:14:08 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 &lt;strong&gt;가스비&lt;/strong&gt;(Gas Fee)임
아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임
이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 &lt;strong&gt;가스리스 트랜잭션&lt;/strong&gt;(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음&lt;/p&gt;
&lt;p&gt;zkSync Era는 이를 위해 &lt;strong&gt;페이마스터&lt;/strong&gt;(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임&lt;/p&gt;</description>
    </item>
    <item>
      <title>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</title>
      <link>https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/</link>
      <pubDate>Sat, 20 Sep 2025 17:15:26 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;머클트리는 블록체인에서 거래 집합을 &lt;strong&gt;안전하고 효율적으로 요약·검증&lt;/strong&gt;하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 &lt;strong&gt;고정 크기 해시 하나&lt;/strong&gt;로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념과-구조&#34;&gt;핵심 개념과 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;머클트리는 보통 &lt;strong&gt;이진 트리&lt;/strong&gt; 형태로 구현함&lt;/li&gt;
&lt;li&gt;거래들을 &lt;strong&gt;리프(leaf)&lt;/strong&gt; 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 &lt;strong&gt;루트 해시&lt;/strong&gt;를 얻음&lt;/li&gt;
&lt;li&gt;해시 함수는 체인별로 다르며 비트코인은 &lt;strong&gt;더블 SHA‑256&lt;/strong&gt;, 이더리움은 트라이 구조에서 &lt;strong&gt;Keccak‑256&lt;/strong&gt; 을 사용함&lt;/li&gt;
&lt;li&gt;최상단 해시를 &lt;strong&gt;머클루트(Merkle root)&lt;/strong&gt; 라 부르며 크기는 해시 함수에 따라 고정됨&lt;/li&gt;
&lt;li&gt;리프 수가 홀수일 때는 마지막 리프를 &lt;strong&gt;복제해 짝을 맞추는 방식&lt;/strong&gt;이 일반적이며 비트코인은 이 규칙을 사용함&lt;/li&gt;
&lt;li&gt;트리 깊이는 리프 수 N에 대해 &lt;strong&gt;⌈log₂ N⌉&lt;/strong&gt; 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동작-원리와-장점&#34;&gt;동작 원리와 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인접 노드 해시 &lt;strong&gt;H_left || H_right&lt;/strong&gt; 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;무결성 검증&lt;/strong&gt;
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;효율적 포함 증명&lt;/strong&gt;
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 &lt;strong&gt;형제 해시들만&lt;/strong&gt; 있으면 됨
필요한 해시 개수는 &lt;strong&gt;O(log N)&lt;/strong&gt; 으로 작아 대역폭과 검증 비용이 작음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 보조&lt;/strong&gt;
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;블록-헤더와-경량-노드spv&#34;&gt;블록 헤더와 경량 노드(SPV)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함&lt;/li&gt;
&lt;li&gt;경량 노드(SPV)는 &lt;strong&gt;블록 전체가 아니라 헤더 체인만&lt;/strong&gt; 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 &lt;strong&gt;머클 증명&lt;/strong&gt; 을 받아 포함 여부를 검증함&lt;/li&gt;
&lt;li&gt;이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨&lt;/li&gt;
&lt;li&gt;이더리움은 전통적인 이진 머클트리 대신 &lt;strong&gt;머클‑패트리샤 트라이(MPT)&lt;/strong&gt; 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;구현-세부와-체인별-차이&#34;&gt;구현 세부와 체인별 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;비트코인&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 PoS(Proof of Stake) 소개</title>
      <link>https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/</link>
      <pubDate>Sat, 20 Sep 2025 17:04:48 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함
개념 정의에 그치지 않고 &lt;strong&gt;운영 시 주의점&lt;/strong&gt;, &lt;strong&gt;보상·출금 흐름&lt;/strong&gt;, &lt;strong&gt;짧은 체인 재구성(Reorg) 원인과 완화책&lt;/strong&gt;까지 다룸&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;PoS는 PoW의 에너지 경쟁을 대체해 &lt;strong&gt;예치된 지분을 바탕으로 검증자를 선정&lt;/strong&gt;하는 합의 메커니즘임
이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 &lt;strong&gt;검증자 기반 보안 모델&lt;/strong&gt;로 이행함&lt;/p&gt;
&lt;p&gt;주요 속성 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에너지 소비 대폭 축소&lt;/li&gt;
&lt;li&gt;스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨&lt;/li&gt;
&lt;li&gt;위반 시 슬래싱과 페널티로 예치금이 감소함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;계층-분리와-beacon-chain의-역할&#34;&gt;계층 분리와 Beacon Chain의 역할&lt;/h3&gt;
&lt;p&gt;이더리움은 &lt;strong&gt;합의 계층(Beacon Chain)&lt;/strong&gt; 과 &lt;strong&gt;실행 계층(Execution Layer)&lt;/strong&gt; 를 분리해 설계함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFT 핵심 용어 정리</title>
      <link>https://handsupmin.github.io/posts/nft-23q12akw/</link>
      <pubDate>Sat, 20 Sep 2025 16:56:17 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/nft-23q12akw/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 &lt;strong&gt;리빌&lt;/strong&gt;, &lt;strong&gt;에어드롭&lt;/strong&gt;, &lt;strong&gt;화이트리스트&lt;/strong&gt;, &lt;strong&gt;마켓플레이스&lt;/strong&gt;를 실무 관점으로 정리함
핵심은 개념 이해를 넘어 &lt;strong&gt;운영 체크리스트&lt;/strong&gt;, &lt;strong&gt;보안 리스크&lt;/strong&gt;, &lt;strong&gt;가격 형성 메커니즘&lt;/strong&gt;까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;공통-전제와-기본-개념&#34;&gt;공통 전제와 기본 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFT 표준&lt;/strong&gt;
주로 ERC‑721과 ERC‑1155를 사용함
721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메타데이터와 저장소&lt;/strong&gt;
토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장
중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFT란? NFT 핵심 개념 정리</title>
      <link>https://handsupmin.github.io/posts/nft-concept-20gd0fl/</link>
      <pubDate>Sat, 20 Sep 2025 16:41:07 +0000</pubDate>
      <guid>https://handsupmin.github.io/posts/nft-concept-20gd0fl/</guid>
      <description>&lt;h3 id=&#34;서문&#34;&gt;서문&lt;/h3&gt;
&lt;p&gt;NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움
이 글은 &lt;strong&gt;실무자 관점&lt;/strong&gt;에서 NFT의 핵심 개념을 단계적으로 정리하고 &lt;strong&gt;구매·발행·보관 시 유의사항&lt;/strong&gt;과 &lt;strong&gt;운영 관행&lt;/strong&gt;을 담는 것을 목표로 함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함
동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 &lt;strong&gt;고유 식별자와 속성&lt;/strong&gt;을 가져 상호 교환 시 동일 가치를 보장하지 않음
블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음
온체인 소유권이 &lt;strong&gt;저작권·초상권 등 법적 권리와 자동 동치가 아님&lt;/strong&gt;에 유의해야 함&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
