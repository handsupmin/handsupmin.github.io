<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>재귀적 영지식 증명이란?(Recursion ZKP) | HandsLog</title>
<meta name=keywords content="영지식증명,ZKP,재귀적-ZKP,Recursion"><meta name=description content="개요

재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임.
목적: 온체인(예: L1)에서 검증 횟수/비용을 줄임. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음.

왜 필요한가

단일 트랜잭션마다 증명 검증하면 검증 비용이 선형 증가함.
재귀를 쓰면 n개의 증명을 로그/계층 구조로 합쳐 한 번만 검증하면 됨.
롤업/배치 처리/프라이버시 워크로드에서 확장성 확보에 유리함.

핵심 개념

내부 증명(Inner proofs): 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들.
합성 회로/Aggregator: 이전 단계의 증명들을 검증하는 로직을 포함한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦.
최종 증명(Outer proof): 여러 단계를 거쳐 하나로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨.
공개 입력 바인딩(Public input binding): 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 무결성 보장함.

동작 흐름

개별 증명 생성: L2에서 트랜잭션/배치 단위로 증명들 생성함.
1차 합성: 합성 회로가 증명 A·B를 내부에서 검증 → “A와 B 모두 올바름”을 나타내는 새 증명 생성.
반복 합성: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임.
최종 합성: 최종 1개 증명 도출.
온체인 검증: L1은 최종 증명 1개만 검증 → 전체 집합이 유효하다는 결론에 도달.


직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름."><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="재귀적 영지식 증명이란?(Recursion ZKP)"><meta property="og:description" content="개요 재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임. 목적: 온체인(예: L1)에서 검증 횟수/비용을 줄임. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음. 왜 필요한가 단일 트랜잭션마다 증명 검증하면 검증 비용이 선형 증가함. 재귀를 쓰면 n개의 증명을 로그/계층 구조로 합쳐 한 번만 검증하면 됨. 롤업/배치 처리/프라이버시 워크로드에서 확장성 확보에 유리함. 핵심 개념 내부 증명(Inner proofs): 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들. 합성 회로/Aggregator: 이전 단계의 증명들을 검증하는 로직을 포함한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦. 최종 증명(Outer proof): 여러 단계를 거쳐 하나로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨. 공개 입력 바인딩(Public input binding): 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 무결성 보장함. 동작 흐름 개별 증명 생성: L2에서 트랜잭션/배치 단위로 증명들 생성함. 1차 합성: 합성 회로가 증명 A·B를 내부에서 검증 → “A와 B 모두 올바름”을 나타내는 새 증명 생성. 반복 합성: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임. 최종 합성: 최종 1개 증명 도출. 온체인 검증: L1은 최종 증명 1개만 검증 → 전체 집합이 유효하다는 결론에 도달. 직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-21T02:33:25+00:00"><meta property="article:modified_time" content="2025-09-21T02:33:25+00:00"><meta property="article:tag" content="영지식증명"><meta property="article:tag" content="ZKP"><meta property="article:tag" content="재귀적-ZKP"><meta property="article:tag" content="Recursion"><meta name=twitter:card content="summary"><meta name=twitter:title content="재귀적 영지식 증명이란?(Recursion ZKP)"><meta name=twitter:description content="개요

재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임.
목적: 온체인(예: L1)에서 검증 횟수/비용을 줄임. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음.

왜 필요한가

단일 트랜잭션마다 증명 검증하면 검증 비용이 선형 증가함.
재귀를 쓰면 n개의 증명을 로그/계층 구조로 합쳐 한 번만 검증하면 됨.
롤업/배치 처리/프라이버시 워크로드에서 확장성 확보에 유리함.

핵심 개념

내부 증명(Inner proofs): 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들.
합성 회로/Aggregator: 이전 단계의 증명들을 검증하는 로직을 포함한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦.
최종 증명(Outer proof): 여러 단계를 거쳐 하나로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨.
공개 입력 바인딩(Public input binding): 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 무결성 보장함.

동작 흐름

개별 증명 생성: L2에서 트랜잭션/배치 단위로 증명들 생성함.
1차 합성: 합성 회로가 증명 A·B를 내부에서 검증 → “A와 B 모두 올바름”을 나타내는 새 증명 생성.
반복 합성: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임.
최종 합성: 최종 1개 증명 도출.
온체인 검증: L1은 최종 증명 1개만 검증 → 전체 집합이 유효하다는 결론에 도달.


직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"재귀적 영지식 증명이란?(Recursion ZKP)","item":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"재귀적 영지식 증명이란?(Recursion ZKP)","name":"재귀적 영지식 증명이란?(Recursion ZKP)","description":"개요 재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임. 목적: 온체인(예: L1)에서 검증 횟수/비용을 줄임. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음. 왜 필요한가 단일 트랜잭션마다 증명 검증하면 검증 비용이 선형 증가함. 재귀를 쓰면 n개의 증명을 로그/계층 구조로 합쳐 한 번만 검증하면 됨. 롤업/배치 처리/프라이버시 워크로드에서 확장성 확보에 유리함. 핵심 개념 내부 증명(Inner proofs): 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들. 합성 회로/Aggregator: 이전 단계의 증명들을 검증하는 로직을 포함한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦. 최종 증명(Outer proof): 여러 단계를 거쳐 하나로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨. 공개 입력 바인딩(Public input binding): 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 무결성 보장함. 동작 흐름 개별 증명 생성: L2에서 트랜잭션/배치 단위로 증명들 생성함. 1차 합성: 합성 회로가 증명 A·B를 내부에서 검증 → “A와 B 모두 올바름”을 나타내는 새 증명 생성. 반복 합성: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임. 최종 합성: 최종 1개 증명 도출. 온체인 검증: L1은 최종 증명 1개만 검증 → 전체 집합이 유효하다는 결론에 도달. 직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름.\n","keywords":["영지식증명","ZKP","재귀적-ZKP","Recursion"],"articleBody":"개요 재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임. 목적: 온체인(예: L1)에서 검증 횟수/비용을 줄임. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음. 왜 필요한가 단일 트랜잭션마다 증명 검증하면 검증 비용이 선형 증가함. 재귀를 쓰면 n개의 증명을 로그/계층 구조로 합쳐 한 번만 검증하면 됨. 롤업/배치 처리/프라이버시 워크로드에서 확장성 확보에 유리함. 핵심 개념 내부 증명(Inner proofs): 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들. 합성 회로/Aggregator: 이전 단계의 증명들을 검증하는 로직을 포함한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦. 최종 증명(Outer proof): 여러 단계를 거쳐 하나로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨. 공개 입력 바인딩(Public input binding): 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 무결성 보장함. 동작 흐름 개별 증명 생성: L2에서 트랜잭션/배치 단위로 증명들 생성함. 1차 합성: 합성 회로가 증명 A·B를 내부에서 검증 → “A와 B 모두 올바름”을 나타내는 새 증명 생성. 반복 합성: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임. 최종 합성: 최종 1개 증명 도출. 온체인 검증: L1은 최종 증명 1개만 검증 → 전체 집합이 유효하다는 결론에 도달. 직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름.\n장점/단점 장점\n온체인 검증 1회로 다수 명제를 커버 → 가스/수수료 절감 배치 크기 커질수록 상대적으로 효율↑ 단점\n증명 생성 파이프라인 복잡도↑, 오프체인 생성 시간/메모리 부담↑ 합성 단계 설계가 비효율적이면 전체 지연이 커질 수 있음 설계 포인트 집계 전략: 이진 트리, k‑ary 트리, 스트리밍 합성 등 워크로드 특성에 맞춰 선택. 공개 입력 설계: 어떤 집합을 증명했는지 루트 커밋/메타데이터를 명확히 포함. 정확성 보장: 합성 회로는 “내부 검증 성공”을 명확히 인코딩해야 함. 사운드니스(정합성): 상위 단계가 하위 단계의 결과를 그대로 받아 검증하도록 데이터 경계(입·출력) 정의 필요. 운영 가드레일: 실패 시 폴백, 배치 크기 캡, 타임아웃/재시도, 관측성(메트릭/로그) 확보. 테스트/검증 체크리스트 재귀 깊이별 테스트: 1→2→4→… 단계별로 증명 생성 시간·메모리·크기 측정. 경계값: 큰 배치/작은 배치/빈 배치, 공개 입력 불일치, 순서 바뀜 등 부정 케이스. 회귀 방지: 고정된 입력 집합에 대한 스냅샷 테스트/해시 고정으로 의도치 않은 변경 탐지. 온체인 검증 리허설: 최종 증명 크기/검증 가스 한도 내 수렴 확인. 개념 비교(헷갈리기 쉬운 용어) Aggregation vs Recursion\nAggregation: 여러 증명을 한 번에 묶어 검증(개념적으로 비재귀적 표현도 포함). Recursion: “증명을 검증하는 회로”에 대해 또 다른 증명을 생성하는 계층적 접근. Batching: 입력을 모아서 처리하는 운영 기법. 재귀/집계와 함께 쓰이면 시너지가 큼.\n활용 시나리오 롤업: L2 다수 트랜잭션 증명을 최종 1개로 합쳐 L1 검증. 프라이버시 애플리케이션: 여러 단계의 정책 만족을 하나의 최종 증명으로 제시. 데이터 가용성 증명: 여러 청크의 검증을 합성해 단일 확인 단계로 축소. 마무리 재귀적 ZKP의 본질 = “증명을 다시 증명” 해서 검증 부담을 한 점으로 수렴시키는 것임. 구체적인 프로토콜/알고리즘 명칭 없이도, 위 개념 요소(내부 증명·합성 회로·최종 증명·공개 입력 바인딩)만 이해하면 전반 동작 원리 파악 가능함. 실제 적용 시에는 목표 TPS/지연, 오프체인 리소스, 온체인 가스 모델을 고려해 집계 전략·배치 정책을 함께 설계하면 됨. ","wordCount":"461","inLanguage":"en","datePublished":"2025-09-21T02:33:25.537Z","dateModified":"2025-09-21T02:33:25.537Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">재귀적 영지식 증명이란?(Recursion ZKP)</h1><div class=post-meta><span title='2025-09-21 02:33:25.537 +0000 UTC'>September 21, 2025</span></div></header><div class=post-content><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><ul><li>재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 <strong>계층적으로 합성</strong>해 <strong>단일 증명</strong>으로 만드는 기법임.</li><li>목적: 온체인(예: L1)에서 <strong>검증 횟수/비용을 줄임</strong>. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음.</li></ul><h2 id=왜-필요한가>왜 필요한가<a hidden class=anchor aria-hidden=true href=#왜-필요한가>#</a></h2><ul><li>단일 트랜잭션마다 증명 검증하면 <strong>검증 비용이 선형 증가</strong>함.</li><li>재귀를 쓰면 n개의 증명을 <strong>로그/계층 구조</strong>로 합쳐 <strong>한 번만 검증</strong>하면 됨.</li><li>롤업/배치 처리/프라이버시 워크로드에서 <strong>확장성</strong> 확보에 유리함.</li></ul><h2 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h2><ul><li><strong>내부 증명(Inner proofs)</strong>: 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들.</li><li><strong>합성 회로/Aggregator</strong>: 이전 단계의 증명들을 <strong>검증하는 로직을 포함</strong>한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦.</li><li><strong>최종 증명(Outer proof)</strong>: 여러 단계를 거쳐 <strong>하나</strong>로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨.</li><li><strong>공개 입력 바인딩(Public input binding)</strong>: 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 <strong>무결성</strong> 보장함.</li></ul><h2 id=동작-흐름>동작 흐름<a hidden class=anchor aria-hidden=true href=#동작-흐름>#</a></h2><ol><li><strong>개별 증명 생성</strong>: L2에서 트랜잭션/배치 단위로 증명들 생성함.</li><li><strong>1차 합성</strong>: 합성 회로가 증명 A·B를 <strong>내부에서 검증</strong> → “A와 B 모두 올바름”을 나타내는 <strong>새 증명</strong> 생성.</li><li><strong>반복 합성</strong>: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임.</li><li><strong>최종 합성</strong>: 최종 1개 증명 도출.</li><li><strong>온체인 검증</strong>: L1은 <strong>최종 증명 1개만</strong> 검증 → 전체 집합이 유효하다는 결론에 도달.</li></ol><blockquote><p>직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름.</p></blockquote><h2 id=장점단점>장점/단점<a hidden class=anchor aria-hidden=true href=#장점단점>#</a></h2><ul><li><p>장점</p><ul><li>온체인 검증 <strong>1회</strong>로 다수 명제를 커버 → <strong>가스/수수료 절감</strong></li><li>배치 크기 커질수록 상대적으로 <strong>효율↑</strong></li></ul></li><li><p>단점</p><ul><li>증명 생성 파이프라인 복잡도↑, 오프체인 <strong>생성 시간/메모리 부담↑</strong></li><li>합성 단계 설계가 비효율적이면 전체 지연이 커질 수 있음</li></ul></li></ul><h2 id=설계-포인트>설계 포인트<a hidden class=anchor aria-hidden=true href=#설계-포인트>#</a></h2><ul><li><strong>집계 전략</strong>: 이진 트리, k‑ary 트리, 스트리밍 합성 등 워크로드 특성에 맞춰 선택.</li><li><strong>공개 입력 설계</strong>: 어떤 집합을 증명했는지 <strong>루트 커밋/메타데이터</strong>를 명확히 포함.</li><li><strong>정확성 보장</strong>: 합성 회로는 “내부 검증 성공”을 <strong>명확히</strong> 인코딩해야 함.</li><li><strong>사운드니스(정합성)</strong>: 상위 단계가 하위 단계의 결과를 <strong>그대로</strong> 받아 검증하도록 데이터 경계(입·출력) 정의 필요.</li><li><strong>운영 가드레일</strong>: 실패 시 폴백, 배치 크기 캡, 타임아웃/재시도, 관측성(메트릭/로그) 확보.</li></ul><h2 id=테스트검증-체크리스트>테스트/검증 체크리스트<a hidden class=anchor aria-hidden=true href=#테스트검증-체크리스트>#</a></h2><ul><li><strong>재귀 깊이별 테스트</strong>: 1→2→4→… 단계별로 증명 생성 시간·메모리·크기 측정.</li><li><strong>경계값</strong>: 큰 배치/작은 배치/빈 배치, 공개 입력 불일치, 순서 바뀜 등 부정 케이스.</li><li><strong>회귀 방지</strong>: 고정된 입력 집합에 대한 <strong>스냅샷 테스트/해시 고정</strong>으로 의도치 않은 변경 탐지.</li><li><strong>온체인 검증 리허설</strong>: 최종 증명 크기/검증 가스 한도 내 수렴 확인.</li></ul><h2 id=개념-비교헷갈리기-쉬운-용어>개념 비교(헷갈리기 쉬운 용어)<a hidden class=anchor aria-hidden=true href=#개념-비교헷갈리기-쉬운-용어>#</a></h2><ul><li><p><strong>Aggregation vs Recursion</strong></p><ul><li>Aggregation: 여러 증명을 <strong>한 번에 묶어</strong> 검증(개념적으로 비재귀적 표현도 포함).</li><li>Recursion: “증명을 검증하는 회로”에 대해 <strong>또 다른 증명을 생성</strong>하는 <strong>계층적</strong> 접근.</li></ul></li><li><p><strong>Batching</strong>: 입력을 모아서 처리하는 운영 기법. 재귀/집계와 함께 쓰이면 시너지가 큼.</p></li></ul><h2 id=활용-시나리오>활용 시나리오<a hidden class=anchor aria-hidden=true href=#활용-시나리오>#</a></h2><ul><li>롤업: L2 다수 트랜잭션 증명을 최종 1개로 합쳐 L1 검증.</li><li>프라이버시 애플리케이션: 여러 단계의 정책 만족을 하나의 최종 증명으로 제시.</li><li>데이터 가용성 증명: 여러 청크의 검증을 합성해 단일 확인 단계로 축소.</li></ul><h2 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h2><ul><li>재귀적 ZKP의 본질 = <strong>“증명을 다시 증명”</strong> 해서 <strong>검증 부담을 한 점으로 수렴</strong>시키는 것임.</li><li>구체적인 프로토콜/알고리즘 명칭 없이도, 위 개념 요소(내부 증명·합성 회로·최종 증명·공개 입력 바인딩)만 이해하면 전반 동작 원리 파악 가능함.</li><li>실제 적용 시에는 목표 TPS/지연, 오프체인 리소스, 온체인 가스 모델을 고려해 <strong>집계 전략·배치 정책</strong>을 함께 설계하면 됨.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/%EC%98%81%EC%A7%80%EC%8B%9D%EC%A6%9D%EB%AA%85/>영지식증명</a></li><li><a href=https://handsupmin.github.io/tags/zkp/>ZKP</a></li><li><a href=https://handsupmin.github.io/tags/%EC%9E%AC%EA%B7%80%EC%A0%81-zkp/>재귀적-ZKP</a></li><li><a href=https://handsupmin.github.io/tags/recursion/>Recursion</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>