<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>재귀적 영지식 증명이란? (Recursion ZKP) | HandsLog</title>
<meta name=keywords content="zkp,zero-knowledge-proof,recursion-zkp,recursion"><meta name=description content="개요
재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임
목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음

왜 필요한가

트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함
재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함
롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림


핵심 개념


내부 증명 Inner proofs
원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="재귀적 영지식 증명이란? (Recursion ZKP)"><meta property="og:description" content="개요 재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임 목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음
왜 필요한가 트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함 재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함 롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림 핵심 개념 내부 증명 Inner proofs 원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-21T02:33:25+00:00"><meta property="article:modified_time" content="2025-09-21T02:33:25+00:00"><meta property="article:tag" content="Zkp"><meta property="article:tag" content="Zero-Knowledge-Proof"><meta property="article:tag" content="Recursion-Zkp"><meta property="article:tag" content="Recursion"><meta name=twitter:card content="summary"><meta name=twitter:title content="재귀적 영지식 증명이란? (Recursion ZKP)"><meta name=twitter:description content="개요
재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임
목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음

왜 필요한가

트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함
재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함
롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림


핵심 개념


내부 증명 Inner proofs
원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"재귀적 영지식 증명이란? (Recursion ZKP)","item":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"재귀적 영지식 증명이란? (Recursion ZKP)","name":"재귀적 영지식 증명이란? (Recursion ZKP)","description":"개요 재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임 목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음\n왜 필요한가 트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함 재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함 롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림 핵심 개념 내부 증명 Inner proofs 원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\n","keywords":["zkp","zero-knowledge-proof","recursion-zkp","recursion"],"articleBody":"개요 재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 계층적으로 합성해 단일 증명으로 만드는 기법임 목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 검증 비용을 상수 수준으로 수렴시키는 데 있음\n왜 필요한가 트랜잭션 단위로 개별 증명을 온체인 검증하면 검증 비용이 선형 증가함 재귀를 쓰면 n개의 증명을 트리 형태로 합성해 한 번의 최종 검증으로 대체 가능함 롤업·배치 처리·프라이버시 워크로드에서 확장성과 최종성 지연 단축을 동시에 노림 핵심 개념 내부 증명 Inner proofs 원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합\n합성 회로 Aggregator 이전 단계 증명들의 검증 로직을 회로로 구현하고 그 결과가 참임을 나타내는 새 증명을 생성\n최종 증명 Outer proof 여러 단계를 거쳐 하나로 압축된 최상위 증명 온체인은 이 증명 하나만 확인하면 전체 집합의 유효성을 신뢰할 수 있음\n공개 입력 바인딩 Public input binding 어떤 증명들을 합쳤는지, 어떤 데이터 루트에 대해 성립하는지 루트 커밋·메타데이터를 공개 입력에 포함해 무결성을 보장함\n동작 흐름 개별 증명 생성 L2에서 트랜잭션 또는 배치 단위로 증명 생성 1차 합성 합성 회로가 증명 A, B를 회로 내부에서 검증하고 A∧B가 참임을 증명 반복 합성 결과들을 다시 쌍으로 묶어 트리 형태로 합성해 증명 개수를 절반씩 축소 최종 합성 1개 증명으로 수렴 온체인 검증 L1은 최종 증명 1개만 검증해 전체 유효성에 도달 직관은 증명을 검증하는 회로에 대해 다시 증명을 만든다는 생각으로 이해하면 됨\n설계 선택지와 트레이드오프 증명 시스템 선택\nGroth16 on BN254 검증이 빠르고 EVM 프리컴파일 지원이 좋아 온체인 비용이 낮은 편이나 회로 변경 시 신뢰 설정이 필요하고 공개 입력 크기에 민감함 PLONK류 KZG 커밋 유연한 회로 합성과 대규모 회로에 적합하나 온체인 검증은 곡선·프리컴파일 제약을 받음 Halo2·IPA 계열 신뢰 설정 없이 동일 곡선 내 재귀가 용이해 깊은 재귀에 유리하나 구현 난이도와 상수 계수가 큼 Nova·SuperNova 폴딩 스킴 증명 크기와 재귀 성능이 우수하고 스트리밍 합성에 적합하나 온체인 검증 경로는 추가 압축 단계가 필요한 설계가 일반적임 곡선 전략\n페어링 재귀는 보통 곡선 사이클 MNT4/6, BLS12‑377 ↔ BW6‑761 등을 활용하거나 서로 다른 곡선 간 검증기를 회로화함 EVM에서 직접 검증할 최종 증명은 BN254 프리컴파일을 활용하는 구성이 실무적으로 유리함 집계 토폴로지\n이진 트리 단순하고 지연 균형이 좋음 k‑ary 트리 폭을 늘려 재귀 깊이를 더 줄이되 각 단계 회로가 커짐 스트리밍 합성 입력이 도착하는 대로 누적하는 PCD·폴딩 기반 경로가 실시간 파이프라인에 유리함 정확성·사운드니스 포인트 공개 입력 바인딩 합성 대상 집합을 명확히 커밋 머클 루트·배치 루트·VK 해시 등으로 고정해 혼합 공격을 차단함\n검증기 회로의 완전성 내부 검증 로직은 검증 키 VK와 증명 π의 결합을 정확히 구현해야 함 VK 해시를 공개 입력에 포함해 검증 키 스와핑을 방지함\n도메인 분리와 RNG 각 재귀 단계의 트랜스크립트 도메인을 분리해 Fiat‑Shamir 충돌을 방지함\n사운드니스 누수 관리 여러 단계 합성 시 오류 누적을 고려해 보안 파라미터를 충분히 잡고, 필요 시 최종 단계에서 재압축 증명으로 마무리함\n온체인 검증과 가스 감각 이더리움 메인넷은 BN254 페어링 프리컴파일 EIP‑196/197을 제공하므로 Groth16 BN254 최종 증명 검증이 일반적으로 가장 경제적임 BLS12‑381 프리컴파일은 메인넷에 기본 탑재되어 있지 않으므로 해당 곡선 기반 증명은 직접 검증 비용이 큼 실무 감각으로 단일 Groth16 검증은 수십만 가스 수준이며 다수 증명을 개별 검증하는 것 대비 재귀 한 번으로 크게 절감 가능함 L2에서는 프리컴파일·유효성 브릿지 정책이 다를 수 있으므로 대상 체인의 가스 모델과 프리미티브를 우선 확인 필요함 합성 스케줄 예시 코드 스니펫 # n개의 내부 증명을 이진 트리로 재귀 합성하는 스케줄 개념 예시 def aggregate(proofs): level = proofs while len(level) \u003e 1: nxt = [] for i in range(0, len(level), 2): a = level[i] b = level[i+1] if i+1 \u003c len(level) else level[i] nxt.append(prove_verify(a, b)) # \"a와 b를 검증하는 회로\"에 대한 새 증명 생성 level = nxt return level[0] # 최종 증명 위 스니펫은 구조 설명용이며 실제 구현은 증명 시스템·곡선·검증기 회로에 따라 상이함\n운영 가드레일과 파이프라인 배치 크기 캡 증명 생성기 큐 길이와 메모리를 감안해 단계별 최대 입력을 제한 타임아웃·재시도 각 단계별 SLA를 두고 실패 시 병렬 재스케줄 또는 부분 재구성 적용 관측성 TTI 포함 지연, TTP 증명 생성 지연, TTF 최종성 도달 시간, 실패율, 메모리 피크를 모니터링 키·파라미터 롤오버 VK·SRS 교체 절차를 정의하고 공개 입력에 버전을 바인딩 테스트·검증 체크리스트 재귀 깊이 스윕 1→2→4→… 단계별로 증명 시간·메모리·최종 증명 크기 프로파일링 경계 케이스 빈 배치, 1개 배치, 홀수 개 입력, 순서 섞임, 공개 입력 미스매치, VK 변경 등 실패 경로 검증 스냅샷·해시 고정 동일 입력 집합에 대해 루트와 최종 증명이 안정적으로 재현되는지 확인 온체인 리허설 가스 한도와 calldata 한도를 기준으로 최종 증명 크기와 검증 호출이 수렴하는지 점검 Aggregation vs Recursion vs Batching Aggregation 여러 증명을 함께 검증하도록 한 번에 묶는 기법으로 비재귀적 접근까지 포함해 쓰이는 넓은 용어 Recursion 검증기를 회로화하고 그에 대한 또 다른 증명을 생성하는 계층적 접근 Batching 입력을 모아 처리하는 운영 기법으로 재귀·집계와 결합하면 시너지가 큼 활용 시나리오 롤업 L2에서 다수 배치 증명을 합성해 L1에 최종 1개 증명만 제출 프라이버시 애플리케이션 여러 단계 정책 만족을 하나의 최종 증명으로 제시 데이터 가용성·보관 증명 여러 청크 검증을 합성해 단일 확인 단계로 축소 언제 재귀를 쓰지 말지 내부 증명 수가 적고 온체인에서 직접 검증해도 가스 절감 효과가 미미한 경우 지연 민감 워크로드에서 재귀 단계가 P99 지연을 악화시키는 경우 증명 시스템 이질성으로 회로 복잡도가 과도하게 커지는 경우 마무리 재귀적 ZKP의 본질은 증명을 다시 증명해 검증 부담을 한 점으로 수렴시키는 데 있음 실전에서는 증명 시스템·곡선·집계 토폴로지·가스 모델을 함께 설계하고, 공개 입력 바인딩·검증기 회로의 완전성·도메인 분리로 사운드니스를 확보하는 것이 핵심임 목표 TPS·지연·오프체인 리소스·온체인 가스 정책을 기준으로 배치와 재귀 깊이를 조율하면 비용과 안정성을 동시에 달성할 수 있음\n참고자료 EIP‑196 BN128 Curve Addition and Scalar Multiplication https://eips.ethereum.org/EIPS/eip-196 EIP‑197 BN128 Pairing https://eips.ethereum.org/EIPS/eip-197 Halo2 Book https://zcash.github.io/halo2 Nova Recursive Arguments https://eprint.iacr.org/2021/370 SuperNova https://eprint.iacr.org/2022/1758 SnarkPack Practical SNARK Aggregation https://eprint.iacr.org/2021/529 Plonky2 Fast Recursive Proofs https://github.com/mir-protocol/plonky2 ","wordCount":"878","inLanguage":"en","datePublished":"2025-09-21T02:33:25.537Z","dateModified":"2025-09-21T02:33:25.537Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://handsupmin.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://handsupmin.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://handsupmin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://handsupmin.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">재귀적 영지식 증명이란? (Recursion ZKP)</h1><div class=post-meta><span title='2025-09-21 02:33:25.537 +0000 UTC'>September 21, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>재귀적 영지식 증명 Recursion ZKP 은 여러 개의 ZK 증명을 <strong>계층적으로 합성</strong>해 <strong>단일 증명</strong>으로 만드는 기법임
목적은 온체인 검증 횟수와 가스를 줄이고, L2 등에서 생성한 다수 증명을 하나로 압축해 <strong>검증 비용을 상수 수준으로 수렴</strong>시키는 데 있음</p><hr><h3 id=왜-필요한가>왜 필요한가<a hidden class=anchor aria-hidden=true href=#왜-필요한가>#</a></h3><ul><li>트랜잭션 단위로 개별 증명을 온체인 검증하면 <strong>검증 비용이 선형 증가</strong>함</li><li>재귀를 쓰면 n개의 증명을 <strong>트리 형태로 합성</strong>해 <strong>한 번의 최종 검증</strong>으로 대체 가능함</li><li>롤업·배치 처리·프라이버시 워크로드에서 <strong>확장성</strong>과 <strong>최종성 지연 단축</strong>을 동시에 노림</li></ul><hr><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><p><strong>내부 증명 Inner proofs</strong>
원래 명제 트랜잭션, 상태 전이, 정책 검증 등에 대한 개별 ZK 증명 집합</p></li><li><p><strong>합성 회로 Aggregator</strong>
이전 단계 증명들의 <strong>검증 로직을 회로로 구현</strong>하고 그 결과가 참임을 나타내는 <strong>새 증명</strong>을 생성</p></li><li><p><strong>최종 증명 Outer proof</strong>
여러 단계를 거쳐 <strong>하나로 압축된 최상위 증명</strong>
온체인은 이 증명 하나만 확인하면 전체 집합의 유효성을 신뢰할 수 있음</p></li><li><p><strong>공개 입력 바인딩 Public input binding</strong>
어떤 증명들을 합쳤는지, 어떤 데이터 루트에 대해 성립하는지 <strong>루트 커밋·메타데이터</strong>를 공개 입력에 포함해 <strong>무결성</strong>을 보장함</p></li></ul><hr><h3 id=동작-흐름>동작 흐름<a hidden class=anchor aria-hidden=true href=#동작-흐름>#</a></h3><ol><li><strong>개별 증명 생성</strong> L2에서 트랜잭션 또는 배치 단위로 증명 생성</li><li><strong>1차 합성</strong> 합성 회로가 증명 A, B를 <strong>회로 내부에서 검증</strong>하고 A∧B가 참임을 증명</li><li><strong>반복 합성</strong> 결과들을 다시 쌍으로 묶어 트리 형태로 합성해 증명 개수를 절반씩 축소</li><li><strong>최종 합성</strong> 1개 증명으로 수렴</li><li><strong>온체인 검증</strong> L1은 <strong>최종 증명 1개</strong>만 검증해 전체 유효성에 도달</li></ol><blockquote><p>직관은 <strong>증명을 검증하는 회로</strong>에 대해 다시 증명을 만든다는 생각으로 이해하면 됨</p></blockquote><hr><h3 id=설계-선택지와-트레이드오프>설계 선택지와 트레이드오프<a hidden class=anchor aria-hidden=true href=#설계-선택지와-트레이드오프>#</a></h3><ul><li><p><strong>증명 시스템 선택</strong></p><ul><li><strong>Groth16 on BN254</strong> 검증이 빠르고 EVM 프리컴파일 지원이 좋아 온체인 비용이 낮은 편이나 회로 변경 시 신뢰 설정이 필요하고 공개 입력 크기에 민감함</li><li><strong>PLONK류 KZG 커밋</strong> 유연한 회로 합성과 대규모 회로에 적합하나 온체인 검증은 곡선·프리컴파일 제약을 받음</li><li><strong>Halo2·IPA 계열</strong> 신뢰 설정 없이 <strong>동일 곡선 내 재귀</strong>가 용이해 깊은 재귀에 유리하나 구현 난이도와 상수 계수가 큼</li><li><strong>Nova·SuperNova 폴딩 스킴</strong> 증명 크기와 재귀 성능이 우수하고 스트리밍 합성에 적합하나 온체인 검증 경로는 추가 압축 단계가 필요한 설계가 일반적임</li></ul></li><li><p><strong>곡선 전략</strong></p><ul><li><strong>페어링 재귀</strong>는 보통 <strong>곡선 사이클</strong> MNT4/6, BLS12‑377 ↔ BW6‑761 등을 활용하거나 <strong>서로 다른 곡선 간 검증기</strong>를 회로화함</li><li>EVM에서 직접 검증할 최종 증명은 <strong>BN254 프리컴파일</strong>을 활용하는 구성이 실무적으로 유리함</li></ul></li><li><p><strong>집계 토폴로지</strong></p><ul><li><strong>이진 트리</strong> 단순하고 지연 균형이 좋음</li><li><strong>k‑ary 트리</strong> 폭을 늘려 재귀 깊이를 더 줄이되 각 단계 회로가 커짐</li><li><strong>스트리밍 합성</strong> 입력이 도착하는 대로 누적하는 PCD·폴딩 기반 경로가 실시간 파이프라인에 유리함</li></ul></li></ul><hr><h3 id=정확성사운드니스-포인트>정확성·사운드니스 포인트<a hidden class=anchor aria-hidden=true href=#정확성사운드니스-포인트>#</a></h3><ul><li><p><strong>공개 입력 바인딩</strong>
합성 대상 집합을 명확히 커밋 머클 루트·배치 루트·VK 해시 등으로 <strong>고정</strong>해 <strong>혼합 공격</strong>을 차단함</p></li><li><p><strong>검증기 회로의 완전성</strong>
내부 검증 로직은 <strong>검증 키 VK</strong>와 <strong>증명 π</strong>의 결합을 정확히 구현해야 함
VK 해시를 공개 입력에 포함해 <strong>검증 키 스와핑</strong>을 방지함</p></li><li><p><strong>도메인 분리와 RNG</strong>
각 재귀 단계의 트랜스크립트 도메인을 분리해 <strong>Fiat‑Shamir 충돌</strong>을 방지함</p></li><li><p><strong>사운드니스 누수 관리</strong>
여러 단계 합성 시 <strong>오류 누적</strong>을 고려해 보안 파라미터를 충분히 잡고, 필요 시 최종 단계에서 <strong>재압축 증명</strong>으로 마무리함</p></li></ul><hr><h3 id=온체인-검증과-가스-감각>온체인 검증과 가스 감각<a hidden class=anchor aria-hidden=true href=#온체인-검증과-가스-감각>#</a></h3><ul><li>이더리움 메인넷은 <strong>BN254 페어링 프리컴파일 EIP‑196/197</strong>을 제공하므로 <strong>Groth16 BN254 최종 증명</strong> 검증이 일반적으로 가장 경제적임</li><li><strong>BLS12‑381 프리컴파일</strong>은 메인넷에 기본 탑재되어 있지 않으므로 해당 곡선 기반 증명은 직접 검증 비용이 큼</li><li>실무 감각으로 <strong>단일 Groth16 검증은 수십만 가스 수준</strong>이며 다수 증명을 개별 검증하는 것 대비 재귀 한 번으로 크게 절감 가능함</li><li>L2에서는 <strong>프리컴파일·유효성 브릿지 정책</strong>이 다를 수 있으므로 대상 체인의 가스 모델과 프리미티브를 우선 확인 필요함</li></ul><hr><h3 id=합성-스케줄-예시-코드-스니펫>합성 스케줄 예시 코드 스니펫<a hidden class=anchor aria-hidden=true href=#합성-스케줄-예시-코드-스니펫>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># n개의 내부 증명을 이진 트리로 재귀 합성하는 스케줄 개념 예시</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>aggregate</span>(proofs):
</span></span><span style=display:flex><span>    level <span style=color:#f92672>=</span> proofs
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(level) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        nxt <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(level), <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> level[i]
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> level[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> len(level) <span style=color:#66d9ef>else</span> level[i]
</span></span><span style=display:flex><span>            nxt<span style=color:#f92672>.</span>append(prove_verify(a, b))  <span style=color:#75715e># &#34;a와 b를 검증하는 회로&#34;에 대한 새 증명 생성</span>
</span></span><span style=display:flex><span>        level <span style=color:#f92672>=</span> nxt
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> level[<span style=color:#ae81ff>0</span>]  <span style=color:#75715e># 최종 증명</span>
</span></span></code></pre></div><p>위 스니펫은 구조 설명용이며 실제 구현은 증명 시스템·곡선·검증기 회로에 따라 상이함</p><hr><h3 id=운영-가드레일과-파이프라인>운영 가드레일과 파이프라인<a hidden class=anchor aria-hidden=true href=#운영-가드레일과-파이프라인>#</a></h3><ul><li><strong>배치 크기 캡</strong> 증명 생성기 큐 길이와 메모리를 감안해 단계별 최대 입력을 제한</li><li><strong>타임아웃·재시도</strong> 각 단계별 SLA를 두고 실패 시 <strong>병렬 재스케줄</strong> 또는 <strong>부분 재구성</strong> 적용</li><li><strong>관측성</strong> TTI 포함 지연, TTP 증명 생성 지연, TTF 최종성 도달 시간, 실패율, 메모리 피크를 모니터링</li><li><strong>키·파라미터 롤오버</strong> VK·SRS 교체 절차를 정의하고 공개 입력에 버전을 바인딩</li></ul><hr><h3 id=테스트검증-체크리스트>테스트·검증 체크리스트<a hidden class=anchor aria-hidden=true href=#테스트검증-체크리스트>#</a></h3><ul><li><strong>재귀 깊이 스윕</strong> 1→2→4→… 단계별로 증명 시간·메모리·최종 증명 크기 프로파일링</li><li><strong>경계 케이스</strong> 빈 배치, 1개 배치, 홀수 개 입력, 순서 섞임, 공개 입력 미스매치, VK 변경 등 실패 경로 검증</li><li><strong>스냅샷·해시 고정</strong> 동일 입력 집합에 대해 루트와 최종 증명이 안정적으로 재현되는지 확인</li><li><strong>온체인 리허설</strong> 가스 한도와 calldata 한도를 기준으로 최종 증명 크기와 검증 호출이 수렴하는지 점검</li></ul><hr><h3 id=aggregation-vs-recursion-vs-batching>Aggregation vs Recursion vs Batching<a hidden class=anchor aria-hidden=true href=#aggregation-vs-recursion-vs-batching>#</a></h3><ul><li><strong>Aggregation</strong> 여러 증명을 함께 검증하도록 <strong>한 번에 묶는 기법</strong>으로 비재귀적 접근까지 포함해 쓰이는 넓은 용어</li><li><strong>Recursion</strong> <strong>검증기를 회로화</strong>하고 그에 대한 <strong>또 다른 증명</strong>을 생성하는 <strong>계층적 접근</strong></li><li><strong>Batching</strong> 입력을 모아 처리하는 운영 기법으로 재귀·집계와 결합하면 시너지가 큼</li></ul><hr><h3 id=활용-시나리오>활용 시나리오<a hidden class=anchor aria-hidden=true href=#활용-시나리오>#</a></h3><ul><li><strong>롤업</strong> L2에서 다수 배치 증명을 합성해 L1에 <strong>최종 1개 증명</strong>만 제출</li><li><strong>프라이버시 애플리케이션</strong> 여러 단계 정책 만족을 하나의 최종 증명으로 제시</li><li><strong>데이터 가용성·보관 증명</strong> 여러 청크 검증을 합성해 <strong>단일 확인 단계</strong>로 축소</li></ul><hr><h3 id=언제-재귀를-쓰지-말지>언제 재귀를 쓰지 말지<a hidden class=anchor aria-hidden=true href=#언제-재귀를-쓰지-말지>#</a></h3><ul><li>내부 증명 수가 적고 온체인에서 직접 검증해도 가스 절감 효과가 미미한 경우</li><li>지연 민감 워크로드에서 재귀 단계가 <strong>P99 지연을 악화</strong>시키는 경우</li><li>증명 시스템 이질성으로 회로 복잡도가 과도하게 커지는 경우</li></ul><hr><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>재귀적 ZKP의 본질은 <strong>증명을 다시 증명</strong>해 <strong>검증 부담을 한 점으로 수렴</strong>시키는 데 있음
실전에서는 <strong>증명 시스템·곡선·집계 토폴로지·가스 모델</strong>을 함께 설계하고, <strong>공개 입력 바인딩·검증기 회로의 완전성·도메인 분리</strong>로 사운드니스를 확보하는 것이 핵심임
목표 TPS·지연·오프체인 리소스·온체인 가스 정책을 기준으로 배치와 재귀 깊이를 조율하면 비용과 안정성을 동시에 달성할 수 있음</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>EIP‑196 BN128 Curve Addition and Scalar Multiplication
<a href=https://eips.ethereum.org/EIPS/eip-196>https://eips.ethereum.org/EIPS/eip-196</a></li><li>EIP‑197 BN128 Pairing
<a href=https://eips.ethereum.org/EIPS/eip-197>https://eips.ethereum.org/EIPS/eip-197</a></li><li>Halo2 Book
<a href=https://zcash.github.io/halo2>https://zcash.github.io/halo2</a></li><li>Nova Recursive Arguments
<a href=https://eprint.iacr.org/2021/370>https://eprint.iacr.org/2021/370</a></li><li>SuperNova
<a href=https://eprint.iacr.org/2022/1758>https://eprint.iacr.org/2022/1758</a></li><li>SnarkPack Practical SNARK Aggregation
<a href=https://eprint.iacr.org/2021/529>https://eprint.iacr.org/2021/529</a></li><li>Plonky2 Fast Recursive Proofs
<a href=https://github.com/mir-protocol/plonky2>https://github.com/mir-protocol/plonky2</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/zkp/>Zkp</a></li><li><a href=https://handsupmin.github.io/tags/zero-knowledge-proof/>Zero-Knowledge-Proof</a></li><li><a href=https://handsupmin.github.io/tags/recursion-zkp/>Recursion-Zkp</a></li><li><a href=https://handsupmin.github.io/tags/recursion/>Recursion</a></li></ul><nav class=paginav><a class=prev href=https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/><span class=title>« Prev</span><br><span>스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법</span>
</a><a class=next href=https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/><span class=title>Next »</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on x" href="https://x.com/intent/tweet/?text=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f&amp;hashtags=zkp%2czero-knowledge-proof%2crecursion-zkp%2crecursion"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f&amp;title=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29&amp;summary=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29&amp;source=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f&title=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on whatsapp" href="https://api.whatsapp.com/send?text=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29%20-%20https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on telegram" href="https://telegram.me/share/url?text=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 재귀적 영지식 증명이란? (Recursion ZKP) on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%9e%ac%ea%b7%80%ec%a0%81%20%ec%98%81%ec%a7%80%ec%8b%9d%20%ec%a6%9d%eb%aa%85%ec%9d%b4%eb%9e%80%3f%20%28Recursion%20ZKP%29&u=https%3a%2f%2fhandsupmin.github.io%2fposts%2frecursion-zkp-basics-274b74%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>