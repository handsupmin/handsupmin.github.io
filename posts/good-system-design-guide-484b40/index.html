<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 | HandsLog</title>
<meta name=keywords content="system-design,state-management,database,indexing,caching,event-driven,queues,observability,resilience,performance,scalability,architecture"><meta name=description content="개요
좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장
시스템 설계의 정의와 접근
소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트

앱 서버
데이터베이스
캐시
큐와 잡 러너
이벤트 버스
프록시와 게이트웨이

좋은 설계의 징후"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/good-system-design-guide-484b40/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/good-system-design-guide-484b40/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/good-system-design-guide-484b40/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/good-system-design-guide-484b40/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙"><meta property="og:description" content="개요 좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함 핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향 과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향 최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장
시스템 설계의 정의와 접근 소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점 주요 구성 요소 팔레트
앱 서버 데이터베이스 캐시 큐와 잡 러너 이벤트 버스 프록시와 게이트웨이 좋은 설계의 징후"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-01T13:12:42+00:00"><meta property="article:modified_time" content="2026-01-01T13:12:42+00:00"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="State-Management"><meta property="article:tag" content="Database"><meta property="article:tag" content="Indexing"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Event-Driven"><meta name=twitter:card content="summary"><meta name=twitter:title content="좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙"><meta name=twitter:description content="개요
좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장
시스템 설계의 정의와 접근
소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트

앱 서버
데이터베이스
캐시
큐와 잡 러너
이벤트 버스
프록시와 게이트웨이

좋은 설계의 징후"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙","item":"https://blog.jsontapose.com/posts/good-system-design-guide-484b40/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙","name":"좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙","description":"개요 좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함 핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향 과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향 최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장\n시스템 설계의 정의와 접근 소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점 주요 구성 요소 팔레트\n앱 서버 데이터베이스 캐시 큐와 잡 러너 이벤트 버스 프록시와 게이트웨이 좋은 설계의 징후\n","keywords":["system-design","state-management","database","indexing","caching","event-driven","queues","observability","resilience","performance","scalability","architecture"],"articleBody":"개요 좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함 핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향 과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향 최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장\n시스템 설계의 정의와 접근 소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점 주요 구성 요소 팔레트\n앱 서버 데이터베이스 캐시 큐와 잡 러너 이벤트 버스 프록시와 게이트웨이 좋은 설계의 징후\n특별히 문제 삼을 부분 없음 생각보다 쉽게 끝남 신경 쓸 필요가 없는 영역이 존재함 복잡함 그 자체는 신호가 아님\n근본 문제를 가리는 장식일 수 있음 초기부터 복잡한 분산 구조 도입 지양 단순한 구성으로 작동을 보장한 뒤 단계적 확장 상태와 무상태 가장 어려운 지점은 상태 관리\n상태 저장 컴포넌트 수를 줄일수록 복잡도와 장애 가능성 하락 상태는 가능한 한 한 곳에서만 관리 나머지는 무상태 API 호출이나 이벤트 발행 역할에 집중 무상태 예시\n입력을 받아 즉시 결과만 반환하는 렌더링 서비스 같은 경량 계산 경로 상태 예시\n데이터베이스에 쓰기 트랜잭션 수행 데이터베이스 설계와 병목 데이터베이스는 상태의 중심이므로 스키마와 인덱스 설계, 병목 해소 전략이 핵심\n스키마와 인덱스\n사람 읽기 쉬운 스키마 선호 전체를 JSON 컬럼에 몰아넣는 과유연 스키마는 애플리케이션 복잡도와 성능 리스크 상승 자주 질의되는 컬럼 기준의 선택적 인덱스 설계 모든 컬럼 인덱싱은 쓰기 오버헤드와 공간 낭비 유발 병목 해소 패턴\nDB 접근이 병목의 상수항이 되는 경우 많음 가능하면 조인 같은 데이터 결합은 DB에서 처리하는 편이 유리 ORM 사용 시 루프 내 쿼리 발생 등 N+1 주의 필요 시 쿼리 분할로 복잡도와 부하 분산 읽기 부하는 복제본으로 분산해 쓰기 노드 보호 트랜잭션과 대량 쓰기 폭주 시 쿼리 스로틀링 고려 느린 작업과 빠른 작업 분리 사용자 인터랙션 경로는 수백 ms 내 응답 목표 오래 걸리는 작업은 최소 확인만 동기 처리하고 백그라운드로 위임하는 패턴 추천 백그라운드 실행 구조의 일반형\n큐에 작업 적재 잡 러너가 소비 장기 예약 작업은 별도 DB 테이블과 스케줄러 조합이 실용적일 때 많음\n캐싱 캐시는 동일 계산 반복이나 고비용 연산의 비용 절감에 유효 그러나 캐시는 새로운 상태를 도입하므로 동기화 이슈와 스테일 데이터 리스크 존재 원칙\n먼저 쿼리 최적화와 인덱싱으로 기본기 강화 후 캐시 도입 검토 대용량 결과물은 Redis/Memcached 대신 문서 저장소에 주기 스냅샷 저장 전략도 옵션 캐시 무효화 규칙과 만료 정책의 단순화 우선 이벤트 처리 이벤트 허브 기반 분산 처리는 고용량과 지연 허용 케이스에서 적합 단순 요청–응답 API가 로깅과 문제 해결에 유리한 경우가 많음 발신자가 수신자 내부 동작을 몰라도 되는 독립성이 필요할 때 이벤트 채택 고려\n데이터 전달 방식 Pull vs Push Pull\n요청 후 응답 모델 단순하지만 폴링 오버헤드와 과부하 가능성 존재 Push\n데이터 변경 시 즉시 전달 효율적이며 최신성 유지에 유리 대량 클라이언트 처리 시 각 방식에 맞춘 인프라 증설 필요\n이벤트 큐, 팬아웃, 캐시 계층, 연결 수 관리 등 핫패스 집중 핫패스는 시스템 내 데이터가 많이 흐르고 사업 임팩트가 큰 경로를 의미 선택지가 적고 실패 영향이 크므로 신중한 설계와 집중 테스트 필요 마이너 기능의 옵션 다양화보다 핫패스 최적화에 자원 우선 배분\n로깅, 메트릭, 추적 비정상 경로 로깅 강화\n에러 원인과 컨텍스트 수집 관측성 기초 지표 수집\nCPU와 메모리 큐 길이 요청 지연과 작업 소요 시간 평균값 대신 분포 지표 관찰\np95, p99 지연에 주목 상위 소수의 느린 요청이 핵심 사용자 문제일 수 있음 분산 추적으로 경계 간 지연과 재시도 파악\n킬스위치, 재시도, 장애 복구 킬스위치로 기능 단위 차단 가능 상태 유지 무작정 재시도는 장애 전파와 증폭 위험\n회로 차단기로 하류 서비스 보호 지수 백오프와 재시도 예산 관리 멱등키로 중복 처리 방지 장애 모드 선택\nfail open이 사용자 영향이 적은 경로 예시로 Rate Limiting 인증과 결제는 fail closed 필수 DB 조인 vs 애플리케이션 조인 논의 요약 관점 A\n복잡한 데이터 결합은 DB가 담당하는 게 성능과 단순성에서 유리 뷰와 저장 프로시저는 데이터 추상화 계층으로 유효 관점 B\n확장성 요구가 큰 구조에서는 DB는 단순 인덱스 조회 역할에 집중 조인과 집계는 수평 확장 쉬운 백엔드에서 처리해 자원 증설로 스케일링 대역폭 관점에서 필요한 데이터만 가져와 애플리케이션에서 결합이 유리한 케이스 존재 실무 결론\n기본값은 DB에 맡기되 데이터 폭발, 팬아웃, 대역폭 병목, 캐시 전략과 결합 등 조건에서 예외 설계 고려 관측 지표와 비용 곡선으로 선택 검증 스키마 설계와 유연성 스키마의 과유연은 앱 복잡도와 성능 문제 야기\n모든 것을 JSON 컬럼이나 EAV로 수용하는 설계는 가독성과 최적화 모두에 독 정규화 가능한 경우엔 정규화 선호 사람이 봐도 용도가 직관적인 테이블 구조 우선 단, 임시 수용을 위한 제한적 JSONB 같은 완충은 특정 상황에서 유용할 수 있으나 기본 규칙은 아님\nORM 사용 시 주의 단일 오브젝트 모델 강제는 복잡한 조회 시 유연성 저하 위험 N+1, 비효율 조인, 불필요 데이터 로딩 주의 필요 시 뷰나 핸드크래프트 쿼리로 경로 단순화\n여러 서비스의 DB 공유 vs API 단일 쓰기 경로 권장 기본값\n한 서비스만 테이블에 쓰기 책임 부여 나머지는 API 호출 또는 이벤트 발행으로 상호작용 반론과 현실 제약\n여러 서비스가 DB를 직접 접근하면 권한과 트랜잭션, 커스텀 쿼리 활용이 쉬움 그러나 스키마 변경 시 영향 반경이 커지고 마이그레이션 제약 증가 실무 결론\n변화 적응성과 조정 범위 최소화를 우선시하면 API가 유리 공유 DB 구조는 소규모·단기에는 빠를 수 있으나 규모 확대 시 실패 사례가 다수 보고됨 구조 변경 시 영향을 받는 팀 수를 지표로 삼아 결정 데이터 전달 인터페이스 우선순위 시스템 설계의 핵심은 사용자가 맞닥뜨리는 인터페이스 설계\n기능 제공과 교환비용의 명확화가 본질 내부 구조는 인터페이스 안정성을 지키며 후속 교체 가능 설계 논의 시간의 다수를 인터페이스 정의와 버전 전략에 투자 권장\n상태와 운영 책임의 분리 무상태 컨테이너 경로는 배포와 롤백으로 복구 쉬움 상태가 붙는 DB와 파일 스토리지는 전담 운영 책임 필요\n백업과 복구 전략 부재는 정상 운영 중에도 잠재 리스크 사고 대응은 수 분 내 배포로 해결되지 않는 영역 존재 캐시와 문서 저장소 선택지 키값 캐시가 아닌 문서 저장소에 주기적 결과 저장 전략\n대용량 결과물 재사용 시 비용 절감 효과 만료와 불일치 관리 단순화 가능 Pull과 Push 확장 전략 Pull 고도화\n조건부 요청과 캐시 검증 헤더 활용 백오프와 지능형 폴링 간격 조절 Push 고도화\n팬아웃을 큐로 비동기화 연결 수 관리와 샤딩으로 수평 확장 관측과 핫패스 최적화 체크리스트 핫패스 정의와 경로 단순화 p95, p99 지연 모니터링과 예산 설정 실패 로그의 샘플링과 컨텍스트 상관ID 부여 큐 적체 알람과 처리율 자동 확장 스로틀링과 회로 차단기 정책 점검 멱등키 적용 범위 정의 HN에서 나온 면접과 복잡도 논의 요약 현실의 좋은 설계는 단순함이 미덕이지만 면접 신호로는 복잡한 다이어그램이 과대평가되는 경향 존재 면접에서는 결정을 내린 이유와 고려 요소를 구조화해 설명하는 능력이 중요하다는 반론 다수 SQL과 NoSQL 선택은 팀 친숙도만이 아니라 작업 부하 특성과 데이터 모델 차이가 중요하다는 의견 존재 복잡함 숭배가 과설계를 장려한다는 비판과, 그래도 면접은 양방향이므로 의도한 평가 포인트에 맞춰 소통해야 한다는 조언 공존 DB 공유와 서비스 경계에 대한 HN 논의 요약 여러 서비스가 한 DB를 공유하면 분산 시스템이 이미 형성된 셈이라 관리 복잡도 상승 가능 반대로 서비스 API가 높은 수준의 인터페이스가 되면 인증과 트랜잭션, 예외처리를 직접 구현해야 하는 부담 발생 장기 유지보수성과 변경 용이성 관점에서 공유 DB보다 API 경계가 유리하다는 경험담 다수 DB 분리 시 가용성 계산과 운영 복잡도 증가도 현실 제약으로 고려 필요 저장 프로시저와 SQL 추상화에 대한 HN 논의 요약 뷰와 저장 프로시저는 데이터 추상화에 유효하다는 견해와, 팀 언어와 도구 표준화 관점에서 유지보수 난이도가 높다는 반론 공존 ORM은 큰 서비스에서 유연성을 제한하고 성능 문제 유발 가능성이 있어 뷰와 핸드크래프트 쿼리 병행 제안 다수 boolean vs timestamp 논의 요약 단순 boolean은 상태 확장 시 필드 난립으로 이어지므로 timestamp나 enum으로 진화 가능성 확보가 낫다는 주장 존재 반론으로 논리적 boolean이 의미상 더 적합하고 데이터 크기와 분석 효율 측면에서 유리한 케이스도 있음 실무 결론은 도메인 변화 방향과 감사 요구에 따라 선택하며, 변경 시점이 중요한 경우 별도 감사 테이블 도입이 더 적합 느린 작업 처리와 인프라 선택 단기 대기열은 인메모리 큐로 충분 장기 스케줄은 DB 기반 스케줄 테이블과 워커 조합이 단순하고 운영이 쉬움 마무리 좋은 시스템 설계의 기본값은 단순함과 상태 최소화 데이터베이스 중심의 스키마와 인덱스, 핫패스 최적화, 관측 가능성 확보가 토대 캐시와 이벤트, 백그라운드 처리, 복잡한 분산 구성은 필요한 순간에만 단계적으로 도입 기술적으로 특별한 설계는 드물고, 지루할 정도로 단순한 구성의 안정적 운영이 장기적으로 가장 강함\n참고자료 https://www.seangoedecke.com/good-system-design/ https://news.ycombinator.com/item?id=44921137 https://en.wikipedia.org/wiki/Systemantics https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model https://pragprog.com/titles/bksqla/sql-antipatterns/ ","wordCount":"1252","inLanguage":"en","datePublished":"2026-01-01T13:12:42.799Z","dateModified":"2026-01-01T13:12:42.799Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/good-system-design-guide-484b40/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙</h1><div class=post-meta><span title='2026-01-01 13:12:42.799 +0000 UTC'>January 1, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장</p><h3 id=시스템-설계의-정의와-접근>시스템 설계의 정의와 접근<a hidden class=anchor aria-hidden=true href=#시스템-설계의-정의와-접근>#</a></h3><p>소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트</p><ul><li>앱 서버</li><li>데이터베이스</li><li>캐시</li><li>큐와 잡 러너</li><li>이벤트 버스</li><li>프록시와 게이트웨이</li></ul><p>좋은 설계의 징후</p><ul><li>특별히 문제 삼을 부분 없음</li><li>생각보다 쉽게 끝남</li><li>신경 쓸 필요가 없는 영역이 존재함</li></ul><p>복잡함 그 자체는 신호가 아님</p><ul><li>근본 문제를 가리는 장식일 수 있음</li><li>초기부터 복잡한 분산 구조 도입 지양</li><li>단순한 구성으로 작동을 보장한 뒤 단계적 확장</li></ul><h3 id=상태와-무상태>상태와 무상태<a hidden class=anchor aria-hidden=true href=#상태와-무상태>#</a></h3><p>가장 어려운 지점은 상태 관리</p><ul><li>상태 저장 컴포넌트 수를 줄일수록 복잡도와 장애 가능성 하락</li><li>상태는 가능한 한 한 곳에서만 관리</li><li>나머지는 무상태 API 호출이나 이벤트 발행 역할에 집중</li></ul><p>무상태 예시</p><ul><li>입력을 받아 즉시 결과만 반환하는 렌더링 서비스 같은 경량 계산 경로</li></ul><p>상태 예시</p><ul><li>데이터베이스에 쓰기 트랜잭션 수행</li></ul><h3 id=데이터베이스-설계와-병목>데이터베이스 설계와 병목<a hidden class=anchor aria-hidden=true href=#데이터베이스-설계와-병목>#</a></h3><p>데이터베이스는 상태의 중심이므로 스키마와 인덱스 설계, 병목 해소 전략이 핵심</p><p>스키마와 인덱스</p><ul><li>사람 읽기 쉬운 스키마 선호</li><li>전체를 JSON 컬럼에 몰아넣는 과유연 스키마는 애플리케이션 복잡도와 성능 리스크 상승</li><li>자주 질의되는 컬럼 기준의 선택적 인덱스 설계</li><li>모든 컬럼 인덱싱은 쓰기 오버헤드와 공간 낭비 유발</li></ul><p>병목 해소 패턴</p><ul><li>DB 접근이 병목의 상수항이 되는 경우 많음</li><li>가능하면 조인 같은 데이터 결합은 DB에서 처리하는 편이 유리</li><li>ORM 사용 시 루프 내 쿼리 발생 등 N+1 주의</li><li>필요 시 쿼리 분할로 복잡도와 부하 분산</li><li>읽기 부하는 복제본으로 분산해 쓰기 노드 보호</li><li>트랜잭션과 대량 쓰기 폭주 시 쿼리 스로틀링 고려</li></ul><h3 id=느린-작업과-빠른-작업-분리>느린 작업과 빠른 작업 분리<a hidden class=anchor aria-hidden=true href=#느린-작업과-빠른-작업-분리>#</a></h3><p>사용자 인터랙션 경로는 수백 ms 내 응답 목표
오래 걸리는 작업은 최소 확인만 동기 처리하고 백그라운드로 위임하는 패턴 추천
백그라운드 실행 구조의 일반형</p><ul><li>큐에 작업 적재</li><li>잡 러너가 소비</li></ul><p>장기 예약 작업은 별도 DB 테이블과 스케줄러 조합이 실용적일 때 많음</p><h3 id=캐싱>캐싱<a hidden class=anchor aria-hidden=true href=#캐싱>#</a></h3><p>캐시는 동일 계산 반복이나 고비용 연산의 비용 절감에 유효
그러나 캐시는 새로운 상태를 도입하므로 동기화 이슈와 스테일 데이터 리스크 존재
원칙</p><ul><li>먼저 쿼리 최적화와 인덱싱으로 기본기 강화 후 캐시 도입 검토</li><li>대용량 결과물은 Redis/Memcached 대신 문서 저장소에 주기 스냅샷 저장 전략도 옵션</li><li>캐시 무효화 규칙과 만료 정책의 단순화 우선</li></ul><h3 id=이벤트-처리>이벤트 처리<a hidden class=anchor aria-hidden=true href=#이벤트-처리>#</a></h3><p>이벤트 허브 기반 분산 처리는 고용량과 지연 허용 케이스에서 적합
단순 요청–응답 API가 로깅과 문제 해결에 유리한 경우가 많음
발신자가 수신자 내부 동작을 몰라도 되는 독립성이 필요할 때 이벤트 채택 고려</p><h3 id=데이터-전달-방식-pull-vs-push>데이터 전달 방식 Pull vs Push<a hidden class=anchor aria-hidden=true href=#데이터-전달-방식-pull-vs-push>#</a></h3><p>Pull</p><ul><li>요청 후 응답 모델</li><li>단순하지만 폴링 오버헤드와 과부하 가능성 존재</li></ul><p>Push</p><ul><li>데이터 변경 시 즉시 전달</li><li>효율적이며 최신성 유지에 유리</li></ul><p>대량 클라이언트 처리 시 각 방식에 맞춘 인프라 증설 필요</p><ul><li>이벤트 큐, 팬아웃, 캐시 계층, 연결 수 관리 등</li></ul><h3 id=핫패스-집중>핫패스 집중<a hidden class=anchor aria-hidden=true href=#핫패스-집중>#</a></h3><p>핫패스는 시스템 내 데이터가 많이 흐르고 사업 임팩트가 큰 경로를 의미
선택지가 적고 실패 영향이 크므로 신중한 설계와 집중 테스트 필요
마이너 기능의 옵션 다양화보다 핫패스 최적화에 자원 우선 배분</p><h3 id=로깅-메트릭-추적>로깅, 메트릭, 추적<a hidden class=anchor aria-hidden=true href=#로깅-메트릭-추적>#</a></h3><p>비정상 경로 로깅 강화</p><ul><li>에러 원인과 컨텍스트 수집</li></ul><p>관측성 기초 지표 수집</p><ul><li>CPU와 메모리</li><li>큐 길이</li><li>요청 지연과 작업 소요 시간</li></ul><p>평균값 대신 분포 지표 관찰</p><ul><li>p95, p99 지연에 주목</li><li>상위 소수의 느린 요청이 핵심 사용자 문제일 수 있음</li></ul><p>분산 추적으로 경계 간 지연과 재시도 파악</p><h3 id=킬스위치-재시도-장애-복구>킬스위치, 재시도, 장애 복구<a hidden class=anchor aria-hidden=true href=#킬스위치-재시도-장애-복구>#</a></h3><p>킬스위치로 기능 단위 차단 가능 상태 유지
무작정 재시도는 장애 전파와 증폭 위험</p><ul><li>회로 차단기로 하류 서비스 보호</li><li>지수 백오프와 재시도 예산 관리</li></ul><p>멱등키로 중복 처리 방지
장애 모드 선택</p><ul><li>fail open이 사용자 영향이 적은 경로 예시로 Rate Limiting</li><li>인증과 결제는 fail closed 필수</li></ul><h3 id=db-조인-vs-애플리케이션-조인-논의-요약>DB 조인 vs 애플리케이션 조인 논의 요약<a hidden class=anchor aria-hidden=true href=#db-조인-vs-애플리케이션-조인-논의-요약>#</a></h3><p>관점 A</p><ul><li>복잡한 데이터 결합은 DB가 담당하는 게 성능과 단순성에서 유리</li><li>뷰와 저장 프로시저는 데이터 추상화 계층으로 유효</li></ul><p>관점 B</p><ul><li>확장성 요구가 큰 구조에서는 DB는 단순 인덱스 조회 역할에 집중</li><li>조인과 집계는 수평 확장 쉬운 백엔드에서 처리해 자원 증설로 스케일링</li><li>대역폭 관점에서 필요한 데이터만 가져와 애플리케이션에서 결합이 유리한 케이스 존재</li></ul><p>실무 결론</p><ul><li>기본값은 DB에 맡기되 데이터 폭발, 팬아웃, 대역폭 병목, 캐시 전략과 결합 등 조건에서 예외 설계 고려</li><li>관측 지표와 비용 곡선으로 선택 검증</li></ul><h3 id=스키마-설계와-유연성>스키마 설계와 유연성<a hidden class=anchor aria-hidden=true href=#스키마-설계와-유연성>#</a></h3><p>스키마의 과유연은 앱 복잡도와 성능 문제 야기</p><ul><li>모든 것을 JSON 컬럼이나 EAV로 수용하는 설계는 가독성과 최적화 모두에 독</li><li>정규화 가능한 경우엔 정규화 선호</li><li>사람이 봐도 용도가 직관적인 테이블 구조 우선</li></ul><p>단, 임시 수용을 위한 제한적 JSONB 같은 완충은 특정 상황에서 유용할 수 있으나 기본 규칙은 아님</p><h3 id=orm-사용-시-주의>ORM 사용 시 주의<a hidden class=anchor aria-hidden=true href=#orm-사용-시-주의>#</a></h3><p>단일 오브젝트 모델 강제는 복잡한 조회 시 유연성 저하 위험
N+1, 비효율 조인, 불필요 데이터 로딩 주의
필요 시 뷰나 핸드크래프트 쿼리로 경로 단순화</p><h3 id=여러-서비스의-db-공유-vs-api-단일-쓰기-경로>여러 서비스의 DB 공유 vs API 단일 쓰기 경로<a hidden class=anchor aria-hidden=true href=#여러-서비스의-db-공유-vs-api-단일-쓰기-경로>#</a></h3><p>권장 기본값</p><ul><li>한 서비스만 테이블에 쓰기 책임 부여</li><li>나머지는 API 호출 또는 이벤트 발행으로 상호작용</li></ul><p>반론과 현실 제약</p><ul><li>여러 서비스가 DB를 직접 접근하면 권한과 트랜잭션, 커스텀 쿼리 활용이 쉬움</li><li>그러나 스키마 변경 시 영향 반경이 커지고 마이그레이션 제약 증가</li></ul><p>실무 결론</p><ul><li>변화 적응성과 조정 범위 최소화를 우선시하면 API가 유리</li><li>공유 DB 구조는 소규모·단기에는 빠를 수 있으나 규모 확대 시 실패 사례가 다수 보고됨</li><li>구조 변경 시 영향을 받는 팀 수를 지표로 삼아 결정</li></ul><h3 id=데이터-전달-인터페이스-우선순위>데이터 전달 인터페이스 우선순위<a hidden class=anchor aria-hidden=true href=#데이터-전달-인터페이스-우선순위>#</a></h3><p>시스템 설계의 핵심은 사용자가 맞닥뜨리는 인터페이스 설계</p><ul><li>기능 제공과 교환비용의 명확화가 본질</li><li>내부 구조는 인터페이스 안정성을 지키며 후속 교체 가능</li></ul><p>설계 논의 시간의 다수를 인터페이스 정의와 버전 전략에 투자 권장</p><h3 id=상태와-운영-책임의-분리>상태와 운영 책임의 분리<a hidden class=anchor aria-hidden=true href=#상태와-운영-책임의-분리>#</a></h3><p>무상태 컨테이너 경로는 배포와 롤백으로 복구 쉬움
상태가 붙는 DB와 파일 스토리지는 전담 운영 책임 필요</p><ul><li>백업과 복구 전략 부재는 정상 운영 중에도 잠재 리스크</li><li>사고 대응은 수 분 내 배포로 해결되지 않는 영역 존재</li></ul><h3 id=캐시와-문서-저장소-선택지>캐시와 문서 저장소 선택지<a hidden class=anchor aria-hidden=true href=#캐시와-문서-저장소-선택지>#</a></h3><p>키값 캐시가 아닌 문서 저장소에 주기적 결과 저장 전략</p><ul><li>대용량 결과물 재사용 시 비용 절감 효과</li><li>만료와 불일치 관리 단순화 가능</li></ul><h3 id=pull과-push-확장-전략>Pull과 Push 확장 전략<a hidden class=anchor aria-hidden=true href=#pull과-push-확장-전략>#</a></h3><p>Pull 고도화</p><ul><li>조건부 요청과 캐시 검증 헤더 활용</li><li>백오프와 지능형 폴링 간격 조절</li></ul><p>Push 고도화</p><ul><li>팬아웃을 큐로 비동기화</li><li>연결 수 관리와 샤딩으로 수평 확장</li></ul><h3 id=관측과-핫패스-최적화-체크리스트>관측과 핫패스 최적화 체크리스트<a hidden class=anchor aria-hidden=true href=#관측과-핫패스-최적화-체크리스트>#</a></h3><ul><li>핫패스 정의와 경로 단순화</li><li>p95, p99 지연 모니터링과 예산 설정</li><li>실패 로그의 샘플링과 컨텍스트 상관ID 부여</li><li>큐 적체 알람과 처리율 자동 확장</li><li>스로틀링과 회로 차단기 정책 점검</li><li>멱등키 적용 범위 정의</li></ul><h3 id=hn에서-나온-면접과-복잡도-논의-요약>HN에서 나온 면접과 복잡도 논의 요약<a hidden class=anchor aria-hidden=true href=#hn에서-나온-면접과-복잡도-논의-요약>#</a></h3><ul><li>현실의 좋은 설계는 단순함이 미덕이지만 면접 신호로는 복잡한 다이어그램이 과대평가되는 경향 존재</li><li>면접에서는 결정을 내린 이유와 고려 요소를 구조화해 설명하는 능력이 중요하다는 반론 다수</li><li>SQL과 NoSQL 선택은 팀 친숙도만이 아니라 작업 부하 특성과 데이터 모델 차이가 중요하다는 의견 존재</li><li>복잡함 숭배가 과설계를 장려한다는 비판과, 그래도 면접은 양방향이므로 의도한 평가 포인트에 맞춰 소통해야 한다는 조언 공존</li></ul><h3 id=db-공유와-서비스-경계에-대한-hn-논의-요약>DB 공유와 서비스 경계에 대한 HN 논의 요약<a hidden class=anchor aria-hidden=true href=#db-공유와-서비스-경계에-대한-hn-논의-요약>#</a></h3><ul><li>여러 서비스가 한 DB를 공유하면 분산 시스템이 이미 형성된 셈이라 관리 복잡도 상승 가능</li><li>반대로 서비스 API가 높은 수준의 인터페이스가 되면 인증과 트랜잭션, 예외처리를 직접 구현해야 하는 부담 발생</li><li>장기 유지보수성과 변경 용이성 관점에서 공유 DB보다 API 경계가 유리하다는 경험담 다수</li><li>DB 분리 시 가용성 계산과 운영 복잡도 증가도 현실 제약으로 고려 필요</li></ul><h3 id=저장-프로시저와-sql-추상화에-대한-hn-논의-요약>저장 프로시저와 SQL 추상화에 대한 HN 논의 요약<a hidden class=anchor aria-hidden=true href=#저장-프로시저와-sql-추상화에-대한-hn-논의-요약>#</a></h3><ul><li>뷰와 저장 프로시저는 데이터 추상화에 유효하다는 견해와, 팀 언어와 도구 표준화 관점에서 유지보수 난이도가 높다는 반론 공존</li><li>ORM은 큰 서비스에서 유연성을 제한하고 성능 문제 유발 가능성이 있어 뷰와 핸드크래프트 쿼리 병행 제안 다수</li></ul><h3 id=boolean-vs-timestamp-논의-요약>boolean vs timestamp 논의 요약<a hidden class=anchor aria-hidden=true href=#boolean-vs-timestamp-논의-요약>#</a></h3><ul><li>단순 boolean은 상태 확장 시 필드 난립으로 이어지므로 timestamp나 enum으로 진화 가능성 확보가 낫다는 주장 존재</li><li>반론으로 논리적 boolean이 의미상 더 적합하고 데이터 크기와 분석 효율 측면에서 유리한 케이스도 있음</li><li>실무 결론은 도메인 변화 방향과 감사 요구에 따라 선택하며, 변경 시점이 중요한 경우 별도 감사 테이블 도입이 더 적합</li></ul><h3 id=느린-작업-처리와-인프라-선택>느린 작업 처리와 인프라 선택<a hidden class=anchor aria-hidden=true href=#느린-작업-처리와-인프라-선택>#</a></h3><ul><li>단기 대기열은 인메모리 큐로 충분</li><li>장기 스케줄은 DB 기반 스케줄 테이블과 워커 조합이 단순하고 운영이 쉬움</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>좋은 시스템 설계의 기본값은 단순함과 상태 최소화
데이터베이스 중심의 스키마와 인덱스, 핫패스 최적화, 관측 가능성 확보가 토대
캐시와 이벤트, 백그라운드 처리, 복잡한 분산 구성은 필요한 순간에만 단계적으로 도입
기술적으로 특별한 설계는 드물고, 지루할 정도로 단순한 구성의 안정적 운영이 장기적으로 가장 강함</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.seangoedecke.com/good-system-design/>https://www.seangoedecke.com/good-system-design/</a></li><li><a href="https://news.ycombinator.com/item?id=44921137">https://news.ycombinator.com/item?id=44921137</a></li><li><a href=https://en.wikipedia.org/wiki/Systemantics>https://en.wikipedia.org/wiki/Systemantics</a></li><li><a href=https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model>https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model</a></li><li><a href=https://pragprog.com/titles/bksqla/sql-antipatterns/>https://pragprog.com/titles/bksqla/sql-antipatterns/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/system-design/>System-Design</a></li><li><a href=https://blog.jsontapose.com/tags/state-management/>State-Management</a></li><li><a href=https://blog.jsontapose.com/tags/database/>Database</a></li><li><a href=https://blog.jsontapose.com/tags/indexing/>Indexing</a></li><li><a href=https://blog.jsontapose.com/tags/caching/>Caching</a></li><li><a href=https://blog.jsontapose.com/tags/event-driven/>Event-Driven</a></li><li><a href=https://blog.jsontapose.com/tags/queues/>Queues</a></li><li><a href=https://blog.jsontapose.com/tags/observability/>Observability</a></li><li><a href=https://blog.jsontapose.com/tags/resilience/>Resilience</a></li><li><a href=https://blog.jsontapose.com/tags/performance/>Performance</a></li><li><a href=https://blog.jsontapose.com/tags/scalability/>Scalability</a></li><li><a href=https://blog.jsontapose.com/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/><span class=title>« Prev</span><br><span>Single Source of Truth(SSOT)의 의미와 적용 예시</span>
</a><a class=next href=https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/><span class=title>Next »</span><br><span>API 에러 응답 설계 가이드 — HTTP Status는 대분류, 비즈니스 의미는 바디</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on x" href="https://x.com/intent/tweet/?text=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f&amp;hashtags=system-design%2cstate-management%2cdatabase%2cindexing%2ccaching%2cevent-driven%2cqueues%2cobservability%2cresilience%2cperformance%2cscalability%2carchitecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f&amp;title=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99&amp;summary=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f&title=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on whatsapp" href="https://api.whatsapp.com/send?text=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on telegram" href="https://telegram.me/share/url?text=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%a2%8b%ec%9d%80%20%ec%8b%9c%ec%8a%a4%ed%85%9c%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%ec%83%81%ed%83%9c%20%ec%b5%9c%ec%86%8c%ed%99%94%ec%99%80%20%ea%b2%80%ec%a6%9d%eb%90%9c%20%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%20%ec%a1%b0%ed%95%a9%ec%9d%98%20%ec%9b%90%ec%b9%99&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fgood-system-design-guide-484b40%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>