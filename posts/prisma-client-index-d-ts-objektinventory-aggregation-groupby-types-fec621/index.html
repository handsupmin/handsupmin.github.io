<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 | HandsLog</title>
<meta name=keywords content="prisma,typescript,type-safety,orm,database,aggregation,group-by"><meta name=description content="@prisma/client의 index.d.ts 개요
Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임
여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리
핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨
핵심 개념

Aggregation 집계
평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산
결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성
Group By 그룹화
특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용
입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재
Count 카운트
조건에 맞는 레코드 개수 반환
_count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능
Find 조회
findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회
반환 타입은 선택한 필드와 관계에 따라 좁혀짐

타입 구조와 동작

집계 결과 타입
ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성
각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음
집계 입력 타입
ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨
그룹화 인자와 출력 타입
ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택
출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환
조회 인자 타입
ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정
메서드 반환 타입 추론
제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐
_count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용

사용 예시

집계 예시

const aggregationResult = await prisma.objektInventory.aggregate({
  _avg: { objektId: true },
  _sum: { lenticularPairTokenId: true },
  where: { owner: 'john' },
})

그룹화 예시

const groupByResult = await prisma.objektInventory.groupBy({
  by: ['status'],
  _count: { _all: true },
  _avg: { objektId: true },
})

카운트 예시

const totalCount = await prisma.objektInventory.count({
  where: { owner: 'john' },
})

조건부 조회 예시

const inventories = await prisma.objektInventory.findMany({
  where: { owner: 'john' },
  orderBy: { updatedAt: 'desc' },
  take: 10,
})
제약과 주의 사항

groupBy 규칙
by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음
take 또는 skip을 사용하는 경우 orderBy 필수
런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보
null 가능성
집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음
연산 전 null 체크 필요
_count 반환 형태
_count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환
사용 목적에 맞는 형태 선택 권장
성능 고려
불필요한 필드 조회 지양, select로 최소화
where 조건에 인덱스 친화적 필드 사용 권장
대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용
타입 안전성
스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행
any 캐스팅으로 타입 보호 우회 금지

맥락과 활용 포인트

데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소
리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용
타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능
반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능

마무리
ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임
입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임
그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조"><meta property="og:description" content="@prisma/client의 index.d.ts 개요 Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임 여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리 핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨
핵심 개념 Aggregation 집계 평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산 결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성 Group By 그룹화 특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용 입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재 Count 카운트 조건에 맞는 레코드 개수 반환 _count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능 Find 조회 findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회 반환 타입은 선택한 필드와 관계에 따라 좁혀짐 타입 구조와 동작 집계 결과 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성 각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨 그룹화 인자와 출력 타입 ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택 출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환 조회 인자 타입 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정 메서드 반환 타입 추론 제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐 _count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용 사용 예시 집계 예시 const aggregationResult = await prisma.objektInventory.aggregate({ _avg: { objektId: true }, _sum: { lenticularPairTokenId: true }, where: { owner: 'john' }, }) 그룹화 예시 const groupByResult = await prisma.objektInventory.groupBy({ by: ['status'], _count: { _all: true }, _avg: { objektId: true }, }) 카운트 예시 const totalCount = await prisma.objektInventory.count({ where: { owner: 'john' }, }) 조건부 조회 예시 const inventories = await prisma.objektInventory.findMany({ where: { owner: 'john' }, orderBy: { updatedAt: 'desc' }, take: 10, }) 제약과 주의 사항 groupBy 규칙 by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음 take 또는 skip을 사용하는 경우 orderBy 필수 런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보 null 가능성 집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음 연산 전 null 체크 필요 _count 반환 형태 _count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환 사용 목적에 맞는 형태 선택 권장 성능 고려 불필요한 필드 조회 지양, select로 최소화 where 조건에 인덱스 친화적 필드 사용 권장 대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용 타입 안전성 스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행 any 캐스팅으로 타입 보호 우회 금지 맥락과 활용 포인트 데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소 리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용 타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능 반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능 마무리 ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임 입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임 그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-22T13:06:38+00:00"><meta property="article:modified_time" content="2025-11-22T13:06:38+00:00"><meta property="article:tag" content="Prisma"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Type-Safety"><meta property="article:tag" content="Orm"><meta property="article:tag" content="Database"><meta property="article:tag" content="Aggregation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조"><meta name=twitter:description content="@prisma/client의 index.d.ts 개요
Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임
여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리
핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨
핵심 개념

Aggregation 집계
평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산
결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성
Group By 그룹화
특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용
입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재
Count 카운트
조건에 맞는 레코드 개수 반환
_count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능
Find 조회
findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회
반환 타입은 선택한 필드와 관계에 따라 좁혀짐

타입 구조와 동작

집계 결과 타입
ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성
각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음
집계 입력 타입
ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨
그룹화 인자와 출력 타입
ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택
출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환
조회 인자 타입
ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정
메서드 반환 타입 추론
제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐
_count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용

사용 예시

집계 예시

const aggregationResult = await prisma.objektInventory.aggregate({
  _avg: { objektId: true },
  _sum: { lenticularPairTokenId: true },
  where: { owner: 'john' },
})

그룹화 예시

const groupByResult = await prisma.objektInventory.groupBy({
  by: ['status'],
  _count: { _all: true },
  _avg: { objektId: true },
})

카운트 예시

const totalCount = await prisma.objektInventory.count({
  where: { owner: 'john' },
})

조건부 조회 예시

const inventories = await prisma.objektInventory.findMany({
  where: { owner: 'john' },
  orderBy: { updatedAt: 'desc' },
  take: 10,
})
제약과 주의 사항

groupBy 규칙
by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음
take 또는 skip을 사용하는 경우 orderBy 필수
런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보
null 가능성
집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음
연산 전 null 체크 필요
_count 반환 형태
_count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환
사용 목적에 맞는 형태 선택 권장
성능 고려
불필요한 필드 조회 지양, select로 최소화
where 조건에 인덱스 친화적 필드 사용 권장
대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용
타입 안전성
스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행
any 캐스팅으로 타입 보호 우회 금지

맥락과 활용 포인트

데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소
리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용
타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능
반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능

마무리
ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임
입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임
그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조","item":"https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조","name":"Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조","description":"@prisma/client의 index.d.ts 개요 Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임 여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리 핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨\n핵심 개념 Aggregation 집계 평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산 결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성 Group By 그룹화 특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용 입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재 Count 카운트 조건에 맞는 레코드 개수 반환 _count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능 Find 조회 findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회 반환 타입은 선택한 필드와 관계에 따라 좁혀짐 타입 구조와 동작 집계 결과 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성 각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨 그룹화 인자와 출력 타입 ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택 출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환 조회 인자 타입 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정 메서드 반환 타입 추론 제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐 _count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용 사용 예시 집계 예시 const aggregationResult = await prisma.objektInventory.aggregate({ _avg: { objektId: true }, _sum: { lenticularPairTokenId: true }, where: { owner: \u0026#39;john\u0026#39; }, }) 그룹화 예시 const groupByResult = await prisma.objektInventory.groupBy({ by: [\u0026#39;status\u0026#39;], _count: { _all: true }, _avg: { objektId: true }, }) 카운트 예시 const totalCount = await prisma.objektInventory.count({ where: { owner: \u0026#39;john\u0026#39; }, }) 조건부 조회 예시 const inventories = await prisma.objektInventory.findMany({ where: { owner: \u0026#39;john\u0026#39; }, orderBy: { updatedAt: \u0026#39;desc\u0026#39; }, take: 10, }) 제약과 주의 사항 groupBy 규칙 by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음 take 또는 skip을 사용하는 경우 orderBy 필수 런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보 null 가능성 집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음 연산 전 null 체크 필요 _count 반환 형태 _count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환 사용 목적에 맞는 형태 선택 권장 성능 고려 불필요한 필드 조회 지양, select로 최소화 where 조건에 인덱스 친화적 필드 사용 권장 대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용 타입 안전성 스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행 any 캐스팅으로 타입 보호 우회 금지 맥락과 활용 포인트 데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소 리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용 타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능 반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능 마무리 ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임 입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임 그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능\n","keywords":["prisma","typescript","type-safety","orm","database","aggregation","group-by"],"articleBody":"@prisma/client의 index.d.ts 개요 Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임 여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리 핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨\n핵심 개념 Aggregation 집계 평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산 결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성 Group By 그룹화 특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용 입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재 Count 카운트 조건에 맞는 레코드 개수 반환 _count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능 Find 조회 findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회 반환 타입은 선택한 필드와 관계에 따라 좁혀짐 타입 구조와 동작 집계 결과 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성 각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨 그룹화 인자와 출력 타입 ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택 출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환 조회 인자 타입 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정 메서드 반환 타입 추론 제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐 _count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용 사용 예시 집계 예시 const aggregationResult = await prisma.objektInventory.aggregate({ _avg: { objektId: true }, _sum: { lenticularPairTokenId: true }, where: { owner: 'john' }, }) 그룹화 예시 const groupByResult = await prisma.objektInventory.groupBy({ by: ['status'], _count: { _all: true }, _avg: { objektId: true }, }) 카운트 예시 const totalCount = await prisma.objektInventory.count({ where: { owner: 'john' }, }) 조건부 조회 예시 const inventories = await prisma.objektInventory.findMany({ where: { owner: 'john' }, orderBy: { updatedAt: 'desc' }, take: 10, }) 제약과 주의 사항 groupBy 규칙 by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음 take 또는 skip을 사용하는 경우 orderBy 필수 런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보 null 가능성 집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음 연산 전 null 체크 필요 _count 반환 형태 _count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환 사용 목적에 맞는 형태 선택 권장 성능 고려 불필요한 필드 조회 지양, select로 최소화 where 조건에 인덱스 친화적 필드 사용 권장 대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용 타입 안전성 스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행 any 캐스팅으로 타입 보호 우회 금지 맥락과 활용 포인트 데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소 리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용 타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능 반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능 마무리 ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임 입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임 그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능\n참고 타입 이름 모음 집계 출력 타입 ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 집계 입력 타입 ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType, ObjektInventoryMinAggregateInputType, ObjektInventoryMaxAggregateInputType, ObjektInventoryCountAggregateInputType 그룹화 관련 ObjektInventoryGroupByArgs, ObjektInventoryGroupByOutputType 조회 관련 ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs 참고자료 아래 문서는 aggregate, groupBy, count, find 계열의 인자와 반환 구조를 가장 정확히 다룸\n참고자료 https://www.prisma.io/docs/orm/prisma-client/queries/aggregation https://www.prisma.io/docs/orm/prisma-client/queries/groupby https://www.prisma.io/docs/orm/reference/prisma-client-reference#count https://www.prisma.io/docs/orm/reference/prisma-client-reference#find ","wordCount":"592","inLanguage":"en","datePublished":"2025-11-22T13:06:38.368Z","dateModified":"2025-11-22T13:06:38.368Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조</h1><div class=post-meta><span title='2025-11-22 13:06:38.368 +0000 UTC'>November 22, 2025</span></div></header><div class=post-content><h2 id=prismaclient의-indexdts-개요>@prisma/client의 index.d.ts 개요<a hidden class=anchor aria-hidden=true href=#prismaclient의-indexdts-개요>#</a></h2><p>Prisma Client가 생성하는 index.d.ts는 모델별 쿼리 메서드와 그 입출력 타입을 정의하는 타입 소스임
여기서는 예시 모델 ObjektInventory를 기준으로 집계 aggregation, 그룹화 groupBy, 카운트 count, 조회 find 계열 메서드의 타입 구조와 사용 맥락 정리
핵심은 타입 안전성과 결과 형태의 명시적 제어이며, 모든 타입은 Prisma 스키마를 기반으로 자동 생성됨</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li>Aggregation 집계
평균, 합, 최소, 최대, 카운트 같은 통계 요약 계산
결과 형태를 명확히 보장하는 Output 타입과 어떤 필드를 집계할지 지정하는 Input 타입으로 구성</li><li>Group By 그룹화
특정 필드 기준으로 그룹 묶음 생성 후 각 그룹에 집계 적용
입력 인자 검증이 엄격하며 by, orderBy, having, take, skip 조합 규칙 존재</li><li>Count 카운트
조건에 맞는 레코드 개수 반환
_count를 다른 집계와 함께 요청하거나 단독 count 메서드로 호출 가능</li><li>Find 조회
findUnique, findFirst, findMany로 조건, 정렬, 페이징, select, include를 조합해 조회
반환 타입은 선택한 필드와 관계에 따라 좁혀짐</li></ul><h3 id=타입-구조와-동작>타입 구조와 동작<a hidden class=anchor aria-hidden=true href=#타입-구조와-동작>#</a></h3><ul><li>집계 결과 타입
ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType 등으로 구성
각 필드는 해당 타입의 스칼라값 또는 null을 가질 수 있음</li><li>집계 입력 타입
ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType 등에서 true로 지정한 필드만 결과에 포함됨</li><li>그룹화 인자와 출력 타입
ObjektInventoryGroupByArgs에 by로 그룹 기준 필드 지정, _count, _avg, _sum, _min, _max 중 필요한 집계 선택
출력은 ObjektInventoryGroupByOutputType으로 각 그룹 키 필드 + 선택한 집계 결과 반환</li><li>조회 인자 타입
ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs에서 where, orderBy, cursor, take, skip, select, include 등을 타입 안전하게 지정</li><li>메서드 반환 타입 추론
제네릭과 조건부 타입을 통해 선택한 select 또는 집계 키에 맞춰 반환 타입이 자동으로 좁혀짐
_count를 true로 둘 경우 숫자 반환, 객체 형태를 원하면 _count { _all: true } 형태 사용</li></ul><h3 id=사용-예시>사용 예시<a hidden class=anchor aria-hidden=true href=#사용-예시>#</a></h3><ul><li>집계 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aggregationResult</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>objektInventory</span>.<span style=color:#a6e22e>aggregate</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_avg</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>objektId</span>: <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_sum</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>lenticularPairTokenId</span>: <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>where</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>owner</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;john&#39;</span> },
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><ul><li>그룹화 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>groupByResult</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>objektInventory</span>.<span style=color:#a6e22e>groupBy</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>by</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;status&#39;</span>],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_count</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>_all</span>: <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_avg</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>objektId</span>: <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><ul><li>카운트 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>totalCount</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>objektInventory</span>.<span style=color:#a6e22e>count</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>where</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>owner</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;john&#39;</span> },
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><ul><li>조건부 조회 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>inventories</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>objektInventory</span>.<span style=color:#a6e22e>findMany</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>where</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>owner</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;john&#39;</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>orderBy</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>updatedAt</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;desc&#39;</span> },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>take</span>: <span style=color:#66d9ef>10</span>,
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=제약과-주의-사항>제약과 주의 사항<a hidden class=anchor aria-hidden=true href=#제약과-주의-사항>#</a></h3><ul><li>groupBy 규칙
by에 포함되지 않은 필드로 orderBy 또는 having을 사용할 수 없음
take 또는 skip을 사용하는 경우 orderBy 필수
런타임 전 타입 레벨에서 오류로 차단되어 쿼리 일관성 확보</li><li>null 가능성
집계 결과는 조건에 맞는 레코드가 없으면 각 필드가 null이 될 수 있음
연산 전 null 체크 필요</li><li>_count 반환 형태
_count: true는 숫자 단일 값, _count: { _all: true }는 카운트 내역을 가진 객체 반환
사용 목적에 맞는 형태 선택 권장</li><li>성능 고려
불필요한 필드 조회 지양, select로 최소화
where 조건에 인덱스 친화적 필드 사용 권장
대규모 groupBy는 데이터베이스 리소스 부담 가능, 필요한 필드와 조건만 사용</li><li>타입 안전성
스키마 변경 시 재생성된 index.d.ts를 기준으로 컴파일 타임 검증 수행
any 캐스팅으로 타입 보호 우회 금지</li></ul><h3 id=맥락과-활용-포인트>맥락과 활용 포인트<a hidden class=anchor aria-hidden=true href=#맥락과-활용-포인트>#</a></h3><ul><li>데이터 분석 워크로드에서 서버 측 집계 활용으로 불필요한 애플리케이션 레벨 후처리 감소</li><li>리포트, 대시보드, 통계 API에서 groupBy + 다중 집계 조합이 유용</li><li>타입 정의가 강제하는 인자 조합 규칙으로 런타임 쿼리 오류를 사전에 방지 가능</li><li>반환 타입이 선택된 입력에 따라 좁혀지므로 응답 스키마를 명확히 설계 가능</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>ObjektInventory를 예로 본 index.d.ts의 집계와 그룹화 타입은 Prisma Client가 제공하는 타입 안전 쿼리의 핵심 축임
입력 타입으로 의도를 명시하고, 출력 타입으로 결과 스키마를 보장하는 흐름이 데이터 품질과 안정성을 높임
그룹화 규칙과 _count 반환 형태, null 가능성 같은 세부 제약만 지키면 복잡한 통계 요구사항도 간결하게 커버 가능</p><h3 id=참고-타입-이름-모음>참고 타입 이름 모음<a hidden class=anchor aria-hidden=true href=#참고-타입-이름-모음>#</a></h3><ul><li>집계 출력 타입
ObjektInventoryAvgAggregateOutputType, ObjektInventorySumAggregateOutputType, ObjektInventoryMinAggregateOutputType, ObjektInventoryMaxAggregateOutputType, ObjektInventoryCountAggregateOutputType</li><li>집계 입력 타입
ObjektInventoryAvgAggregateInputType, ObjektInventorySumAggregateInputType, ObjektInventoryMinAggregateInputType, ObjektInventoryMaxAggregateInputType, ObjektInventoryCountAggregateInputType</li><li>그룹화 관련
ObjektInventoryGroupByArgs, ObjektInventoryGroupByOutputType</li><li>조회 관련
ObjektInventoryFindUniqueArgs, ObjektInventoryFindFirstArgs, ObjektInventoryFindManyArgs</li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><p>아래 문서는 aggregate, groupBy, count, find 계열의 인자와 반환 구조를 가장 정확히 다룸</p><h3 id=참고자료-1>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료-1>#</a></h3><ul><li><a href=https://www.prisma.io/docs/orm/prisma-client/queries/aggregation>https://www.prisma.io/docs/orm/prisma-client/queries/aggregation</a></li><li><a href=https://www.prisma.io/docs/orm/prisma-client/queries/groupby>https://www.prisma.io/docs/orm/prisma-client/queries/groupby</a></li><li><a href=https://www.prisma.io/docs/orm/reference/prisma-client-reference#count>https://www.prisma.io/docs/orm/reference/prisma-client-reference#count</a></li><li><a href=https://www.prisma.io/docs/orm/reference/prisma-client-reference#find>https://www.prisma.io/docs/orm/reference/prisma-client-reference#find</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/prisma/>Prisma</a></li><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/type-safety/>Type-Safety</a></li><li><a href=https://blog.jsontapose.com/tags/orm/>Orm</a></li><li><a href=https://blog.jsontapose.com/tags/database/>Database</a></li><li><a href=https://blog.jsontapose.com/tags/aggregation/>Aggregation</a></li><li><a href=https://blog.jsontapose.com/tags/group-by/>Group-By</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/><span class=title>« Prev</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span>
</a><a class=next href=https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/><span class=title>Next »</span><br><span>JavaScript Promise.all과 Map 정리 – 동시 비동기 처리와 키-값 컬렉션 기본</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on x" href="https://x.com/intent/tweet/?text=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f&amp;hashtags=prisma%2ctypescript%2ctype-safety%2corm%2cdatabase%2caggregation%2cgroup-by"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f&amp;title=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0&amp;summary=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f&title=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on whatsapp" href="https://api.whatsapp.com/send?text=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on telegram" href="https://telegram.me/share/url?text=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Prisma%20Client%20index.d.ts%eb%a1%9c%20%ec%9d%bd%eb%8a%94%20ObjektInventory%20%ec%a7%91%ea%b3%84%c2%b7%ea%b7%b8%eb%a3%b9%ed%99%94%20%ed%83%80%ec%9e%85%20%ea%b5%ac%ec%a1%b0&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fprisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>