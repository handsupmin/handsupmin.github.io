<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TypeScript에서 type과 interface 차이와 선택 기준 | HandsLog</title>
<meta name=keywords content="typescript,type-alias,interface,type-system,union,intersection"><meta name=description content="개요
TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름
객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐
핵심 차이 포인트 중심으로 정리
핵심 개념


type

타입 별칭 정의 수단
기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리
선언 병합 불가



interface

객체의 구조 정의 수단
확장과 선언 병합 지원
주로 객체와 클래스와의 계약 정의에 사용



// type 별칭 최소 예시
type ID = number | string
type Point = [number, number]
type Person = { name: string } & { age: number }

// interface 최소 예시
interface User { name: string; age: number }
interface Employee extends User { employeeId: number }차이점과 동작


표현 범위"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="TypeScript에서 type과 interface 차이와 선택 기준"><meta property="og:description" content="개요 TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름 객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐 핵심 차이 포인트 중심으로 정리
핵심 개념 type
타입 별칭 정의 수단 기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리 선언 병합 불가 interface
객체의 구조 정의 수단 확장과 선언 병합 지원 주로 객체와 클래스와의 계약 정의에 사용 // type 별칭 최소 예시 type ID = number | string type Point = [number, number] type Person = { name: string } & { age: number } // interface 최소 예시 interface User { name: string; age: number } interface Employee extends User { employeeId: number }차이점과 동작 표현 범위"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-09T13:14:16+00:00"><meta property="article:modified_time" content="2026-01-09T13:14:16+00:00"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Type-Alias"><meta property="article:tag" content="Interface"><meta property="article:tag" content="Type-System"><meta property="article:tag" content="Union"><meta property="article:tag" content="Intersection"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript에서 type과 interface 차이와 선택 기준"><meta name=twitter:description content="개요
TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름
객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐
핵심 차이 포인트 중심으로 정리
핵심 개념


type

타입 별칭 정의 수단
기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리
선언 병합 불가



interface

객체의 구조 정의 수단
확장과 선언 병합 지원
주로 객체와 클래스와의 계약 정의에 사용



// type 별칭 최소 예시
type ID = number | string
type Point = [number, number]
type Person = { name: string } & { age: number }

// interface 최소 예시
interface User { name: string; age: number }
interface Employee extends User { employeeId: number }차이점과 동작


표현 범위"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"TypeScript에서 type과 interface 차이와 선택 기준","item":"https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TypeScript에서 type과 interface 차이와 선택 기준","name":"TypeScript에서 type과 interface 차이와 선택 기준","description":"개요 TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름 객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐 핵심 차이 포인트 중심으로 정리\n핵심 개념 type\n타입 별칭 정의 수단 기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리 선언 병합 불가 interface\n객체의 구조 정의 수단 확장과 선언 병합 지원 주로 객체와 클래스와의 계약 정의에 사용 // type 별칭 최소 예시 type ID = number | string type Point = [number, number] type Person = { name: string } \u0026amp; { age: number } // interface 최소 예시 interface User { name: string; age: number } interface Employee extends User { employeeId: number }차이점과 동작 표현 범위\n","keywords":["typescript","type-alias","interface","type-system","union","intersection"],"articleBody":"개요 TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름 객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐 핵심 차이 포인트 중심으로 정리\n핵심 개념 type\n타입 별칭 정의 수단 기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리 선언 병합 불가 interface\n객체의 구조 정의 수단 확장과 선언 병합 지원 주로 객체와 클래스와의 계약 정의에 사용 // type 별칭 최소 예시 type ID = number | string type Point = [number, number] type Person = { name: string } \u0026 { age: number } // interface 최소 예시 interface User { name: string; age: number } interface Employee extends User { employeeId: number }차이점과 동작 표현 범위\ntype은 유니언, 튜플, 조건부 타입, 매핑된 타입 등 고급 타입 구성 가능 interface는 객체 중심 표현에 최적화, 유니언/튜플 직접 표현 불가 확장 방식\ninterface는 extends로 계층 설계 용이 type은 교차 타입(\u0026)으로 합성, 사실상 객체 타입 확장 대체 가능 interface는 객체 형태의 type 별칭을 extends할 수 있으나 유니언 등 비객체 타입은 확장 불가 선언 병합\ninterface는 같은 이름으로 재선언 시 자동 병합 지원 type은 동일 이름 중복 정의 불가, 병합 미지원 클래스와의 호환\n클래스 implements에는 interface뿐 아니라 객체 형태의 type 별칭도 사용 가능 차이는 선언 병합 가능 여부와 확장 구문 차이에서 발생 장단점 type 장점\n유니언, 튜플, 교차, 조건부, 매핑된 타입 등 복잡한 타입 모델링에 강함 별칭으로 복잡한 표현 캡슐화, 가독성 향상 type 단점\n선언 병합 미지원 확장은 교차 타입으로만 구성, 명시적 계층 표현은 제한적 interface 장점\nextends 기반 계층화 용이, 객체 모델 설계에 적합 선언 병합 지원으로 점진적 확장과 모듈 보강에 유리 클래스와의 계약 정의에 직관적 interface 단점\n유니언/튜플 등 비객체 타입 표현 한계 매우 복잡한 조합형 타입 표현에는 제약 사용 권장 interface 권장 상황\n도메인 객체 구조 정의 및 계층 확장 필요 라이브러리 타입 공개 시 선언 병합 또는 모듈 보강 가능성이 있음 클래스가 구현해야 할 계약을 명시하고자 함 type 권장 상황\n유니언, 교차, 튜플 등 복합 타입 모델링 필요 조건부/매핑된 타입 같은 고급 타입 구성 필요 인터페이스로 표현하기 어려운 조합형 타입 단순화 필요 // 인터페이스 계층 최소 예시 interface Shape { area(): number } interface Rectangle extends Shape { width: number; height: number } // 유니언 별칭 최소 예시 type Status = 'success' | 'error' | 'loading'예시로 보는 핵심 포인트 선언 병합은 interface만 가능 interface Profile { name: string } interface Profile { age: number } // Profile은 { name: string; age: number }로 병합됨 type으로 객체 타입 확장하는 일반 패턴 type Base = { id: string } type WithTimestamps = Base \u0026 { createdAt: Date; updatedAt: Date }주의 사항 interface가 type보다 항상 우월하거나 그 반대는 아님, 모델링 목표에 따라 선택 interface는 비객체 타입 확장 불가, type은 선언 병합 불가 클래스 implements에는 객체 형태의 type도 사용 가능, 오해 주의 최신 TS에서 공통 기능이 늘었지만 핵심 차이는 선언 병합과 표현 범위에 남아 있음 요약 객체 구조 정의와 확장, 모듈 보강 필요 시 interface 우선 유니언, 튜플, 교차, 조건부 등 복합 타입 모델링 시 type 우선 팀 컨벤션에 따라 일관성 유지 권장, 특정 케이스에서는 혼용 실무적 선택 유효 참고자료 https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces https://www.typescriptlang.org/docs/handbook/declaration-merging.html https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types ","wordCount":"497","inLanguage":"en","datePublished":"2026-01-09T13:14:16.898Z","dateModified":"2026-01-09T13:14:16.898Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">TypeScript에서 type과 interface 차이와 선택 기준</h1><div class=post-meta><span title='2026-01-09 13:14:16.898 +0000 UTC'>January 9, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름
객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐
핵심 차이 포인트 중심으로 정리</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><p>type</p><ul><li>타입 별칭 정의 수단</li><li>기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리</li><li>선언 병합 불가</li></ul></li><li><p>interface</p><ul><li>객체의 구조 정의 수단</li><li>확장과 선언 병합 지원</li><li>주로 객체와 클래스와의 계약 정의에 사용</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#616e87;font-style:italic>// type 별칭 최소 예시
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>type</span> ID <span style=color:#81a1c1>=</span> <span style=color:#81a1c1>number</span> <span style=color:#81a1c1>|</span> <span style=color:#81a1c1>string</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>type</span> Point <span style=color:#81a1c1>=</span> <span style=color:#eceff4>[</span><span style=color:#81a1c1>number</span><span style=color:#eceff4>,</span> <span style=color:#81a1c1>number</span><span style=color:#eceff4>]</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>type</span> Person <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span> <span style=color:#eceff4>}</span> <span style=color:#81a1c1>&amp;</span> <span style=color:#eceff4>{</span> age: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// interface 최소 예시
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>interface</span> User <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span><span style=color:#eceff4>;</span> age: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>interface</span> Employee <span style=color:#81a1c1;font-weight:700>extends</span> User <span style=color:#eceff4>{</span> employeeId: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span></span></span></code></pre></div><h3 id=차이점과-동작>차이점과 동작<a hidden class=anchor aria-hidden=true href=#차이점과-동작>#</a></h3><ul><li><p>표현 범위</p><ul><li>type은 유니언, 튜플, 조건부 타입, 매핑된 타입 등 고급 타입 구성 가능</li><li>interface는 객체 중심 표현에 최적화, 유니언/튜플 직접 표현 불가</li></ul></li><li><p>확장 방식</p><ul><li>interface는 extends로 계층 설계 용이</li><li>type은 교차 타입(&)으로 합성, 사실상 객체 타입 확장 대체 가능</li><li>interface는 객체 형태의 type 별칭을 extends할 수 있으나 유니언 등 비객체 타입은 확장 불가</li></ul></li><li><p>선언 병합</p><ul><li>interface는 같은 이름으로 재선언 시 자동 병합 지원</li><li>type은 동일 이름 중복 정의 불가, 병합 미지원</li></ul></li><li><p>클래스와의 호환</p><ul><li>클래스 implements에는 interface뿐 아니라 객체 형태의 type 별칭도 사용 가능</li><li>차이는 선언 병합 가능 여부와 확장 구문 차이에서 발생</li></ul></li></ul><h3 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h3><ul><li><p>type 장점</p><ul><li>유니언, 튜플, 교차, 조건부, 매핑된 타입 등 복잡한 타입 모델링에 강함</li><li>별칭으로 복잡한 표현 캡슐화, 가독성 향상</li></ul></li><li><p>type 단점</p><ul><li>선언 병합 미지원</li><li>확장은 교차 타입으로만 구성, 명시적 계층 표현은 제한적</li></ul></li><li><p>interface 장점</p><ul><li>extends 기반 계층화 용이, 객체 모델 설계에 적합</li><li>선언 병합 지원으로 점진적 확장과 모듈 보강에 유리</li><li>클래스와의 계약 정의에 직관적</li></ul></li><li><p>interface 단점</p><ul><li>유니언/튜플 등 비객체 타입 표현 한계</li><li>매우 복잡한 조합형 타입 표현에는 제약</li></ul></li></ul><h3 id=사용-권장>사용 권장<a hidden class=anchor aria-hidden=true href=#사용-권장>#</a></h3><ul><li><p>interface 권장 상황</p><ul><li>도메인 객체 구조 정의 및 계층 확장 필요</li><li>라이브러리 타입 공개 시 선언 병합 또는 모듈 보강 가능성이 있음</li><li>클래스가 구현해야 할 계약을 명시하고자 함</li></ul></li><li><p>type 권장 상황</p><ul><li>유니언, 교차, 튜플 등 복합 타입 모델링 필요</li><li>조건부/매핑된 타입 같은 고급 타입 구성 필요</li><li>인터페이스로 표현하기 어려운 조합형 타입 단순화 필요</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 인터페이스 계층 최소 예시
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>interface</span> Shape <span style=color:#eceff4>{</span> area<span style=color:#eceff4>()</span><span style=color:#81a1c1>:</span> <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>interface</span> Rectangle <span style=color:#81a1c1;font-weight:700>extends</span> Shape <span style=color:#eceff4>{</span> width: <span style=color:#81a1c1>number</span><span style=color:#eceff4>;</span> height: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 유니언 별칭 최소 예시
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>type</span> Status <span style=color:#81a1c1>=</span> <span style=color:#a3be8c>&#39;success&#39;</span> <span style=color:#81a1c1>|</span> <span style=color:#a3be8c>&#39;error&#39;</span> <span style=color:#81a1c1>|</span> <span style=color:#a3be8c>&#39;loading&#39;</span></span></span></code></pre></div><h3 id=예시로-보는-핵심-포인트>예시로 보는 핵심 포인트<a hidden class=anchor aria-hidden=true href=#예시로-보는-핵심-포인트>#</a></h3><ul><li>선언 병합은 interface만 가능</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>interface</span> Profile <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>interface</span> Profile <span style=color:#eceff4>{</span> age: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// Profile은 { name: string; age: number }로 병합됨
</span></span></span></code></pre></div><ul><li>type으로 객체 타입 확장하는 일반 패턴</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>type</span> Base <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> id: <span style=color:#81a1c1>string</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>type</span> WithTimestamps <span style=color:#81a1c1>=</span> Base <span style=color:#81a1c1>&amp;</span> <span style=color:#eceff4>{</span> createdAt: <span style=color:#81a1c1>Date</span><span style=color:#eceff4>;</span> updatedAt: <span style=color:#81a1c1>Date</span> <span style=color:#eceff4>}</span></span></span></code></pre></div><h3 id=주의-사항>주의 사항<a hidden class=anchor aria-hidden=true href=#주의-사항>#</a></h3><ul><li>interface가 type보다 항상 우월하거나 그 반대는 아님, 모델링 목표에 따라 선택</li><li>interface는 비객체 타입 확장 불가, type은 선언 병합 불가</li><li>클래스 implements에는 객체 형태의 type도 사용 가능, 오해 주의</li><li>최신 TS에서 공통 기능이 늘었지만 핵심 차이는 선언 병합과 표현 범위에 남아 있음</li></ul><h3 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h3><ul><li>객체 구조 정의와 확장, 모듈 보강 필요 시 interface 우선</li><li>유니언, 튜플, 교차, 조건부 등 복합 타입 모델링 시 type 우선</li><li>팀 컨벤션에 따라 일관성 유지 권장, 특정 케이스에서는 혼용 실무적 선택 유효</li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases>https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces>https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/declaration-merging.html>https://www.typescriptlang.org/docs/handbook/declaration-merging.html</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types>https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/type-alias/>Type-Alias</a></li><li><a href=https://blog.jsontapose.com/tags/interface/>Interface</a></li><li><a href=https://blog.jsontapose.com/tags/type-system/>Type-System</a></li><li><a href=https://blog.jsontapose.com/tags/union/>Union</a></li><li><a href=https://blog.jsontapose.com/tags/intersection/>Intersection</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/><span class=title>« Prev</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span>
</a><a class=next href=https://blog.jsontapose.com/posts/database-collation-and-character-set-320bf2/><span class=title>Next »</span><br><span>데이터베이스 Collation 정렬·비교 규칙과 인코딩 차이</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on x" href="https://x.com/intent/tweet/?text=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f&amp;hashtags=typescript%2ctype-alias%2cinterface%2ctype-system%2cunion%2cintersection"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f&amp;title=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;summary=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f&title=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on whatsapp" href="https://api.whatsapp.com/send?text=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on telegram" href="https://telegram.me/share/url?text=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript에서 type과 interface 차이와 선택 기준 on ycombinator" href="https://news.ycombinator.com/submitlink?t=TypeScript%ec%97%90%ec%84%9c%20type%ea%b3%bc%20interface%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-type-vs-interface-b3670b%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>