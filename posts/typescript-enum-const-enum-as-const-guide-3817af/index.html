<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TypeScript enum, const enum, as const의 차이와 선택 가이드 | HandsLog</title>
<meta name=keywords content="typescript,enum,const-enum,as-const,literal-types,discriminated-union,type-inference,tree-shaking,build-tooling"><meta name=description content="개요
TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임
여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐
실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함
이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함
핵심 개념과 정의

enum  값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김
const enum  enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성
as const  const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장

여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임
enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음
as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="TypeScript enum, const enum, as const의 차이와 선택 가이드"><meta property="og:description" content="개요 TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임 여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐 실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함 이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함
핵심 개념과 정의 enum 값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김 const enum enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성 as const const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장 여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임 enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음 as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T13:11:16+00:00"><meta property="article:modified_time" content="2025-10-14T13:11:16+00:00"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Enum"><meta property="article:tag" content="Const-Enum"><meta property="article:tag" content="As-Const"><meta property="article:tag" content="Literal-Types"><meta property="article:tag" content="Discriminated-Union"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript enum, const enum, as const의 차이와 선택 가이드"><meta name=twitter:description content="개요
TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임
여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐
실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함
이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함
핵심 개념과 정의

enum  값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김
const enum  enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성
as const  const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장

여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임
enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음
as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"TypeScript enum, const enum, as const의 차이와 선택 가이드","item":"https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TypeScript enum, const enum, as const의 차이와 선택 가이드","name":"TypeScript enum, const enum, as const의 차이와 선택 가이드","description":"개요 TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임 여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐 실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함 이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함\n핵심 개념과 정의 enum 값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김 const enum enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성 as const const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장 여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임 enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음 as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함\n","keywords":["typescript","enum","const-enum","as-const","literal-types","discriminated-union","type-inference","tree-shaking","build-tooling"],"articleBody":"개요 TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임 여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐 실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함 이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함\n핵심 개념과 정의 enum 값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김 const enum enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성 as const const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장 여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임 enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음 as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함\nenum 동작 원리와 구조 멤버 종류 상수 멤버와 계산된 멤버로 구분됨\n상수 멤버 컴파일 타임에 확정 가능한 값 계산된 멤버 표현식을 평가해야 정해지는 값, const enum에서는 허용되지 않음 값 타입별 분류\n숫자형 enum 기본값 0부터 1씩 자동 증가, 역매핑 지원 문자열형 enum 문자열 상수 부여, 역매핑은 키에서 값 방향만 성립 혼합형 enum 숫자와 문자열 혼재, 특별한 이유가 없다면 권장하지 않음 자동 할당 규칙\n첫 멤버 초기화가 없으면 0 할당 직전 멤버가 숫자 상수면 다음 멤버는 +1 증가 값 부여 양방향 매핑\n숫자형 enum은 키→값과 값→키 모두 접근 가능 런타임 객체로 역참조가 가능해 디버깅에는 편하지만 코드가 늘어나고 tree-shaking에 불리함 제약\n멤버 이름은 숫자 식별자 불가 라이브러리 배포 시 번들 크기 영향 고려 필요 enum의 장단점 장점\n의도 표현력이 좋음 열거형이라는 도메인 모델을 바로 드러냄 안전성 향상 지정한 값 집합만 허용되는 형태로 오입력 방지에 유리함 숫자형의 역매핑이 디버깅과 로그 판독에 편리 단점\n코드 팽창 즉시 실행 패턴과 역매핑 테이블로 번들 크기 증가 가능성 tree-shaking에 불리 선언만 해도 구현 코드가 남아 죽은 코드 제거가 어려움 문자열형만 필요할 때도 런타임 테이블을 유지해야 하는 비용 발생 const enum의 목적과 제약 목적\nenum 접근 비용과 추가 생성 코드를 제거하여 가벼운 산출물 확보 사용 지점에 값이 inlined되어 역참조 테이블 자체를 만들지 않음 제약과 주의\n계산된 멤버 금지 상수 표현식만 허용 툴체인 호환성 이슈 빈번 Babel 등 타입 지우기 전용 트랜스파일러는 const enum을 지원하지 않거나 그대로 통과시키는 경우가 있어 런타임 에러 유발 위험 존재 isolatedModules 옵션 사용 시 모듈 단일 변환 제약으로 const enum이 막히거나 preserveConstEnums 설정과 충돌 가능성 라이브러리 배포 시 소비자 환경에 따라 의미가 달라질 수 있음 선언 파일 d.ts에 const enum을 노출하면 소비자 컴파일러 설정과 상호작용이 필요해 파편화 가능성 발생 요약하면, const enum은 산출물 최적화에 유리하지만, 빌드 파이프라인과 배포 경로가 단순하지 않으면 리스크가 큼\nas const의 의도와 효과 의도\n값의 리터럴 타입화와 readonly 부여를 통해 상수성을 보장하고 타입 좁히기 수행 객체 키를 통한 값 집합 설계 후 해당 값들의 유니온 타입을 간단히 얻을 수 있음 효과\n값 그 자체가 타입으로 추론됨 문자열은 문자열 리터럴 타입, 숫자는 숫자 리터럴 타입으로 고정 객체 단위 as const는 모든 프로퍼티를 readonly로 바꾸어 재할당 차단 런타임 오버헤드 없음 단순한 객체와 배열 그대로 유지되어 tree-shaking에도 유리 실무 포인트\nenum의 역매핑이 꼭 필요하지 않다면 as const 기반의 객체 열거가 가장 무난 선언과 타입 획득을 분리해 재사용성과 트리셰이킹을 확보 가능 최소 예시 스니펫 스니펫 1 숫자형 enum의 역매핑\nenum Direction { Up, Down, } Direction.Up // 0 Direction[0] // 'Up' 스니펫 2 as const로 값 유니온 타입 얻기\nconst Status = { Ready: 'ready', Done: 'done', } as const type Status = typeof Status[keyof typeof Status] // 'ready' | 'done' 위 두 가지로 enum의 역매핑 유무와 as const의 리터럴 타입화를 직관적으로 비교 가능\nDiscriminated Union과 as const 상태를 안전하게 분기하려면 판별 가능한 공통 필드를 두는 것이 핵심\n공통 필드 kind 같은 것을 문자열 리터럴로 고정 각 변형에 고유 속성을 부여하고 분기 시 kind로 좁히기 이때 as const로 kind 값을 리터럴 타입으로 확정하면 분기 안전성이 올라감 Discriminated Union은 넓은 유니온 타입에서 특정 필드의 리터럴 값 비교로 타입 가드를 자동 유도함 리터럴 타입화가 불완전하면 존재할 수도 없을 수도 있는 속성으로 판단해 접근 시 에러가 날 수 있음 as const를 적용해 판별 키를 리터럴로 고정하면 분기 후 속성 접근이 안전해짐\nconst enum의 함정 정리 Babel 트랜스파일 TypeScript 구문 제거 위주로 동작하여 const enum을 컴파일하지 않음 결과적으로 사용 지점에서 값이 남지 않고 식별자 자체가 유지되어 런타임 에러 가능 SWC 등 대체 트랜스파일러 사용 시에도 설정 차이에 따라 const enum이 보존되거나 잘못 처리될 수 있음 tsconfig의 isolatedModules가 켜진 환경에서는 모듈 단위 변환 제약으로 const enum 사용이 제한되거나 preserveConstEnums와 상충 가능 라이브러리 d.ts에 const enum을 노출하면 소비자 빌드가 동일한 규칙으로 inlining해야 하므로 빌드 파이프라인 결속이 필요해짐 이런 리스크로 인해 팀 규칙으로 const enum 금지, as const 권장으로 정하는 경우가 많음\n선택 가이드라인 다음 체크리스트로 결정\n역매핑이 꼭 필요함 숫자값에서 이름을 역으로 알아야 하는 요구가 명확함\n예 바이너리 프로토콜 디버깅에서 숫자코드를 사람 읽는 문자열로 즉시 확인 필요 선택 enum 고려 번들 크기와 tree-shaking이 중요함 런타임 테이블 생성 비용을 피하고 싶음\n선택 as const 기반 객체 열거 권장 빌드 파이프라인이 단순함 tsc 단독 빌드, const enum을 안전하게 inline 가능하다고 확신함\n선택 const enum 사용 가능하나 팀 규칙으로 명시하고 도구 호환성 테스트 필수 라이브러리 배포 소비자 환경 다양, 선언 파일 안정성이 최우선\n선택 const enum 지양, as const + 타입 유니온 익스포트 권장 값 집합을 타입으로 바로 얻고 싶음, 리터럴 타입화와 readonly가 필요함\n선택 as const로 객체를 선언하고 typeof와 keyof 조합으로 유니온 타입 획득 베스트 프랙티스 팀 규칙 정의 enum은 역매핑이 실질적 이득을 줄 때에만 사용, 기본값은 as const 빌드 파이프라인 점검 Babel 사용 시 const enum 금지, tsc emit 환경에서만 제한적 허용 선언과 타입 분리 as const 객체를 런타임 값으로 노출하고, 타입은 typeof와 keyof로 파생 문자열형만 필요한 경우 enum 대신 문자열 리터럴 유니온 또는 as const 객체 사용 공개 API의 안정성 확보 라이브러리 환경에서는 상수 집합을 값과 타입으로 동시에 노출하되 const enum 회피 자동 증가 규칙에 의존하지 않기 enum 숫자값이 외부 계약이라면 명시적으로 값 지정 트레이드오프 요약 enum 의도 표현력과 역매핑 편의 제공, 대신 런타임 테이블과 번들 팽창 감수 const enum 매우 가벼운 산출물 확보, 대신 빌드 호환성 리스크와 계산된 멤버 제한 수용 as const 타입 안전과 tree-shaking 친화성 확보, 대신 역매핑 등 런타임 편의는 직접 구현 필요 실무 기본값은 as const, 명확한 필요가 있을 때만 enum, const enum은 파이프라인이 보장될 때 선택\n참고로 알아두면 좋은 설정과 패턴 tsconfig preserveConstEnums true로 두면 const enum을 제거하지 않고 남김 라이브러리 소비자 측에서 inlining을 기대하는 형태가 되어 호환성 이슈가 더 커질 수 있음 tsconfig isolatedModules 각 파일을 독립적으로 변환하므로 const enum 사용이 제한되는 경우가 있음 Discriminated Union의 판별 키는 문자열 리터럴 타입으로 고정 as const 적극 활용 값에서 타입 뽑기 패턴 typeof Obj[keyof typeof Obj] 조합으로 값 유니온 타입 생성 마무리 양방향 매핑이 기능 요구사항에 포함되어 있는지, 빌드 파이프라인이 const enum을 안전하게 처리하는지, 번들 크기 최적화의 우선순위가 높은지부터 판단하면 선택이 단순해짐 대부분의 프런트엔드와 서버 사이드 TypeScript 코드에서는 as const 기반 상수 객체와 리터럴 유니온이 안전하고 유지보수 친화적임 역매핑이 명백한 가치를 제공할 때만 enum을 채택하고, const enum은 도구 체인이 이를 보장할 때 제한적으로 사용함 목적에 맞춘 선택이 코드의 명료성과 산출물 품질을 동시에 끌어올림\n참고자료 https://www.typescriptlang.org/docs/handbook/enums.html https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions https://www.typescriptlang.org/tsconfig#preserveConstEnums https://www.typescriptlang.org/tsconfig#isolatedModules https://babeljs.io/docs/babel-plugin-transform-typescript ","wordCount":"1123","inLanguage":"en","datePublished":"2025-10-14T13:11:16.123Z","dateModified":"2025-10-14T13:11:16.123Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-guide-3817af/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://handsupmin.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://handsupmin.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://handsupmin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://handsupmin.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">TypeScript enum, const enum, as const의 차이와 선택 가이드</h1><div class=post-meta><span title='2025-10-14 13:11:16.123 +0000 UTC'>October 14, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>TypeScript에서 값 집합을 식별자에 묶어 표현할 때 가장 먼저 떠오르는 도구가 enum임
여기에 컴파일 결과를 가볍게 하려는 const enum, 값 자체를 타입으로 고정하는 as const가 더해지며 선택지가 많아짐
실무에서는 번들러와 트랜스파일러 조합, 배포 산출물 정책, 팀의 코딩 규칙까지 함께 고려해야 함
이 글은 각각의 개념과 동작 원리를 짚고, 장단점과 함정을 실무 맥락에서 정리하여 목적에 맞는 선택 기준을 제시함</p><h3 id=핵심-개념과-정의>핵심 개념과 정의<a hidden class=anchor aria-hidden=true href=#핵심-개념과-정의>#</a></h3><ul><li>enum 값 집합을 열거하는 타입 기능, 숫자형과 문자열형 지원, 컴파일 시 양방향 매핑이 생김</li><li>const enum enum을 inline하는 형태, 사용처에 값이 치환되어 구현 코드가 제거되는 특성</li><li>as const const assertion 문법, 값의 리터럴 타입화와 readonly 부여로 상수성 보장</li></ul><p>여기서 가장 큰 차이는 컴파일 결과와 타입 추론 방식임
enum은 런타임에 역매핑 테이블이 남는 반면, const enum은 값이 사용 지점에 치환되고 테이블이 남지 않음
as const는 타입 시스템에서 값의 범위를 리터럴로 좁히고, 객체의 경우 프로퍼티를 readonly로 고정함</p><h3 id=enum-동작-원리와-구조>enum 동작 원리와 구조<a hidden class=anchor aria-hidden=true href=#enum-동작-원리와-구조>#</a></h3><ul><li><p>멤버 종류 상수 멤버와 계산된 멤버로 구분됨</p><ul><li>상수 멤버 컴파일 타임에 확정 가능한 값</li><li>계산된 멤버 표현식을 평가해야 정해지는 값, const enum에서는 허용되지 않음</li></ul></li><li><p>값 타입별 분류</p><ul><li>숫자형 enum 기본값 0부터 1씩 자동 증가, 역매핑 지원</li><li>문자열형 enum 문자열 상수 부여, 역매핑은 키에서 값 방향만 성립</li><li>혼합형 enum 숫자와 문자열 혼재, 특별한 이유가 없다면 권장하지 않음</li></ul></li><li><p>자동 할당 규칙</p><ul><li>첫 멤버 초기화가 없으면 0 할당</li><li>직전 멤버가 숫자 상수면 다음 멤버는 +1 증가 값 부여</li></ul></li><li><p>양방향 매핑</p><ul><li>숫자형 enum은 키→값과 값→키 모두 접근 가능</li><li>런타임 객체로 역참조가 가능해 디버깅에는 편하지만 코드가 늘어나고 tree-shaking에 불리함</li></ul></li><li><p>제약</p><ul><li>멤버 이름은 숫자 식별자 불가</li><li>라이브러리 배포 시 번들 크기 영향 고려 필요</li></ul></li></ul><h3 id=enum의-장단점>enum의 장단점<a hidden class=anchor aria-hidden=true href=#enum의-장단점>#</a></h3><p>장점</p><ul><li>의도 표현력이 좋음 열거형이라는 도메인 모델을 바로 드러냄</li><li>안전성 향상 지정한 값 집합만 허용되는 형태로 오입력 방지에 유리함</li><li>숫자형의 역매핑이 디버깅과 로그 판독에 편리</li></ul><p>단점</p><ul><li>코드 팽창 즉시 실행 패턴과 역매핑 테이블로 번들 크기 증가 가능성</li><li>tree-shaking에 불리 선언만 해도 구현 코드가 남아 죽은 코드 제거가 어려움</li><li>문자열형만 필요할 때도 런타임 테이블을 유지해야 하는 비용 발생</li></ul><h3 id=const-enum의-목적과-제약>const enum의 목적과 제약<a hidden class=anchor aria-hidden=true href=#const-enum의-목적과-제약>#</a></h3><p>목적</p><ul><li>enum 접근 비용과 추가 생성 코드를 제거하여 가벼운 산출물 확보</li><li>사용 지점에 값이 inlined되어 역참조 테이블 자체를 만들지 않음</li></ul><p>제약과 주의</p><ul><li>계산된 멤버 금지 상수 표현식만 허용</li><li>툴체인 호환성 이슈 빈번 Babel 등 타입 지우기 전용 트랜스파일러는 const enum을 지원하지 않거나 그대로 통과시키는 경우가 있어 런타임 에러 유발 위험 존재</li><li>isolatedModules 옵션 사용 시 모듈 단일 변환 제약으로 const enum이 막히거나 preserveConstEnums 설정과 충돌 가능성</li><li>라이브러리 배포 시 소비자 환경에 따라 의미가 달라질 수 있음 선언 파일 d.ts에 const enum을 노출하면 소비자 컴파일러 설정과 상호작용이 필요해 파편화 가능성 발생</li></ul><p>요약하면, const enum은 산출물 최적화에 유리하지만, 빌드 파이프라인과 배포 경로가 단순하지 않으면 리스크가 큼</p><h3 id=as-const의-의도와-효과>as const의 의도와 효과<a hidden class=anchor aria-hidden=true href=#as-const의-의도와-효과>#</a></h3><p>의도</p><ul><li>값의 리터럴 타입화와 readonly 부여를 통해 상수성을 보장하고 타입 좁히기 수행</li><li>객체 키를 통한 값 집합 설계 후 해당 값들의 유니온 타입을 간단히 얻을 수 있음</li></ul><p>효과</p><ul><li>값 그 자체가 타입으로 추론됨 문자열은 문자열 리터럴 타입, 숫자는 숫자 리터럴 타입으로 고정</li><li>객체 단위 as const는 모든 프로퍼티를 readonly로 바꾸어 재할당 차단</li><li>런타임 오버헤드 없음 단순한 객체와 배열 그대로 유지되어 tree-shaking에도 유리</li></ul><p>실무 포인트</p><ul><li>enum의 역매핑이 꼭 필요하지 않다면 as const 기반의 객체 열거가 가장 무난</li><li>선언과 타입 획득을 분리해 재사용성과 트리셰이킹을 확보 가능</li></ul><h3 id=최소-예시-스니펫>최소 예시 스니펫<a hidden class=anchor aria-hidden=true href=#최소-예시-스니펫>#</a></h3><p>스니펫 1 숫자형 enum의 역매핑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Direction</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Up</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Down</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Direction</span>.<span style=color:#a6e22e>Up</span>        <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Direction</span>[<span style=color:#ae81ff>0</span>]        <span style=color:#75715e>// &#39;Up&#39;
</span></span></span></code></pre></div><p>스니펫 2 as const로 값 유니온 타입 얻기</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Ready</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ready&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Done</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;done&#39;</span>,
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>Status</span>[<span style=color:#66d9ef>keyof</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>Status</span>]  <span style=color:#75715e>// &#39;ready&#39; | &#39;done&#39;
</span></span></span></code></pre></div><p>위 두 가지로 enum의 역매핑 유무와 as const의 리터럴 타입화를 직관적으로 비교 가능</p><h3 id=discriminated-union과-as-const>Discriminated Union과 as const<a hidden class=anchor aria-hidden=true href=#discriminated-union과-as-const>#</a></h3><p>상태를 안전하게 분기하려면 판별 가능한 공통 필드를 두는 것이 핵심</p><ul><li>공통 필드 kind 같은 것을 문자열 리터럴로 고정</li><li>각 변형에 고유 속성을 부여하고 분기 시 kind로 좁히기</li><li>이때 as const로 kind 값을 리터럴 타입으로 확정하면 분기 안전성이 올라감</li></ul><p>Discriminated Union은 넓은 유니온 타입에서 특정 필드의 리터럴 값 비교로 타입 가드를 자동 유도함
리터럴 타입화가 불완전하면 존재할 수도 없을 수도 있는 속성으로 판단해 접근 시 에러가 날 수 있음
as const를 적용해 판별 키를 리터럴로 고정하면 분기 후 속성 접근이 안전해짐</p><h3 id=const-enum의-함정-정리>const enum의 함정 정리<a hidden class=anchor aria-hidden=true href=#const-enum의-함정-정리>#</a></h3><ul><li>Babel 트랜스파일 TypeScript 구문 제거 위주로 동작하여 const enum을 컴파일하지 않음 결과적으로 사용 지점에서 값이 남지 않고 식별자 자체가 유지되어 런타임 에러 가능</li><li>SWC 등 대체 트랜스파일러 사용 시에도 설정 차이에 따라 const enum이 보존되거나 잘못 처리될 수 있음</li><li>tsconfig의 isolatedModules가 켜진 환경에서는 모듈 단위 변환 제약으로 const enum 사용이 제한되거나 preserveConstEnums와 상충 가능</li><li>라이브러리 d.ts에 const enum을 노출하면 소비자 빌드가 동일한 규칙으로 inlining해야 하므로 빌드 파이프라인 결속이 필요해짐</li></ul><p>이런 리스크로 인해 팀 규칙으로 const enum 금지, as const 권장으로 정하는 경우가 많음</p><h3 id=선택-가이드라인>선택 가이드라인<a hidden class=anchor aria-hidden=true href=#선택-가이드라인>#</a></h3><p>다음 체크리스트로 결정</p><ul><li><p>역매핑이 꼭 필요함 숫자값에서 이름을 역으로 알아야 하는 요구가 명확함</p><ul><li>예 바이너리 프로토콜 디버깅에서 숫자코드를 사람 읽는 문자열로 즉시 확인 필요</li><li>선택 enum 고려</li></ul></li><li><p>번들 크기와 tree-shaking이 중요함 런타임 테이블 생성 비용을 피하고 싶음</p><ul><li>선택 as const 기반 객체 열거 권장</li></ul></li><li><p>빌드 파이프라인이 단순함 tsc 단독 빌드, const enum을 안전하게 inline 가능하다고 확신함</p><ul><li>선택 const enum 사용 가능하나 팀 규칙으로 명시하고 도구 호환성 테스트 필수</li></ul></li><li><p>라이브러리 배포 소비자 환경 다양, 선언 파일 안정성이 최우선</p><ul><li>선택 const enum 지양, as const + 타입 유니온 익스포트 권장</li></ul></li><li><p>값 집합을 타입으로 바로 얻고 싶음, 리터럴 타입화와 readonly가 필요함</p><ul><li>선택 as const로 객체를 선언하고 typeof와 keyof 조합으로 유니온 타입 획득</li></ul></li></ul><h3 id=베스트-프랙티스>베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#베스트-프랙티스>#</a></h3><ul><li>팀 규칙 정의 enum은 역매핑이 실질적 이득을 줄 때에만 사용, 기본값은 as const</li><li>빌드 파이프라인 점검 Babel 사용 시 const enum 금지, tsc emit 환경에서만 제한적 허용</li><li>선언과 타입 분리 as const 객체를 런타임 값으로 노출하고, 타입은 typeof와 keyof로 파생</li><li>문자열형만 필요한 경우 enum 대신 문자열 리터럴 유니온 또는 as const 객체 사용</li><li>공개 API의 안정성 확보 라이브러리 환경에서는 상수 집합을 값과 타입으로 동시에 노출하되 const enum 회피</li><li>자동 증가 규칙에 의존하지 않기 enum 숫자값이 외부 계약이라면 명시적으로 값 지정</li></ul><h3 id=트레이드오프-요약>트레이드오프 요약<a hidden class=anchor aria-hidden=true href=#트레이드오프-요약>#</a></h3><ul><li>enum 의도 표현력과 역매핑 편의 제공, 대신 런타임 테이블과 번들 팽창 감수</li><li>const enum 매우 가벼운 산출물 확보, 대신 빌드 호환성 리스크와 계산된 멤버 제한 수용</li><li>as const 타입 안전과 tree-shaking 친화성 확보, 대신 역매핑 등 런타임 편의는 직접 구현 필요</li></ul><p>실무 기본값은 as const, 명확한 필요가 있을 때만 enum, const enum은 파이프라인이 보장될 때 선택</p><h3 id=참고로-알아두면-좋은-설정과-패턴>참고로 알아두면 좋은 설정과 패턴<a hidden class=anchor aria-hidden=true href=#참고로-알아두면-좋은-설정과-패턴>#</a></h3><ul><li>tsconfig preserveConstEnums true로 두면 const enum을 제거하지 않고 남김 라이브러리 소비자 측에서 inlining을 기대하는 형태가 되어 호환성 이슈가 더 커질 수 있음</li><li>tsconfig isolatedModules 각 파일을 독립적으로 변환하므로 const enum 사용이 제한되는 경우가 있음</li><li>Discriminated Union의 판별 키는 문자열 리터럴 타입으로 고정 as const 적극 활용</li><li>값에서 타입 뽑기 패턴 typeof Obj[keyof typeof Obj] 조합으로 값 유니온 타입 생성</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>양방향 매핑이 기능 요구사항에 포함되어 있는지, 빌드 파이프라인이 const enum을 안전하게 처리하는지, 번들 크기 최적화의 우선순위가 높은지부터 판단하면 선택이 단순해짐
대부분의 프런트엔드와 서버 사이드 TypeScript 코드에서는 as const 기반 상수 객체와 리터럴 유니온이 안전하고 유지보수 친화적임
역매핑이 명백한 가치를 제공할 때만 enum을 채택하고, const enum은 도구 체인이 이를 보장할 때 제한적으로 사용함
목적에 맞춘 선택이 코드의 명료성과 산출물 품질을 동시에 끌어올림</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.typescriptlang.org/docs/handbook/enums.html>https://www.typescriptlang.org/docs/handbook/enums.html</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums>https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#enums</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions>https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions>https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions</a></li><li><a href=https://www.typescriptlang.org/tsconfig#preserveConstEnums>https://www.typescriptlang.org/tsconfig#preserveConstEnums</a></li><li><a href=https://www.typescriptlang.org/tsconfig#isolatedModules>https://www.typescriptlang.org/tsconfig#isolatedModules</a></li><li><a href=https://babeljs.io/docs/babel-plugin-transform-typescript>https://babeljs.io/docs/babel-plugin-transform-typescript</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/typescript/>Typescript</a></li><li><a href=https://handsupmin.github.io/tags/enum/>Enum</a></li><li><a href=https://handsupmin.github.io/tags/const-enum/>Const-Enum</a></li><li><a href=https://handsupmin.github.io/tags/as-const/>As-Const</a></li><li><a href=https://handsupmin.github.io/tags/literal-types/>Literal-Types</a></li><li><a href=https://handsupmin.github.io/tags/discriminated-union/>Discriminated-Union</a></li><li><a href=https://handsupmin.github.io/tags/type-inference/>Type-Inference</a></li><li><a href=https://handsupmin.github.io/tags/tree-shaking/>Tree-Shaking</a></li><li><a href=https://handsupmin.github.io/tags/build-tooling/>Build-Tooling</a></li></ul><nav class=paginav><a class=next href=https://handsupmin.github.io/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/><span class=title>Next »</span><br><span>블록체인 인덱서 가이드</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on x" href="https://x.com/intent/tweet/?text=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f&amp;hashtags=typescript%2cenum%2cconst-enum%2cas-const%2cliteral-types%2cdiscriminated-union%2ctype-inference%2ctree-shaking%2cbuild-tooling"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f&amp;title=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;summary=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;source=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f&title=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on whatsapp" href="https://api.whatsapp.com/send?text=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c%20-%20https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on telegram" href="https://telegram.me/share/url?text=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript enum, const enum, as const의 차이와 선택 가이드 on ycombinator" href="https://news.ycombinator.com/submitlink?t=TypeScript%20enum%2c%20const%20enum%2c%20as%20const%ec%9d%98%20%ec%b0%a8%ec%9d%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b0%80%ec%9d%b4%eb%93%9c&u=https%3a%2f%2fhandsupmin.github.io%2fposts%2ftypescript-enum-const-enum-as-const-guide-3817af%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>