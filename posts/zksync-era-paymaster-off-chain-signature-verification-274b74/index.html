<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>오프체인 서명 검증 페이마스터 (in ZkSync Era) | HandsLog</title>
<meta name=keywords content="zksync,paymaster,eip-712,off-chain-signature,solidity,ethersjs"><meta name=description content="
주의

아래는 “핵심 동작만 이해할 수 있는” 부분 스니펫과 설명임.
실제 배포 전에는 보안 리뷰·테스트 필수.


개요
오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 가스비 대납(paymaster) 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. ZkSync Era 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.

문제 정의 & 설계 의도
내가 당면한 문제

가스비 대납 필요함
제한된 대상만 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함)
가스 낭비/잔고 소진 리스크 최소화해야 함 (악용·오구성·스팸 대비)

단순 대안(toAddressPaymaster)에서 드러난 한계


신규 유저 온보딩 흐름과 충돌"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="오프체인 서명 검증 페이마스터 (in ZkSync Era)"><meta property="og:description" content=" 주의
아래는 “핵심 동작만 이해할 수 있는” 부분 스니펫과 설명임. 실제 배포 전에는 보안 리뷰·테스트 필수. 개요 오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 가스비 대납(paymaster) 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. ZkSync Era 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.
문제 정의 & 설계 의도 내가 당면한 문제 가스비 대납 필요함 제한된 대상만 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함) 가스 낭비/잔고 소진 리스크 최소화해야 함 (악용·오구성·스팸 대비) 단순 대안(toAddressPaymaster)에서 드러난 한계 신규 유저 온보딩 흐름과 충돌"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-21T02:14:08+00:00"><meta property="article:modified_time" content="2025-09-21T02:14:08+00:00"><meta property="article:tag" content="Zksync"><meta property="article:tag" content="Paymaster"><meta property="article:tag" content="Eip-712"><meta property="article:tag" content="Off-Chain-Signature"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Ethersjs"><meta name=twitter:card content="summary"><meta name=twitter:title content="오프체인 서명 검증 페이마스터 (in ZkSync Era)"><meta name=twitter:description content="
주의

아래는 “핵심 동작만 이해할 수 있는” 부분 스니펫과 설명임.
실제 배포 전에는 보안 리뷰·테스트 필수.


개요
오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 가스비 대납(paymaster) 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. ZkSync Era 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.

문제 정의 & 설계 의도
내가 당면한 문제

가스비 대납 필요함
제한된 대상만 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함)
가스 낭비/잔고 소진 리스크 최소화해야 함 (악용·오구성·스팸 대비)

단순 대안(toAddressPaymaster)에서 드러난 한계


신규 유저 온보딩 흐름과 충돌"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"오프체인 서명 검증 페이마스터 (in ZkSync Era)","item":"https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"오프체인 서명 검증 페이마스터 (in ZkSync Era)","name":"오프체인 서명 검증 페이마스터 (in ZkSync Era)","description":" 주의\n아래는 “핵심 동작만 이해할 수 있는” 부분 스니펫과 설명임. 실제 배포 전에는 보안 리뷰·테스트 필수. 개요 오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 가스비 대납(paymaster) 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. ZkSync Era 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.\n문제 정의 \u0026amp; 설계 의도 내가 당면한 문제 가스비 대납 필요함 제한된 대상만 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함) 가스 낭비/잔고 소진 리스크 최소화해야 함 (악용·오구성·스팸 대비) 단순 대안(toAddressPaymaster)에서 드러난 한계 신규 유저 온보딩 흐름과 충돌\n","keywords":["zksync","paymaster","eip-712","off-chain-signature","solidity","ethersjs"],"articleBody":" 주의\n아래는 “핵심 동작만 이해할 수 있는” 부분 스니펫과 설명임. 실제 배포 전에는 보안 리뷰·테스트 필수. 개요 오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 가스비 대납(paymaster) 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. ZkSync Era 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.\n문제 정의 \u0026 설계 의도 내가 당면한 문제 가스비 대납 필요함 제한된 대상만 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함) 가스 낭비/잔고 소진 리스크 최소화해야 함 (악용·오구성·스팸 대비) 단순 대안(toAddressPaymaster)에서 드러난 한계 신규 유저 온보딩 흐름과 충돌\n신규 유저는 AccountFactory.deployAccount로 AA 지갑을 생성 이 시점 트랜잭션의 to가 AccountFactory가 됨 toAddressPaymaster에 AccountFactory를 넣으면 누구나 지갑 생성에 공용 페이마스터 사용 가능해짐 → 권한 통제 실패 잔고 소진 위험\n단순 to 기반 허용은 요청의 가스 상한·가격·의도를 검증하지 않음 과도한 gasLimit/maxFeePerGas로 반복 호출 시 잔고 드레인 위험 정상 시나리오에서도 “과대 추정”이 누적되면 비용 누수 채택한 방향: Signature‑based Paymaster 오프체인 서명으로 누가, 언제까지, 어떤 한도 안에서 사용할지 정밀 승인 온체인에서는 EIP‑712로 도메인 바인딩 + 서명 검증 → 메시지 변조·체인 전이 재사용 방지 승인 실패 시 fail‑closed (대납 거절이 기본값) 설계 원칙\n최소 권한(least privilege): 서명 스코프를 유저·만료·가스 한도에 바인딩 결정론적 검증: 온·오프체인 해시/도메인 구성 완전 일치 비용 상한: 과다 가스 청구 차단(정책적으로 상한 검증/캡핑 고려) 운영성: 키 롤오버/킬스위치/관측성 내장 핵심 아이디어 EIP‑712로 구조화 데이터(user, 만료, 가스 파라미터)를 서명 페이마스터가 도메인 분리자 + 타입 해시로 서명 검증 검증 성공 시 부트로더에 필요한 가스비 전송 컨트랙트 스니펫 1) 타입 해시 정의 // 타입명·필드 순서·타입은 서버/클라이언트와 **완전 일치**해야 함 // 문자열 내부의 공백, 콤마 위치까지 동일해야 함 bytes32 constant SIGNED_GAS_REQUEST_TYPEHASH = keccak256(\"SignedGasRequest(address user,uint256 expiry,uint256 gasLimit,uint256 gasPrice)\"); 2) EIP‑712 도메인 \u0026 서명자 보관 contract SignedGasPaymaster is IPaymaster, EIP712 /* ... */ { address public signer; // 서버 서명키의 공개주소 constructor(address _signer) EIP712(\"SignedGasPaymaster\", \"1\") // 도메인 name, version { require(_signer != address(0), \"invalid signer\"); signer = _signer; } modifier onlyBootloader() { require(msg.sender == BOOTLOADER_FORMAL_ADDRESS, \"only bootloader\"); _; } // ... } 3) 검증 코어 (validate 흐름 일부) // validateAndPayForPaymasterTransaction(...) 내부 일부 bytes4 sel = bytes4(_transaction.paymasterInput[0:4]); if (sel == IPaymasterFlow.general.selector) { bytes memory inner = abi.decode(_transaction.paymasterInput[4:], (bytes)); (uint256 expiry, uint256 recGasLimit, uint256 recGasPrice, bytes memory sig) = abi.decode(inner, (uint256, uint256, uint256, bytes)); require(block.timestamp \u003c= expiry, \"expired\"); address user = address(uint160(_transaction.from)); bytes32 structHash = keccak256(abi.encode( SIGNED_GAS_REQUEST_TYPEHASH, user, expiry, recGasLimit, recGasPrice )); bytes32 digest = _hashTypedDataV4(structHash); require(digest.recover(sig) == signer, \"invalid signer\"); // 예시: 필요 가스비 계산 후 부트로더로 전송 uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas; (bool ok, ) = payable(BOOTLOADER_FORMAL_ADDRESS).call{value: requiredETH}(\"\"); require(ok, \"fee transfer failed\"); } else { revert(\"unsupported flow\"); } 포인트\n타입 문자열·필드 순서 불일치 → 즉시 실패 _hashTypedDataV4로 도메인 결합 → 타 체인/계약 재사용 불가 recover(sig) == signer 여야 통과 정책 강화를 위해 (_transaction.gasLimit ≤ recGasLimit) 등 상한 검증 추가 고려 (아래 참조) 서버 스니펫 // Ethers v5 기준 예시 const domain = { name: \"SignedGasPaymaster\", version: \"1\", chainId, verifyingContract: PAYMASTER_ADDRESS, }; const types = { SignedGasRequest: [ { name: \"user\", type: \"address\" }, { name: \"expiry\", type: \"uint256\" }, { name: \"gasLimit\", type: \"uint256\" }, { name: \"gasPrice\", type: \"uint256\" }, ], }; const value = { user, expiry, // 짧게 (예: +120초) gasLimit: recGasLimit, // 추정 + 버퍼 gasPrice: recGasPrice, // fee data 반영 }; const signature = await signer._signTypedData(domain, types, value); // paymasterInput = selector(IPaymasterFlow.general) || abi.encode(expiry, recGasLimit, recGasPrice, signature) 포인트\n도메인(name/version/chainId/verifyingContract) 1:1 일치 만료(expiry) 짧게 → 리플레이 윈도우 축소 서버가 반환하는 추천 가스 값은 온체인에서 상한 검증/캡핑에 사용 가능 클라이언트 스니펫 // 서버 응답: { paymasterInput, recGasLimit, recGasPrice } const tx = await wallet.sendTransaction({ to: targetContract, data: calldata, gasLimit: recGasLimit, maxFeePerGas: recGasPrice, customData: { paymasterParams: { paymaster: PAYMASTER_ADDRESS, paymasterInput, }, }, }); 왜 toAddressPaymaster 가 안 맞았나 (대안 검토 \u0026 탈락 사유) 대안 장점 치명적 단점(탈락 근거) 단순 toAddressPaymaster 구현 단순 (1) 신규 유저 지갑 생성 시 to = AccountFactory → 공용 대납화(2) 가스 한도·가격 검증 부재 → 잔고 드레인 리스크 to 화이트리스트 + IP 제한 진입 장벽 소폭 상승 체인 레벨에서 의도/파라미터 미바인딩. 프록시/재전송/버스트 트래픽에 취약 온체인 사용자 allowlist 권한 명시적 온체인 상태·거버넌스 비용↑, 롤오버·철회 지연. 신규 유저 온보딩 UX 저하 오프체인 서명 기반(채택) 유저·만료·가스 바인딩, 도메인 분리로 재사용 차단, fail‑closed 서명 인프라·키 보관·관측성 구축 필요 (운영으로 해결) 위협 모델 \u0026 방어 전략 무단 사용(공개 대납 유도) → 서명 필요: 서명자 키 없는 제3자는 사용 불가 리플레이 공격(같은 서명 재사용) → 짧은 만료 + 필요 시 per‑user nonce 체인/계약 전이 재사용 → EIP‑712 도메인 분리자 (name/version/chainId/contract) 가스 과청구/과다 버퍼 → 추천 가스 상한 바인딩: tx.gasLimit ≤ recGasLimit, tx.maxFeePerGas ≤ recGasPrice 검증(정책 옵션) 파라미터 변조 → 타입드 데이터 해시 재계산으로 무결성 보장 서명키 유출 → KMS/HSM·킬스위치·키 롤오버, changeSigner 절차 부트로더 스푸핑 → onlyBootloader 가드 잔액 고갈 → 예산 캡/레이트 리미트/대납 중단 스위치 운영 드리프트(클라/서버/체인 도메인 불일치) → 도메인 구성에 대한 CI 테스트 \u0026 캐너리 “Off‑chain Signature Verification” 빠르게 이해하기 오프체인(서버)에서 타입드 데이터에 서명 → 온체인에서 도메인 분리자를 포함해 동일 구조로 해시 재생성 → recover()로 서명자 주소 복원 → 저장된 signer와 매칭되면 승인 멀티시그와 달리 단일 승인자(서버 키) 기준 정책 실행 오라클 서명과 유사하나, 가스 대납 승인이라는 도메인에 특화 서버에서 서명한 걸 컨트랙트에서 어떻게 검증하는가? 입력 디코딩 → 파라미터 추출 (expiry, recGasLimit, recGasPrice, signature, user = tx.from) 동일 타입·필드로 struct hash 생성 → _hashTypedDataV4로 도메인 결합 digest.recover(signature) == 저장된 signer 확인 정책 옵션: tx.gasLimit/maxFeePerGas가 추천 상한 이내인지 검사 _hashTypedDataV4는 상속한 EIP712가 생성자에서 설정한 name/version + chainId + contract로 도메인 분리자를 내부 계산함. 클라이언트/서버는 동일 도메인 구성을 사용해야 함.\n“서명된 데이터”와 “실제 파라미터”가 같은지 어떻게 보장함? 컨트랙트가 전달받은 파라미터로 동일한 구조체 해시를 다시 만들고, 그 해시로 서명자 복원 입력이 한 비트라도 바뀌면 해시가 달라져 복원 주소가 달라짐 → 검증 실패 따라서 서명자 확인과 메시지 무결성을 동시에 보장 운영·보안 설계 키 관리: HSM/KMS, 키 롤오버(이중 서명 전환 기간), 유출 시 즉시 changeSigner + 킬스위치 예산·레이트: 일일/시간당 대납 예산, per‑user 레이트 리미트, 버스트 감지 시 자동 중단 관측성: 승인/거절 사유 코드, 만료/가스상한 위반 카운트, 부트로더 송금 실패 알람 정책 구성: gasLimit/maxFeePerGas 상한 정책, 메서드 스코프 바인딩(옵션: to/selector/calldataHash를 타입드 데이터에 포함) 디그레이드 전략: 대납 실패 시 사용자 지불로 폴백, UX 메시지 일관화 테스트 전략 타입/도메인 동치성 테스트: 서버·클라·컨트랙트 EIP‑712 도메인/타입 문자열 스냅샷 비교 경계값: 만료 임계(±1s), 가스 상한 초과/동일/미만, fee data 드리프트 리플레이: 동일 서명 다중 제출, 체인ID 변경, 컨트랙트 주소 변경 부정 시나리오: signer 위조, 타입 문자열 공백/쉼표 오염, 인코딩 순서 변경 퍼포먼스: 검증 가스 오버헤드 측정(서명 길이/경로에 따른 차이), 부트로더 송금 실패 복구 결과 권한 있는 요청만 대납: 승인 스코프가 유저·시간·가스로 좁혀짐 공격 면 축소: to 기반 공개 대납 제거, 체인/계약 재사용·리플레이 차단 운영 제어 가능: 예산/레이트/킬스위치로 실시간 리스크 컨트롤 확장성: 필요 시 타입드 데이터에 to/selector/nonce/budgetId 등 추가해 정책 세분화 가능 트러블슈팅 포인트 타입 문자열 불일치: 글자/공백/쉼표 하나 차이로 실패 (SignedGasRequest 철자, 필드 순서) 도메인 값 불일치: name/version/chainId/verifyingContract 중 하나라도 다르면 실패 만료 초과: 서버·노드 시간차 → 만료는 짧되 소폭 여유 가스 괴리: 서버 추천과 실제 트랜잭션 값 차이 → 상한 검증/캡핑 정책 도입 부트로더 외 호출: onlyBootloader 누락 시 보안 취약 참고자료 OpenZeppelin EIP‑712: 도메인/해시/서명 유틸 ethers.js _signTypedData: 타입드 데이터 서명 ZkSync Era Paymaster 가이드 \u0026 zksync‑contracts 인터페이스 문서 (최신 동작은 공식 문서/레포 확인 권장) 마무리 핵심은 문제 정의 → 위협 모델링 → 정책 바인딩(유저·시간·가스) → 도메인 분리자 적용 → 운영 가드레일의 일관된 흐름임. 단순 to 기반 허용으로는 신규 온보딩/남용/드레인을 막기 어려움. 오프체인 서명 기반은 승인 스코프를 정밀하게 바인딩하고, 실패 시 기본 거절하는 fail‑closed 아키텍처를 제공함. 스니펫만으로 동작 원리를 이해할 수 있으며, 실제 적용 시에는 상한 검증·메서드 스코프·nonce·관측성 등 정책을 추가해 운영 등급으로 끌어올릴 수 있음.\n","wordCount":"1189","inLanguage":"en","datePublished":"2025-09-21T02:14:08.087Z","dateModified":"2025-09-21T02:14:08.087Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">오프체인 서명 검증 페이마스터 (in ZkSync Era)</h1><div class=post-meta><span title='2025-09-21 02:14:08.087 +0000 UTC'>September 21, 2025</span></div></header><div class=post-content><blockquote><p><strong>주의</strong></p><ul><li>아래는 “핵심 동작만 이해할 수 있는” <strong>부분 스니펫</strong>과 설명임.</li><li>실제 배포 전에는 보안 리뷰·테스트 필수.</li></ul></blockquote><hr><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p>오프체인에서 생성한 EIP‑712 서명을 온체인에서 검증해 <strong>가스비 대납(paymaster)</strong> 을 구현함. 메타트랜잭션·가스리스 UX 제공 목적. <strong>ZkSync Era</strong> 환경 기준으로 컨트랙트/서버/클라이언트 최소 구성과 운영·보안 포인트를 정리함.</p><hr><h2 id=문제-정의--설계-의도>문제 정의 & 설계 의도<a hidden class=anchor aria-hidden=true href=#문제-정의--설계-의도>#</a></h2><h3 id=내가-당면한-문제>내가 당면한 문제<a hidden class=anchor aria-hidden=true href=#내가-당면한-문제>#</a></h3><ul><li><strong>가스비 대납</strong> 필요함</li><li><strong>제한된 대상만</strong> 사용 가능해야 함 (우리 서비스 내에서만 사용 가능해야함)</li><li><strong>가스 낭비/잔고 소진</strong> 리스크 최소화해야 함 (악용·오구성·스팸 대비)</li></ul><h3 id=단순-대안toaddresspaymaster에서-드러난-한계>단순 대안(toAddressPaymaster)에서 드러난 한계<a hidden class=anchor aria-hidden=true href=#단순-대안toaddresspaymaster에서-드러난-한계>#</a></h3><ol><li><p><strong>신규 유저 온보딩 흐름과 충돌</strong></p><ul><li>신규 유저는 <code>AccountFactory.deployAccount</code>로 AA 지갑을 생성</li><li>이 시점 트랜잭션의 <code>to</code>가 <strong>AccountFactory</strong>가 됨</li><li><code>toAddressPaymaster</code>에 <code>AccountFactory</code>를 넣으면 <strong>누구나</strong> 지갑 생성에 공용 페이마스터 사용 가능해짐 → <strong>권한 통제 실패</strong></li></ul></li><li><p><strong>잔고 소진 위험</strong></p><ul><li>단순 <code>to</code> 기반 허용은 <strong>요청의 가스 상한·가격·의도</strong>를 검증하지 않음</li><li>과도한 <code>gasLimit/maxFeePerGas</code>로 반복 호출 시 <strong>잔고 드레인</strong> 위험</li><li>정상 시나리오에서도 “과대 추정”이 누적되면 <strong>비용 누수</strong></li></ul></li></ol><h3 id=채택한-방향-signaturebased-paymaster>채택한 방향: <strong>Signature‑based Paymaster</strong><a hidden class=anchor aria-hidden=true href=#채택한-방향-signaturebased-paymaster>#</a></h3><ul><li><strong>오프체인 서명</strong>으로 <em>누가</em>, <em>언제까지</em>, <em>어떤 한도 안에서</em> 사용할지 <strong>정밀 승인</strong></li><li>온체인에서는 EIP‑712로 <strong>도메인 바인딩</strong> + <strong>서명 검증</strong> → 메시지 변조·체인 전이 재사용 방지</li><li>승인 실패 시 <strong>fail‑closed</strong> (대납 거절이 기본값)</li></ul><blockquote><p><strong>설계 원칙</strong></p><ul><li>최소 권한(least privilege): 서명 스코프를 <strong>유저·만료·가스 한도</strong>에 바인딩</li><li>결정론적 검증: 온·오프체인 해시/도메인 구성 <strong>완전 일치</strong></li><li>비용 상한: 과다 가스 청구 차단(정책적으로 상한 검증/캡핑 고려)</li><li>운영성: 키 롤오버/킬스위치/관측성 내장</li></ul></blockquote><hr><h2 id=핵심-아이디어>핵심 아이디어<a hidden class=anchor aria-hidden=true href=#핵심-아이디어>#</a></h2><ul><li>EIP‑712로 <strong>구조화 데이터</strong>(user, 만료, 가스 파라미터)를 서명</li><li>페이마스터가 <strong>도메인 분리자</strong> + <strong>타입 해시</strong>로 서명 검증</li><li>검증 성공 시 부트로더에 필요한 가스비 전송</li></ul><hr><h2 id=컨트랙트-스니펫>컨트랙트 스니펫<a hidden class=anchor aria-hidden=true href=#컨트랙트-스니펫>#</a></h2><h3 id=1-타입-해시-정의>1) 타입 해시 정의<a hidden class=anchor aria-hidden=true href=#1-타입-해시-정의>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// 타입명·필드 순서·타입은 서버/클라이언트와 **완전 일치**해야 함
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 문자열 내부의 공백, 콤마 위치까지 동일해야 함
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bytes32</span> <span style=color:#66d9ef>constant</span> SIGNED_GAS_REQUEST_TYPEHASH <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    keccak256(<span style=color:#e6db74>&#34;SignedGasRequest(address user,uint256 expiry,uint256 gasLimit,uint256 gasPrice)&#34;</span>);
</span></span></code></pre></div><h3 id=2-eip712-도메인--서명자-보관>2) EIP‑712 도메인 & 서명자 보관<a hidden class=anchor aria-hidden=true href=#2-eip712-도메인--서명자-보관>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>SignedGasPaymaster</span> <span style=color:#66d9ef>is</span> IPaymaster, EIP712 <span style=color:#75715e>/* ... */</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> signer; <span style=color:#75715e>// 서버 서명키의 공개주소
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>address</span> _signer)
</span></span><span style=display:flex><span>        EIP712(<span style=color:#e6db74>&#34;SignedGasPaymaster&#34;</span>, <span style=color:#e6db74>&#34;1&#34;</span>) <span style=color:#75715e>// 도메인 name, version
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        require(_signer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>address</span>(<span style=color:#ae81ff>0</span>), <span style=color:#e6db74>&#34;invalid signer&#34;</span>);
</span></span><span style=display:flex><span>        signer <span style=color:#f92672>=</span> _signer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>modifier</span> <span style=color:#a6e22e>onlyBootloader</span>() {
</span></span><span style=display:flex><span>        require(msg.sender <span style=color:#f92672>==</span> BOOTLOADER_FORMAL_ADDRESS, <span style=color:#e6db74>&#34;only bootloader&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>_</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=3-검증-코어-validate-흐름-일부>3) 검증 코어 (validate 흐름 일부)<a hidden class=anchor aria-hidden=true href=#3-검증-코어-validate-흐름-일부>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// validateAndPayForPaymasterTransaction(...) 내부 일부
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bytes4</span> sel <span style=color:#f92672>=</span> <span style=color:#66d9ef>bytes4</span>(_transaction.paymasterInput[<span style=color:#ae81ff>0</span><span style=color:#f92672>:</span><span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (sel <span style=color:#f92672>==</span> IPaymasterFlow.general.selector) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> inner <span style=color:#f92672>=</span> abi.decode(_transaction.paymasterInput[<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span>], (<span style=color:#66d9ef>bytes</span>));
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>uint256</span> expiry, <span style=color:#66d9ef>uint256</span> recGasLimit, <span style=color:#66d9ef>uint256</span> recGasPrice, <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> sig) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        abi.decode(inner, (<span style=color:#66d9ef>uint256</span>, <span style=color:#66d9ef>uint256</span>, <span style=color:#66d9ef>uint256</span>, <span style=color:#66d9ef>bytes</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    require(block.timestamp <span style=color:#f92672>&lt;=</span> expiry, <span style=color:#e6db74>&#34;expired&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> user <span style=color:#f92672>=</span> <span style=color:#66d9ef>address</span>(<span style=color:#66d9ef>uint160</span>(_transaction.<span style=color:#66d9ef>from</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bytes32</span> structHash <span style=color:#f92672>=</span> keccak256(abi.encode(
</span></span><span style=display:flex><span>        SIGNED_GAS_REQUEST_TYPEHASH,
</span></span><span style=display:flex><span>        user,
</span></span><span style=display:flex><span>        expiry,
</span></span><span style=display:flex><span>        recGasLimit,
</span></span><span style=display:flex><span>        recGasPrice
</span></span><span style=display:flex><span>    ));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bytes32</span> digest <span style=color:#f92672>=</span> _hashTypedDataV4(structHash);
</span></span><span style=display:flex><span>    require(digest.recover(sig) <span style=color:#f92672>==</span> signer, <span style=color:#e6db74>&#34;invalid signer&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 예시: 필요 가스비 계산 후 부트로더로 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint256</span> requiredETH <span style=color:#f92672>=</span> _transaction.gasLimit <span style=color:#f92672>*</span> _transaction.maxFeePerGas;
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>bool</span> ok, ) <span style=color:#f92672>=</span> <span style=color:#66d9ef>payable</span>(BOOTLOADER_FORMAL_ADDRESS).call{value<span style=color:#f92672>:</span> requiredETH}(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    require(ok, <span style=color:#e6db74>&#34;fee transfer failed&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    revert(<span style=color:#e6db74>&#34;unsupported flow&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>포인트</p><ul><li><strong>타입 문자열</strong>·필드 순서 불일치 → 즉시 실패</li><li><code>_hashTypedDataV4</code>로 도메인 결합 → 타 체인/계약 재사용 불가</li><li><code>recover(sig)</code> == <code>signer</code> 여야 통과</li><li>정책 강화를 위해 <code>(_transaction.gasLimit ≤ recGasLimit)</code> 등 <strong>상한 검증</strong> 추가 고려 (아래 참조)</li></ul></blockquote><hr><h2 id=서버-스니펫>서버 스니펫<a hidden class=anchor aria-hidden=true href=#서버-스니펫>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// Ethers v5 기준 예시
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>domain</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;SignedGasPaymaster&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>version</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>chainId</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>verifyingContract</span>: <span style=color:#66d9ef>PAYMASTER_ADDRESS</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>types</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>SignedGasRequest</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;user&#34;</span>,     <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;address&#34;</span>  },
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;expiry&#34;</span>,   <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;uint256&#34;</span>  },
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;gasLimit&#34;</span>, <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;uint256&#34;</span>  },
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;gasPrice&#34;</span>, <span style=color:#66d9ef>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;uint256&#34;</span>  },
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>user</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>expiry</span>,                 <span style=color:#75715e>// 짧게 (예: +120초)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gasLimit</span>:  <span style=color:#66d9ef>recGasLimit</span>, <span style=color:#75715e>// 추정 + 버퍼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gasPrice</span>:  <span style=color:#66d9ef>recGasPrice</span>, <span style=color:#75715e>// fee data 반영
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>signature</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>signer</span>.<span style=color:#a6e22e>_signTypedData</span>(<span style=color:#a6e22e>domain</span>, <span style=color:#a6e22e>types</span>, <span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// paymasterInput = selector(IPaymasterFlow.general) || abi.encode(expiry, recGasLimit, recGasPrice, signature)
</span></span></span></code></pre></div><blockquote><p>포인트</p><ul><li>도메인(name/version/chainId/verifyingContract) <strong>1:1 일치</strong></li><li>만료(expiry) 짧게 → 리플레이 윈도우 축소</li><li>서버가 반환하는 추천 가스 값은 온체인에서 <strong>상한 검증/캡핑</strong>에 사용 가능</li></ul></blockquote><hr><h2 id=클라이언트-스니펫>클라이언트 스니펫<a hidden class=anchor aria-hidden=true href=#클라이언트-스니펫>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#75715e>// 서버 응답: { paymasterInput, recGasLimit, recGasPrice }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tx</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>wallet</span>.<span style=color:#a6e22e>sendTransaction</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>to</span>: <span style=color:#66d9ef>targetContract</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>calldata</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>gasLimit</span>: <span style=color:#66d9ef>recGasLimit</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>maxFeePerGas</span>: <span style=color:#66d9ef>recGasPrice</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>customData</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>paymasterParams</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>paymaster</span>: <span style=color:#66d9ef>PAYMASTER_ADDRESS</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>paymasterInput</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><hr><h2 id=왜-toaddresspaymaster-가-안-맞았나-대안-검토--탈락-사유>왜 toAddressPaymaster 가 안 맞았나 (대안 검토 & 탈락 사유)<a hidden class=anchor aria-hidden=true href=#왜-toaddresspaymaster-가-안-맞았나-대안-검토--탈락-사유>#</a></h2><table><thead><tr><th>대안</th><th>장점</th><th>치명적 단점(탈락 근거)</th></tr></thead><tbody><tr><td>단순 <code>toAddressPaymaster</code></td><td>구현 단순</td><td>(1) 신규 유저 지갑 생성 시 <code>to = AccountFactory</code> → <strong>공용 대납화</strong>(2) 가스 한도·가격 검증 부재 → <strong>잔고 드레인</strong> 리스크</td></tr><tr><td><code>to</code> 화이트리스트 + IP 제한</td><td>진입 장벽 소폭 상승</td><td>체인 레벨에서 <strong>의도/파라미터 미바인딩</strong>. 프록시/재전송/버스트 트래픽에 취약</td></tr><tr><td>온체인 사용자 allowlist</td><td>권한 명시적</td><td>온체인 상태·거버넌스 비용↑, 롤오버·철회 지연. 신규 유저 온보딩 UX 저하</td></tr><tr><td><strong>오프체인 서명 기반(채택)</strong></td><td><strong>유저·만료·가스</strong> 바인딩, 도메인 분리로 재사용 차단, <strong>fail‑closed</strong></td><td>서명 인프라·키 보관·관측성 구축 필요 (운영으로 해결)</td></tr></tbody></table><hr><h2 id=위협-모델--방어-전략>위협 모델 & 방어 전략<a hidden class=anchor aria-hidden=true href=#위협-모델--방어-전략>#</a></h2><ul><li><strong>무단 사용(공개 대납 유도)</strong> → <em>서명 필요</em>: 서명자 키 없는 제3자는 사용 불가</li><li><strong>리플레이 공격(같은 서명 재사용)</strong> → <em>짧은 만료 + 필요 시 per‑user nonce</em></li><li><strong>체인/계약 전이 재사용</strong> → <em>EIP‑712 도메인 분리자</em> (name/version/chainId/contract)</li><li><strong>가스 과청구/과다 버퍼</strong> → <em>추천 가스 상한 바인딩</em>: <code>tx.gasLimit ≤ recGasLimit</code>, <code>tx.maxFeePerGas ≤ recGasPrice</code> 검증(정책 옵션)</li><li><strong>파라미터 변조</strong> → <em>타입드 데이터 해시</em> 재계산으로 무결성 보장</li><li><strong>서명키 유출</strong> → <em>KMS/HSM·킬스위치·키 롤오버</em>, <code>changeSigner</code> 절차</li><li><strong>부트로더 스푸핑</strong> → <em><code>onlyBootloader</code> 가드</em></li><li><strong>잔액 고갈</strong> → <em>예산 캡/레이트 리미트/대납 중단 스위치</em></li><li><strong>운영 드리프트(클라/서버/체인 도메인 불일치)</strong> → <em>도메인 구성에 대한 CI 테스트 & 캐너리</em></li></ul><hr><h2 id=offchain-signature-verification-빠르게-이해하기>“Off‑chain Signature Verification” 빠르게 이해하기<a hidden class=anchor aria-hidden=true href=#offchain-signature-verification-빠르게-이해하기>#</a></h2><ul><li>오프체인(서버)에서 <strong>타입드 데이터</strong>에 서명 → 온체인에서 <strong>도메인 분리자</strong>를 포함해 동일 구조로 해시 재생성 → <code>recover()</code>로 서명자 주소 복원 → 저장된 <code>signer</code>와 매칭되면 승인</li><li>멀티시그와 달리 <strong>단일 승인자</strong>(서버 키) 기준 정책 실행</li><li>오라클 서명과 유사하나, <strong>가스 대납 승인</strong>이라는 도메인에 특화</li></ul><hr><h2 id=서버에서-서명한-걸-컨트랙트에서-어떻게-검증하는가>서버에서 서명한 걸 컨트랙트에서 어떻게 검증하는가?<a hidden class=anchor aria-hidden=true href=#서버에서-서명한-걸-컨트랙트에서-어떻게-검증하는가>#</a></h2><ol><li><strong>입력 디코딩 → 파라미터 추출</strong> (expiry, recGasLimit, recGasPrice, signature, user = <code>tx.from</code>)</li><li><strong>동일 타입·필드로 struct hash 생성 → <code>_hashTypedDataV4</code>로 도메인 결합</strong></li><li><strong><code>digest.recover(signature)</code> == 저장된 <code>signer</code></strong> 확인</li><li><strong>정책 옵션</strong>: <code>tx.gasLimit/maxFeePerGas</code>가 추천 상한 이내인지 검사</li></ol><blockquote><p><code>_hashTypedDataV4</code>는 상속한 <code>EIP712</code>가 <strong>생성자에서 설정한 name/version + chainId + contract</strong>로 도메인 분리자를 내부 계산함. 클라이언트/서버는 동일 도메인 구성을 사용해야 함.</p></blockquote><hr><h2 id=서명된-데이터와-실제-파라미터가-같은지-어떻게-보장함>“서명된 데이터”와 “실제 파라미터”가 같은지 어떻게 보장함?<a hidden class=anchor aria-hidden=true href=#서명된-데이터와-실제-파라미터가-같은지-어떻게-보장함>#</a></h2><ul><li>컨트랙트가 전달받은 파라미터로 <strong>동일한 구조체 해시</strong>를 다시 만들고, 그 해시로 <strong>서명자 복원</strong></li><li>입력이 한 비트라도 바뀌면 해시가 달라져 복원 주소가 달라짐 → 검증 실패</li><li>따라서 <strong>서명자 확인</strong>과 <strong>메시지 무결성</strong>을 동시에 보장</li></ul><hr><h2 id=운영보안-설계>운영·보안 설계<a hidden class=anchor aria-hidden=true href=#운영보안-설계>#</a></h2><ul><li><strong>키 관리</strong>: HSM/KMS, 키 롤오버(이중 서명 전환 기간), 유출 시 즉시 <code>changeSigner</code> + 킬스위치</li><li><strong>예산·레이트</strong>: 일일/시간당 대납 예산, per‑user 레이트 리미트, 버스트 감지 시 자동 중단</li><li><strong>관측성</strong>: 승인/거절 사유 코드, 만료/가스상한 위반 카운트, 부트로더 송금 실패 알람</li><li><strong>정책 구성</strong>: <code>gasLimit</code>/<code>maxFeePerGas</code> 상한 정책, 메서드 스코프 바인딩(옵션: <code>to</code>/<code>selector</code>/<code>calldataHash</code>를 타입드 데이터에 포함)</li><li><strong>디그레이드 전략</strong>: 대납 실패 시 <strong>사용자 지불</strong>로 폴백, UX 메시지 일관화</li></ul><hr><h2 id=테스트-전략>테스트 전략<a hidden class=anchor aria-hidden=true href=#테스트-전략>#</a></h2><ul><li><strong>타입/도메인 동치성 테스트</strong>: 서버·클라·컨트랙트 EIP‑712 도메인/타입 문자열 스냅샷 비교</li><li><strong>경계값</strong>: 만료 임계(±1s), 가스 상한 초과/동일/미만, fee data 드리프트</li><li><strong>리플레이</strong>: 동일 서명 다중 제출, 체인ID 변경, 컨트랙트 주소 변경</li><li><strong>부정 시나리오</strong>: signer 위조, 타입 문자열 공백/쉼표 오염, 인코딩 순서 변경</li><li><strong>퍼포먼스</strong>: 검증 가스 오버헤드 측정(서명 길이/경로에 따른 차이), 부트로더 송금 실패 복구</li></ul><hr><h2 id=결과>결과<a hidden class=anchor aria-hidden=true href=#결과>#</a></h2><ul><li><strong>권한 있는 요청만 대납</strong>: 승인 스코프가 <strong>유저·시간·가스</strong>로 좁혀짐</li><li><strong>공격 면 축소</strong>: <code>to</code> 기반 공개 대납 제거, 체인/계약 재사용·리플레이 차단</li><li><strong>운영 제어 가능</strong>: 예산/레이트/킬스위치로 실시간 리스크 컨트롤</li><li><strong>확장성</strong>: 필요 시 타입드 데이터에 <code>to/selector/nonce/budgetId</code> 등 추가해 정책 세분화 가능</li></ul><hr><h2 id=트러블슈팅-포인트>트러블슈팅 포인트<a hidden class=anchor aria-hidden=true href=#트러블슈팅-포인트>#</a></h2><ul><li><strong>타입 문자열 불일치</strong>: 글자/공백/쉼표 하나 차이로 실패 (<code>SignedGasRequest</code> 철자, 필드 순서)</li><li><strong>도메인 값 불일치</strong>: name/version/chainId/verifyingContract 중 하나라도 다르면 실패</li><li><strong>만료 초과</strong>: 서버·노드 시간차 → 만료는 짧되 <strong>소폭 여유</strong></li><li><strong>가스 괴리</strong>: 서버 추천과 실제 트랜잭션 값 차이 → 상한 검증/캡핑 정책 도입</li><li><strong>부트로더 외 호출</strong>: <code>onlyBootloader</code> 누락 시 보안 취약</li></ul><hr><h2 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h2><ul><li>OpenZeppelin <strong>EIP‑712</strong>: 도메인/해시/서명 유틸</li><li>ethers.js <strong><code>_signTypedData</code></strong>: 타입드 데이터 서명</li><li>ZkSync Era <strong>Paymaster</strong> 가이드 & zksync‑contracts 인터페이스 문서</li><li>(최신 동작은 공식 문서/레포 확인 권장)</li></ul><hr><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>핵심은 <strong>문제 정의 → 위협 모델링 → 정책 바인딩(유저·시간·가스) → 도메인 분리자 적용 → 운영 가드레일</strong>의 일관된 흐름임.
단순 <code>to</code> 기반 허용으로는 신규 온보딩/남용/드레인을 막기 어려움. <strong>오프체인 서명 기반</strong>은 승인 스코프를 정밀하게 바인딩하고, 실패 시 기본 거절하는 <strong>fail‑closed</strong> 아키텍처를 제공함.
스니펫만으로 <strong>동작 원리</strong>를 이해할 수 있으며, 실제 적용 시에는 상한 검증·메서드 스코프·nonce·관측성 등 정책을 추가해 <strong>운영 등급</strong>으로 끌어올릴 수 있음.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/zksync/>Zksync</a></li><li><a href=https://handsupmin.github.io/tags/paymaster/>Paymaster</a></li><li><a href=https://handsupmin.github.io/tags/eip-712/>Eip-712</a></li><li><a href=https://handsupmin.github.io/tags/off-chain-signature/>Off-Chain-Signature</a></li><li><a href=https://handsupmin.github.io/tags/solidity/>Solidity</a></li><li><a href=https://handsupmin.github.io/tags/ethersjs/>Ethersjs</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>