<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 | HandsLog</title>
<meta name=keywords content="mysql,indexes,query-tuning,btree,storage-engine,sequential-io,random-io,innodb,database-performance"><meta name=description content="개요
인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움
MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨
또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함
디스크 I/O가 성능을 좌우하는 이유
CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림
DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본"><meta property="og:description" content="개요 인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움 MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨 또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함
디스크 I/O가 성능을 좌우하는 이유 CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림 DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-05T13:15:15+00:00"><meta property="article:modified_time" content="2026-01-05T13:15:15+00:00"><meta property="article:tag" content="Mysql"><meta property="article:tag" content="Indexes"><meta property="article:tag" content="Query-Tuning"><meta property="article:tag" content="Btree"><meta property="article:tag" content="Storage-Engine"><meta property="article:tag" content="Sequential-Io"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본"><meta name=twitter:description content="개요
인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움
MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨
또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함
디스크 I/O가 성능을 좌우하는 이유
CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림
DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본","item":"https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본","name":"MySQL 인덱스와 디스크 I\/O 이해로 시작하는 쿼리 튜닝 기본","description":"개요 인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움 MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨 또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함\n디스크 I/O가 성능을 좌우하는 이유 CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림 DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨\n","keywords":["mysql","indexes","query-tuning","btree","storage-engine","sequential-io","random-io","innodb","database-performance"],"articleBody":"개요 인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움 MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨 또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함\n디스크 I/O가 성능을 좌우하는 이유 CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림 DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨\nI/O는 컴퓨터와 주변 장치 간 데이터 전송 전반을 의미하며 파일 시스템 접근, 디스크 읽기·쓰기, 컨트롤러 캐시 플러시 등 시스템 전반의 입출력 행위를 포함함\n저장 매체 개요 서버 환경에서 흔히 쓰는 저장 매체 구분\n내장 디스크 내부 장착형 디스크 드라이브 DAS Direct Attached Storage, 본체에 직접 연결하는 디스크 확장 장치 NAS Network Attached Storage, 네트워크를 통해 공유되는 파일 스토리지 SAN Storage Area Network, 전용 네트워크로 연결되는 블록 스토리지 내장 디스크는 서버 섀시 공간 제약으로 장착 수량과 용량 확장이 제한됨 DAS는 본체에 직결되어 내장 디스크와 유사한 방식으로 동작하며 대용량 확장에 유리하나 하나의 호스트에 귀속되므로 다중 서버 공유 불가 NAS는 TCP/IP 기반 공유 스토리지로 여러 서버에서 동시에 접근 가능하나 직접 연결 대비 지연과 처리량 손실 발생 SAN은 광케이블 등 전용 인터커넥트를 사용해 대용량과 높은 성능, 안정성을 제공하나 구축 비용이 큼\n일반적인 성능과 비용 특성은 내장 디스크 → DAS → SAN 순으로 고성능·고비용 경향을 가짐 모든 매체 내부에는 하나 이상의 디스크 드라이브가 존재한다는 공통점이 있음\nHDD와 SSD의 차이 전통적인 HDD는 플래터와 디스크 헤드를 움직여 데이터를 읽고 쓰는 기계식 구조를 가짐 SSD는 플래시 메모리를 사용해 기계적 움직임 없이 접근하므로 지연이 낮고 랜덤 I/O가 월등히 빠름 인터페이스는 SATA, SAS 등 기존 채널을 그대로 활용 가능하며 서버 스토리지 구성에 바로 적용 가능함\n왜 HDD는 SSD보다 느린가\nHDD는 플래터로 물리적 위치를 탐색해야 해 접근 지연이 필연적으로 큼 SSD는 셀에 전자적으로 접근하므로 위치 탐색 지연이 현저히 낮음 순차 I/O에서는 SSD가 HDD와 유사하거나 다소 빠른 수준을 보이기도 하나 데이터베이스는 작은 블록의 랜덤 접근 비중이 높아 SSD의 이점이 크게 드러남\n랜덤 I/O와 순차 I/O 두 방식 모두 결국 디스크 헤드를 적절한 위치로 이동해 데이터를 읽고 쓰는 동작을 수반함 차이는 접근 패턴에 있음\n순차 I/O 연속된 페이지를 한 번의 흐름으로 접근 랜덤 I/O 불연속 페이지를 여러 번 나눠 접근 예시로 3개의 페이지를 기록하는 경우\n순차 I/O 시스템 콜 1회, 헤드 이동 1회로 연속 기록 랜덤 I/O 시스템 콜 3회, 헤드 이동 3회로 분산 기록 디스크 접근 시간은 헤드 이동과 회전 지연에서 대부분 결정됨 따라서 같은 양의 데이터를 다룰 때 순차 I/O가 랜덤 I/O보다 유리함 DBMS에서는 작은 단위의 랜덤 I/O가 빈번하므로 이를 완화하기 위해 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등 완충 메커니즘을 제공함\n쓰기 작업은 fsync와 같은 동기화가 필요하며 순차 I/O라 해도 동기화 호출이 잦으면 랜덤 I/O처럼 비효율이 발생 가능함 RAID 컨트롤러의 캐시 메모리는 빈번한 동기화 호출을 병합해 순차 쓰기 형태로 변환하는 데 기여함\n실무 쿼리 튜닝에서 랜덤 I/O를 순차 I/O로 전환하는 전략은 제한적임 목표는 랜덤 I/O 자체를 줄이는 것, 즉 쿼리가 필요한 데이터만 읽도록 만드는 것에 초점\n인덱스 레인지 스캔은 주로 랜덤 I/O를 유발하고 풀 테이블 스캔은 순차 I/O를 활용함 큰 테이블에서 대부분의 레코드를 읽는 경우에는 인덱스를 배제하고 풀 스캔을 유도하는 편이 더 빠를 수 있음 이는 OLAP나 대용량 통계 처리에서 종종 채택되는 전략이며 OLTP 특성의 워크로드에서는 신중한 적용이 필요함\nOLTP On-Line Transaction Processing, 데이터 갱신 중심의 다중 동시 트랜잭션 처리 방식 OLAP On-Line Analytic Processing, 대화형 분석 질의와 집계 중심의 정보 처리 방식\n인덱스의 기본 개념 인덱스는 컬럼 값과 해당 레코드의 저장 위치를 키-값 쌍으로 보관하는 구조를 가짐 책의 찾아보기 색인처럼 정렬된 상태로 유지되어 원하는 값을 빠르게 찾을 수 있음\n자료구조 비유\nSortedList 정렬 유지, 조회 빠름, 삽입·갱신 비용 큼 → DB 인덱스에 대응 ArrayList 저장 순서 유지, 별도 정렬 없음 → 데이터 파일에 대응 인덱스는 읽기 성능을 높이는 대신 쓰기 비용을 증가시킴 INSERT, UPDATE, DELETE 시 인덱스 구조를 유지하기 위한 추가 작업이 발생함 따라서 WHERE 절에 등장한다고 모두 인덱스로 만드는 것은 역효과를 초래할 수 있음 인덱스 추가 여부는 쓰기 성능 희생 가능한 범위와 읽기 가속 기대치를 기준으로 판단해야 함\n역할 관점 분류\nPrimary Key 테이블의 대표 키, 고유성과 식별성 보장 Secondary Key 보조 인덱스, 검색 가속 목적 알고리즘 관점 분류\nB-Tree 가장 범용적, 원본 값을 정렬해 보관 Hash 해시 값으로 인덱싱, 동등 비교에 매우 빠름, 전방 일치 등 범위 검색 부적합, 주로 메모리 기반 엔진에서 활용 Fractal-Tree B-Tree의 쓰기 비용을 낮추기 위한 변형, 범용 사용 가능성을 지향하나 성숙도는 상대적으로 낮음 고유성 관점 분류\nUnique 같은 키 값 1개만 허용 Non-Unique 같은 키 값 여러 개 허용 유니크 여부는 옵티마이저의 실행 계획 선택에 중요한 신호로 작용함\nB-Tree 인덱스 이해 B-Tree는 DB 인덱싱에서 가장 널리 쓰이는 기본 알고리즘이며 B+-Tree 또는 B*-Tree 형태가 일반적 여기서 B는 Binary가 아닌 Balanced를 의미함\nB-Tree는 컬럼의 원래 값을 기반으로 정렬 상태를 유지함 일부 엔진은 프리픽스 길이로 앞부분만 보관해 공간을 절약하기도 함 특수 요구사항을 제외하면 범용 검색에 가장 적합함\n구조\n루트 노드 트리 최상단, 탐색 시작점 브랜치 노드 중간 계층, 하위 노드로 경로 분기 리프 노드 최하단, 실제 인덱스 키와 레코드 주소 보관 인덱스 키는 정렬돼 있으나 데이터 파일의 레코드는 일반적으로 임의 순서로 저장됨 삭제 공간 재활용과 페이지 분할 등으로 물리 저장 순서는 삽입 순서와 달라질 수 있음\n예외적으로 InnoDB는 클러스터형 저장 방식을 사용함\n클러스터링 기본 프라이머리 키 순서로 레코드가 물리적으로 모여 저장됨 오라클의 IOT, MS SQL의 클러스터 테이블과 유사 개념 InnoDB는 기본값으로 클러스터링 테이블을 생성함 리프 노드의 레코드 주소 의미\n일부 시스템은 물리적 주소를 직접 가리킴 MyISAM은 내부 레코드 ID 형태로 참조 InnoDB는 프라이머리 키가 클러스터 키이므로 프라이머리 키 자체가 주소 역할을 수행 결과적으로 인덱스 레코드는 인덱스 키와 주소 성분의 조합으로 이뤄짐 인덱스 설계와 I/O 관점 팁 큰 범위를 읽는 질의는 인덱스 레인지 스캔보다 풀 스캔이 더 빠를 수 있음 순차 I/O 활용 선택도가 높은 조건을 선행 컬럼으로 배치해 랜덤 I/O 횟수 최소화 커버링 인덱스 활용으로 테이블 접근을 회피하면 랜덤 I/O를 크게 절감 가능 불필요한 보조 인덱스는 쓰기 비용과 공간만 증가시키므로 주기적 점검 필요 유니크 인덱스는 탐색을 빠르게 하고 불필요한 추가 탐색을 줄여 옵티마이저 결정에 긍정적 신호 제공 간단 예시로 보는 선택 전략 조건이 전체의 80% 이상을 포함하는 집계 질의 → 인덱스보다 풀 스캔이 유리할 가능성 큼 조건이 1% 미만으로 매우 선별적이고 필요한 컬럼이 인덱스에 모두 포함됨 → 커버링 인덱스로 랜덤 I/O 최소화 조인에서 드라이빙 테이블을 고선택도 조건으로 줄인 뒤 조인 실행 → 조인 전체 랜덤 I/O 감소 마무리 인덱스는 읽기 효율을 위해 쓰기 비용을 감수하는 장치라는 본질을 잊지 말아야 함 MySQL에서는 스토리지 엔진 특성과 I/O 패턴 이해가 실행 계획과 성능 결과를 가르는 핵심 요소가 됨 튜닝의 목표는 랜덤 I/O를 순차 I/O로 바꾸는 것이 아니라 불필요한 랜덤 I/O 자체를 줄이는 것임 B-Tree의 구조와 InnoDB의 클러스터링 특성을 이해하고, 선택도와 커버링 여부를 기준으로 인덱스를 설계하면 실무에서 체감 성능 향상을 얻을 수 있음\n참고자료 https://velog.io/@keywookim/MySQL-Index-%EC%BF%BC%EB%A6%AC%ED%8A%9C%EB%8B%9D%EC%9D%98-%EA%B8%B0%EB%B3%B8-1 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html https://12bme.tistory.com/138 ","wordCount":"1064","inLanguage":"en","datePublished":"2026-01-05T13:15:15.641Z","dateModified":"2026-01-05T13:15:15.641Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본</h1><div class=post-meta><span title='2026-01-05 13:15:15.641 +0000 UTC'>January 5, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움
MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨
또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함</p><h3 id=디스크-io가-성능을-좌우하는-이유>디스크 I/O가 성능을 좌우하는 이유<a hidden class=anchor aria-hidden=true href=#디스크-io가-성능을-좌우하는-이유>#</a></h3><p>CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림
DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨</p><p>I/O는 컴퓨터와 주변 장치 간 데이터 전송 전반을 의미하며 파일 시스템 접근, 디스크 읽기·쓰기, 컨트롤러 캐시 플러시 등 시스템 전반의 입출력 행위를 포함함</p><h3 id=저장-매체-개요>저장 매체 개요<a hidden class=anchor aria-hidden=true href=#저장-매체-개요>#</a></h3><p>서버 환경에서 흔히 쓰는 저장 매체 구분</p><ul><li>내장 디스크 내부 장착형 디스크 드라이브</li><li>DAS Direct Attached Storage, 본체에 직접 연결하는 디스크 확장 장치</li><li>NAS Network Attached Storage, 네트워크를 통해 공유되는 파일 스토리지</li><li>SAN Storage Area Network, 전용 네트워크로 연결되는 블록 스토리지</li></ul><p>내장 디스크는 서버 섀시 공간 제약으로 장착 수량과 용량 확장이 제한됨
DAS는 본체에 직결되어 내장 디스크와 유사한 방식으로 동작하며 대용량 확장에 유리하나 하나의 호스트에 귀속되므로 다중 서버 공유 불가
NAS는 TCP/IP 기반 공유 스토리지로 여러 서버에서 동시에 접근 가능하나 직접 연결 대비 지연과 처리량 손실 발생
SAN은 광케이블 등 전용 인터커넥트를 사용해 대용량과 높은 성능, 안정성을 제공하나 구축 비용이 큼</p><p>일반적인 성능과 비용 특성은 내장 디스크 → DAS → SAN 순으로 고성능·고비용 경향을 가짐
모든 매체 내부에는 하나 이상의 디스크 드라이브가 존재한다는 공통점이 있음</p><h3 id=hdd와-ssd의-차이>HDD와 SSD의 차이<a hidden class=anchor aria-hidden=true href=#hdd와-ssd의-차이>#</a></h3><p>전통적인 HDD는 플래터와 디스크 헤드를 움직여 데이터를 읽고 쓰는 기계식 구조를 가짐
SSD는 플래시 메모리를 사용해 기계적 움직임 없이 접근하므로 지연이 낮고 랜덤 I/O가 월등히 빠름
인터페이스는 SATA, SAS 등 기존 채널을 그대로 활용 가능하며 서버 스토리지 구성에 바로 적용 가능함</p><p>왜 HDD는 SSD보다 느린가</p><ul><li>HDD는 플래터로 물리적 위치를 탐색해야 해 접근 지연이 필연적으로 큼</li><li>SSD는 셀에 전자적으로 접근하므로 위치 탐색 지연이 현저히 낮음</li></ul><p>순차 I/O에서는 SSD가 HDD와 유사하거나 다소 빠른 수준을 보이기도 하나 데이터베이스는 작은 블록의 랜덤 접근 비중이 높아 SSD의 이점이 크게 드러남</p><h3 id=랜덤-io와-순차-io>랜덤 I/O와 순차 I/O<a hidden class=anchor aria-hidden=true href=#랜덤-io와-순차-io>#</a></h3><p>두 방식 모두 결국 디스크 헤드를 적절한 위치로 이동해 데이터를 읽고 쓰는 동작을 수반함
차이는 접근 패턴에 있음</p><ul><li>순차 I/O 연속된 페이지를 한 번의 흐름으로 접근</li><li>랜덤 I/O 불연속 페이지를 여러 번 나눠 접근</li></ul><p>예시로 3개의 페이지를 기록하는 경우</p><ul><li>순차 I/O 시스템 콜 1회, 헤드 이동 1회로 연속 기록</li><li>랜덤 I/O 시스템 콜 3회, 헤드 이동 3회로 분산 기록</li></ul><p>디스크 접근 시간은 헤드 이동과 회전 지연에서 대부분 결정됨
따라서 같은 양의 데이터를 다룰 때 순차 I/O가 랜덤 I/O보다 유리함
DBMS에서는 작은 단위의 랜덤 I/O가 빈번하므로 이를 완화하기 위해 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등 완충 메커니즘을 제공함</p><p>쓰기 작업은 fsync와 같은 동기화가 필요하며 순차 I/O라 해도 동기화 호출이 잦으면 랜덤 I/O처럼 비효율이 발생 가능함
RAID 컨트롤러의 캐시 메모리는 빈번한 동기화 호출을 병합해 순차 쓰기 형태로 변환하는 데 기여함</p><p>실무 쿼리 튜닝에서 랜덤 I/O를 순차 I/O로 전환하는 전략은 제한적임
목표는 랜덤 I/O 자체를 줄이는 것, 즉 쿼리가 필요한 데이터만 읽도록 만드는 것에 초점</p><p>인덱스 레인지 스캔은 주로 랜덤 I/O를 유발하고 풀 테이블 스캔은 순차 I/O를 활용함
큰 테이블에서 대부분의 레코드를 읽는 경우에는 인덱스를 배제하고 풀 스캔을 유도하는 편이 더 빠를 수 있음
이는 OLAP나 대용량 통계 처리에서 종종 채택되는 전략이며 OLTP 특성의 워크로드에서는 신중한 적용이 필요함</p><p>OLTP On-Line Transaction Processing, 데이터 갱신 중심의 다중 동시 트랜잭션 처리 방식
OLAP On-Line Analytic Processing, 대화형 분석 질의와 집계 중심의 정보 처리 방식</p><h3 id=인덱스의-기본-개념>인덱스의 기본 개념<a hidden class=anchor aria-hidden=true href=#인덱스의-기본-개념>#</a></h3><p>인덱스는 컬럼 값과 해당 레코드의 저장 위치를 키-값 쌍으로 보관하는 구조를 가짐
책의 찾아보기 색인처럼 정렬된 상태로 유지되어 원하는 값을 빠르게 찾을 수 있음</p><p>자료구조 비유</p><ul><li>SortedList 정렬 유지, 조회 빠름, 삽입·갱신 비용 큼 → DB 인덱스에 대응</li><li>ArrayList 저장 순서 유지, 별도 정렬 없음 → 데이터 파일에 대응</li></ul><p>인덱스는 읽기 성능을 높이는 대신 쓰기 비용을 증가시킴
INSERT, UPDATE, DELETE 시 인덱스 구조를 유지하기 위한 추가 작업이 발생함
따라서 WHERE 절에 등장한다고 모두 인덱스로 만드는 것은 역효과를 초래할 수 있음
인덱스 추가 여부는 쓰기 성능 희생 가능한 범위와 읽기 가속 기대치를 기준으로 판단해야 함</p><p>역할 관점 분류</p><ul><li>Primary Key 테이블의 대표 키, 고유성과 식별성 보장</li><li>Secondary Key 보조 인덱스, 검색 가속 목적</li></ul><p>알고리즘 관점 분류</p><ul><li>B-Tree 가장 범용적, 원본 값을 정렬해 보관</li><li>Hash 해시 값으로 인덱싱, 동등 비교에 매우 빠름, 전방 일치 등 범위 검색 부적합, 주로 메모리 기반 엔진에서 활용</li><li>Fractal-Tree B-Tree의 쓰기 비용을 낮추기 위한 변형, 범용 사용 가능성을 지향하나 성숙도는 상대적으로 낮음</li></ul><p>고유성 관점 분류</p><ul><li>Unique 같은 키 값 1개만 허용</li><li>Non-Unique 같은 키 값 여러 개 허용</li></ul><p>유니크 여부는 옵티마이저의 실행 계획 선택에 중요한 신호로 작용함</p><h3 id=b-tree-인덱스-이해>B-Tree 인덱스 이해<a hidden class=anchor aria-hidden=true href=#b-tree-인덱스-이해>#</a></h3><p>B-Tree는 DB 인덱싱에서 가장 널리 쓰이는 기본 알고리즘이며 B+-Tree 또는 B*-Tree 형태가 일반적
여기서 B는 Binary가 아닌 Balanced를 의미함</p><p>B-Tree는 컬럼의 원래 값을 기반으로 정렬 상태를 유지함 일부 엔진은 프리픽스 길이로 앞부분만 보관해 공간을 절약하기도 함
특수 요구사항을 제외하면 범용 검색에 가장 적합함</p><p>구조</p><ul><li>루트 노드 트리 최상단, 탐색 시작점</li><li>브랜치 노드 중간 계층, 하위 노드로 경로 분기</li><li>리프 노드 최하단, 실제 인덱스 키와 레코드 주소 보관</li></ul><p>인덱스 키는 정렬돼 있으나 데이터 파일의 레코드는 일반적으로 임의 순서로 저장됨
삭제 공간 재활용과 페이지 분할 등으로 물리 저장 순서는 삽입 순서와 달라질 수 있음</p><p>예외적으로 InnoDB는 클러스터형 저장 방식을 사용함</p><ul><li>클러스터링 기본 프라이머리 키 순서로 레코드가 물리적으로 모여 저장됨</li><li>오라클의 IOT, MS SQL의 클러스터 테이블과 유사 개념</li><li>InnoDB는 기본값으로 클러스터링 테이블을 생성함</li></ul><p>리프 노드의 레코드 주소 의미</p><ul><li>일부 시스템은 물리적 주소를 직접 가리킴</li><li>MyISAM은 내부 레코드 ID 형태로 참조</li><li>InnoDB는 프라이머리 키가 클러스터 키이므로 프라이머리 키 자체가 주소 역할을 수행
결과적으로 인덱스 레코드는 인덱스 키와 주소 성분의 조합으로 이뤄짐</li></ul><h3 id=인덱스-설계와-io-관점-팁>인덱스 설계와 I/O 관점 팁<a hidden class=anchor aria-hidden=true href=#인덱스-설계와-io-관점-팁>#</a></h3><ul><li>큰 범위를 읽는 질의는 인덱스 레인지 스캔보다 풀 스캔이 더 빠를 수 있음 순차 I/O 활용</li><li>선택도가 높은 조건을 선행 컬럼으로 배치해 랜덤 I/O 횟수 최소화</li><li>커버링 인덱스 활용으로 테이블 접근을 회피하면 랜덤 I/O를 크게 절감 가능</li><li>불필요한 보조 인덱스는 쓰기 비용과 공간만 증가시키므로 주기적 점검 필요</li><li>유니크 인덱스는 탐색을 빠르게 하고 불필요한 추가 탐색을 줄여 옵티마이저 결정에 긍정적 신호 제공</li></ul><h3 id=간단-예시로-보는-선택-전략>간단 예시로 보는 선택 전략<a hidden class=anchor aria-hidden=true href=#간단-예시로-보는-선택-전략>#</a></h3><ul><li>조건이 전체의 80% 이상을 포함하는 집계 질의 → 인덱스보다 풀 스캔이 유리할 가능성 큼</li><li>조건이 1% 미만으로 매우 선별적이고 필요한 컬럼이 인덱스에 모두 포함됨 → 커버링 인덱스로 랜덤 I/O 최소화</li><li>조인에서 드라이빙 테이블을 고선택도 조건으로 줄인 뒤 조인 실행 → 조인 전체 랜덤 I/O 감소</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>인덱스는 읽기 효율을 위해 쓰기 비용을 감수하는 장치라는 본질을 잊지 말아야 함
MySQL에서는 스토리지 엔진 특성과 I/O 패턴 이해가 실행 계획과 성능 결과를 가르는 핵심 요소가 됨
튜닝의 목표는 랜덤 I/O를 순차 I/O로 바꾸는 것이 아니라 불필요한 랜덤 I/O 자체를 줄이는 것임
B-Tree의 구조와 InnoDB의 클러스터링 특성을 이해하고, 선택도와 커버링 여부를 기준으로 인덱스를 설계하면 실무에서 체감 성능 향상을 얻을 수 있음</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://velog.io/@keywookim/MySQL-Index-%EC%BF%BC%EB%A6%AC%ED%8A%9C%EB%8B%9D%EC%9D%98-%EA%B8%B0%EB%B3%B8-1>https://velog.io/@keywookim/MySQL-Index-%EC%BF%BC%EB%A6%AC%ED%8A%9C%EB%8B%9D%EC%9D%98-%EA%B8%B0%EB%B3%B8-1</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html>https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html>https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html</a></li><li><a href=https://12bme.tistory.com/138>https://12bme.tistory.com/138</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/mysql/>Mysql</a></li><li><a href=https://blog.jsontapose.com/tags/indexes/>Indexes</a></li><li><a href=https://blog.jsontapose.com/tags/query-tuning/>Query-Tuning</a></li><li><a href=https://blog.jsontapose.com/tags/btree/>Btree</a></li><li><a href=https://blog.jsontapose.com/tags/storage-engine/>Storage-Engine</a></li><li><a href=https://blog.jsontapose.com/tags/sequential-io/>Sequential-Io</a></li><li><a href=https://blog.jsontapose.com/tags/random-io/>Random-Io</a></li><li><a href=https://blog.jsontapose.com/tags/innodb/>Innodb</a></li><li><a href=https://blog.jsontapose.com/tags/database-performance/>Database-Performance</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/><span class=title>« Prev</span><br><span>TID 전파 베스트 프랙티스: HTTP 헤더와 메시지 큐 Payload 기준</span>
</a><a class=next href=https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/><span class=title>Next »</span><br><span>유한 상태 머신(FSM) 기본 개념과 적용 포인트</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on x" href="https://x.com/intent/tweet/?text=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f&amp;hashtags=mysql%2cindexes%2cquery-tuning%2cbtree%2cstorage-engine%2csequential-io%2crandom-io%2cinnodb%2cdatabase-performance"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f&amp;title=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8&amp;summary=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f&title=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on whatsapp" href="https://api.whatsapp.com/send?text=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on telegram" href="https://telegram.me/share/url?text=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본 on ycombinator" href="https://news.ycombinator.com/submitlink?t=MySQL%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%94%94%ec%8a%a4%ed%81%ac%20I%2fO%20%ec%9d%b4%ed%95%b4%eb%a1%9c%20%ec%8b%9c%ec%9e%91%ed%95%98%eb%8a%94%20%ec%bf%bc%eb%a6%ac%20%ed%8a%9c%eb%8b%9d%20%ea%b8%b0%eb%b3%b8&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-index-io-basics-query-tuning-1-0f2ad2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>