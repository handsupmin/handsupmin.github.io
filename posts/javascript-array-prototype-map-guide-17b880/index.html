<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 | HandsLog</title>
<meta name=keywords content="javascript,array,map,functional-programming,es5,browser-compatibility,tips"><meta name=description content="개요
Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임
원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음
희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨
구문
arr.map(callback(currentValue[, index[, array]])[, thisArg])

callback 현재 요소를 변환해 새 요소를 생성하는 함수
currentValue 현재 요소 값
index 선택 현재 요소의 인덱스
array 선택 map을 호출한 원본 배열
thisArg 선택 콜백 실행 시 this로 사용할 값

반환값
각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환
원본 배열과 길이는 동일하고 희소성도 보존됨"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴"><meta property="og:description" content="개요 Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임 원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음 희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨
구문 arr.map(callback(currentValue[, index[, array]])[, thisArg])
callback 현재 요소를 변환해 새 요소를 생성하는 함수 currentValue 현재 요소 값 index 선택 현재 요소의 인덱스 array 선택 map을 호출한 원본 배열 thisArg 선택 콜백 실행 시 this로 사용할 값 반환값 각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환 원본 배열과 길이는 동일하고 희소성도 보존됨"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-12T13:28:49+00:00"><meta property="article:modified_time" content="2026-02-12T13:28:49+00:00"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Array"><meta property="article:tag" content="Map"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Es5"><meta property="article:tag" content="Browser-Compatibility"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴"><meta name=twitter:description content="개요
Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임
원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음
희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨
구문
arr.map(callback(currentValue[, index[, array]])[, thisArg])

callback 현재 요소를 변환해 새 요소를 생성하는 함수
currentValue 현재 요소 값
index 선택 현재 요소의 인덱스
array 선택 map을 호출한 원본 배열
thisArg 선택 콜백 실행 시 this로 사용할 값

반환값
각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환
원본 배열과 길이는 동일하고 희소성도 보존됨"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴","item":"https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴","name":"JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴","description":"개요 Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임 원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음 희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨\n구문 arr.map(callback(currentValue[, index[, array]])[, thisArg])\ncallback 현재 요소를 변환해 새 요소를 생성하는 함수 currentValue 현재 요소 값 index 선택 현재 요소의 인덱스 array 선택 map을 호출한 원본 배열 thisArg 선택 콜백 실행 시 this로 사용할 값 반환값 각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환 원본 배열과 길이는 동일하고 희소성도 보존됨\n","keywords":["javascript","array","map","functional-programming","es5","browser-compatibility","tips"],"articleBody":"개요 Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임 원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음 희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨\n구문 arr.map(callback(currentValue[, index[, array]])[, thisArg])\ncallback 현재 요소를 변환해 새 요소를 생성하는 함수 currentValue 현재 요소 값 index 선택 현재 요소의 인덱스 array 선택 map을 호출한 원본 배열 thisArg 선택 콜백 실행 시 this로 사용할 값 반환값 각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환 원본 배열과 길이는 동일하고 희소성도 보존됨\n동작 원리와 특징 순회 범위 고정 첫 콜백이 호출되기 전에 배열의 길이 스냅샷이 결정됨 추가와 삭제 map 진행 중 추가된 요소는 방문하지 않음, 방문 전 삭제된 요소는 건너뜀 값 읽기 시점 요소 값은 방문 시점의 최신 값이 콜백에 전달됨 희소 배열 처리 값이 없는 인덱스는 콜백 미호출, 결과 배열에서도 동일 인덱스가 빈 슬롯으로 남음 this 바인딩 thisArg가 주어지면 콜백의 this로 사용되고, 없으면 undefined가 기본값으로 들어감. 최종 this는 일반적인 this 바인딩 규칙을 따름 불변성 보장 map 자체는 원본을 수정하지 않음. 단 콜백 내부에서 원본을 바꾸면 그 영향은 순회 타이밍에 따라 결과에 반영될 수 있음 언제 map을 쓰는가 변환 목적 각 요소를 다른 값으로 치환해 새 배열로 만들 때 사용 forEach와 비교 forEach는 반환값이 없고 부수효과 중심. map은 새 배열 생성 중심 flatMap과 비교 요소를 배열로 변환하고 1단계 평탄화가 필요하면 flatMap 권장 간단 예시 숫자 변환 numbers.map(Math.sqrt) 제곱근 배열 생성 객체 재구성 list.map(({ key, value }) =\u003e ({ [key]: value })) 키-값 쌍을 객체로 매핑 문자열에도 적용 가능 Array.prototype.map.call('Hello', ch =\u003e ch.charCodeAt(0)) 문자 코드 배열 생성 유사 배열 처리 Array.from(document.querySelectorAll('select option:checked'), el =\u003e el.value) NodeList를 값 배열로 변환 까다로운 사례와 주의 parseInt와 map의 조합 혼동 포인트 map은 콜백에 (value, index, array)를 전달함 parseInt는 두 번째 인자로 기수(radix)를 받음 ['1','2','3'].map(parseInt)는 내부적으로 parseInt('1', 0), parseInt('2', 1), parseInt('3', 2)를 호출하므로 결과가 [1, NaN, NaN]이 됨 안전한 대안 arr.map(x =\u003e parseInt(x, 10)) 또는 arr.map(Number) 사용. Number는 부동소수점과 지수표현을 숫자로 변환함 희소 배열 보존 의도적으로 빈 슬롯을 제거하려면 map 전에 filter로 값 존재 여부를 확인하거나 map 이후에 compaction 절차 필요 성능 고려 대형 배열에서 불필요한 할당을 줄이려면 변환이 필요할 때만 map 사용. 변환 없이 반복이 목적이면 for-of나 forEach가 더 적합할 수 있음 콜백 작성 팁 순수 함수 지향 동일 입력은 동일 출력 보장. 부수효과 최소화 권장 명시적 반환 값 콜백은 항상 새 값을 반환해야 함. 반환 누락 시 undefined가 채워짐 thisArg 사용 지양 화살표 함수와 클로저를 우선 고려. 필요한 경우에만 thisArg 전달 동작 세부 규칙 요약 길이 스냅샷 고정 map 시작 시 len 결정, 이후 변경은 순회 범위에 영향 없음 요소 추가 무시 순회 중 추가된 인덱스는 미방문 요소 삭제 무시 방문 전 삭제된 인덱스는 미방문 값 갱신 반영 방문 시점에 읽은 값 사용 희소성 유지 원본의 빈 슬롯은 결과에도 빈 슬롯으로 유지 최소 스니펫 모음 제곱근 배열 const roots = [1, 4, 9].map(Math.sqrt) 두 배 만들기 const doubled = [1, 4, 9].map(n =\u003e n * 2) 안전한 정수 변환 const ints = ['1','2','3'].map(s =\u003e parseInt(s, 10)) 빠른 숫자 변환 const nums = ['1.1','2.2e2'].map(Number) NodeList 값 추출 const values = Array.from(document.querySelectorAll('select option:checked'), el =\u003e el.value) 문자열 문자 코드 const codes = Array.prototype.map.call('Hi', ch =\u003e ch.charCodeAt(0)) 폴리필 요약 map은 ES5에서 도입됨. 매우 오래된 환경에서는 폴리필이 필요할 수 있음 표준 알고리즘은 this를 객체화하고 길이를 Uint32로 계산, 각 존재하는 인덱스에 대해 콜백을 call로 호출하고 결과를 동일 인덱스에 기록하는 흐름을 따름 자체 구현 시 다음 조건을 충족해야 함 this가 null 또는 undefined인 경우 TypeError 발생 callback이 함수가 아니면 TypeError 발생 존재하는 인덱스에만 콜백 호출, 결과 배열에 동일 인덱스로 기록 희소성 보존과 길이 스냅샷 규칙 준수 실무에선 검증된 표준 폴리필이나 런타임의 내장 구현 사용 권장 호환성 현대 브라우저와 일반적인 서버 런타임에서 폭넓게 지원됨. 레거시 환경 대상이 아니라면 추가 조치 불필요 베스트 프랙티스 목적 분리 변환은 map, 필터링은 filter, 축약은 reduce로 역할 분리 체이닝 설계 map → filter → reduce 등 파이프라인 가독성 유지 희소 배열 다루기 전처리로 빈 슬롯 제거 또는 기본값 채우기 고려 parseInt 사용 시 radix 명시. 필요 시 Number로 단순 변환 배열이 아닌 대상에는 Array.from 또는 명시적 call로 map 적용 같이 보기 Array.prototype.forEach 반복만 필요할 때 선택 Array.prototype.flatMap 1단계 평탄화가 필요한 변환에 사용 Array.from 유사 배열을 배열로 변환하거나 생성 시 맵 함수 제공 가능 참고 링크 요약 사양의 map 알고리즘과 콜백 호출 규칙은 TC39 ECMAScript 명세를 따름 parseInt와 map의 상호작용 이슈는 잘 알려진 사례로, 콜백 인자 전달 규칙을 이해하면 쉽게 피할 수 있음 참고자료 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map http://www.wirfs-brock.com/allen/posts/166 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach ","wordCount":"709","inLanguage":"en","datePublished":"2026-02-12T13:28:49.805Z","dateModified":"2026-02-12T13:28:49.805Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴</h1><div class=post-meta><span title='2026-02-12 13:28:49.805 +0000 UTC'>February 12, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임
원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음
희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨</p><h3 id=구문>구문<a hidden class=anchor aria-hidden=true href=#구문>#</a></h3><p><code>arr.map(callback(currentValue[, index[, array]])[, thisArg])</code></p><ul><li>callback 현재 요소를 변환해 새 요소를 생성하는 함수</li><li>currentValue 현재 요소 값</li><li>index 선택 현재 요소의 인덱스</li><li>array 선택 map을 호출한 원본 배열</li><li>thisArg 선택 콜백 실행 시 this로 사용할 값</li></ul><h3 id=반환값>반환값<a hidden class=anchor aria-hidden=true href=#반환값>#</a></h3><p>각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환
원본 배열과 길이는 동일하고 희소성도 보존됨</p><h3 id=동작-원리와-특징>동작 원리와 특징<a hidden class=anchor aria-hidden=true href=#동작-원리와-특징>#</a></h3><ul><li>순회 범위 고정 첫 콜백이 호출되기 전에 배열의 길이 스냅샷이 결정됨</li><li>추가와 삭제 map 진행 중 추가된 요소는 방문하지 않음, 방문 전 삭제된 요소는 건너뜀</li><li>값 읽기 시점 요소 값은 방문 시점의 최신 값이 콜백에 전달됨</li><li>희소 배열 처리 값이 없는 인덱스는 콜백 미호출, 결과 배열에서도 동일 인덱스가 빈 슬롯으로 남음</li><li>this 바인딩 thisArg가 주어지면 콜백의 this로 사용되고, 없으면 undefined가 기본값으로 들어감. 최종 this는 일반적인 this 바인딩 규칙을 따름</li><li>불변성 보장 map 자체는 원본을 수정하지 않음. 단 콜백 내부에서 원본을 바꾸면 그 영향은 순회 타이밍에 따라 결과에 반영될 수 있음</li></ul><h3 id=언제-map을-쓰는가>언제 map을 쓰는가<a hidden class=anchor aria-hidden=true href=#언제-map을-쓰는가>#</a></h3><ul><li>변환 목적 각 요소를 다른 값으로 치환해 새 배열로 만들 때 사용</li><li>forEach와 비교 forEach는 반환값이 없고 부수효과 중심. map은 새 배열 생성 중심</li><li>flatMap과 비교 요소를 배열로 변환하고 1단계 평탄화가 필요하면 flatMap 권장</li></ul><h3 id=간단-예시>간단 예시<a hidden class=anchor aria-hidden=true href=#간단-예시>#</a></h3><ul><li>숫자 변환 <code>numbers.map(Math.sqrt)</code> 제곱근 배열 생성</li><li>객체 재구성 <code>list.map(({ key, value }) => ({ [key]: value }))</code> 키-값 쌍을 객체로 매핑</li><li>문자열에도 적용 가능 <code>Array.prototype.map.call('Hello', ch => ch.charCodeAt(0))</code> 문자 코드 배열 생성</li><li>유사 배열 처리 <code>Array.from(document.querySelectorAll('select option:checked'), el => el.value)</code> NodeList를 값 배열로 변환</li></ul><h3 id=까다로운-사례와-주의>까다로운 사례와 주의<a hidden class=anchor aria-hidden=true href=#까다로운-사례와-주의>#</a></h3><ul><li>parseInt와 map의 조합 혼동 포인트<ul><li>map은 콜백에 (value, index, array)를 전달함</li><li>parseInt는 두 번째 인자로 기수(radix)를 받음</li><li><code>['1','2','3'].map(parseInt)</code>는 내부적으로 <code>parseInt('1', 0)</code>, <code>parseInt('2', 1)</code>, <code>parseInt('3', 2)</code>를 호출하므로 결과가 <code>[1, NaN, NaN]</code>이 됨</li><li>안전한 대안 <code>arr.map(x => parseInt(x, 10))</code> 또는 <code>arr.map(Number)</code> 사용. Number는 부동소수점과 지수표현을 숫자로 변환함</li></ul></li><li>희소 배열 보존 의도적으로 빈 슬롯을 제거하려면 map 전에 filter로 값 존재 여부를 확인하거나 map 이후에 compaction 절차 필요</li><li>성능 고려 대형 배열에서 불필요한 할당을 줄이려면 변환이 필요할 때만 map 사용. 변환 없이 반복이 목적이면 for-of나 forEach가 더 적합할 수 있음</li></ul><h3 id=콜백-작성-팁>콜백 작성 팁<a hidden class=anchor aria-hidden=true href=#콜백-작성-팁>#</a></h3><ul><li>순수 함수 지향 동일 입력은 동일 출력 보장. 부수효과 최소화 권장</li><li>명시적 반환 값 콜백은 항상 새 값을 반환해야 함. 반환 누락 시 undefined가 채워짐</li><li>thisArg 사용 지양 화살표 함수와 클로저를 우선 고려. 필요한 경우에만 thisArg 전달</li></ul><h3 id=동작-세부-규칙-요약>동작 세부 규칙 요약<a hidden class=anchor aria-hidden=true href=#동작-세부-규칙-요약>#</a></h3><ul><li>길이 스냅샷 고정 map 시작 시 len 결정, 이후 변경은 순회 범위에 영향 없음</li><li>요소 추가 무시 순회 중 추가된 인덱스는 미방문</li><li>요소 삭제 무시 방문 전 삭제된 인덱스는 미방문</li><li>값 갱신 반영 방문 시점에 읽은 값 사용</li><li>희소성 유지 원본의 빈 슬롯은 결과에도 빈 슬롯으로 유지</li></ul><h3 id=최소-스니펫-모음>최소 스니펫 모음<a hidden class=anchor aria-hidden=true href=#최소-스니펫-모음>#</a></h3><ul><li>제곱근 배열 <code>const roots = [1, 4, 9].map(Math.sqrt)</code></li><li>두 배 만들기 <code>const doubled = [1, 4, 9].map(n => n * 2)</code></li><li>안전한 정수 변환 <code>const ints = ['1','2','3'].map(s => parseInt(s, 10))</code></li><li>빠른 숫자 변환 <code>const nums = ['1.1','2.2e2'].map(Number)</code></li><li>NodeList 값 추출 <code>const values = Array.from(document.querySelectorAll('select option:checked'), el => el.value)</code></li><li>문자열 문자 코드 <code>const codes = Array.prototype.map.call('Hi', ch => ch.charCodeAt(0))</code></li></ul><h3 id=폴리필-요약>폴리필 요약<a hidden class=anchor aria-hidden=true href=#폴리필-요약>#</a></h3><ul><li>map은 ES5에서 도입됨. 매우 오래된 환경에서는 폴리필이 필요할 수 있음</li><li>표준 알고리즘은 this를 객체화하고 길이를 Uint32로 계산, 각 존재하는 인덱스에 대해 콜백을 call로 호출하고 결과를 동일 인덱스에 기록하는 흐름을 따름</li><li>자체 구현 시 다음 조건을 충족해야 함<ul><li>this가 null 또는 undefined인 경우 TypeError 발생</li><li>callback이 함수가 아니면 TypeError 발생</li><li>존재하는 인덱스에만 콜백 호출, 결과 배열에 동일 인덱스로 기록</li><li>희소성 보존과 길이 스냅샷 규칙 준수</li></ul></li><li>실무에선 검증된 표준 폴리필이나 런타임의 내장 구현 사용 권장</li></ul><h3 id=호환성>호환성<a hidden class=anchor aria-hidden=true href=#호환성>#</a></h3><ul><li>현대 브라우저와 일반적인 서버 런타임에서 폭넓게 지원됨. 레거시 환경 대상이 아니라면 추가 조치 불필요</li></ul><h3 id=베스트-프랙티스>베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#베스트-프랙티스>#</a></h3><ul><li>목적 분리 변환은 map, 필터링은 filter, 축약은 reduce로 역할 분리</li><li>체이닝 설계 map → filter → reduce 등 파이프라인 가독성 유지</li><li>희소 배열 다루기 전처리로 빈 슬롯 제거 또는 기본값 채우기 고려</li><li>parseInt 사용 시 radix 명시. 필요 시 Number로 단순 변환</li><li>배열이 아닌 대상에는 Array.from 또는 명시적 call로 map 적용</li></ul><h3 id=같이-보기>같이 보기<a hidden class=anchor aria-hidden=true href=#같이-보기>#</a></h3><ul><li>Array.prototype.forEach 반복만 필요할 때 선택</li><li>Array.prototype.flatMap 1단계 평탄화가 필요한 변환에 사용</li><li>Array.from 유사 배열을 배열로 변환하거나 생성 시 맵 함수 제공 가능</li></ul><h3 id=참고-링크-요약>참고 링크 요약<a hidden class=anchor aria-hidden=true href=#참고-링크-요약>#</a></h3><ul><li>사양의 map 알고리즘과 콜백 호출 규칙은 TC39 ECMAScript 명세를 따름</li><li>parseInt와 map의 상호작용 이슈는 잘 알려진 사례로, 콜백 인자 전달 규칙을 이해하면 쉽게 피할 수 있음</li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></li><li><a href=https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map>https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map</a></li><li><a href=http://www.wirfs-brock.com/allen/posts/166>http://www.wirfs-brock.com/allen/posts/166</a></li><li><a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a></li><li><a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap</a></li><li><a href=https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/javascript/>Javascript</a></li><li><a href=https://blog.jsontapose.com/tags/array/>Array</a></li><li><a href=https://blog.jsontapose.com/tags/map/>Map</a></li><li><a href=https://blog.jsontapose.com/tags/functional-programming/>Functional-Programming</a></li><li><a href=https://blog.jsontapose.com/tags/es5/>Es5</a></li><li><a href=https://blog.jsontapose.com/tags/browser-compatibility/>Browser-Compatibility</a></li><li><a href=https://blog.jsontapose.com/tags/tips/>Tips</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/><span class=title>« Prev</span><br><span>a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer</span>
</a><a class=next href=https://blog.jsontapose.com/posts/css-media-queries-prefers-color-scheme-9b1dbe/><span class=title>Next »</span><br><span>CSS 미디어 쿼리 기본기와 prefers-color-scheme 적용</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on x" href="https://x.com/intent/tweet/?text=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f&amp;hashtags=javascript%2carray%2cmap%2cfunctional-programming%2ces5%2cbrowser-compatibility%2ctips"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f&amp;title=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4&amp;summary=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f&title=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on whatsapp" href="https://api.whatsapp.com/send?text=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on telegram" href="https://telegram.me/share/url?text=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴 on ycombinator" href="https://news.ycombinator.com/submitlink?t=JavaScript%20Array.prototype.map%20%ec%99%84%ec%a0%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%3a%20%eb%8f%99%ec%9e%91%20%ec%9b%90%eb%a6%ac%2c%20%ec%a3%bc%ec%9d%98%ec%a0%90%2c%20%ec%8b%a4%ec%a0%84%20%ed%8c%a8%ed%84%b4&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-array-prototype-map-guide-17b880%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>