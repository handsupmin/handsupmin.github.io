<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>pnpm 설치 방식과 워크스페이스 사용법 | HandsLog</title>
<meta name=keywords content="pnpm,npm,패키지매니저,워크스페이스"><meta name=description content="서문
pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.
개념 및 배경
pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음."><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/pnpm/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/pnpm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/pnpm/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="pnpm 설치 방식과 워크스페이스 사용법"><meta property="og:description" content="서문 pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.
개념 및 배경 pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-20T16:44:51+00:00"><meta property="article:modified_time" content="2025-09-20T16:44:51+00:00"><meta property="article:tag" content="Pnpm"><meta property="article:tag" content="Npm"><meta property="article:tag" content="패키지매니저"><meta property="article:tag" content="워크스페이스"><meta name=twitter:card content="summary"><meta name=twitter:title content="pnpm 설치 방식과 워크스페이스 사용법"><meta name=twitter:description content="서문
pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.
개념 및 배경
pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"pnpm 설치 방식과 워크스페이스 사용법","item":"https://handsupmin.github.io/posts/pnpm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"pnpm 설치 방식과 워크스페이스 사용법","name":"pnpm 설치 방식과 워크스페이스 사용법","description":"서문 pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.\n개념 및 배경 pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음.\n","keywords":["pnpm","npm","패키지매니저","워크스페이스"],"articleBody":"서문 pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.\n개념 및 배경 pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음.\n폴더 예시는 다음과 같음\nmy-project/ │ ├── node_modules/ # 프로젝트 내 의존성 패키지 경로 (심볼릭 링크 포함) │ ├── express -\u003e ~/.pnpm-store//node_modules/express │ └── react -\u003e ~/.pnpm-store//node_modules/react ├── package.json └── pnpm-lock.yaml 사용법 및 동작 예시 로컬 설치 명령: pnpm install express 동작: 현재 프로젝트에만 의존성 선언 및 node_modules의 심볼릭 링크 생성 전역 설치 명령: pnpm add -g typescript 동작: 시스템 전역으로 사용 가능한 바이너리/패키지 설치, 글로벌 경로는 일반적으로 ~/.local/share/pnpm (Mac/Linux 기준) 서브디렉터리 설치 서브디렉터리에 package.json이 있으면 해당 위치에서 pnpm install을 실행하면 그 디렉터리 기준으로 설치가 이루어짐 워크스페이스 루트에 pnpm-workspace.yaml을 두고 packages 경로를 지정하면 여러 서브패키지가 의존성을 공유하거나 직접 참조 가능 예시 설정: packages: - \"packages/*\" 워크스페이스 사용 시 공통 의존성은 글로벌 저장소에 한 번만 저장되고, 각 패키지의 node_modules는 필요한 링크만 가리키도록 구성됨. 로컬 개발 시 패키지 간 참조를 쉽게 처리할 수 있어 모노레포 관리에 유리함.\n마무리 pnpm은 프로젝트별 독립 설치 정책을 유지하면서도 글로벌 저장소와 심볼릭 링크 구조로 중복 저장을 제거해 실무에서 디스크 사용과 설치 시간을 절감함. 워크스페이스 기능을 활용하면 모노레포 환경에서 의존성 관리와 패키지 간 연동 작업이 간편해짐. 기존 npm 사용 패턴과 큰 차이 없이 도입 가능하므로, 디스크 효율이나 대규모 레포 관리가 필요할 때 우선 고려 대상임.\n참고자료 https://pnpm.io/ https://pnpm.io/workspaces ","wordCount":"280","inLanguage":"en","datePublished":"2025-09-20T16:44:51.556Z","dateModified":"2025-09-20T16:44:51.556Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/pnpm/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">pnpm 설치 방식과 워크스페이스 사용법</h1><div class=post-meta><span title='2025-09-20 16:44:51.556 +0000 UTC'>September 20, 2025</span></div></header><div class=post-content><h3 id=서문>서문<a hidden class=anchor aria-hidden=true href=#서문>#</a></h3><p>pnpm은 npm과 유사한 CLI를 제공하면서도 의존성 저장 구조에서 차별점을 둔 패키지 매니저입니다. 대규모 모노레포나 여러 프로젝트를 동시에 관리할 때 중복 패키지로 인한 디스크 낭비를 줄이고 설치 속도를 개선하는 것이 목적입니다. 이 글은 pnpm의 설치 동작 원리와 워크스페이스 활용 방법을 실무 관점에서 정리합니다.</p><h3 id=개념-및-배경>개념 및 배경<a hidden class=anchor aria-hidden=true href=#개념-및-배경>#</a></h3><p>pnpm은 기본적으로 각 프로젝트의 package.json에 정의된 의존성만 설치합니다. 그러나 실제 패키지 파일은 사용자의 전용 글로벌 저장소(예: ~/.pnpm-store)에 다운로드되어 보관됩니다. 프로젝트의 node_modules에는 실제 파일 대신 글로벌 저장소의 패키지로 향하는 심볼릭 링크가 생성됩니다. 이 구조 덕분에 동일한 패키지가 여러 프로젝트에서 필요할 때 물리적 복제가 발생하지 않음.</p><p>폴더 예시는 다음과 같음</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>my-project/
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>├── node_modules/        # 프로젝트 내 의존성 패키지 경로 (심볼릭 링크 포함)
</span></span><span style=display:flex><span>│   ├── express -&gt; ~/.pnpm-store/&lt;hash&gt;/node_modules/express
</span></span><span style=display:flex><span>│   └── react -&gt; ~/.pnpm-store/&lt;hash&gt;/node_modules/react
</span></span><span style=display:flex><span>├── package.json
</span></span><span style=display:flex><span>└── pnpm-lock.yaml
</span></span></code></pre></div><h3 id=사용법-및-동작-예시>사용법 및 동작 예시<a hidden class=anchor aria-hidden=true href=#사용법-및-동작-예시>#</a></h3><ul><li>로컬 설치<ul><li>명령: pnpm install express</li><li>동작: 현재 프로젝트에만 의존성 선언 및 node_modules의 심볼릭 링크 생성</li></ul></li><li>전역 설치<ul><li>명령: pnpm add -g typescript</li><li>동작: 시스템 전역으로 사용 가능한 바이너리/패키지 설치, 글로벌 경로는 일반적으로 ~/.local/share/pnpm (Mac/Linux 기준)</li></ul></li><li>서브디렉터리 설치<ul><li>서브디렉터리에 package.json이 있으면 해당 위치에서 pnpm install을 실행하면 그 디렉터리 기준으로 설치가 이루어짐</li></ul></li><li>워크스페이스<ul><li>루트에 pnpm-workspace.yaml을 두고 packages 경로를 지정하면 여러 서브패키지가 의존성을 공유하거나 직접 참조 가능</li><li>예시 설정:</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>packages</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;packages/*&#34;</span>
</span></span></code></pre></div><p>워크스페이스 사용 시 공통 의존성은 글로벌 저장소에 한 번만 저장되고, 각 패키지의 node_modules는 필요한 링크만 가리키도록 구성됨. 로컬 개발 시 패키지 간 참조를 쉽게 처리할 수 있어 모노레포 관리에 유리함.</p><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>pnpm은 프로젝트별 독립 설치 정책을 유지하면서도 글로벌 저장소와 심볼릭 링크 구조로 중복 저장을 제거해 실무에서 디스크 사용과 설치 시간을 절감함. 워크스페이스 기능을 활용하면 모노레포 환경에서 의존성 관리와 패키지 간 연동 작업이 간편해짐. 기존 npm 사용 패턴과 큰 차이 없이 도입 가능하므로, 디스크 효율이나 대규모 레포 관리가 필요할 때 우선 고려 대상임.</p><h2 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h2><ul><li><a href=https://pnpm.io/>https://pnpm.io/</a></li><li><a href=https://pnpm.io/workspaces>https://pnpm.io/workspaces</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/pnpm/>Pnpm</a></li><li><a href=https://handsupmin.github.io/tags/npm/>Npm</a></li><li><a href=https://handsupmin.github.io/tags/%ED%8C%A8%ED%82%A4%EC%A7%80%EB%A7%A4%EB%8B%88%EC%A0%80/>패키지매니저</a></li><li><a href=https://handsupmin.github.io/tags/%EC%9B%8C%ED%81%AC%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/>워크스페이스</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>