<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 | HandsLog</title>
<meta name=keywords content="블록체인,머클트리,Merkle Tree,데이터구조,라이트노드"><meta name=description content="개요
머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함

핵심 개념과 구조

머클트리는 보통 이진 트리 형태로 구현함
거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음
해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함
최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨
리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함
트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음


동작 원리와 장점

인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음
무결성 검증
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음
효율적 포함 증명
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨
필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음
확장성 보조
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함


블록 헤더와 경량 노드(SPV)

비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함
경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함
이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨
이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함


구현 세부와 체인별 차이


비트코인"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"><meta property="og:description" content="개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함
핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-20T17:15:26+00:00"><meta property="article:modified_time" content="2025-09-20T17:15:26+00:00"><meta property="article:tag" content="블록체인"><meta property="article:tag" content="머클트리"><meta property="article:tag" content="Merkle Tree"><meta property="article:tag" content="데이터구조"><meta property="article:tag" content="라이트노드"><meta name=twitter:card content="summary"><meta name=twitter:title content="머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"><meta name=twitter:description content="개요
머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함

핵심 개념과 구조

머클트리는 보통 이진 트리 형태로 구현함
거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음
해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함
최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨
리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함
트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음


동작 원리와 장점

인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음
무결성 검증
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음
효율적 포함 증명
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨
필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음
확장성 보조
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함


블록 헤더와 경량 노드(SPV)

비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함
경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함
이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨
이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함


구현 세부와 체인별 차이


비트코인"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","item":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","name":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","description":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n","keywords":["블록체인","머클트리","Merkle Tree","데이터구조","라이트노드"],"articleBody":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u003e\u003e= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","wordCount":"751","inLanguage":"en","datePublished":"2025-09-20T17:15:26.218Z","dateModified":"2025-09-20T17:15:26.218Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://handsupmin.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://handsupmin.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://handsupmin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://handsupmin.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</h1><div class=post-meta><span title='2025-09-20 17:15:26.218 +0000 UTC'>September 20, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>머클트리는 블록체인에서 거래 집합을 <strong>안전하고 효율적으로 요약·검증</strong>하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 <strong>고정 크기 해시 하나</strong>로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함</p><hr><h3 id=핵심-개념과-구조>핵심 개념과 구조<a hidden class=anchor aria-hidden=true href=#핵심-개념과-구조>#</a></h3><ul><li>머클트리는 보통 <strong>이진 트리</strong> 형태로 구현함</li><li>거래들을 <strong>리프(leaf)</strong> 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 <strong>루트 해시</strong>를 얻음</li><li>해시 함수는 체인별로 다르며 비트코인은 <strong>더블 SHA‑256</strong>, 이더리움은 트라이 구조에서 <strong>Keccak‑256</strong> 을 사용함</li><li>최상단 해시를 <strong>머클루트(Merkle root)</strong> 라 부르며 크기는 해시 함수에 따라 고정됨</li><li>리프 수가 홀수일 때는 마지막 리프를 <strong>복제해 짝을 맞추는 방식</strong>이 일반적이며 비트코인은 이 규칙을 사용함</li><li>트리 깊이는 리프 수 N에 대해 <strong>⌈log₂ N⌉</strong> 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음</li></ul><hr><h3 id=동작-원리와-장점>동작 원리와 장점<a hidden class=anchor aria-hidden=true href=#동작-원리와-장점>#</a></h3><ul><li>인접 노드 해시 <strong>H_left || H_right</strong> 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음</li><li><strong>무결성 검증</strong>
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음</li><li><strong>효율적 포함 증명</strong>
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 <strong>형제 해시들만</strong> 있으면 됨
필요한 해시 개수는 <strong>O(log N)</strong> 으로 작아 대역폭과 검증 비용이 작음</li><li><strong>확장성 보조</strong>
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함</li></ul><hr><h3 id=블록-헤더와-경량-노드spv>블록 헤더와 경량 노드(SPV)<a hidden class=anchor aria-hidden=true href=#블록-헤더와-경량-노드spv>#</a></h3><ul><li>비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함</li><li>경량 노드(SPV)는 <strong>블록 전체가 아니라 헤더 체인만</strong> 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 <strong>머클 증명</strong> 을 받아 포함 여부를 검증함</li><li>이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨</li><li>이더리움은 전통적인 이진 머클트리 대신 <strong>머클‑패트리샤 트라이(MPT)</strong> 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함</li></ul><hr><h3 id=구현-세부와-체인별-차이>구현 세부와 체인별 차이<a hidden class=anchor aria-hidden=true href=#구현-세부와-체인별-차이>#</a></h3><ul><li><p><strong>비트코인</strong></p><ul><li>리프는 거래 직렬화의 <strong>더블 SHA‑256</strong> 해시이며 내부 노드도 자식 두 해시를 <strong>더블 SHA‑256</strong> 으로 결합함</li><li>리프가 홀수면 마지막 해시를 <strong>복제</strong> 해 상위로 올림</li><li>과거 <strong>중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크</strong> 가 보고되어 소프트웨어에서 감지 플래그로 방지함</li><li>엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐</li></ul></li><li><p><strong>이더리움</strong></p><ul><li>거래·영수증·상태는 <strong>MPT</strong> 로 관리되며 노드 해시는 <strong>Keccak‑256</strong> 임</li><li>구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함</li></ul></li></ul><hr><h3 id=머클-증명과-검증-절차>머클 증명과 검증 절차<a hidden class=anchor aria-hidden=true href=#머클-증명과-검증-절차>#</a></h3><ul><li><p>입력 요소</p><ul><li>대상 거래의 해시 또는 리프 값</li><li>루트까지 올라가는 경로의 <strong>형제 해시 리스트</strong></li><li>각 단계에서 왼쪽·오른쪽 위치를 나타내는 <strong>인덱스 또는 방향 정보</strong></li></ul></li><li><p>검증 절차</p><ul><li>리프에서 시작해 단계별로 형제 해시와 <strong>정확한 순서</strong> 로 결합하며 상위 해시를 계산</li><li>최종 계산값이 블록 헤더의 머클루트와 <strong>일치하면 포함이 성립</strong></li></ul></li></ul><p>아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sha256d</span>(b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hashlib<span style=color:#f92672>.</span>sha256(hashlib<span style=color:#f92672>.</span>sha256(b)<span style=color:#f92672>.</span>digest())<span style=color:#f92672>.</span>digest()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_merkle_proof</span>(leaf, proof, root, index, double_hash<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>    h <span style=color:#f92672>=</span> sha256d(leaf) <span style=color:#66d9ef>if</span> double_hash <span style=color:#66d9ef>else</span> leaf
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> sibling <span style=color:#f92672>in</span> proof:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:      <span style=color:#75715e># left child</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> sha256d(h <span style=color:#f92672>+</span> sibling)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:                    <span style=color:#75715e># right child</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> sha256d(sibling <span style=color:#f92672>+</span> h)
</span></span><span style=display:flex><span>        index <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h <span style=color:#f92672>==</span> root
</span></span></code></pre></div><p>코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함</p><hr><h3 id=실무적-고려사항>실무적 고려사항<a hidden class=anchor aria-hidden=true href=#실무적-고려사항>#</a></h3><ul><li><strong>직렬화 규약 일치</strong>
체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐</li><li><strong>해시 결합 순서 고정</strong>
반드시 <strong>왼쪽 먼저, 오른쪽 다음</strong> 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴</li><li><strong>홀수 리프 처리 방식 확인</strong>
복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요</li><li><strong>머클 증명의 한계</strong>
포함 여부만 증명하며 거래의 <strong>유효성</strong> 자체는 별도 검증이 필요함
비포함 증명이나 동적 집합 갱신에는 <strong>스파스 머클트리</strong> 또는 <strong>벡터 커밋먼트</strong> 같은 다른 구조가 더 적합함</li><li><strong>멀티프루프와 배치 검증</strong>
여러 거래를 한꺼번에 검증할 때 <strong>공유 경로를 묶는 멀티프루프</strong> 를 사용하면 전송량과 검증 비용을 줄일 수 있음</li><li><strong>보안과 신뢰 경계</strong>
SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함
운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함</li></ul><hr><h3 id=실전-적용-시나리오>실전 적용 시나리오<a hidden class=anchor aria-hidden=true href=#실전-적용-시나리오>#</a></h3><ul><li><strong>모바일 지갑</strong>
헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함</li><li><strong>인덱싱 서비스</strong>
특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 <strong>정확한 포함</strong> 을 첨부해 무결성을 보장함</li><li><strong>브리지·크로스체인 메시지</strong>
원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임</li><li><strong>감사·포렌식</strong>
오프체인 데이터 스냅샷에 머클 루트를 부여해 <strong>변조 불가 로그</strong> 로 관리하고 분쟁 시 증명으로 활용함</li></ul><hr><h3 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h3><p>머클트리는 <strong>트리 기반 해싱</strong> 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 <strong>O(log N)</strong> 크기의 증명만으로 포함을 검증하게 해주는 구조임
비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함
현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>Bitcoin Developer Guide Merkle Trees
<a href=https://developer.bitcoin.org/devguide/merkle_trees>https://developer.bitcoin.org/devguide/merkle_trees</a></li><li>Bitcoin Wiki Merkle tree
<a href=https://en.bitcoin.it/wiki/Merkle_tree>https://en.bitcoin.it/wiki/Merkle_tree</a></li><li>Ethereum Docs Merkle Patricia Trie
<a href=https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie>https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie</a></li><li>Wikipedia Merkle tree
<a href=https://en.wikipedia.org/wiki/Merkle_tree>https://en.wikipedia.org/wiki/Merkle_tree</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/>블록체인</a></li><li><a href=https://handsupmin.github.io/tags/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC/>머클트리</a></li><li><a href=https://handsupmin.github.io/tags/merkle-tree/>Merkle Tree</a></li><li><a href=https://handsupmin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0/>데이터구조</a></li><li><a href=https://handsupmin.github.io/tags/%EB%9D%BC%EC%9D%B4%ED%8A%B8%EB%85%B8%EB%93%9C/>라이트노드</a></li></ul><nav class=paginav><a class=prev href=https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/><span class=title>« Prev</span><br><span>재귀적 영지식 증명이란? (Recursion ZKP)</span>
</a><a class=next href=https://handsupmin.github.io/posts/ethereum-pos-proof-of-stake-274b74/><span class=title>Next »</span><br><span>이더리움 PoS(Proof of Stake) 소개</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on x" href="https://x.com/intent/tweet/?text=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f&amp;hashtags=%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%2c%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%2cMerkleTree%2c%eb%8d%b0%ec%9d%b4%ed%84%b0%ea%b5%ac%ec%a1%b0%2c%eb%9d%bc%ec%9d%b4%ed%8a%b8%eb%85%b8%eb%93%9c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f&amp;title=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0&amp;summary=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0&amp;source=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f&title=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on whatsapp" href="https://api.whatsapp.com/send?text=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0%20-%20https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on telegram" href="https://telegram.me/share/url?text=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%28Merkle%20Tree%29%eb%9e%80%3f%20%eb%a8%b8%ed%81%b4%ed%8a%b8%eb%a6%ac%ec%9d%98%20%ea%b0%9c%eb%85%90%ea%b3%bc%20%eb%b8%94%eb%a1%9d%ec%b2%b4%ec%9d%b8%ec%97%90%ec%84%9c%ec%9d%98%20%ec%97%ad%ed%95%a0&u=https%3a%2f%2fhandsupmin.github.io%2fposts%2fmerkle-tree-blockchain-role-274b74%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>