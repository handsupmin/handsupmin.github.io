<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할 | HandsLog</title>
<meta name=keywords content="블록체인,머클트리,Merkle Tree,데이터구조,라이트노드"><meta name=description content="개요
머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함

핵심 개념과 구조

머클트리는 보통 이진 트리 형태로 구현함
거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음
해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함
최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨
리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함
트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음


동작 원리와 장점

인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음
무결성 검증
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음
효율적 포함 증명
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨
필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음
확장성 보조
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함


블록 헤더와 경량 노드(SPV)

비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함
경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함
이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨
이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함


구현 세부와 체인별 차이


비트코인"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"><meta property="og:description" content="개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함
핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-20T17:15:26+00:00"><meta property="article:modified_time" content="2025-09-20T17:15:26+00:00"><meta property="article:tag" content="블록체인"><meta property="article:tag" content="머클트리"><meta property="article:tag" content="Merkle Tree"><meta property="article:tag" content="데이터구조"><meta property="article:tag" content="라이트노드"><meta name=twitter:card content="summary"><meta name=twitter:title content="머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할"><meta name=twitter:description content="개요
머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함

핵심 개념과 구조

머클트리는 보통 이진 트리 형태로 구현함
거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음
해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함
최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨
리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함
트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음


동작 원리와 장점

인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음
무결성 검증
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음
효율적 포함 증명
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨
필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음
확장성 보조
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함


블록 헤더와 경량 노드(SPV)

비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함
경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함
이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨
이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함


구현 세부와 체인별 차이


비트코인"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","item":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","name":"머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할","description":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n","keywords":["블록체인","머클트리","Merkle Tree","데이터구조","라이트노드"],"articleBody":"개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함\n핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인\n리프는 거래 직렬화의 더블 SHA‑256 해시이며 내부 노드도 자식 두 해시를 더블 SHA‑256 으로 결합함 리프가 홀수면 마지막 해시를 복제 해 상위로 올림 과거 중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크 가 보고되어 소프트웨어에서 감지 플래그로 방지함 엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐 이더리움\n거래·영수증·상태는 MPT 로 관리되며 노드 해시는 Keccak‑256 임 구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함 머클 증명과 검증 절차 입력 요소\n대상 거래의 해시 또는 리프 값 루트까지 올라가는 경로의 형제 해시 리스트 각 단계에서 왼쪽·오른쪽 위치를 나타내는 인덱스 또는 방향 정보 검증 절차\n리프에서 시작해 단계별로 형제 해시와 정확한 순서 로 결합하며 상위 해시를 계산 최종 계산값이 블록 헤더의 머클루트와 일치하면 포함이 성립 아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함\nimport hashlib def sha256d(b): return hashlib.sha256(hashlib.sha256(b).digest()).digest() def verify_merkle_proof(leaf, proof, root, index, double_hash=True): h = sha256d(leaf) if double_hash else leaf for sibling in proof: if index \u0026 1 == 0: # left child h = sha256d(h + sibling) else: # right child h = sha256d(sibling + h) index \u003e\u003e= 1 return h == root 코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함\n실무적 고려사항 직렬화 규약 일치 체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐 해시 결합 순서 고정 반드시 왼쪽 먼저, 오른쪽 다음 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴 홀수 리프 처리 방식 확인 복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요 머클 증명의 한계 포함 여부만 증명하며 거래의 유효성 자체는 별도 검증이 필요함 비포함 증명이나 동적 집합 갱신에는 스파스 머클트리 또는 벡터 커밋먼트 같은 다른 구조가 더 적합함 멀티프루프와 배치 검증 여러 거래를 한꺼번에 검증할 때 공유 경로를 묶는 멀티프루프 를 사용하면 전송량과 검증 비용을 줄일 수 있음 보안과 신뢰 경계 SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함 운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함 실전 적용 시나리오 모바일 지갑 헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함 인덱싱 서비스 특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 정확한 포함 을 첨부해 무결성을 보장함 브리지·크로스체인 메시지 원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임 감사·포렌식 오프체인 데이터 스냅샷에 머클 루트를 부여해 변조 불가 로그 로 관리하고 분쟁 시 증명으로 활용함 정리 머클트리는 트리 기반 해싱 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 O(log N) 크기의 증명만으로 포함을 검증하게 해주는 구조임 비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함 현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함\n참고자료 Bitcoin Developer Guide Merkle Trees https://developer.bitcoin.org/devguide/merkle_trees Bitcoin Wiki Merkle tree https://en.bitcoin.it/wiki/Merkle_tree Ethereum Docs Merkle Patricia Trie https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie Wikipedia Merkle tree https://en.wikipedia.org/wiki/Merkle_tree ","wordCount":"751","inLanguage":"en","datePublished":"2025-09-20T17:15:26.218Z","dateModified":"2025-09-20T17:15:26.218Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/merkle-tree-blockchain-role-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</h1><div class=post-meta><span title='2025-09-20 17:15:26.218 +0000 UTC'>September 20, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>머클트리는 블록체인에서 거래 집합을 <strong>안전하고 효율적으로 요약·검증</strong>하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 <strong>고정 크기 해시 하나</strong>로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함</p><hr><h3 id=핵심-개념과-구조>핵심 개념과 구조<a hidden class=anchor aria-hidden=true href=#핵심-개념과-구조>#</a></h3><ul><li>머클트리는 보통 <strong>이진 트리</strong> 형태로 구현함</li><li>거래들을 <strong>리프(leaf)</strong> 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 <strong>루트 해시</strong>를 얻음</li><li>해시 함수는 체인별로 다르며 비트코인은 <strong>더블 SHA‑256</strong>, 이더리움은 트라이 구조에서 <strong>Keccak‑256</strong> 을 사용함</li><li>최상단 해시를 <strong>머클루트(Merkle root)</strong> 라 부르며 크기는 해시 함수에 따라 고정됨</li><li>리프 수가 홀수일 때는 마지막 리프를 <strong>복제해 짝을 맞추는 방식</strong>이 일반적이며 비트코인은 이 규칙을 사용함</li><li>트리 깊이는 리프 수 N에 대해 <strong>⌈log₂ N⌉</strong> 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음</li></ul><hr><h3 id=동작-원리와-장점>동작 원리와 장점<a hidden class=anchor aria-hidden=true href=#동작-원리와-장점>#</a></h3><ul><li>인접 노드 해시 <strong>H_left || H_right</strong> 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음</li><li><strong>무결성 검증</strong>
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음</li><li><strong>효율적 포함 증명</strong>
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 <strong>형제 해시들만</strong> 있으면 됨
필요한 해시 개수는 <strong>O(log N)</strong> 으로 작아 대역폭과 검증 비용이 작음</li><li><strong>확장성 보조</strong>
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함</li></ul><hr><h3 id=블록-헤더와-경량-노드spv>블록 헤더와 경량 노드(SPV)<a hidden class=anchor aria-hidden=true href=#블록-헤더와-경량-노드spv>#</a></h3><ul><li>비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함</li><li>경량 노드(SPV)는 <strong>블록 전체가 아니라 헤더 체인만</strong> 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 <strong>머클 증명</strong> 을 받아 포함 여부를 검증함</li><li>이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨</li><li>이더리움은 전통적인 이진 머클트리 대신 <strong>머클‑패트리샤 트라이(MPT)</strong> 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함</li></ul><hr><h3 id=구현-세부와-체인별-차이>구현 세부와 체인별 차이<a hidden class=anchor aria-hidden=true href=#구현-세부와-체인별-차이>#</a></h3><ul><li><p><strong>비트코인</strong></p><ul><li>리프는 거래 직렬화의 <strong>더블 SHA‑256</strong> 해시이며 내부 노드도 자식 두 해시를 <strong>더블 SHA‑256</strong> 으로 결합함</li><li>리프가 홀수면 마지막 해시를 <strong>복제</strong> 해 상위로 올림</li><li>과거 <strong>중복 거래로 동일 루트가 나올 수 있는 변형(mutated) 리스크</strong> 가 보고되어 소프트웨어에서 감지 플래그로 방지함</li><li>엔디언 처리와 직렬화 규약을 엄격히 맞추지 않으면 루트가 달라짐</li></ul></li><li><p><strong>이더리움</strong></p><ul><li>거래·영수증·상태는 <strong>MPT</strong> 로 관리되며 노드 해시는 <strong>Keccak‑256</strong> 임</li><li>구조와 증명 포맷이 이진 머클트리와 다르므로 구현 시 완전히 별도의 로직이 필요함</li></ul></li></ul><hr><h3 id=머클-증명과-검증-절차>머클 증명과 검증 절차<a hidden class=anchor aria-hidden=true href=#머클-증명과-검증-절차>#</a></h3><ul><li><p>입력 요소</p><ul><li>대상 거래의 해시 또는 리프 값</li><li>루트까지 올라가는 경로의 <strong>형제 해시 리스트</strong></li><li>각 단계에서 왼쪽·오른쪽 위치를 나타내는 <strong>인덱스 또는 방향 정보</strong></li></ul></li><li><p>검증 절차</p><ul><li>리프에서 시작해 단계별로 형제 해시와 <strong>정확한 순서</strong> 로 결합하며 상위 해시를 계산</li><li>최종 계산값이 블록 헤더의 머클루트와 <strong>일치하면 포함이 성립</strong></li></ul></li></ul><p>아래는 개념 확인용 파이썬 예시이며 비트코인의 더블 SHA‑256 결합을 가정함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> hashlib
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sha256d</span>(b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hashlib<span style=color:#f92672>.</span>sha256(hashlib<span style=color:#f92672>.</span>sha256(b)<span style=color:#f92672>.</span>digest())<span style=color:#f92672>.</span>digest()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_merkle_proof</span>(leaf, proof, root, index, double_hash<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>    h <span style=color:#f92672>=</span> sha256d(leaf) <span style=color:#66d9ef>if</span> double_hash <span style=color:#66d9ef>else</span> leaf
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> sibling <span style=color:#f92672>in</span> proof:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> index <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:      <span style=color:#75715e># left child</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> sha256d(h <span style=color:#f92672>+</span> sibling)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:                    <span style=color:#75715e># right child</span>
</span></span><span style=display:flex><span>            h <span style=color:#f92672>=</span> sha256d(sibling <span style=color:#f92672>+</span> h)
</span></span><span style=display:flex><span>        index <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> h <span style=color:#f92672>==</span> root
</span></span></code></pre></div><p>코드는 교육 목적의 단순화된 형태이며 실제 네트워크 구현은 직렬화 규약과 엔디언 변환, 오류 처리, 멀티프루프 등 추가 고려가 필요함</p><hr><h3 id=실무적-고려사항>실무적 고려사항<a hidden class=anchor aria-hidden=true href=#실무적-고려사항>#</a></h3><ul><li><strong>직렬화 규약 일치</strong>
체인별 바이트 순서와 직렬화 포맷을 정확히 맞추지 않으면 루트가 달라짐</li><li><strong>해시 결합 순서 고정</strong>
반드시 <strong>왼쪽 먼저, 오른쪽 다음</strong> 순서를 유지해야 하며 반대로 결합하면 다른 루트가 나옴</li><li><strong>홀수 리프 처리 방식 확인</strong>
복제 여부와 예외 처리 규칙이 구현마다 다를 수 있으니 사전 합의 필요</li><li><strong>머클 증명의 한계</strong>
포함 여부만 증명하며 거래의 <strong>유효성</strong> 자체는 별도 검증이 필요함
비포함 증명이나 동적 집합 갱신에는 <strong>스파스 머클트리</strong> 또는 <strong>벡터 커밋먼트</strong> 같은 다른 구조가 더 적합함</li><li><strong>멀티프루프와 배치 검증</strong>
여러 거래를 한꺼번에 검증할 때 <strong>공유 경로를 묶는 멀티프루프</strong> 를 사용하면 전송량과 검증 비용을 줄일 수 있음</li><li><strong>보안과 신뢰 경계</strong>
SPV는 포함 증명과 헤더 체인을 신뢰하지만 전체 상태 전이의 완전 검증은 풀노드가 담당함
운영 환경에서는 풀노드 다변화와 네트워크 지연 모니터링, 헤더 유효성 검사 정책을 병행해야 함</li></ul><hr><h3 id=실전-적용-시나리오>실전 적용 시나리오<a hidden class=anchor aria-hidden=true href=#실전-적용-시나리오>#</a></h3><ul><li><strong>모바일 지갑</strong>
헤더 동기화와 머클 증명으로 경량 송금 확인을 제공해 UX와 데이터 요건을 동시에 충족함</li><li><strong>인덱싱 서비스</strong>
특정 주소나 토큰 이벤트를 색인할 때 머클 증명으로 <strong>정확한 포함</strong> 을 첨부해 무결성을 보장함</li><li><strong>브리지·크로스체인 메시지</strong>
원체인의 포함 증명을 타 체인에서 검증해 메타데이터 신뢰를 높임</li><li><strong>감사·포렌식</strong>
오프체인 데이터 스냅샷에 머클 루트를 부여해 <strong>변조 불가 로그</strong> 로 관리하고 분쟁 시 증명으로 활용함</li></ul><hr><h3 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h3><p>머클트리는 <strong>트리 기반 해싱</strong> 으로 대량의 거래를 고정 크기 해시 하나로 요약하고 <strong>O(log N)</strong> 크기의 증명만으로 포함을 검증하게 해주는 구조임
비트코인처럼 단순 이진 머클트리와 이더리움의 MPT는 구현과 증명 포맷이 다르므로 목적에 맞는 구조를 선택해야 함
현업에서는 직렬화 규약과 결합 순서, 홀수 리프 처리, 증명 포맷 합의, SPV의 신뢰 경계를 명확히 하고 멀티프루프·스파스 구조 등 확장 기법을 상황에 맞게 채택하는 것이 중요함</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>Bitcoin Developer Guide Merkle Trees
<a href=https://developer.bitcoin.org/devguide/merkle_trees>https://developer.bitcoin.org/devguide/merkle_trees</a></li><li>Bitcoin Wiki Merkle tree
<a href=https://en.bitcoin.it/wiki/Merkle_tree>https://en.bitcoin.it/wiki/Merkle_tree</a></li><li>Ethereum Docs Merkle Patricia Trie
<a href=https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie>https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie</a></li><li>Wikipedia Merkle tree
<a href=https://en.wikipedia.org/wiki/Merkle_tree>https://en.wikipedia.org/wiki/Merkle_tree</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/>블록체인</a></li><li><a href=https://handsupmin.github.io/tags/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC/>머클트리</a></li><li><a href=https://handsupmin.github.io/tags/merkle-tree/>Merkle Tree</a></li><li><a href=https://handsupmin.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0/>데이터구조</a></li><li><a href=https://handsupmin.github.io/tags/%EB%9D%BC%EC%9D%B4%ED%8A%B8%EB%85%B8%EB%93%9C/>라이트노드</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>