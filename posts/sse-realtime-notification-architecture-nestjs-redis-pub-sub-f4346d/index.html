<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) | HandsLog</title>
<meta name=keywords content="sse,server-sent-events,redis,pub-sub,nestjs,kubernetes,real-time,backend-architecture"><meta name=description content="SSE(Server-Sent Events)란 무엇인가
SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임
주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함

SSE vs 웹소켓, 그리고 한계
SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)"><meta property="og:description" content="SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임
주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함
SSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-25T13:06:24+00:00"><meta property="article:modified_time" content="2025-10-25T13:06:24+00:00"><meta property="article:tag" content="Sse"><meta property="article:tag" content="Server-Sent-Events"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Pub-Sub"><meta property="article:tag" content="Nestjs"><meta property="article:tag" content="Kubernetes"><meta name=twitter:card content="summary"><meta name=twitter:title content="SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)"><meta name=twitter:description content="SSE(Server-Sent Events)란 무엇인가
SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임
주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함

SSE vs 웹소켓, 그리고 한계
SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)","item":"https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)","name":"SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)","description":"SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\n주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\nSSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\n","keywords":["sse","server-sent-events","redis","pub-sub","nestjs","kubernetes","real-time","backend-architecture"],"articleBody":"SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임\n주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함\nSSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함\n장점 간단한 구현 EventSource API(이 예제에선 안 썼지만)는 사용이 매우 간편하며 자동 재연결 기능까지 내장함. 서버 측도 기존 HTTP 서버에서 헤더 설정만 추가하면 됨 HTTP 친화적 (HTTP/2의 강력한 이점) HTTP/1.1의 한계: 브라우저는 동일 도메인당 최대 6개 연결 제한이 있어, SSE가 1개를 점유하면 다른 API 요청이 지연(Head-of-Line Blocking)될 수 있음 HTTP/2의 해결책: HTTP/2는 하나의 TCP 연결 내에서 여러 요청/응답을 스트림(Stream)으로 다중화(Multiplexing)함. 즉, SSE 연결(스트림 1)이 열려 있는 상태에서도 다른 API 요청(스트림 2, 3)이 동일한 TCP 연결을 통해 지연 없이 동시에 처리됨 결론: 프로덕션 환경에서는 6개 연결 제한 회피를 위해 HTTP/2 (HTTPS) 환경 구성을 강력히 권장함 유지보수 용이 프로토콜 자체가 단순하여 디버깅이나 유지보수가 웹소켓보다 쉬움 한계 단방향 통신 (One-way) 가장 큰 한계로, 오직 서버에서 클라이언트로만 데이터를 보낼 수 있음. 클라이언트가 서버로 데이터를 보내려면 별도의 fetch나 axios를 사용한 POST 요청이 필요함 연결 수 제한 (HTTP/1.1) 위에서 언급했듯이, HTTP/1.1 환경에서는 브라우저의 도메인당 연결 수 제한(보통 6개)에 영향을 받음 프로토콜: 표준 HTTP SSE는 웹소켓(WebSocket)처럼 ws:// 같은 별도의 프로토콜을 사용하지 않음 우리가 일반적으로 사용하는 표준 HTTP/1.1 (또는 HTTP/2) 프로토콜 위에서 동작함\n핵심 동작 원리는, 클라이언트의 최초 HTTP GET 요청에 대해 서버가 연결을 종료(close)하지 않고, 응답을 스트리밍하는 것임\nSSE 연결 (서버 측 설정) 클라이언트가 SSE 연결을 요청할 때(예: /events), 서버는 일반적인 HTML이나 JSON이 아닌, 이벤트 스트림임을 알리는 특정 HTTP 헤더로 응답해야 함\nContent-Type: text/event-stream (필수) Connection: keep-alive (연결 유지) Cache-Control: no-cache (중간 프록시나 브라우저가 응답을 캐시하지 않도록 방지) // Node.js (Express 예시) // npm install express import express from \"express\"; const app = express(); // 연결된 모든 클라이언트(res 객체)를 저장 const clients = new Set(); app.get(\"/events\", (req, res) =\u003e { // 1. SSE 연결을 위한 필수 헤더 설정 res.writeHead(200, { \"Content-Type\": \"text/event-stream\", Connection: \"keep-alive\", \"Cache-Control\": \"no-cache\", }); // 2. 연결된 클라이언트를 Set에 추가 clients.add(res); console.log(\"Client connected\"); // 3. 클라이언트가 연결을 끊었을 때의 처리 req.on(\"close\", () =\u003e { clients.delete(res); console.log(\"Client disconnected\"); }); }); app.listen(3000, () =\u003e console.log(\"SSE server listening on port 3000\")); SSE 연결 (클라이언트 측 - EventSource 미사용) 브라우저에는 EventSource라는 SSE 전용 API가 있지만, 여기서는 SSE가 HTTP 위에서 어떻게 동작하는지 명확히 보기 위해 fetch API의 스트리밍 기능을 사용함\nfetch를 사용하면 서버의 응답 바디(body)를 ReadableStream으로 받아 청크(chunk) 단위로 처리할 수 있음\n// Client-side (Browser JS) async function connectSSE() { let response; try { response = await fetch(\"http://localhost:3000/events\"); } catch (error) { console.error(\"Connection failed:\", error); return; } // 1. 응답 바디에서 ReadableStream의 리더(reader)를 가져옴 const reader = response.body.getReader(); // 2. 텍스트 디코더 준비 (바이너리 데이터를 UTF-8 텍스트로 변환) const decoder = new TextDecoder(); // 3. 스트림이 끝날 때(done)까지 무한 루프 while (true) { const { done, value } = await reader.read(); if (done) { console.log(\"Stream finished\"); break; // 서버가 연결을 종료함 } // 4. 수신된 바이너리 청크(value)를 텍스트로 디코딩 const rawChunk = decoder.decode(value); // (이후 이 청크를 파싱하는 로직이 필요함) parseStreamChunk(rawChunk); } } // (파싱 로직은 아래 '이벤트 파싱' 섹션 참고) connectSSE(); SSE 이벤트 형식과 송신 (서버 측) SSE는 정해진 텍스트 형식을 사용함. 가장 중요한 필드는 data:임 각 메시지는 두 번의 개행(\\n\\n)으로 구분됨\ndata: [보낼 데이터] (필수) event: [이벤트 이름] (옵션, 클라이언트가 이벤트를 구분할 때 사용) id: [메시지 ID] (옵션, 재연결 시 마지막 ID를 서버로 보냄) clients Set에 저장된 res 객체에 res.write()를 사용해 데이터를 전송함\n// Node.js (Express) - 서버 어디에서든 호출 가능 // 모든 연결된 클라이언트에게 브로드캐스트하는 함수 function broadcast(eventName, data) { // 1. (옵션) 'update'라는 이름의 이벤트를 지정 const message = `event: ${eventName}\\n` + // 2. (필수) 실제 데이터를 'data:' 필드에 담아 전송 `data: ${data}\\n` + // 3. (필수) 메시지의 끝을 알리는 개행 전송 `\\n`; for (const res of clients) { res.write(message); } } // 2초마다 모든 클라이언트에게 'update' 이벤트 전송 setInterval(() =\u003e { broadcast(\"update\", `This is message number ${Date.now()}`); }, 2000); JSON 데이터 전송 시 주의점 data: 필드가 여러 줄일 경우 파서는 이를 \\n으로 이어붙임 이는 JSON을 여러 줄의 data: 필드로 쪼개어 보내면 안 된다는 것을 의미함\n// 서버에서 JSON 전송 시 const payload = { user: \"test\", value: 123 }; // [Good ✅] JSON은 반드시 한 줄의 data 필드로 전송 broadcast(\"update\", JSON.stringify(payload)); // (전송되는 텍스트: 'event: update\\ndata: {\"user\":\"test\",\"value\":123}\\n\\n') // [Bad ❌] 아래와 같이 여러 data 라인에 걸쳐 JSON을 쪼개면 // res.write(`data: {\"user\": \"test\",\\n`) // res.write(`data: \"value\": 123}\\n\\n`) // 클라이언트 파서는 망가진 텍스트('{\"user\": \"test\",\\n\"value\": 123}')를 받게 되어 // JSON.parse()에서 오류가 발생함 SSE 이벤트 파싱 (클라이언트 측 - EventSource 미사용) 서버가 보낸 데이터 청크는 메시지 경계(\\n\\n)와 정확히 일치하지 않을 수 있음 따라서 클라이언트는 데이터를 버퍼(buffer)에 쌓아두고, 메시지 구분자(\\n\\n)가 나타날 때마다 파싱해야 함\n// Client-side (Browser JS) let buffer = \"\"; // 수신된 청크를 임시 저장할 버퍼 // connectSSE()의 read() 루프에서 호출되는 함수 function parseStreamChunk(rawChunk) { // 1. 버퍼에 새로 수신된 청크를 추가 buffer += rawChunk; // 2. 버퍼에서 메시지 구분자(\\n\\n)를 찾음 let boundary = buffer.indexOf(\"\\n\\n\"); // 3. 구분자가 존재하면 (즉, 메시지가 하나 이상 완성되면) while (boundary !== -1) { // 4. 완성된 메시지 한 개를 추출 (구분자 앞까지) const rawMessage = buffer.substring(0, boundary); // 5. 버퍼에서 처리된 메시지+구분자 제거 buffer = buffer.substring(boundary + 2); // 6. 추출한 메시지 파싱 parseMessage(rawMessage); // 7. 버퍼에 또 다른 메시지가 있는지 확인 boundary = buffer.indexOf(\"\\n\\n\"); } } // 수신된 raw 메시지를 파싱하는 헬퍼 함수 function parseMessage(rawMessage) { const lines = rawMessage.split(\"\\n\"); let eventType = \"message\"; // event: 필드가 없으면 기본값 'message' let eventData = \"\"; for (const line of lines) { if (line.startsWith(\"event:\")) { eventType = line.substring(6).trim(); } else if (line.startsWith(\"data:\")) { // data 필드가 여러 줄일 경우를 대비해 (JSON이 아닌 경우) eventData += line.substring(5).trim(); } } if (eventData) { console.log(`[Event Received] Type: ${eventType}, Data: ${eventData}`); // 여기서 DOM을 업데이트하거나 알림을 표시하는 등 실제 작업 수행 } } 하트비트 (Heartbeat) 일부 프록시 서버나 방화벽은 일정 시간 동안 데이터 전송이 없으면 해당 연결을 유휴(idle) 상태로 간주하고 강제로 종료할 수 있음 이를 방지하기 위해 서버는 주기적으로 의미 없는 데이터(주석)를 보내 연결이 살아있음을 알려야 함. 이를 하트비트라고 함\nSSE 스펙에서 콜론(:)으로 시작하는 라인은 주석으로 취급되며 클라이언트에서 무시됨\n// Node.js (Express) - 서버 측 // 15초마다 하트비트 전송 setInterval(() =\u003e { // : 주석은 클라이언트의 message 이벤트로 전달되지 않음 const heartbeatMessage = \": heartbeat\\n\\n\"; for (const res of clients) { res.write(heartbeatMessage); } }, 15000); 클라이언트 측에서는 parseMessage 함수가 event:나 data:가 아닌 라인을 무시하므로 별도 코드가 필요 없음\n서버에서 특정 연결 강제 종료 인증 만료, 중복 로그인 등의 이유로 서버가 특정 사용자의 연결을 선별적으로 종료해야 할 수 있음\n// Node.js (Express) - /events 핸들러 app.get(\"/events\", (req, res) =\u003e { // ... 헤더 설정 ... // (실제로는 JWT 등에서 파싱한 ID) res.locals.userId = \"user-\" + Math.floor(Math.random() * 1000); clients.add(res); req.on(\"close\", () =\u003e { clients.delete(res); }); }); // (어드민 API 등) 특정 사용자를 종료시켜야 할 때 function kickUser(userIdToKick, reason) { for (const res of clients) { if (res.locals.userId === userIdToKick) { // 1. 클라이언트가 처리할 수 있는 에러 이벤트를 전송 const message = `event: error\\ndata: ${JSON.stringify({ code: \"KICKED\", reason: reason, })}\\n\\n`; res.write(message); // 2. 스트림을 정상적으로 종료 (클라이언트의 req.on('close')가 호출됨) res.end(); console.log(`Kicked user: ${userIdToKick}`); break; } } } // 예시: 5초 뒤 특정 유저 강제 종료 setTimeout(() =\u003e { // (실제로는 ID를 특정해야 함) if (clients.size \u003e 0) { const userToKick = clients.values().next().value.locals.userId; kickUser(userToKick, \"Session expired\"); } }, 5000); 마무리 SSE는 단방향 실시간 데이터(알림, 시세, 피드) 전송이 필요할 때 구현이 간단하고 효율적인 훌륭한 선택지임\n반면, 채팅이나 실시간 온라인 게임처럼 클라이언트와 서버가 지속적으로 데이터를 주고받는 양방향 통신이 필수적이라면 웹소켓이 적합함\n프로젝트의 요구사항을 명확히 파악하고, 단방향인지 양방향인지를 기준으로 적절한 기술 스펙을 고르는 것이 중요함\n참고자료 MDN - Server-Sent Events 사용하기 https://developer.mozilla.org/ko/docs/Web/API/Server-Sent_Events/Using_Server-Sent_Events WHATWG - Server-Sent Events 스펙 https://html.spec.whatwg.org/multipage/server-sent-events.html ","wordCount":"1259","inLanguage":"en","datePublished":"2025-10-25T13:06:24.493Z","dateModified":"2025-10-25T13:06:24.493Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://handsupmin.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://handsupmin.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://handsupmin.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://handsupmin.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)</h1><div class=post-meta><span title='2025-10-25 13:06:24.493 +0000 UTC'>October 25, 2025</span></div></header><div class=post-content><h1 id=sseserver-sent-events란-무엇인가>SSE(Server-Sent Events)란 무엇인가<a hidden class=anchor aria-hidden=true href=#sseserver-sent-events란-무엇인가>#</a></h1><p>SSE는 <strong>Server-Sent Events</strong>의 약자로, 서버가 클라이언트로 <strong>실시간 데이터를 단방향으로 푸시</strong>(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임</p><p>주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함</p><hr><h2 id=sse-vs-웹소켓-그리고-한계>SSE vs 웹소켓, 그리고 한계<a hidden class=anchor aria-hidden=true href=#sse-vs-웹소켓-그리고-한계>#</a></h2><p>SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함</p><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ul><li><strong>간단한 구현</strong>
<code>EventSource</code> API(이 예제에선 안 썼지만)는 사용이 매우 간편하며 자동 재연결 기능까지 내장함. 서버 측도 기존 HTTP 서버에서 헤더 설정만 추가하면 됨</li><li><strong>HTTP 친화적 (HTTP/2의 강력한 이점)</strong><ul><li><strong>HTTP/1.1의 한계</strong>: 브라우저는 동일 도메인당 최대 6개 연결 제한이 있어, SSE가 1개를 점유하면 다른 API 요청이 지연(Head-of-Line Blocking)될 수 있음</li><li><strong>HTTP/2의 해결책</strong>: HTTP/2는 하나의 TCP 연결 내에서 여러 요청/응답을 <strong>스트림</strong>(Stream)으로 다중화(Multiplexing)함. 즉, SSE 연결(스트림 1)이 열려 있는 상태에서도 다른 API 요청(스트림 2, 3)이 동일한 TCP 연결을 통해 지연 없이 동시에 처리됨</li><li><strong>결론</strong>: 프로덕션 환경에서는 6개 연결 제한 회피를 위해 <strong>HTTP/2 (HTTPS) 환경 구성</strong>을 강력히 권장함</li></ul></li><li><strong>유지보수 용이</strong>
프로토콜 자체가 단순하여 디버깅이나 유지보수가 웹소켓보다 쉬움</li></ul><h3 id=한계>한계<a hidden class=anchor aria-hidden=true href=#한계>#</a></h3><ul><li><strong>단방향 통신 (One-way)</strong>
가장 큰 한계로, 오직 <strong>서버에서 클라이언트로</strong>만 데이터를 보낼 수 있음. 클라이언트가 서버로 데이터를 보내려면 별도의 <code>fetch</code>나 <code>axios</code>를 사용한 POST 요청이 필요함</li><li><strong>연결 수 제한 (HTTP/1.1)</strong>
위에서 언급했듯이, HTTP/1.1 환경에서는 브라우저의 도메인당 연결 수 제한(보통 6개)에 영향을 받음</li></ul><hr><h2 id=프로토콜-표준-http>프로토콜: 표준 HTTP<a hidden class=anchor aria-hidden=true href=#프로토콜-표준-http>#</a></h2><p>SSE는 웹소켓(WebSocket)처럼 <code>ws://</code> 같은 별도의 프로토콜을 사용하지 않음
우리가 일반적으로 사용하는 <strong>표준 HTTP/1.1</strong> (또는 HTTP/2) 프로토콜 위에서 동작함</p><p>핵심 동작 원리는, 클라이언트의 <strong>최초 HTTP GET 요청</strong>에 대해 서버가 연결을 종료(<code>close</code>)하지 않고, <strong>응답을 스트리밍</strong>하는 것임</p><hr><h2 id=sse-연결-서버-측-설정>SSE 연결 (서버 측 설정)<a hidden class=anchor aria-hidden=true href=#sse-연결-서버-측-설정>#</a></h2><p>클라이언트가 SSE 연결을 요청할 때(예: <code>/events</code>), 서버는 일반적인 HTML이나 JSON이 아닌, 이벤트 스트림임을 알리는 특정 HTTP 헤더로 응답해야 함</p><ul><li><code>Content-Type: text/event-stream</code> (필수)</li><li><code>Connection: keep-alive</code> (연결 유지)</li><li><code>Cache-Control: no-cache</code> (중간 프록시나 브라우저가 응답을 캐시하지 않도록 방지)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Node.js (Express 예시)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// npm install express
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>express</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;express&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>express</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 연결된 모든 클라이언트(res 객체)를 저장
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clients</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Set</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/events&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. SSE 연결을 위한 필수 헤더 설정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>writeHead</span>(<span style=color:#ae81ff>200</span>, {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Content-Type&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;text/event-stream&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Connection</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;keep-alive&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Cache-Control&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;no-cache&#34;</span>,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. 연결된 클라이언트를 Set에 추가
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>clients</span>.<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>res</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Client connected&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. 클라이언트가 연결을 끊었을 때의 처리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;close&#34;</span>, () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>clients</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>res</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Client disconnected&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>3000</span>, () =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;SSE server listening on port 3000&#34;</span>));
</span></span></code></pre></div><hr><h2 id=sse-연결-클라이언트-측---eventsource-미사용>SSE 연결 (클라이언트 측 - EventSource 미사용)<a hidden class=anchor aria-hidden=true href=#sse-연결-클라이언트-측---eventsource-미사용>#</a></h2><p>브라우저에는 <code>EventSource</code>라는 SSE 전용 API가 있지만, 여기서는 SSE가 HTTP 위에서 어떻게 동작하는지 명확히 보기 위해 <code>fetch</code> API의 스트리밍 기능을 사용함</p><p><code>fetch</code>를 사용하면 서버의 응답 바디(body)를 <code>ReadableStream</code>으로 받아 청크(chunk) 단위로 처리할 수 있음</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Client-side (Browser JS)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>connectSSE</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>response</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#34;http://localhost:3000/events&#34;</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Connection failed:&#34;</span>, <span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. 응답 바디에서 ReadableStream의 리더(reader)를 가져옴
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>reader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>body</span>.<span style=color:#a6e22e>getReader</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. 텍스트 디코더 준비 (바이너리 데이터를 UTF-8 텍스트로 변환)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>decoder</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TextDecoder</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. 스트림이 끝날 때(done)까지 무한 루프
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>done</span>, <span style=color:#a6e22e>value</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>reader</span>.<span style=color:#a6e22e>read</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>done</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Stream finished&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// 서버가 연결을 종료함
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 수신된 바이너리 청크(value)를 텍스트로 디코딩
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rawChunk</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>decoder</span>.<span style=color:#a6e22e>decode</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// (이후 이 청크를 파싱하는 로직이 필요함)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>parseStreamChunk</span>(<span style=color:#a6e22e>rawChunk</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// (파싱 로직은 아래 &#39;이벤트 파싱&#39; 섹션 참고)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>connectSSE</span>();
</span></span></code></pre></div><hr><h2 id=sse-이벤트-형식과-송신-서버-측>SSE 이벤트 형식과 송신 (서버 측)<a hidden class=anchor aria-hidden=true href=#sse-이벤트-형식과-송신-서버-측>#</a></h2><p>SSE는 정해진 텍스트 형식을 사용함. 가장 중요한 필드는 <code>data:</code>임
각 메시지는 <strong>두 번의 개행</strong>(<code>\n\n</code>)으로 구분됨</p><ul><li><code>data: [보낼 데이터]</code> (필수)</li><li><code>event: [이벤트 이름]</code> (옵션, 클라이언트가 이벤트를 구분할 때 사용)</li><li><code>id: [메시지 ID]</code> (옵션, 재연결 시 마지막 ID를 서버로 보냄)</li></ul><p><code>clients</code> Set에 저장된 <code>res</code> 객체에 <code>res.write()</code>를 사용해 데이터를 전송함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Node.js (Express) - 서버 어디에서든 호출 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 모든 연결된 클라이언트에게 브로드캐스트하는 함수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>broadcast</span>(<span style=color:#a6e22e>eventName</span>, <span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. (옵션) &#39;update&#39;라는 이름의 이벤트를 지정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>`event: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>eventName</span><span style=color:#e6db74>}</span><span style=color:#e6db74>\n`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. (필수) 실제 데이터를 &#39;data:&#39; 필드에 담아 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#e6db74>`data: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>data</span><span style=color:#e6db74>}</span><span style=color:#e6db74>\n`</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. (필수) 메시지의 끝을 알리는 개행 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#e6db74>`\n`</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>clients</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2초마다 모든 클라이언트에게 &#39;update&#39; 이벤트 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>broadcast</span>(<span style=color:#e6db74>&#34;update&#34;</span>, <span style=color:#e6db74>`This is message number </span><span style=color:#e6db74>${</span>Date.<span style=color:#a6e22e>now</span>()<span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>2000</span>);
</span></span></code></pre></div><hr><h2 id=json-데이터-전송-시-주의점>JSON 데이터 전송 시 주의점<a hidden class=anchor aria-hidden=true href=#json-데이터-전송-시-주의점>#</a></h2><p><code>data:</code> 필드가 여러 줄일 경우 파서는 이를 <code>\n</code>으로 이어붙임
이는 <strong>JSON을 여러 줄의 <code>data:</code> 필드로 쪼개어 보내면 안 된다</strong>는 것을 의미함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 서버에서 JSON 전송 시
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>payload</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;test&#34;</span>, <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>123</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// [Good ✅] JSON은 반드시 한 줄의 data 필드로 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>broadcast</span>(<span style=color:#e6db74>&#34;update&#34;</span>, <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>payload</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>// (전송되는 텍스트: &#39;event: update\ndata: {&#34;user&#34;:&#34;test&#34;,&#34;value&#34;:123}\n\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// [Bad ❌] 아래와 같이 여러 data 라인에 걸쳐 JSON을 쪼개면
</span></span></span><span style=display:flex><span><span style=color:#75715e>// res.write(`data: {&#34;user&#34;: &#34;test&#34;,\n`)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// res.write(`data: &#34;value&#34;: 123}\n\n`)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 클라이언트 파서는 망가진 텍스트(&#39;{&#34;user&#34;: &#34;test&#34;,\n&#34;value&#34;: 123}&#39;)를 받게 되어
</span></span></span><span style=display:flex><span><span style=color:#75715e>// JSON.parse()에서 오류가 발생함
</span></span></span></code></pre></div><hr><h2 id=sse-이벤트-파싱-클라이언트-측---eventsource-미사용>SSE 이벤트 파싱 (클라이언트 측 - EventSource 미사용)<a hidden class=anchor aria-hidden=true href=#sse-이벤트-파싱-클라이언트-측---eventsource-미사용>#</a></h2><p>서버가 보낸 데이터 청크는 메시지 경계(<code>\n\n</code>)와 정확히 일치하지 않을 수 있음
따라서 클라이언트는 데이터를 버퍼(buffer)에 쌓아두고, 메시지 구분자(<code>\n\n</code>)가 나타날 때마다 파싱해야 함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Client-side (Browser JS)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>; <span style=color:#75715e>// 수신된 청크를 임시 저장할 버퍼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// connectSSE()의 read() 루프에서 호출되는 함수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>parseStreamChunk</span>(<span style=color:#a6e22e>rawChunk</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. 버퍼에 새로 수신된 청크를 추가
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>rawChunk</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. 버퍼에서 메시지 구분자(\n\n)를 찾음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>boundary</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>indexOf</span>(<span style=color:#e6db74>&#34;\n\n&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. 구분자가 존재하면 (즉, 메시지가 하나 이상 완성되면)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>boundary</span> <span style=color:#f92672>!==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 완성된 메시지 한 개를 추출 (구분자 앞까지)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rawMessage</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>boundary</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 버퍼에서 처리된 메시지+구분자 제거
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#a6e22e>boundary</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6. 추출한 메시지 파싱
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>parseMessage</span>(<span style=color:#a6e22e>rawMessage</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 7. 버퍼에 또 다른 메시지가 있는지 확인
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>boundary</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>indexOf</span>(<span style=color:#e6db74>&#34;\n\n&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 수신된 raw 메시지를 파싱하는 헬퍼 함수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>parseMessage</span>(<span style=color:#a6e22e>rawMessage</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>lines</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rawMessage</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;\n&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>eventType</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;message&#34;</span>; <span style=color:#75715e>// event: 필드가 없으면 기본값 &#39;message&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>eventData</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>line</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>lines</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;event:&#34;</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>eventType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>6</span>).<span style=color:#a6e22e>trim</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;data:&#34;</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// data 필드가 여러 줄일 경우를 대비해 (JSON이 아닌 경우)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>eventData</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>5</span>).<span style=color:#a6e22e>trim</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>eventData</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`[Event Received] Type: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>eventType</span><span style=color:#e6db74>}</span><span style=color:#e6db74>, Data: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>eventData</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 여기서 DOM을 업데이트하거나 알림을 표시하는 등 실제 작업 수행
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=하트비트-heartbeat>하트비트 (Heartbeat)<a hidden class=anchor aria-hidden=true href=#하트비트-heartbeat>#</a></h2><p>일부 프록시 서버나 방화벽은 일정 시간 동안 데이터 전송이 없으면 해당 연결을 유휴(idle) 상태로 간주하고 강제로 종료할 수 있음
이를 방지하기 위해 서버는 주기적으로 의미 없는 데이터(주석)를 보내 연결이 살아있음을 알려야 함. 이를 <strong>하트비트</strong>라고 함</p><p>SSE 스펙에서 콜론(<code>:</code>)으로 시작하는 라인은 주석으로 취급되며 클라이언트에서 무시됨</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Node.js (Express) - 서버 측
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 15초마다 하트비트 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>setInterval</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// : 주석은 클라이언트의 message 이벤트로 전달되지 않음
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heartbeatMessage</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;: heartbeat\n\n&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>clients</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>heartbeatMessage</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>15000</span>);
</span></span></code></pre></div><p>클라이언트 측에서는 <code>parseMessage</code> 함수가 <code>event:</code>나 <code>data:</code>가 아닌 라인을 무시하므로 별도 코드가 필요 없음</p><hr><h2 id=서버에서-특정-연결-강제-종료>서버에서 특정 연결 강제 종료<a hidden class=anchor aria-hidden=true href=#서버에서-특정-연결-강제-종료>#</a></h2><p>인증 만료, 중복 로그인 등의 이유로 서버가 특정 사용자의 연결을 선별적으로 종료해야 할 수 있음</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Node.js (Express) - /events 핸들러
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;/events&#34;</span>, (<span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>res</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... 헤더 설정 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// (실제로는 JWT 등에서 파싱한 ID)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>locals</span>.<span style=color:#a6e22e>userId</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;user-&#34;</span> <span style=color:#f92672>+</span> Math.<span style=color:#a6e22e>floor</span>(Math.<span style=color:#a6e22e>random</span>() <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>clients</span>.<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>res</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;close&#34;</span>, () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>clients</span>.<span style=color:#66d9ef>delete</span>(<span style=color:#a6e22e>res</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// (어드민 API 등) 특정 사용자를 종료시켜야 할 때
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>kickUser</span>(<span style=color:#a6e22e>userIdToKick</span>, <span style=color:#a6e22e>reason</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>clients</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>locals</span>.<span style=color:#a6e22e>userId</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>userIdToKick</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 1. 클라이언트가 처리할 수 있는 에러 이벤트를 전송
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`event: error\ndata: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>code</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;KICKED&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>reason</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>reason</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>}</span><span style=color:#e6db74>)}\n\n`</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 2. 스트림을 정상적으로 종료 (클라이언트의 req.on(&#39;close&#39;)가 호출됨)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>end</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Kicked user: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>userIdToKick</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 예시: 5초 뒤 특정 유저 강제 종료
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>setTimeout</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// (실제로는 ID를 특정해야 함)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>clients</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>userToKick</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>clients</span>.<span style=color:#a6e22e>values</span>().<span style=color:#a6e22e>next</span>().<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>locals</span>.<span style=color:#a6e22e>userId</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kickUser</span>(<span style=color:#a6e22e>userToKick</span>, <span style=color:#e6db74>&#34;Session expired&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}, <span style=color:#ae81ff>5000</span>);
</span></span></code></pre></div><hr><h2 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h2><p><strong>SSE</strong>는 <strong>단방향</strong> 실시간 데이터(알림, 시세, 피드) 전송이 필요할 때 구현이 간단하고 효율적인 훌륭한 선택지임</p><p>반면, 채팅이나 실시간 온라인 게임처럼 클라이언트와 서버가 지속적으로 데이터를 주고받는 <strong>양방향</strong> 통신이 필수적이라면 <strong>웹소켓</strong>이 적합함</p><p>프로젝트의 요구사항을 명확히 파악하고, 단방향인지 양방향인지를 기준으로 적절한 기술 스펙을 고르는 것이 중요함</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>MDN - Server-Sent Events 사용하기
<a href=https://developer.mozilla.org/ko/docs/Web/API/Server-Sent_Events/Using_Server-Sent_Events>https://developer.mozilla.org/ko/docs/Web/API/Server-Sent_Events/Using_Server-Sent_Events</a></li><li>WHATWG - Server-Sent Events 스펙
<a href=https://html.spec.whatwg.org/multipage/server-sent-events.html>https://html.spec.whatwg.org/multipage/server-sent-events.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/sse/>Sse</a></li><li><a href=https://handsupmin.github.io/tags/server-sent-events/>Server-Sent-Events</a></li><li><a href=https://handsupmin.github.io/tags/redis/>Redis</a></li><li><a href=https://handsupmin.github.io/tags/pub-sub/>Pub-Sub</a></li><li><a href=https://handsupmin.github.io/tags/nestjs/>Nestjs</a></li><li><a href=https://handsupmin.github.io/tags/kubernetes/>Kubernetes</a></li><li><a href=https://handsupmin.github.io/tags/real-time/>Real-Time</a></li><li><a href=https://handsupmin.github.io/tags/backend-architecture/>Backend-Architecture</a></li></ul><nav class=paginav><a class=prev href=https://handsupmin.github.io/posts/innodb-pk-less-tables-trade-offs-2dc695/><span class=title>« Prev</span><br><span>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</span>
</a><a class=next href=https://handsupmin.github.io/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/><span class=title>Next »</span><br><span>Node.js 환경에서 디버깅하기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on x" href="https://x.com/intent/tweet/?text=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f&amp;hashtags=sse%2cserver-sent-events%2credis%2cpub-sub%2cnestjs%2ckubernetes%2creal-time%2cbackend-architecture"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f&amp;title=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29&amp;summary=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29&amp;source=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f&title=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on whatsapp" href="https://api.whatsapp.com/send?text=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29%20-%20https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on telegram" href="https://telegram.me/share/url?text=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29&amp;url=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events) on ycombinator" href="https://news.ycombinator.com/submitlink?t=SSE%eb%9e%80%3f%20%ec%8b%a4%ec%8b%9c%ea%b0%84%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%ec%a0%84%eb%8b%ac%20%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c%20%28Server-Sent%20Events%29&u=https%3a%2f%2fhandsupmin.github.io%2fposts%2fsse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>