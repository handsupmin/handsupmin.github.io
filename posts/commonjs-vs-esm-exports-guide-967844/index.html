<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 | HandsLog</title>
<meta name=keywords content="javascript,nodejs,esm,commonjs,modules,tree-shaking,bundling,typescript,package-json,npm"><meta name=description content="개요
JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음
CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임
현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함
라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가
핵심 개념과 정의


CommonJS CJS

require, module.exports 기반 동적 로더
모듈 로드와 평가가 호출 지점에서 동기 수행
Node.js 생태계에 널리 보급, 레거시 호환성 강함



ECMAScript Modules ESM"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심"><meta property="og:description" content="개요 JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음 CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임 현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함 라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가
핵심 개념과 정의 CommonJS CJS
require, module.exports 기반 동적 로더 모듈 로드와 평가가 호출 지점에서 동기 수행 Node.js 생태계에 널리 보급, 레거시 호환성 강함 ECMAScript Modules ESM"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-16T13:06:40+00:00"><meta property="article:modified_time" content="2025-11-16T13:06:40+00:00"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Esm"><meta property="article:tag" content="Commonjs"><meta property="article:tag" content="Modules"><meta property="article:tag" content="Tree-Shaking"><meta name=twitter:card content="summary"><meta name=twitter:title content="CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심"><meta name=twitter:description content="개요
JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음
CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임
현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함
라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가
핵심 개념과 정의


CommonJS CJS

require, module.exports 기반 동적 로더
모듈 로드와 평가가 호출 지점에서 동기 수행
Node.js 생태계에 널리 보급, 레거시 호환성 강함



ECMAScript Modules ESM"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심","item":"https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심","name":"CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심","description":"개요 JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음 CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임 현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함 라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가\n핵심 개념과 정의 CommonJS CJS\nrequire, module.exports 기반 동적 로더 모듈 로드와 평가가 호출 지점에서 동기 수행 Node.js 생태계에 널리 보급, 레거시 호환성 강함 ECMAScript Modules ESM\n","keywords":["javascript","nodejs","esm","commonjs","modules","tree-shaking","bundling","typescript","package-json","npm"],"articleBody":"개요 JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음 CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임 현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함 라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가\n핵심 개념과 정의 CommonJS CJS\nrequire, module.exports 기반 동적 로더 모듈 로드와 평가가 호출 지점에서 동기 수행 Node.js 생태계에 널리 보급, 레거시 호환성 강함 ECMAScript Modules ESM\nimport, export 기반 정적 구조 로더가 그래프를 사전 파싱·인스턴스화 후 평가 수행 트리 쉐이킹, 코드 분할, IDE 지원 등 정적 분석 최적화 친화 표준성\nCommonJS는 ECMA-262 표준 아님 ESM은 ECMAScript의 공식 모듈 시스템 동작 원리와 구조 ESM 로딩 파이프라인 1 파싱 의존성 그래프 구성 2 인스턴스화 export 바인딩을 메모리에 등록, 상호 참조 연결 준비 3 평가 종속성 그래프 완성 후 후위 DFS로 실행 이 과정 덕분에 순환 참조 상황에서도 일관된 레퍼런스 노출 가능\nCommonJS 로딩 특성\nrequire 호출 시 즉시 읽고 실행 후 내보낸 값 반환 실행 즉시 평가 모델로 인해 순환 참조 시 불완전한 값 노출 가능 호출 위치 기준 동기 블로킹 정적 vs 동적 구조 차이\nESM import는 파일 최상단에서만 사용 가능, 조건부 로드는 import 함수 사용 필요 비동기 CommonJS require는 어디서든 호출 가능, 조건과 루프 내부 허용 간단 스니펫\n// CJS const { add } = require('./add') // ESM import { add } from './add.js' // ESM의 조건부 로드 const m = await import('./feature.js') 순환 의존성 관찰 포인트 CJS는 모듈이 읽히는 즉시 평가되므로 순환 참조 구간에서 부분 초기화된 객체가 노출될 수 있음 ESM은 인스턴스화 단계에서 export 바인딩을 먼저 연결한 후 평가를 진행하므로 상대적으로 안정적인 참조 제공 export default의 한계 default export는 이름 없는 바인딩 특성으로 사용 여부 정적 분석이 어려워 트리 쉐이킹에 불리 named export는 사용 경로를 정적으로 추론 가능하여 불필요 코드 제거에 유리 간단 스니펫\n// named export 권장 export const foo = () =\u003e {} export const bar = () =\u003e {} 왜 CommonJS를 아직 쓰는가 동기적 로딩과 즉시 실행 특성이 유리한 경우 존재 CLI, 짧은 유틸 스크립트, 초기화 순서가 명확한 서버 스크립트 유연한 동적 로딩 요구 런타임 조건 분기에서 모듈 로드가 단순함 레거시 호환성 및 생태계 축적 기존 패키지 다수가 CJS를 기본으로 제공해 즉시 호환 진입 장벽 낮음 별도 설정 없이 require, module.exports 사용 가능 상호 운용 제약 ESM에서 CJS 불러오기는 상대적으로 수월하지만, CJS에서 ESM 불러오기는 동기 불가 import 함수 필요 CJS는 동기, ESM은 비동기인가 절반은 맞고 절반은 오해\nCJS require는 호출 지점에서 블로킹되는 동기 로드 ESM은 정적 import가 로더 단계에서 사전 처리됨, 평가와 의존성 해결이 비동기적으로 진행될 수 있음 ESM의 import 함수는 진짜 비동기 프리미티브 Promise 기반 Top-level await 지원으로 ESM 그래프 평가가 비동기 컨텍스트를 포함 가능 핵심 정리\nrequire 동기 블로킹 import 정적 선언 기반, 평가는 비동기 흐름에 통합 가능 import 함수 동적·비동기 로드 파일이 CJS인지 ESM인지 판별 규칙 package.json type 필드 기본값 commonjs이면 .js는 CJS로 해석 type이 module이면 .js는 ESM으로 해석 확장자 강제 규칙 .cjs는 항상 CJS .mjs는 항상 ESM TypeScript 4.7 이후 node16 또는 nodenext 모듈 해석에서 동일 규칙 적용 .ts는 type에 따라 CJS 또는 ESM로 간주 .cts는 항상 CJS TS .mts는 항상 ESM TS exports 필드로 듀얼 번들 제공하기 목적과 역할 요약\n패키지 엔트리 포인트 지정 main 대체 subpath exports로 외부 노출 경로를 명세적으로 제한하고 가상 경로 구성 conditional exports로 동일 경로에 조건별 다른 빌드 제공 require vs import 등 중요 규칙\n경로는 상대 경로 . 로 시작해야 함 패키지의 Module System에 맞는 올바른 확장자 사용 CJS 패키지에서 ESM 타깃은 .mjs로 명시 ESM 패키지에서 CJS 타깃은 .cjs로 명시 잘못된 확장자 혼용 시 로더가 잘못된 모듈 시스템으로 파싱하여 문법 에러 발생 가능 import를 CJS 로더로 읽는 상황 등 간단 스니펫 조건 기반 듀얼 매핑\n{ \"exports\": { \".\": { \"require\": \"./dist/index.cjs\", \"import\": \"./dist/index.mjs\" } } } subpath exports 예시 최소형\n{ \"exports\": { \".\": \"./dist/index.js\", \"./utils\": \"./dist/utils/index.js\" } } TypeScript와 exports 연동 TS 4.7 node16, nodenext에서 exports 기반 타입 탐색 수행 CJS TS와 ESM TS 타입 선언을 구분 지원 .d.cts, .d.mts conditional exports에서 types 키 사용 가능 런타임 번들와 타입 경로를 함께 지정 간단 스니펫 TS 대응 최소형\n{ \"exports\": { \".\": { \"require\": { \"types\": \"./index.d.cts\", \"default\": \"./index.cjs\" }, \"import\": { \"types\": \"./index.d.mts\", \"default\": \"./index.mjs\" } } } } 주의 사항\n패키지 type에 맞춘 타입 선언 확장자 사용 필요 ESM 패키지에서 CJS 타입은 .d.cts로 제공 하나의 .d.ts만 제공하면 ESM 기준으로 인식될 수 있어 CJS TS 소비자에서 순수 ESM으로만 확인된다는 타입 에러 발생 가능 라이브러리와 애플리케이션에서의 선택 가이드 라이브러리 배포\nexports 필드로 듀얼 번들 제공 require, import 조건 분기 ESM 우선 설계, CJS 호환 유지 트랜스파일 또는 별도 번들 생성 named export 중심 API 설계 default export 최소화 deep import 차단 subpath exports로 공개 API만 노출 TypeScript는 .d.cts, .d.mts 명시적 제공 node16 or nodenext 권장 sideEffects 필드 정확히 기입하여 트리 쉐이킹 신뢰성 확보 애플리케이션\n가능하면 ESM 중심 구성 브라우저·번들러 친화, 최적화 용이 Node 실행은 type module 또는 .mjs 채택, ESM 전환 단계에서는 import 함수로 점진적 마이그레이션 CLI나 초기화 민감 스크립트는 CJS 유지 선택지 고려 상호 운용\nESM에서 CJS import는 상대적으로 단순 CJS에서 ESM은 동기 불가 import 함수 사용 필요, 초기화 순서와 에러 처리 설계 필요 주의와 한계, 베스트 프랙티스 순환 의존성 최소화 구조화, 공통 상수와 타입은 별도 모듈로 분리 런타임 분기 require 남용 자제 ESM에서는 import 함수로 명시적 처리 모듈 경로는 상대·절대 혼용 최소화, 패키지 내 공개 경로는 exports 단일 진입점 유지 번들 결과 검증 ESM 트리 쉐이킹 결과 사이즈, 사이드 이펙트 잔존 여부 확인 CJS 번들에서 동등 기능 보장 여부 스냅샷 테스트 타입 분해 독립 검증 TS 소비자 환경별 CJS TS, ESM TS에서 d.ts 해석 확인 Node 버전 범위 명확화 engines 필드와 README에 지원 범위 표기 간단 예시로 보는 오해 방지 포인트 ESM의 import는 코드 어디서나 호출 불가, 파일 최상단에서만 선언 가능 조건부 로드는 import 함수 사용 Promise 기반 비동기로 다뤄야 함 CJS require는 동기 블로킹이므로 I O 이전 초기화 구간에서 직관적이나, 대규모 앱에서는 병렬성 저해 요인 될 수 있음 default export 남발은 트리 쉐이킹 방해 요소, 팀 규칙으로 named export 우선 채택 권장 마무리 CommonJS는 동기적이고 유연한 런타임 로딩 모델로 여전히 실용적 선택지임 ESM은 정적 분석 기반의 공식 표준으로 최적화와 도구 친화성에서 우위 확보 두 시스템은 설계 철학과 로딩 모델이 다르므로 단순 문법 취향 문제가 아님 라이브러리는 exports 필드로 듀얼 번들 제공, 타입까지 포함한 일관된 상호 운용성 확보 권장 애플리케이션은 ESM 우선 전략을 기본값으로 두되, 운영 맥락에 따라 CJS를 도구적으로 병행 선택 결국 선택 기준은 성능 최적화, 호환성, 팀의 배포 표준, 소비자 환경의 조합임\n참고자료 https://velog.io/@kakasoo/ESM%EA%B3%BC-CommonJS%EC%9D%98-%EC%B0%A8%EC%9D%B4 https://toss.tech/article/commonjs-esm-exports-field https://nodejs.org/api/modules.html https://nodejs.org/api/esm.html https://nodejs.org/api/packages.html#determining-module-system https://nodejs.org/api/packages.html#exports https://nodejs.org/api/packages.html#subpath-exports https://nodejs.org/api/packages.html#conditional-exports https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html ","wordCount":"1054","inLanguage":"en","datePublished":"2025-11-16T13:06:40.229Z","dateModified":"2025-11-16T13:06:40.229Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/commonjs-vs-esm-exports-guide-967844/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심</h1><div class=post-meta><span title='2025-11-16 13:06:40.229 +0000 UTC'>November 16, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>JavaScript 모듈 시스템은 CommonJS와 ECMAScript Modules 두 축으로 운용되어 왔음
CommonJS는 커뮤니티 주도의 비표준 모듈 시스템으로 Node.js 생태계를 이끌었고, ESM은 ECMAScript 표준으로 채택된 정적 분석 기반 모듈 시스템임
현대 툴체인과 브라우저 친화성, 최적화 요구로 인해 ESM 채택이 확대 중이나, 서버 스크립트와 레거시 호환성 관점에서 CommonJS의 실용성 또한 여전함
라이브러리 배포 측면에서는 두 시스템 모두 대응하는 듀얼 번들이 요구되는 상황 증가</p><h3 id=핵심-개념과-정의>핵심 개념과 정의<a hidden class=anchor aria-hidden=true href=#핵심-개념과-정의>#</a></h3><ul><li><p>CommonJS CJS</p><ul><li>require, module.exports 기반 동적 로더</li><li>모듈 로드와 평가가 호출 지점에서 동기 수행</li><li>Node.js 생태계에 널리 보급, 레거시 호환성 강함</li></ul></li><li><p>ECMAScript Modules ESM</p><ul><li>import, export 기반 정적 구조</li><li>로더가 그래프를 사전 파싱·인스턴스화 후 평가 수행</li><li>트리 쉐이킹, 코드 분할, IDE 지원 등 정적 분석 최적화 친화</li></ul></li><li><p>표준성</p><ul><li>CommonJS는 ECMA-262 표준 아님</li><li>ESM은 ECMAScript의 공식 모듈 시스템</li></ul></li></ul><h3 id=동작-원리와-구조>동작 원리와 구조<a hidden class=anchor aria-hidden=true href=#동작-원리와-구조>#</a></h3><ul><li><p>ESM 로딩 파이프라인
1 파싱 의존성 그래프 구성
2 인스턴스화 export 바인딩을 메모리에 등록, 상호 참조 연결 준비
3 평가 종속성 그래프 완성 후 후위 DFS로 실행
이 과정 덕분에 순환 참조 상황에서도 일관된 레퍼런스 노출 가능</p></li><li><p>CommonJS 로딩 특성</p><ul><li>require 호출 시 즉시 읽고 실행 후 내보낸 값 반환</li><li>실행 즉시 평가 모델로 인해 순환 참조 시 불완전한 값 노출 가능</li><li>호출 위치 기준 동기 블로킹</li></ul></li><li><p>정적 vs 동적 구조 차이</p><ul><li>ESM import는 파일 최상단에서만 사용 가능, 조건부 로드는 import 함수 사용 필요 비동기</li><li>CommonJS require는 어디서든 호출 가능, 조건과 루프 내부 허용</li></ul></li></ul><p>간단 스니펫</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// CJS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>add</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;./add&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ESM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>add</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;./add.js&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ESM의 조건부 로드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>import</span>(<span style=color:#e6db74>&#39;./feature.js&#39;</span>)
</span></span></code></pre></div><h3 id=순환-의존성-관찰-포인트>순환 의존성 관찰 포인트<a hidden class=anchor aria-hidden=true href=#순환-의존성-관찰-포인트>#</a></h3><ul><li>CJS는 모듈이 읽히는 즉시 평가되므로 순환 참조 구간에서 부분 초기화된 객체가 노출될 수 있음</li><li>ESM은 인스턴스화 단계에서 export 바인딩을 먼저 연결한 후 평가를 진행하므로 상대적으로 안정적인 참조 제공</li></ul><h3 id=export-default의-한계>export default의 한계<a hidden class=anchor aria-hidden=true href=#export-default의-한계>#</a></h3><ul><li>default export는 이름 없는 바인딩 특성으로 사용 여부 정적 분석이 어려워 트리 쉐이킹에 불리</li><li>named export는 사용 경로를 정적으로 추론 가능하여 불필요 코드 제거에 유리</li></ul><p>간단 스니펫</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// named export 권장
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> () =&gt; {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bar</span> <span style=color:#f92672>=</span> () =&gt; {}
</span></span></code></pre></div><h3 id=왜-commonjs를-아직-쓰는가>왜 CommonJS를 아직 쓰는가<a hidden class=anchor aria-hidden=true href=#왜-commonjs를-아직-쓰는가>#</a></h3><ul><li>동기적 로딩과 즉시 실행 특성이 유리한 경우 존재<ul><li>CLI, 짧은 유틸 스크립트, 초기화 순서가 명확한 서버 스크립트</li></ul></li><li>유연한 동적 로딩 요구<ul><li>런타임 조건 분기에서 모듈 로드가 단순함</li></ul></li><li>레거시 호환성 및 생태계 축적<ul><li>기존 패키지 다수가 CJS를 기본으로 제공해 즉시 호환</li></ul></li><li>진입 장벽 낮음<ul><li>별도 설정 없이 require, module.exports 사용 가능</li></ul></li><li>상호 운용 제약<ul><li>ESM에서 CJS 불러오기는 상대적으로 수월하지만, CJS에서 ESM 불러오기는 동기 불가 import 함수 필요</li></ul></li></ul><h3 id=cjs는-동기-esm은-비동기인가>CJS는 동기, ESM은 비동기인가<a hidden class=anchor aria-hidden=true href=#cjs는-동기-esm은-비동기인가>#</a></h3><p>절반은 맞고 절반은 오해</p><ul><li>CJS require는 호출 지점에서 블로킹되는 동기 로드</li><li>ESM은 정적 import가 로더 단계에서 사전 처리됨, 평가와 의존성 해결이 비동기적으로 진행될 수 있음</li><li>ESM의 import 함수는 진짜 비동기 프리미티브 Promise 기반</li><li>Top-level await 지원으로 ESM 그래프 평가가 비동기 컨텍스트를 포함 가능</li></ul><p>핵심 정리</p><ul><li>require 동기 블로킹</li><li>import 정적 선언 기반, 평가는 비동기 흐름에 통합 가능</li><li>import 함수 동적·비동기 로드</li></ul><h3 id=파일이-cjs인지-esm인지-판별-규칙>파일이 CJS인지 ESM인지 판별 규칙<a hidden class=anchor aria-hidden=true href=#파일이-cjs인지-esm인지-판별-규칙>#</a></h3><ul><li>package.json type 필드<ul><li>기본값 commonjs이면 .js는 CJS로 해석</li><li>type이 module이면 .js는 ESM으로 해석</li></ul></li><li>확장자 강제 규칙<ul><li>.cjs는 항상 CJS</li><li>.mjs는 항상 ESM</li></ul></li><li>TypeScript 4.7 이후 node16 또는 nodenext 모듈 해석에서 동일 규칙 적용<ul><li>.ts는 type에 따라 CJS 또는 ESM로 간주</li><li>.cts는 항상 CJS TS</li><li>.mts는 항상 ESM TS</li></ul></li></ul><h3 id=exports-필드로-듀얼-번들-제공하기>exports 필드로 듀얼 번들 제공하기<a hidden class=anchor aria-hidden=true href=#exports-필드로-듀얼-번들-제공하기>#</a></h3><p>목적과 역할 요약</p><ul><li>패키지 엔트리 포인트 지정 main 대체</li><li>subpath exports로 외부 노출 경로를 명세적으로 제한하고 가상 경로 구성</li><li>conditional exports로 동일 경로에 조건별 다른 빌드 제공 require vs import 등</li></ul><p>중요 규칙</p><ul><li>경로는 상대 경로 . 로 시작해야 함</li><li>패키지의 Module System에 맞는 올바른 확장자 사용<ul><li>CJS 패키지에서 ESM 타깃은 .mjs로 명시</li><li>ESM 패키지에서 CJS 타깃은 .cjs로 명시</li></ul></li><li>잘못된 확장자 혼용 시 로더가 잘못된 모듈 시스템으로 파싱하여 문법 에러 발생 가능 import를 CJS 로더로 읽는 상황 등</li></ul><p>간단 스니펫 조건 기반 듀얼 매핑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;exports&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;.&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;require&#34;</span>: <span style=color:#e6db74>&#34;./dist/index.cjs&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;import&#34;</span>: <span style=color:#e6db74>&#34;./dist/index.mjs&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>subpath exports 예시 최소형</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;exports&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;.&#34;</span>: <span style=color:#e6db74>&#34;./dist/index.js&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;./utils&#34;</span>: <span style=color:#e6db74>&#34;./dist/utils/index.js&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=typescript와-exports-연동>TypeScript와 exports 연동<a hidden class=anchor aria-hidden=true href=#typescript와-exports-연동>#</a></h3><ul><li>TS 4.7 node16, nodenext에서 exports 기반 타입 탐색 수행</li><li>CJS TS와 ESM TS 타입 선언을 구분 지원 .d.cts, .d.mts</li><li>conditional exports에서 types 키 사용 가능 런타임 번들와 타입 경로를 함께 지정</li></ul><p>간단 스니펫 TS 대응 최소형</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;exports&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;.&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;require&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;types&#34;</span>: <span style=color:#e6db74>&#34;./index.d.cts&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;default&#34;</span>: <span style=color:#e6db74>&#34;./index.cjs&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;import&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;types&#34;</span>: <span style=color:#e6db74>&#34;./index.d.mts&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;default&#34;</span>: <span style=color:#e6db74>&#34;./index.mjs&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>주의 사항</p><ul><li>패키지 type에 맞춘 타입 선언 확장자 사용 필요 ESM 패키지에서 CJS 타입은 .d.cts로 제공</li><li>하나의 .d.ts만 제공하면 ESM 기준으로 인식될 수 있어 CJS TS 소비자에서 순수 ESM으로만 확인된다는 타입 에러 발생 가능</li></ul><h3 id=라이브러리와-애플리케이션에서의-선택-가이드>라이브러리와 애플리케이션에서의 선택 가이드<a hidden class=anchor aria-hidden=true href=#라이브러리와-애플리케이션에서의-선택-가이드>#</a></h3><ul><li><p>라이브러리 배포</p><ul><li>exports 필드로 듀얼 번들 제공 require, import 조건 분기</li><li>ESM 우선 설계, CJS 호환 유지 트랜스파일 또는 별도 번들 생성</li><li>named export 중심 API 설계 default export 최소화</li><li>deep import 차단 subpath exports로 공개 API만 노출</li><li>TypeScript는 .d.cts, .d.mts 명시적 제공 node16 or nodenext 권장</li><li>sideEffects 필드 정확히 기입하여 트리 쉐이킹 신뢰성 확보</li></ul></li><li><p>애플리케이션</p><ul><li>가능하면 ESM 중심 구성 브라우저·번들러 친화, 최적화 용이</li><li>Node 실행은 type module 또는 .mjs 채택, ESM 전환 단계에서는 import 함수로 점진적 마이그레이션</li><li>CLI나 초기화 민감 스크립트는 CJS 유지 선택지 고려</li></ul></li><li><p>상호 운용</p><ul><li>ESM에서 CJS import는 상대적으로 단순</li><li>CJS에서 ESM은 동기 불가 import 함수 사용 필요, 초기화 순서와 에러 처리 설계 필요</li></ul></li></ul><h3 id=주의와-한계-베스트-프랙티스>주의와 한계, 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#주의와-한계-베스트-프랙티스>#</a></h3><ul><li>순환 의존성 최소화 구조화, 공통 상수와 타입은 별도 모듈로 분리</li><li>런타임 분기 require 남용 자제 ESM에서는 import 함수로 명시적 처리</li><li>모듈 경로는 상대·절대 혼용 최소화, 패키지 내 공개 경로는 exports 단일 진입점 유지</li><li>번들 결과 검증<ul><li>ESM 트리 쉐이킹 결과 사이즈, 사이드 이펙트 잔존 여부 확인</li><li>CJS 번들에서 동등 기능 보장 여부 스냅샷 테스트</li></ul></li><li>타입 분해 독립 검증 TS 소비자 환경별 CJS TS, ESM TS에서 d.ts 해석 확인</li><li>Node 버전 범위 명확화 engines 필드와 README에 지원 범위 표기</li></ul><h3 id=간단-예시로-보는-오해-방지-포인트>간단 예시로 보는 오해 방지 포인트<a hidden class=anchor aria-hidden=true href=#간단-예시로-보는-오해-방지-포인트>#</a></h3><ul><li>ESM의 import는 코드 어디서나 호출 불가, 파일 최상단에서만 선언 가능</li><li>조건부 로드는 import 함수 사용 Promise 기반 비동기로 다뤄야 함</li><li>CJS require는 동기 블로킹이므로 I O 이전 초기화 구간에서 직관적이나, 대규모 앱에서는 병렬성 저해 요인 될 수 있음</li><li>default export 남발은 트리 쉐이킹 방해 요소, 팀 규칙으로 named export 우선 채택 권장</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>CommonJS는 동기적이고 유연한 런타임 로딩 모델로 여전히 실용적 선택지임
ESM은 정적 분석 기반의 공식 표준으로 최적화와 도구 친화성에서 우위 확보
두 시스템은 설계 철학과 로딩 모델이 다르므로 단순 문법 취향 문제가 아님
라이브러리는 exports 필드로 듀얼 번들 제공, 타입까지 포함한 일관된 상호 운용성 확보 권장
애플리케이션은 ESM 우선 전략을 기본값으로 두되, 운영 맥락에 따라 CJS를 도구적으로 병행 선택
결국 선택 기준은 성능 최적화, 호환성, 팀의 배포 표준, 소비자 환경의 조합임</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://velog.io/@kakasoo/ESM%EA%B3%BC-CommonJS%EC%9D%98-%EC%B0%A8%EC%9D%B4>https://velog.io/@kakasoo/ESM%EA%B3%BC-CommonJS%EC%9D%98-%EC%B0%A8%EC%9D%B4</a></li><li><a href=https://toss.tech/article/commonjs-esm-exports-field>https://toss.tech/article/commonjs-esm-exports-field</a></li><li><a href=https://nodejs.org/api/modules.html>https://nodejs.org/api/modules.html</a></li><li><a href=https://nodejs.org/api/esm.html>https://nodejs.org/api/esm.html</a></li><li><a href=https://nodejs.org/api/packages.html#determining-module-system>https://nodejs.org/api/packages.html#determining-module-system</a></li><li><a href=https://nodejs.org/api/packages.html#exports>https://nodejs.org/api/packages.html#exports</a></li><li><a href=https://nodejs.org/api/packages.html#subpath-exports>https://nodejs.org/api/packages.html#subpath-exports</a></li><li><a href=https://nodejs.org/api/packages.html#conditional-exports>https://nodejs.org/api/packages.html#conditional-exports</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html>https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/javascript/>Javascript</a></li><li><a href=https://blog.jsontapose.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jsontapose.com/tags/esm/>Esm</a></li><li><a href=https://blog.jsontapose.com/tags/commonjs/>Commonjs</a></li><li><a href=https://blog.jsontapose.com/tags/modules/>Modules</a></li><li><a href=https://blog.jsontapose.com/tags/tree-shaking/>Tree-Shaking</a></li><li><a href=https://blog.jsontapose.com/tags/bundling/>Bundling</a></li><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/package-json/>Package-Json</a></li><li><a href=https://blog.jsontapose.com/tags/npm/>Npm</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/><span class=title>« Prev</span><br><span>Prisma where 관계 필터 some vs every 동작 차이와 주의점</span>
</a><a class=next href=https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/><span class=title>Next »</span><br><span>JavaScript Array.prototype.map 개념과 사용법 정리</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on x" href="https://x.com/intent/tweet/?text=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f&amp;hashtags=javascript%2cnodejs%2cesm%2ccommonjs%2cmodules%2ctree-shaking%2cbundling%2ctypescript%2cpackage-json%2cnpm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f&amp;title=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac&amp;summary=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f&title=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on whatsapp" href="https://api.whatsapp.com/send?text=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on telegram" href="https://telegram.me/share/url?text=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CommonJS vs ESM 정리와 듀얼 번들 구축 가이드 exports 필드 중심 on ycombinator" href="https://news.ycombinator.com/submitlink?t=CommonJS%20vs%20ESM%20%ec%a0%95%eb%a6%ac%ec%99%80%20%eb%93%80%ec%96%bc%20%eb%b2%88%eb%93%a4%20%ea%b5%ac%ec%b6%95%20%ea%b0%80%ec%9d%b4%eb%93%9c%20exports%20%ed%95%84%eb%93%9c%20%ec%a4%91%ec%8b%ac&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fcommonjs-vs-esm-exports-guide-967844%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>