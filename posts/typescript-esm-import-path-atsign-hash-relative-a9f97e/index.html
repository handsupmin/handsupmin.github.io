<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 | HandsLog</title>
<meta name=keywords content="typescript,esm,nodejs,import,module-resolution,path-alias,npm-scopes,import-maps"><meta name=description content='개요
TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴

import &mldr; from &lsquo;@&mldr;&rsquo;
import &mldr; from &lsquo;&mldr;&rsquo;
import &mldr; from &lsquo;#&mldr;&rsquo;

표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름

&lsquo;@&lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능
&lsquo;&mldr;&lsquo;는 상대·절대 경로로 파일 시스템 기준 해석
&lsquo;#&lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용

아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함
&lsquo;@&mldr;&rsquo; 경로의 두 가지 의미
1) 경로 별칭 path alias

의도: 길고 복잡한 상대 경로를 짧게 추상화
설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl
예시

{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@models/*": ["src/models/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}import { User } from &#39;@models/User&#39;
import { calculate } from &#39;@utils/math&#39;
장점

상대 경로를 단순화, 가독성 및 리팩터링 내성 향상


주의

tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님
Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요
예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요



2) 스코프된 패키지 scoped package

의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합
표기: @scope/package-name 형태

@nestjs/swagger, @angular/core 등


사용 이유

네임스페이스로 이름 충돌 회피
관련 패키지의 그룹화와 공개·비공개 관리


설치

npm install @nestjs/swagger
해석

이 경우 &lsquo;@&lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작
tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석



&lsquo;&mldr;&rsquo; 상대·절대 경로 import

상대 경로 &lsquo;./&rsquo;, &lsquo;../&rsquo; 기준으로 현재 파일 위치에서 탐색
절대 경로 &lsquo;/path&rsquo;는 실행 환경마다 기준이 다름

브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석
Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음


예시

import { User } from &#39;./models/User&#39;
import { calculate } from &#39;../utils/math&#39;
장점

추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델
모듈 간 물리적 의존 관계가 드러남


단점

디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승
구조 변경 시 경로 대량 수정 발생



&lsquo;#&mldr;&rsquo; 경로의 의미
&lsquo;#{name}&rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의'><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정"><meta property="og:description" content='개요 TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴
import … from ‘@…’ import … from ‘…’ import … from ‘#…’ 표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름
‘@‘는 경로 별칭 또는 npm 스코프 패키지 의미 가능 ‘…‘는 상대·절대 경로로 파일 시스템 기준 해석 ‘#‘는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용 아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함
‘@…’ 경로의 두 가지 의미 1) 경로 별칭 path alias 의도: 길고 복잡한 상대 경로를 짧게 추상화 설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl 예시 { "compilerOptions": { "baseUrl": "./", "paths": { "@models/*": ["src/models/*"], "@utils/*": ["src/utils/*"] } } }import { User } from &#39;@models/User&#39; import { calculate } from &#39;@utils/math&#39; 장점 상대 경로를 단순화, 가독성 및 리팩터링 내성 향상 주의 tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님 Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요 예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요 2) 스코프된 패키지 scoped package 의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합 표기: @scope/package-name 형태 @nestjs/swagger, @angular/core 등 사용 이유 네임스페이스로 이름 충돌 회피 관련 패키지의 그룹화와 공개·비공개 관리 설치 npm install @nestjs/swagger 해석 이 경우 ‘@‘는 경로 별칭이 아닌 패키지 이름의 일부로 동작 tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석 ‘…’ 상대·절대 경로 import 상대 경로 ‘./’, ‘../’ 기준으로 현재 파일 위치에서 탐색 절대 경로 ‘/path’는 실행 환경마다 기준이 다름 브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석 Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음 예시 import { User } from &#39;./models/User&#39; import { calculate } from &#39;../utils/math&#39; 장점 추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델 모듈 간 물리적 의존 관계가 드러남 단점 디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승 구조 변경 시 경로 대량 수정 발생 ‘#…’ 경로의 의미 ‘#{name}’ 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-23T13:15:57+00:00"><meta property="article:modified_time" content="2026-01-23T13:15:57+00:00"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Esm"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Import"><meta property="article:tag" content="Module-Resolution"><meta property="article:tag" content="Path-Alias"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정"><meta name=twitter:description content='개요
TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴

import &mldr; from &lsquo;@&mldr;&rsquo;
import &mldr; from &lsquo;&mldr;&rsquo;
import &mldr; from &lsquo;#&mldr;&rsquo;

표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름

&lsquo;@&lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능
&lsquo;&mldr;&lsquo;는 상대·절대 경로로 파일 시스템 기준 해석
&lsquo;#&lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용

아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함
&lsquo;@&mldr;&rsquo; 경로의 두 가지 의미
1) 경로 별칭 path alias

의도: 길고 복잡한 상대 경로를 짧게 추상화
설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl
예시

{
  "compilerOptions": {
    "baseUrl": "./",
    "paths": {
      "@models/*": ["src/models/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}import { User } from &#39;@models/User&#39;
import { calculate } from &#39;@utils/math&#39;
장점

상대 경로를 단순화, 가독성 및 리팩터링 내성 향상


주의

tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님
Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요
예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요



2) 스코프된 패키지 scoped package

의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합
표기: @scope/package-name 형태

@nestjs/swagger, @angular/core 등


사용 이유

네임스페이스로 이름 충돌 회피
관련 패키지의 그룹화와 공개·비공개 관리


설치

npm install @nestjs/swagger
해석

이 경우 &lsquo;@&lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작
tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석



&lsquo;&mldr;&rsquo; 상대·절대 경로 import

상대 경로 &lsquo;./&rsquo;, &lsquo;../&rsquo; 기준으로 현재 파일 위치에서 탐색
절대 경로 &lsquo;/path&rsquo;는 실행 환경마다 기준이 다름

브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석
Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음


예시

import { User } from &#39;./models/User&#39;
import { calculate } from &#39;../utils/math&#39;
장점

추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델
모듈 간 물리적 의존 관계가 드러남


단점

디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승
구조 변경 시 경로 대량 수정 발생



&lsquo;#&mldr;&rsquo; 경로의 의미
&lsquo;#{name}&rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정","item":"https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정","name":"TypeScript\/ESM import 경로 정리: \u0027@\u0027, \u0027#\u0027, 상대 경로의 의미와 설정","description":"개요 TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴\nimport \u0026hellip; from \u0026lsquo;@\u0026hellip;\u0026rsquo; import \u0026hellip; from \u0026lsquo;\u0026hellip;\u0026rsquo; import \u0026hellip; from \u0026lsquo;#\u0026hellip;\u0026rsquo; 표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름\n\u0026lsquo;@\u0026lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능 \u0026lsquo;\u0026hellip;\u0026lsquo;는 상대·절대 경로로 파일 시스템 기준 해석 \u0026lsquo;#\u0026lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용 아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함\n\u0026lsquo;@\u0026hellip;\u0026rsquo; 경로의 두 가지 의미 1) 경로 별칭 path alias 의도: 길고 복잡한 상대 경로를 짧게 추상화 설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl 예시 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@models/*\u0026#34;: [\u0026#34;src/models/*\u0026#34;], \u0026#34;@utils/*\u0026#34;: [\u0026#34;src/utils/*\u0026#34;] } } }import { User } from \u0026#39;@models/User\u0026#39; import { calculate } from \u0026#39;@utils/math\u0026#39; 장점 상대 경로를 단순화, 가독성 및 리팩터링 내성 향상 주의 tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님 Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요 예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요 2) 스코프된 패키지 scoped package 의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합 표기: @scope/package-name 형태 @nestjs/swagger, @angular/core 등 사용 이유 네임스페이스로 이름 충돌 회피 관련 패키지의 그룹화와 공개·비공개 관리 설치 npm install @nestjs/swagger 해석 이 경우 \u0026lsquo;@\u0026lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작 tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석 \u0026lsquo;\u0026hellip;\u0026rsquo; 상대·절대 경로 import 상대 경로 \u0026lsquo;./\u0026rsquo;, \u0026lsquo;../\u0026rsquo; 기준으로 현재 파일 위치에서 탐색 절대 경로 \u0026lsquo;/path\u0026rsquo;는 실행 환경마다 기준이 다름 브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석 Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음 예시 import { User } from \u0026#39;./models/User\u0026#39; import { calculate } from \u0026#39;../utils/math\u0026#39; 장점 추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델 모듈 간 물리적 의존 관계가 드러남 단점 디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승 구조 변경 시 경로 대량 수정 발생 \u0026lsquo;#\u0026hellip;\u0026rsquo; 경로의 의미 \u0026lsquo;#{name}\u0026rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의\n","keywords":["typescript","esm","nodejs","import","module-resolution","path-alias","npm-scopes","import-maps"],"articleBody":"개요 TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴\nimport … from ‘@…’ import … from ‘…’ import … from ‘#…’ 표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름\n‘@‘는 경로 별칭 또는 npm 스코프 패키지 의미 가능 ‘…‘는 상대·절대 경로로 파일 시스템 기준 해석 ‘#‘는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용 아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함\n‘@…’ 경로의 두 가지 의미 1) 경로 별칭 path alias 의도: 길고 복잡한 상대 경로를 짧게 추상화 설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl 예시 { \"compilerOptions\": { \"baseUrl\": \"./\", \"paths\": { \"@models/*\": [\"src/models/*\"], \"@utils/*\": [\"src/utils/*\"] } } }import { User } from '@models/User' import { calculate } from '@utils/math' 장점 상대 경로를 단순화, 가독성 및 리팩터링 내성 향상 주의 tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님 Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요 예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요 2) 스코프된 패키지 scoped package 의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합 표기: @scope/package-name 형태 @nestjs/swagger, @angular/core 등 사용 이유 네임스페이스로 이름 충돌 회피 관련 패키지의 그룹화와 공개·비공개 관리 설치 npm install @nestjs/swagger 해석 이 경우 ‘@‘는 경로 별칭이 아닌 패키지 이름의 일부로 동작 tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석 ‘…’ 상대·절대 경로 import 상대 경로 ‘./’, ‘../’ 기준으로 현재 파일 위치에서 탐색 절대 경로 ‘/path’는 실행 환경마다 기준이 다름 브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석 Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음 예시 import { User } from './models/User' import { calculate } from '../utils/math' 장점 추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델 모듈 간 물리적 의존 관계가 드러남 단점 디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승 구조 변경 시 경로 대량 수정 발생 ‘#…’ 경로의 의미 ‘#{name}’ 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의\n1) Node.js 패키지 imports 개념: package.json 의 imports 필드로 패키지 내부 전용 별칭 제공 특징 키는 반드시 ‘#‘로 시작 동일 패키지 내부 전용. 외부 소비자가 임의로 참조 불가 ESM 해석기에 의해 런타임에서 동작. 번들러 없이도 Node가 직접 이해 설정 예시 { \"name\": \"my-package\", \"type\": \"module\", \"imports\": { \"#utils\": \"./src/utils/index.js\", \"#models/*\": \"./src/models/*.js\" } } 사용 예시 import { calc } from '#utils' import { User } from '#models/User' 장점 런타임이 이해하는 공식 별칭. tsconfig paths와 달리 Node 해석 일관성 확보 외부 공개 API와 내부 경로를 분리하는 캡슐화에 유리 주의 패키지 외부에서는 ‘#…’ 경로 사용 불가. 내부 전용 설계임 TypeScript는 nodenext 또는 node16 모듈 해석 설정에서 해당 매핑을 인지 가능. 도구별 지원 상태 확인 필요 2) 브라우저 import maps에서의 별칭 키 개념: 브라우저가 script type=importmap 또는 별도 importmap.json을 통해 모듈 스펙ifier를 URL로 매핑 ‘#…‘는 필수 형식 아님. 임의의 bare specifier 사용 가능. 다만 충돌 방지를 위해 ‘#’ 접두를 쓰는 패턴이 존재 예시 { \"imports\": { \"#utils\": \"/src/utils/\", \"#models\": \"/src/models/\" } }import { User } from '#models/User' 주의 Node.js는 HTML 기반 import maps를 지원하지 않음. Node에서 import maps를 쓰고자 한다면 번들러 또는 서버 사이드 변환 계층 필요 브라우저 타깃이 아닌 순수 Node 런타임에는 package.json imports를 고려하는 편이 적합 차이점 요약 ‘@…’ 경로\ntsconfig paths 기반 별칭 또는 npm 스코프 패키지 이름 두 의미 존재 tsconfig paths는 타입 체커 전용 별칭. 런타임 동작을 위해 번들러·로더 설정 동기화 필요 스코프 패키지는 패키지 네임스페이스 표기. 설정 없이 npm 해석 ‘…’ 경로\n상대·절대 경로를 직접 명시하는 기본 형태 설정 불필요. 환경 공통 동작 경로가 깊어지면 가독성 저하 ‘#…’ 경로\nNode.js package.json 의 imports로 정의하는 내부 전용 별칭 또는 브라우저 import maps에서의 별칭 키로 사용 Node 런타임 관점에서는 package imports가 공식적이고 안정적이며, 외부 노출 불가라는 제약이 있음 브라우저 import maps는 브라우저 전용 메커니즘. Node에서 직접 사용 불가 어떤 방식을 언제 쓸까 작은 프로젝트 또는 간단한 모듈 트리\n상대 경로 유지가 가장 직관적 대규모 코드베이스, 깊은 디렉터리 구조, 다수의 교차 참조\n경로 별칭 도입으로 가독성 확보 Node 런타임 우선이면 package.json imports의 ‘#…’ 채택 고려 브라우저 우선이면 import maps 또는 번들러 alias 사용 라이브러리 패키지 내부 캡슐화 강화 필요\n‘#…’ package imports로 내부 경로 보호 및 API 경계 명확화 프레임워크·조직 단위 패키지 묶음 배포\n‘@scope/name’ 스코프 패키지로 네임스페이스 관리 실무 주의사항과 베스트 프랙티스 tsconfig paths를 쓰면 반드시 런타임 해석자와 동기화\n번들러 alias, 테스트 러너, ts-node, ESLint import resolver를 함께 맞춤 Node 런타임 기준 별칭 1순위는 package.json imports 고려\n런타임이 직접 이해하므로 환경 의존성 감소 외부에 노출하지 않을 내부 경로에만 적용하는 것이 원칙 브라우저 타깃에서 import maps 사용 시 폴리필·번들링 전략과 함께 설계\n구형 브라우저 호환성, 캐시 전략, 배포 경로 관리 동반 검토 절대 경로 ‘/…’ 사용 자제\n브라우저와 Node에서 의미가 달라 이식성 낮음. 환경 단절 이슈 유발 가능 혼용을 최소화하고 팀 컨벤션 수립\n동일 목적의 별칭 체계는 한 가지 메커니즘으로 통일 예) 서버는 ‘#…’ imports, 클라이언트는 import maps, 공용 TypeScript는 상대 경로 또는 제한적 paths 간단 예시 스니펫 tsconfig paths로 ‘@utils/*’ 매핑 { \"compilerOptions\": { \"baseUrl\": \"./\", \"paths\": { \"@utils/*\": [\"src/utils/*\"] } } }import { calc } from '@utils/math' Node package imports로 ‘#utils’ 매핑 { \"type\": \"module\", \"imports\": { \"#utils\": \"./src/utils/index.js\" } }import { calc } from '#utils' 브라우저 import maps에서 ‘#models’ 매핑 { \"imports\": { \"#models\": \"/src/models/\" } }import { User } from '#models/User'마무리 ‘@’, ‘#’, 상대 경로는 표면적으로 비슷해 보여도 책임 주체와 동작 레이어가 다름\n‘@‘는 경로 별칭 또는 스코프 패키지 이름 ‘#‘는 Node의 package imports 또는 브라우저 import maps 별칭 키 상대·절대 경로는 파일 시스템·URL 기준 직접 지정 런타임이 무엇을 실제로 해석하는지부터 결정한 뒤 별칭 전략을 선택하는 것이 유지보수 비용을 줄이는 가장 확실한 방법임\n참고자료 https://www.typescriptlang.org/tsconfig#paths https://nodejs.org/api/packages.html#imports https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#import_maps https://github.com/WICG/import-maps https://docs.npmjs.com/cli/v10/using-npm/scope ","wordCount":"886","inLanguage":"en","datePublished":"2026-01-23T13:15:57.736Z","dateModified":"2026-01-23T13:15:57.736Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정</h1><div class=post-meta><span title='2026-01-23 13:15:57.736 +0000 UTC'>January 23, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴</p><ul><li>import &mldr; from &lsquo;@&mldr;&rsquo;</li><li>import &mldr; from &lsquo;&mldr;&rsquo;</li><li>import &mldr; from &lsquo;#&mldr;&rsquo;</li></ul><p>표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름</p><ul><li>&lsquo;@&lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능</li><li>&lsquo;&mldr;&lsquo;는 상대·절대 경로로 파일 시스템 기준 해석</li><li>&lsquo;#&lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용</li></ul><p>아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함</p><h3 id=-경로의-두-가지-의미>&lsquo;@&mldr;&rsquo; 경로의 두 가지 의미<a hidden class=anchor aria-hidden=true href=#-경로의-두-가지-의미>#</a></h3><h4 id=1-경로-별칭-path-alias>1) 경로 별칭 path alias<a hidden class=anchor aria-hidden=true href=#1-경로-별칭-path-alias>#</a></h4><ul><li>의도: 길고 복잡한 상대 경로를 짧게 추상화</li><li>설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl</li><li>예시</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;compilerOptions&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;baseUrl&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;./&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;paths&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>      <span style=color:#81a1c1>&#34;@models/*&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>[</span><span style=color:#a3be8c>&#34;src/models/*&#34;</span><span style=color:#eceff4>],</span>
</span></span><span style=display:flex><span>      <span style=color:#81a1c1>&#34;@utils/*&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>[</span><span style=color:#a3be8c>&#34;src/utils/*&#34;</span><span style=color:#eceff4>]</span>
</span></span><span style=display:flex><span>    <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>  <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> User <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;@models/User&#39;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> calculate <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;@utils/math&#39;</span></span></span></code></pre></div><ul><li>장점<ul><li>상대 경로를 단순화, 가독성 및 리팩터링 내성 향상</li></ul></li><li>주의<ul><li>tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님</li><li>Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요</li><li>예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요</li></ul></li></ul><h4 id=2-스코프된-패키지-scoped-package>2) 스코프된 패키지 scoped package<a hidden class=anchor aria-hidden=true href=#2-스코프된-패키지-scoped-package>#</a></h4><ul><li>의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합</li><li>표기: @scope/package-name 형태<ul><li>@nestjs/swagger, @angular/core 등</li></ul></li><li>사용 이유<ul><li>네임스페이스로 이름 충돌 회피</li><li>관련 패키지의 그룹화와 공개·비공개 관리</li></ul></li><li>설치</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>npm install @nestjs/swagger</span></span></code></pre></div><ul><li>해석<ul><li>이 경우 &lsquo;@&lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작</li><li>tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석</li></ul></li></ul><h3 id=-상대절대-경로-import>&lsquo;&mldr;&rsquo; 상대·절대 경로 import<a hidden class=anchor aria-hidden=true href=#-상대절대-경로-import>#</a></h3><ul><li>상대 경로 &lsquo;./&rsquo;, &lsquo;../&rsquo; 기준으로 현재 파일 위치에서 탐색</li><li>절대 경로 &lsquo;/path&rsquo;는 실행 환경마다 기준이 다름<ul><li>브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석</li><li>Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음</li></ul></li><li>예시</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> User <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;./models/User&#39;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> calculate <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;../utils/math&#39;</span></span></span></code></pre></div><ul><li>장점<ul><li>추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델</li><li>모듈 간 물리적 의존 관계가 드러남</li></ul></li><li>단점<ul><li>디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승</li><li>구조 변경 시 경로 대량 수정 발생</li></ul></li></ul><h3 id=-경로의-의미>&lsquo;#&mldr;&rsquo; 경로의 의미<a hidden class=anchor aria-hidden=true href=#-경로의-의미>#</a></h3><p>&lsquo;#{name}&rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의</p><h4 id=1-nodejs-패키지-imports>1) Node.js 패키지 imports<a hidden class=anchor aria-hidden=true href=#1-nodejs-패키지-imports>#</a></h4><ul><li>개념: package.json 의 imports 필드로 패키지 내부 전용 별칭 제공</li><li>특징<ul><li>키는 반드시 &lsquo;#&lsquo;로 시작</li><li>동일 패키지 내부 전용. 외부 소비자가 임의로 참조 불가</li><li>ESM 해석기에 의해 런타임에서 동작. 번들러 없이도 Node가 직접 이해</li></ul></li><li>설정 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;name&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;my-package&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;type&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;module&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;imports&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;#utils&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;./src/utils/index.js&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;#models/*&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;./src/models/*.js&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><ul><li>사용 예시</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> calc <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;#utils&#39;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> User <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;#models/User&#39;</span></span></span></code></pre></div><ul><li>장점<ul><li>런타임이 이해하는 공식 별칭. tsconfig paths와 달리 Node 해석 일관성 확보</li><li>외부 공개 API와 내부 경로를 분리하는 캡슐화에 유리</li></ul></li><li>주의<ul><li>패키지 외부에서는 &lsquo;#&mldr;&rsquo; 경로 사용 불가. 내부 전용 설계임</li><li>TypeScript는 nodenext 또는 node16 모듈 해석 설정에서 해당 매핑을 인지 가능. 도구별 지원 상태 확인 필요</li></ul></li></ul><h4 id=2-브라우저-import-maps에서의-별칭-키>2) 브라우저 import maps에서의 별칭 키<a hidden class=anchor aria-hidden=true href=#2-브라우저-import-maps에서의-별칭-키>#</a></h4><ul><li>개념: 브라우저가 script type=importmap 또는 별도 importmap.json을 통해 모듈 스펙ifier를 URL로 매핑</li><li>&lsquo;#&mldr;&lsquo;는 필수 형식 아님. 임의의 bare specifier 사용 가능. 다만 충돌 방지를 위해 &lsquo;#&rsquo; 접두를 쓰는 패턴이 존재</li><li>예시</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;imports&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;#utils&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;/src/utils/&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;#models&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;/src/models/&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> User <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;#models/User&#39;</span></span></span></code></pre></div><ul><li>주의<ul><li>Node.js는 HTML 기반 import maps를 지원하지 않음. Node에서 import maps를 쓰고자 한다면 번들러 또는 서버 사이드 변환 계층 필요</li><li>브라우저 타깃이 아닌 순수 Node 런타임에는 package.json imports를 고려하는 편이 적합</li></ul></li></ul><h3 id=차이점-요약>차이점 요약<a hidden class=anchor aria-hidden=true href=#차이점-요약>#</a></h3><ul><li><p>&lsquo;@&mldr;&rsquo; 경로</p><ul><li>tsconfig paths 기반 별칭 또는 npm 스코프 패키지 이름 두 의미 존재</li><li>tsconfig paths는 타입 체커 전용 별칭. 런타임 동작을 위해 번들러·로더 설정 동기화 필요</li><li>스코프 패키지는 패키지 네임스페이스 표기. 설정 없이 npm 해석</li></ul></li><li><p>&lsquo;&mldr;&rsquo; 경로</p><ul><li>상대·절대 경로를 직접 명시하는 기본 형태</li><li>설정 불필요. 환경 공통 동작</li><li>경로가 깊어지면 가독성 저하</li></ul></li><li><p>&lsquo;#&mldr;&rsquo; 경로</p><ul><li>Node.js package.json 의 imports로 정의하는 내부 전용 별칭 또는 브라우저 import maps에서의 별칭 키로 사용</li><li>Node 런타임 관점에서는 package imports가 공식적이고 안정적이며, 외부 노출 불가라는 제약이 있음</li><li>브라우저 import maps는 브라우저 전용 메커니즘. Node에서 직접 사용 불가</li></ul></li></ul><h3 id=어떤-방식을-언제-쓸까>어떤 방식을 언제 쓸까<a hidden class=anchor aria-hidden=true href=#어떤-방식을-언제-쓸까>#</a></h3><ul><li><p>작은 프로젝트 또는 간단한 모듈 트리</p><ul><li>상대 경로 유지가 가장 직관적</li></ul></li><li><p>대규모 코드베이스, 깊은 디렉터리 구조, 다수의 교차 참조</p><ul><li>경로 별칭 도입으로 가독성 확보</li><li>Node 런타임 우선이면 package.json imports의 &lsquo;#&mldr;&rsquo; 채택 고려</li><li>브라우저 우선이면 import maps 또는 번들러 alias 사용</li></ul></li><li><p>라이브러리 패키지 내부 캡슐화 강화 필요</p><ul><li>&lsquo;#&mldr;&rsquo; package imports로 내부 경로 보호 및 API 경계 명확화</li></ul></li><li><p>프레임워크·조직 단위 패키지 묶음 배포</p><ul><li>&lsquo;@scope/name&rsquo; 스코프 패키지로 네임스페이스 관리</li></ul></li></ul><h3 id=실무-주의사항과-베스트-프랙티스>실무 주의사항과 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#실무-주의사항과-베스트-프랙티스>#</a></h3><ul><li><p>tsconfig paths를 쓰면 반드시 런타임 해석자와 동기화</p><ul><li>번들러 alias, 테스트 러너, ts-node, ESLint import resolver를 함께 맞춤</li></ul></li><li><p>Node 런타임 기준 별칭 1순위는 package.json imports 고려</p><ul><li>런타임이 직접 이해하므로 환경 의존성 감소</li><li>외부에 노출하지 않을 내부 경로에만 적용하는 것이 원칙</li></ul></li><li><p>브라우저 타깃에서 import maps 사용 시 폴리필·번들링 전략과 함께 설계</p><ul><li>구형 브라우저 호환성, 캐시 전략, 배포 경로 관리 동반 검토</li></ul></li><li><p>절대 경로 &lsquo;/&mldr;&rsquo; 사용 자제</p><ul><li>브라우저와 Node에서 의미가 달라 이식성 낮음. 환경 단절 이슈 유발 가능</li></ul></li><li><p>혼용을 최소화하고 팀 컨벤션 수립</p><ul><li>동일 목적의 별칭 체계는 한 가지 메커니즘으로 통일</li><li>예) 서버는 &lsquo;#&mldr;&rsquo; imports, 클라이언트는 import maps, 공용 TypeScript는 상대 경로 또는 제한적 paths</li></ul></li></ul><h3 id=간단-예시-스니펫>간단 예시 스니펫<a hidden class=anchor aria-hidden=true href=#간단-예시-스니펫>#</a></h3><ul><li>tsconfig paths로 &lsquo;@utils/*&rsquo; 매핑</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;compilerOptions&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;baseUrl&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;./&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>&#34;paths&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span> <span style=color:#81a1c1>&#34;@utils/*&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>[</span><span style=color:#a3be8c>&#34;src/utils/*&#34;</span><span style=color:#eceff4>]</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>  <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> calc <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;@utils/math&#39;</span></span></span></code></pre></div><ul><li>Node package imports로 &lsquo;#utils&rsquo; 매핑</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;type&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;module&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;imports&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span> <span style=color:#81a1c1>&#34;#utils&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;./src/utils/index.js&#34;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> calc <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;#utils&#39;</span></span></span></code></pre></div><ul><li>브라우저 import maps에서 &lsquo;#models&rsquo; 매핑</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>&#34;imports&#34;</span><span style=color:#eceff4>:</span> <span style=color:#eceff4>{</span> <span style=color:#81a1c1>&#34;#models&#34;</span><span style=color:#eceff4>:</span> <span style=color:#a3be8c>&#34;/src/models/&#34;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#eceff4>{</span> User <span style=color:#eceff4>}</span> <span style=color:#81a1c1;font-weight:700>from</span> <span style=color:#a3be8c>&#39;#models/User&#39;</span></span></span></code></pre></div><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>&lsquo;@&rsquo;, &lsquo;#&rsquo;, 상대 경로는 표면적으로 비슷해 보여도 책임 주체와 동작 레이어가 다름</p><ul><li>&lsquo;@&lsquo;는 경로 별칭 또는 스코프 패키지 이름</li><li>&lsquo;#&lsquo;는 Node의 package imports 또는 브라우저 import maps 별칭 키</li><li>상대·절대 경로는 파일 시스템·URL 기준 직접 지정</li></ul><p>런타임이 무엇을 실제로 해석하는지부터 결정한 뒤 별칭 전략을 선택하는 것이 유지보수 비용을 줄이는 가장 확실한 방법임</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.typescriptlang.org/tsconfig#paths>https://www.typescriptlang.org/tsconfig#paths</a></li><li><a href=https://nodejs.org/api/packages.html#imports>https://nodejs.org/api/packages.html#imports</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#import_maps>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#import_maps</a></li><li><a href=https://github.com/WICG/import-maps>https://github.com/WICG/import-maps</a></li><li><a href=https://docs.npmjs.com/cli/v10/using-npm/scope>https://docs.npmjs.com/cli/v10/using-npm/scope</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/esm/>Esm</a></li><li><a href=https://blog.jsontapose.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jsontapose.com/tags/import/>Import</a></li><li><a href=https://blog.jsontapose.com/tags/module-resolution/>Module-Resolution</a></li><li><a href=https://blog.jsontapose.com/tags/path-alias/>Path-Alias</a></li><li><a href=https://blog.jsontapose.com/tags/npm-scopes/>Npm-Scopes</a></li><li><a href=https://blog.jsontapose.com/tags/import-maps/>Import-Maps</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/><span class=title>« Prev</span><br><span>RxJS 핵심 가이드와 내부 동작 이해 Observable Subject Teardown Scheduler Operator</span>
</a><a class=next href=https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/><span class=title>Next »</span><br><span>CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on x" href="https://x.com/intent/tweet/?text=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f&amp;hashtags=typescript%2cesm%2cnodejs%2cimport%2cmodule-resolution%2cpath-alias%2cnpm-scopes%2cimport-maps"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f&amp;title=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95&amp;summary=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f&title=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on whatsapp" href="https://api.whatsapp.com/send?text=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on telegram" href="https://telegram.me/share/url?text=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share TypeScript/ESM import 경로 정리: '@', '#', 상대 경로의 의미와 설정 on ycombinator" href="https://news.ycombinator.com/submitlink?t=TypeScript%2fESM%20import%20%ea%b2%bd%eb%a1%9c%20%ec%a0%95%eb%a6%ac%3a%20%27%40%27%2c%20%27%23%27%2c%20%ec%83%81%eb%8c%80%20%ea%b2%bd%eb%a1%9c%ec%9d%98%20%ec%9d%98%eb%af%b8%ec%99%80%20%ec%84%a4%ec%a0%95&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2ftypescript-esm-import-path-atsign-hash-relative-a9f97e%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>