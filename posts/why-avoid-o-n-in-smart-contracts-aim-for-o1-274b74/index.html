<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법 | HandsLog</title>
<meta name=keywords content="solidity,smart-contracts,gas-optimization,data-structures,ethereum"><meta name=description content='개요
스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.
문제 정의와 영향

상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식
문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험
정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가

핵심 개념과 대안

매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1)

mapping(address => bool) public users;

function register(address user) public {
  require(!users[user], "already registered");
  users[user] = true;
}
장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)'><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"><meta property="og:description" content='개요 스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.
문제 정의와 영향 상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식 문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험 정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가 핵심 개념과 대안 매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1) mapping(address => bool) public users; function register(address user) public { require(!users[user], "already registered"); users[user] = true; } 장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)'><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-21T13:05:50+00:00"><meta property="article:modified_time" content="2025-09-21T13:05:50+00:00"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Smart-Contracts"><meta property="article:tag" content="Gas-Optimization"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Ethereum"><meta name=twitter:card content="summary"><meta name=twitter:title content="스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"><meta name=twitter:description content='개요
스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.
문제 정의와 영향

상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식
문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험
정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가

핵심 개념과 대안

매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1)

mapping(address => bool) public users;

function register(address user) public {
  require(!users[user], "already registered");
  users[user] = true;
}
장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","item":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","name":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","description":"개요 스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.\n문제 정의와 영향 상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식 문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험 정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가 핵심 개념과 대안 매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1) mapping(address =\u0026gt; bool) public users; function register(address user) public { require(!users[user], \u0026#34;already registered\u0026#34;); users[user] = true; } 장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)\n","keywords":["solidity","smart-contracts","gas-optimization","data-structures","ethereum"],"articleBody":"개요 스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.\n문제 정의와 영향 상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식 문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험 정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가 핵심 개념과 대안 매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1) mapping(address =\u003e bool) public users; function register(address user) public { require(!users[user], \"already registered\"); users[user] = true; } 장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)\n배열 + 매핑 병행. 배열에 값 저장, 매핑에 인덱스 기록으로 O(1) 추가/삭제/조회 보장. 검증된 오픈소스 구현체(EnumerableSet 등)를 활용하면 안전한 패턴으로 사용 가능 동작 원리(배열+매핑 패턴) 값은 배열에 저장. 배열은 인덱스 기반 접근 허용 매핑은 값 -\u003e 배열 인덱스(또는 인덱스+1) 저장. 매핑 조회로 인덱스 즉시 획득 삭제 시에는 배열의 마지막 요소를 타겟 인덱스로 옮기고 매핑을 갱신하여 O(1) 삭제 이 패턴은 배열 열거와 상수 시간 체크를 동시에 만족시킴 실무 포인트(주의/한계/베스트프랙티스) 반복문 전면 금지 규칙이 아닌, ‘무제한 반복’ 금지 규칙으로 이해할 것. 반복의 상한이 명확히 제한되는 경우 허용 매핑은 열거 기능 없음. 온체인 열거가 필수면 배열 병행 또는 외부 인덱싱 설계 필요 배열+매핑 병행 시 상태 일관성 유지 책임. 삽입/삭제 시 둘 다 반드시 동기화할 것 대량 작업 필요 시 오프체인 처리와 이벤트 기반 인덱싱 활용 권장 함수 설계 시 최악의 케이스(최대 n) 가스 추정으로 블록 가스 한도 초과 여부 검증 거버넌스·관리자 권한으로 데이터 정리(archiving/pruning) 가능한 메커니즘 고려 라이브러리 사용 시 검증된 구현체 적용. 커스텀 구현은 경계 사례 테스트 필수 간단한 설계 대안 조회 전용 인덱스는 오프체인에 위임. 온체인은 상태 변경에만 집중 배치 처리(pagination) 형태로 유저 열람 제공. 한 트랜잭션당 처리량 제한 최대 허용 원소 수 설정 및 초과 시 신규 가입 제한 또는 아카이빙 트리거 검증과 회귀 방지 가스 사용량 가정 기반 단위·통합 테스트 작성. 최대 예상 n에 대해 시뮬레이션 실행 리그레션 테스트로 배열·매핑 동기화 상태 검증 포함 모니터링: 트랜잭션 실패(Exceeds block gas limit) 알람, 가스 사용 추세 대시보드 결론 스마트 컨트랙트에서 O(n) 연산은 단순한 비효율을 넘어 실행 불가 리스크를 초래함. 매핑을 사용한 상수 시간 조회 또는 배열+매핑 병행 패턴으로 열거성과 성능을 균형 있게 확보할 것. 오프체인 인덱싱, 배치 처리, 데이터 정리 정책 등 운영 수단을 함께 설계해야 장기적으로 안정적인 서비스 운영 가능.\n참고자료 https://medium.com/@aiden.p/%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EC%97%90%EC%84%9C-o-n-%EC%9D%84-%ED%94%BC%ED%95%98%EA%B3%A0-o-1-%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%A7%84%EC%A7%9C-%EC%9D%B4%EC%9C%A0-74b867b2281e https://www.youtube.com/watch?v=Q_1M2JaijjQ https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol ","wordCount":"432","inLanguage":"en","datePublished":"2025-09-21T13:05:50.555Z","dateModified":"2025-09-21T13:05:50.555Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법</h1><div class=post-meta><span title='2025-09-21 13:05:50.555 +0000 UTC'>September 21, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>스마트 컨트랙트 구현에서 반복문으로 인한 O(n) 연산은 단순한 성능 문제를 넘어 서비스 가용성에 직결되는 문제를 유발함. 블록 가스 한도와 트랜잭션 가스 비용 구조 때문에 선형 탐색이나 무제한 반복은 결국 특정 상태에서 함수가 더 이상 실행되지 못하는 상황(Exceeds block gas limit)으로 이어질 수 있음. 이유와 개선 방법, 실무에서 고려할 포인트를 정리함.</p><h3 id=문제-정의와-영향>문제 정의와 영향<a hidden class=anchor aria-hidden=true href=#문제-정의와-영향>#</a></h3><ul><li>상태 검증을 위해 배열을 전수 탐색하는 구현 사례. 예: 사용자 등록 시 users 배열을 처음부터 끝까지 비교하여 중복 체크하는 방식</li><li>문제점 요약: 가스 비용이 가입자 수에 비례해 증가. 블록 가스 한도를 넘기면 해당 함수 호출 불가. 서비스 정상성 저하 및 DoS 위험</li><li>정량적 예시: 개별 비교에 일정 가스가 소모되고 가입자 수가 수만 명대가 되면 단일 트랜잭션으로 처리 불가</li></ul><h3 id=핵심-개념과-대안>핵심 개념과 대안<a hidden class=anchor aria-hidden=true href=#핵심-개념과-대안>#</a></h3><ol><li>매핑(mapping)을 이용한 존재 여부 체크. 키-값 해시 조회 특성으로 조회/삽입/삭제 모두 O(1)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>address</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>public</span> users;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>register</span>(<span style=color:#66d9ef>address</span> user) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>  require(<span style=color:#f92672>!</span>users[user], <span style=color:#e6db74>&#34;already registered&#34;</span>);
</span></span><span style=display:flex><span>  users[user] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>장점: 존재 여부 확인 비용 고정. 단점: 전체 열거 불가(온체인 인덱스 조회 불가)</p><ol start=2><li>배열 + 매핑 병행. 배열에 값 저장, 매핑에 인덱스 기록으로 O(1) 추가/삭제/조회 보장. 검증된 오픈소스 구현체(EnumerableSet 등)를 활용하면 안전한 패턴으로 사용 가능</li></ol><h3 id=동작-원리배열매핑-패턴>동작 원리(배열+매핑 패턴)<a hidden class=anchor aria-hidden=true href=#동작-원리배열매핑-패턴>#</a></h3><ul><li>값은 배열에 저장. 배열은 인덱스 기반 접근 허용</li><li>매핑은 값 -> 배열 인덱스(또는 인덱스+1) 저장. 매핑 조회로 인덱스 즉시 획득</li><li>삭제 시에는 배열의 마지막 요소를 타겟 인덱스로 옮기고 매핑을 갱신하여 O(1) 삭제</li><li>이 패턴은 배열 열거와 상수 시간 체크를 동시에 만족시킴</li></ul><h3 id=실무-포인트주의한계베스트프랙티스>실무 포인트(주의/한계/베스트프랙티스)<a hidden class=anchor aria-hidden=true href=#실무-포인트주의한계베스트프랙티스>#</a></h3><ul><li>반복문 전면 금지 규칙이 아닌, &lsquo;무제한 반복&rsquo; 금지 규칙으로 이해할 것. 반복의 상한이 명확히 제한되는 경우 허용</li><li>매핑은 열거 기능 없음. 온체인 열거가 필수면 배열 병행 또는 외부 인덱싱 설계 필요</li><li>배열+매핑 병행 시 상태 일관성 유지 책임. 삽입/삭제 시 둘 다 반드시 동기화할 것</li><li>대량 작업 필요 시 오프체인 처리와 이벤트 기반 인덱싱 활용 권장</li><li>함수 설계 시 최악의 케이스(최대 n) 가스 추정으로 블록 가스 한도 초과 여부 검증</li><li>거버넌스·관리자 권한으로 데이터 정리(archiving/pruning) 가능한 메커니즘 고려</li><li>라이브러리 사용 시 검증된 구현체 적용. 커스텀 구현은 경계 사례 테스트 필수</li></ul><h3 id=간단한-설계-대안>간단한 설계 대안<a hidden class=anchor aria-hidden=true href=#간단한-설계-대안>#</a></h3><ul><li>조회 전용 인덱스는 오프체인에 위임. 온체인은 상태 변경에만 집중</li><li>배치 처리(pagination) 형태로 유저 열람 제공. 한 트랜잭션당 처리량 제한</li><li>최대 허용 원소 수 설정 및 초과 시 신규 가입 제한 또는 아카이빙 트리거</li></ul><h3 id=검증과-회귀-방지>검증과 회귀 방지<a hidden class=anchor aria-hidden=true href=#검증과-회귀-방지>#</a></h3><ul><li>가스 사용량 가정 기반 단위·통합 테스트 작성. 최대 예상 n에 대해 시뮬레이션 실행</li><li>리그레션 테스트로 배열·매핑 동기화 상태 검증 포함</li><li>모니터링: 트랜잭션 실패(Exceeds block gas limit) 알람, 가스 사용 추세 대시보드</li></ul><h3 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3><p>스마트 컨트랙트에서 O(n) 연산은 단순한 비효율을 넘어 실행 불가 리스크를 초래함. 매핑을 사용한 상수 시간 조회 또는 배열+매핑 병행 패턴으로 열거성과 성능을 균형 있게 확보할 것. 오프체인 인덱싱, 배치 처리, 데이터 정리 정책 등 운영 수단을 함께 설계해야 장기적으로 안정적인 서비스 운영 가능.</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://medium.com/@aiden.p/%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EC%97%90%EC%84%9C-o-n-%EC%9D%84-%ED%94%BC%ED%95%98%EA%B3%A0-o-1-%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%A7%84%EC%A7%9C-%EC%9D%B4%EC%9C%A0-74b867b2281e>https://medium.com/@aiden.p/%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EC%97%90%EC%84%9C-o-n-%EC%9D%84-%ED%94%BC%ED%95%98%EA%B3%A0-o-1-%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%A7%84%EC%A7%9C-%EC%9D%B4%EC%9C%A0-74b867b2281e</a></li><li><a href="https://www.youtube.com/watch?v=Q_1M2JaijjQ">https://www.youtube.com/watch?v=Q_1M2JaijjQ</a></li><li><a href=https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol>https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/solidity/>Solidity</a></li><li><a href=https://handsupmin.github.io/tags/smart-contracts/>Smart-Contracts</a></li><li><a href=https://handsupmin.github.io/tags/gas-optimization/>Gas-Optimization</a></li><li><a href=https://handsupmin.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://handsupmin.github.io/tags/ethereum/>Ethereum</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>