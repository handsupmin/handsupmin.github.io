<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법 | HandsLog</title>
<meta name=keywords content="solidity,smart-contracts,gas-optimization,data-structures,ethereum"><meta name=description content="개요
스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음
블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림
이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함

문제 정의와 영향

배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함
예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식
가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가
공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음
RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임


핵심 개념과 대안
1) 매핑으로 존재 여부 O(1) 검사
저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"><meta property="og:description" content="개요 스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음 블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림 이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함
문제 정의와 영향 배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함 예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식 가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가 공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음 RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임 핵심 개념과 대안 1) 매핑으로 존재 여부 O(1) 검사 저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-21T13:05:50+00:00"><meta property="article:modified_time" content="2025-09-21T13:05:50+00:00"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Smart-Contracts"><meta property="article:tag" content="Gas-Optimization"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Ethereum"><meta name=twitter:card content="summary"><meta name=twitter:title content="스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법"><meta name=twitter:description content="개요
스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음
블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림
이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함

문제 정의와 영향

배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함
예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식
가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가
공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음
RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임


핵심 개념과 대안
1) 매핑으로 존재 여부 O(1) 검사
저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","item":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","name":"스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법","description":"개요 스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음 블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림 이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\n문제 정의와 영향 배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함 예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식 가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가 공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음 RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임 핵심 개념과 대안 1) 매핑으로 존재 여부 O(1) 검사 저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\n","keywords":["solidity","smart-contracts","gas-optimization","data-structures","ethereum"],"articleBody":"개요 스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 실행 불가로 이어질 수 있음 블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 가스 한도 초과를 일으켜 서비스 가용성을 떨어뜨림 이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함\n문제 정의와 영향 배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함 예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식 가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가 공격자가 가스 그리핑을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 DoS가 될 수 있음 RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 미포함·리버트임 핵심 개념과 대안 1) 매핑으로 존재 여부 O(1) 검사 저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함\nmapping(address =\u003e bool) public users; function register(address user) public { require(!users[user], \"already registered\"); users[user] = true; } 장점 고정 비용으로 존재 확인이 가능 주의 매핑은 온체인 열거 불가이므로 조회 인덱스는 별도로 설계해야 함\n2) 배열 + 매핑 병행 패턴 배열에 값, 매핑에 인덱스 정보를 저장해 추가·삭제·조회 O(1) 과 열거 가능을 동시에 달성함 삭제는 스왑 후 pop으로 상수 시간 처리함\n간단 라이브러리 예시\n// 24줄 예시 라이브러리 library AddressSet { struct Set { address[] _list; mapping(address =\u003e uint256) _index; } function contains(Set storage s, address a) internal view returns (bool) { return s._index[a] != 0; } function add(Set storage s, address a) internal returns (bool) { if (contains(s, a)) return false; s._list.push(a); s._index[a] = s._list.length; return true; } function remove(Set storage s, address a) internal returns (bool) { uint256 i = s._index[a]; if (i == 0) return false; uint256 li = s._list.length; address last = s._list[li - 1]; s._list[i - 1] = last; s._index[last] = i; s._list.pop(); delete s._index[a]; return true; } function length(Set storage s) internal view returns (uint256) { return s._list.length; } function at(Set storage s, uint256 i) internal view returns (address) { return s._list[i]; } } 3) 루프 상한이 명확한 배치 패턴 무제한 루프가 아니라 상한이 보장된 반복만 허용하고 나머지는 다음 호출로 미룸 예 require(batch.length \u003c= MAX_BATCH) 와 체크포인트 저장\n4) 온체인 최소화·오프체인 인덱싱 상태 변경만 온체인에 기록하고 열거·검색은 이벤트 기반 인덱서에 위임함 The Graph 같은 인덱서 또는 백엔드 DB를 사용해 조회 성능을 확보함\n5) 푸시 대신 풀 패턴 N명에게 한 번에 분배하는 푸시 루프 대신 각 수령자가 claim으로 가져가게 해 루프를 제거함 머클 드롭처럼 증명 기반 청구를 쓰면 대량 분배에서도 O(1) per user 달성 가능\n동작 원리 상세 배열 + 매핑 배열에 값 저장, 매핑에 값 → 배열 인덱스+1 저장으로 0을 미존재로 활용 삭제 시 타깃 인덱스에 마지막 요소를 스왑하고 pop, 스왑된 요소의 인덱스를 갱신 삽입·삭제·존재 확인이 모두 상수 시간으로 동작하며 length·at로 열거 가능 실무 포인트 주의·한계·베스트 프랙티스 금기는 무제한 반복이며 루프 자체 금지는 아님 반복의 상한이 코드로 보장되면 안전하게 사용할 수 있음 매핑은 열거가 불가 온체인 열거가 필요하면 배열을 병행하거나 이벤트 인덱싱을 설계함 배열+매핑 병행은 상태 동기화가 생명 삽입·삭제마다 두 구조를 함께 갱신하고 실패 시 일관성 유지를 보장해야 함 대량 작업은 오프체인에서 사전 계산하고 온체인에는 커밋·증명만 올림 함수는 최악 케이스 가스 기준으로 설계하고 배포 전 시뮬레이션으로 수렴 여부를 확인함 관리자 권한으로 아카이빙·프루닝을 허용하면 장기적으로 가스 추세를 안정화할 수 있음 검증된 구현 사용을 우선 고려 OpenZeppelin EnumerableSet 같은 표준 라이브러리는 경계 사례가 잘 다듬어져 있음 추가 최적화 팁 가스·안정성 SSTORE 비용 상식 신규 슬롯 기록은 매우 비싸고 기존 값 업데이트가 상대적으로 저렴하며 가스 환급은 최근 제안들로 크게 축소됨 많은 슬롯을 자주 비우는 설계는 기대만큼 환급이 일어나지 않을 수 있음 콜드·웜 접근 처음 접근하는 저장소·계정은 콜드 비용이 높고 같은 트랜잭션 내 재접근은 웜으로 저렴해짐 같은 키를 여러 번 읽는다면 한 번 읽어 메모리에 캐시하고 사용함 데이터 모델 집합이 ID 기반이면 mapping(uint256 =\u003e uint256) 비트맵으로 압축해 SSTORE 개수를 줄일 수 있음 루프 미세 최적화 상한이 작은 루프에서 unchecked { ++i } 로 증가 비용을 절감할 수 있으나 오버플로 안전성을 스스로 보장해야 함 외부 호출은 풀 패턴 루프 안에서 외부 호출을 하지 말고 사용자가 개별 청구하는 풀 모델로 전환해 재진입·가스 폭탄 리스크를 줄임 EIP‑2930 접근 리스트 가스 민감 트랜잭션은 Access List로 콜드 비용을 일부 완화하는 방식을 검토함 간단한 설계 대안 조회 전용 인덱스 오프체인 위임 온체인은 상태 변경과 이벤트만 발행 페이지네이션 제공 한 호출당 처리량을 제한해 UX와 가스 안정성을 동시에 확보 상한·쿼터·할당량 도입 최대 원소 수나 1회 배치 한도를 프로토콜 상수로 명시하고 초과 시 아카이빙 트리거 검증과 회귀 방지 가스 예산 테스트 최대 예상 n에 대해 단위·통합 테스트로 가스 사용량을 프로파일링 일관성 테스트 배열·매핑 동기화가 항상 유지되는지 경계 케이스로 검증 모니터링 트랜잭션 실패율, 가스 사용 추세, out of gas 류 에러 알람을 운영 대시보드에 포함 프로퍼티 기반 테스트 삽입·삭제·재삽입을 무작위 시퀀스로 실행해 인버리언트를 검증 감사 체크리스트 사용자 입력에 의해 루프 길이가 통제 불가한 경로가 있는지 외부 호출이 루프 내부에 존재하는지 반복 상한을 보장하는 require 검사가 있는지 로컬 캐시 없이 동일 SLOAD를 반복하는지 상태 구조가 장기적으로 가스가 비단조 증가하도록 설계됐는지 실패 시 롤백으로 상태 일관성이 유지되는지 마무리 스마트 컨트랙트의 O(n) 루프는 단순한 비효율이 아니라 운영 불능으로 연결될 수 있는 위험 요소임 매핑과 배열+매핑 패턴으로 상수 시간 검사를 확보하고, 배치·풀·오프체인 인덱싱을 결합해 열거와 성능을 균형 있게 달성할 것 배포 전에는 최악 케이스 가스를 기준으로 테스트하고, 배포 후에는 모니터링과 프루닝 정책으로 장기 안정성을 유지할 것\n참고자료 OpenZeppelin EnumerableSet https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol EIP‑2929 Gas cost increases for state access https://eips.ethereum.org/EIPS/eip-2929 EIP‑3529 Reduction in refunds https://eips.ethereum.org/EIPS/eip-3529 The Graph 문서 인덱싱 개요 https://thegraph.com/docs MerkleProof 유틸리티 https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography ","wordCount":"850","inLanguage":"en","datePublished":"2025-09-21T13:05:50.555Z","dateModified":"2025-09-21T13:05:50.555Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법</h1><div class=post-meta><span title='2025-09-21 13:05:50.555 +0000 UTC'>September 21, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 <strong>실행 불가</strong>로 이어질 수 있음
블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 <strong>가스 한도 초과</strong>를 일으켜 서비스 가용성을 떨어뜨림
이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함</p><hr><h3 id=문제-정의와-영향>문제 정의와 영향<a hidden class=anchor aria-hidden=true href=#문제-정의와-영향>#</a></h3><ul><li>배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함
예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식</li><li>가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가</li><li>공격자가 <strong>가스 그리핑</strong>을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 <strong>DoS</strong>가 될 수 있음</li><li>RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 <strong>미포함·리버트</strong>임</li></ul><hr><h3 id=핵심-개념과-대안>핵심 개념과 대안<a hidden class=anchor aria-hidden=true href=#핵심-개념과-대안>#</a></h3><p><strong>1) 매핑으로 존재 여부 O(1) 검사</strong>
저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>address</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>public</span> users;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>register</span>(<span style=color:#66d9ef>address</span> user) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>  require(<span style=color:#f92672>!</span>users[user], <span style=color:#e6db74>&#34;already registered&#34;</span>);
</span></span><span style=display:flex><span>  users[user] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>장점 고정 비용으로 존재 확인이 가능
주의 매핑은 <strong>온체인 열거 불가</strong>이므로 조회 인덱스는 별도로 설계해야 함</p><p><strong>2) 배열 + 매핑 병행 패턴</strong>
배열에 값, 매핑에 인덱스 정보를 저장해 <strong>추가·삭제·조회 O(1)</strong> 과 <strong>열거 가능</strong>을 동시에 달성함
삭제는 스왑 후 pop으로 상수 시간 처리함</p><p>간단 라이브러리 예시</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// 24줄 예시 라이브러리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>library</span> AddressSet {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Set</span> { <span style=color:#66d9ef>address</span>[] _list; <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>address</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) _index; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>contains</span>(Set <span style=color:#66d9ef>storage</span> s, <span style=color:#66d9ef>address</span> a) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s._index[a] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(Set <span style=color:#66d9ef>storage</span> s, <span style=color:#66d9ef>address</span> a) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (contains(s, a)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    s._list.push(a);
</span></span><span style=display:flex><span>    s._index[a] <span style=color:#f92672>=</span> s._list.length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>remove</span>(Set <span style=color:#66d9ef>storage</span> s, <span style=color:#66d9ef>address</span> a) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> i <span style=color:#f92672>=</span> s._index[a];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> li <span style=color:#f92672>=</span> s._list.length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> last <span style=color:#f92672>=</span> s._list[li <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    s._list[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>    s._index[last] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    s._list.pop();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> s._index[a];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>length</span>(Set <span style=color:#66d9ef>storage</span> s) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span>) { <span style=color:#66d9ef>return</span> s._list.length; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>at</span>(Set <span style=color:#66d9ef>storage</span> s, <span style=color:#66d9ef>uint256</span> i) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>address</span>) { <span style=color:#66d9ef>return</span> s._list[i]; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>3) 루프 상한이 명확한 배치 패턴</strong>
무제한 루프가 아니라 <strong>상한이 보장된</strong> 반복만 허용하고 나머지는 다음 호출로 미룸
예 <code>require(batch.length &lt;= MAX_BATCH)</code> 와 체크포인트 저장</p><p><strong>4) 온체인 최소화·오프체인 인덱싱</strong>
상태 변경만 온체인에 기록하고 열거·검색은 이벤트 기반 인덱서에 위임함
The Graph 같은 인덱서 또는 백엔드 DB를 사용해 조회 성능을 확보함</p><p><strong>5) 푸시 대신 풀 패턴</strong>
N명에게 한 번에 분배하는 푸시 루프 대신 각 수령자가 <code>claim</code>으로 가져가게 해 루프를 제거함
머클 드롭처럼 증명 기반 청구를 쓰면 대량 분배에서도 O(1) per user 달성 가능</p><hr><h3 id=동작-원리-상세-배열--매핑>동작 원리 상세 배열 + 매핑<a hidden class=anchor aria-hidden=true href=#동작-원리-상세-배열--매핑>#</a></h3><ul><li>배열에 값 저장, 매핑에 값 → 배열 인덱스+1 저장으로 0을 미존재로 활용</li><li>삭제 시 타깃 인덱스에 <strong>마지막 요소를 스왑</strong>하고 pop, 스왑된 요소의 인덱스를 갱신</li><li>삽입·삭제·존재 확인이 모두 상수 시간으로 동작하며 <code>length</code>·<code>at</code>로 열거 가능</li></ul><hr><h3 id=실무-포인트-주의한계베스트-프랙티스>실무 포인트 주의·한계·베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#실무-포인트-주의한계베스트-프랙티스>#</a></h3><ul><li>금기는 <strong>무제한 반복</strong>이며 루프 자체 금지는 아님
반복의 <strong>상한</strong>이 코드로 보장되면 안전하게 사용할 수 있음</li><li>매핑은 열거가 불가
온체인 열거가 필요하면 배열을 병행하거나 이벤트 인덱싱을 설계함</li><li>배열+매핑 병행은 <strong>상태 동기화</strong>가 생명
삽입·삭제마다 두 구조를 함께 갱신하고 실패 시 일관성 유지를 보장해야 함</li><li>대량 작업은 오프체인에서 사전 계산하고 온체인에는 <strong>커밋·증명</strong>만 올림</li><li>함수는 <strong>최악 케이스 가스</strong> 기준으로 설계하고 배포 전 시뮬레이션으로 수렴 여부를 확인함</li><li>관리자 권한으로 <strong>아카이빙·프루닝</strong>을 허용하면 장기적으로 가스 추세를 안정화할 수 있음</li><li>검증된 구현 사용을 우선 고려
OpenZeppelin <code>EnumerableSet</code> 같은 표준 라이브러리는 경계 사례가 잘 다듬어져 있음</li></ul><hr><h3 id=추가-최적화-팁-가스안정성>추가 최적화 팁 가스·안정성<a hidden class=anchor aria-hidden=true href=#추가-최적화-팁-가스안정성>#</a></h3><ul><li><strong>SSTORE 비용 상식</strong>
신규 슬롯 기록은 매우 비싸고 기존 값 업데이트가 상대적으로 저렴하며 가스 환급은 최근 제안들로 크게 축소됨
많은 슬롯을 자주 비우는 설계는 기대만큼 환급이 일어나지 않을 수 있음</li><li><strong>콜드·웜 접근</strong>
처음 접근하는 저장소·계정은 콜드 비용이 높고 같은 트랜잭션 내 재접근은 웜으로 저렴해짐
같은 키를 여러 번 읽는다면 한 번 읽어 <strong>메모리에 캐시</strong>하고 사용함</li><li><strong>데이터 모델</strong>
집합이 ID 기반이면 <code>mapping(uint256 => uint256)</code> 비트맵으로 압축해 SSTORE 개수를 줄일 수 있음</li><li><strong>루프 미세 최적화</strong>
상한이 작은 루프에서 <code>unchecked { ++i }</code> 로 증가 비용을 절감할 수 있으나 <strong>오버플로 안전성</strong>을 스스로 보장해야 함</li><li><strong>외부 호출은 풀 패턴</strong>
루프 안에서 외부 호출을 하지 말고 사용자가 개별 청구하는 풀 모델로 전환해 <strong>재진입·가스 폭탄</strong> 리스크를 줄임</li><li><strong>EIP‑2930 접근 리스트</strong>
가스 민감 트랜잭션은 Access List로 콜드 비용을 일부 완화하는 방식을 검토함</li></ul><hr><h3 id=간단한-설계-대안>간단한 설계 대안<a hidden class=anchor aria-hidden=true href=#간단한-설계-대안>#</a></h3><ul><li><strong>조회 전용 인덱스 오프체인 위임</strong> 온체인은 상태 변경과 이벤트만 발행</li><li><strong>페이지네이션 제공</strong> 한 호출당 처리량을 제한해 UX와 가스 안정성을 동시에 확보</li><li><strong>상한·쿼터·할당량 도입</strong> 최대 원소 수나 1회 배치 한도를 프로토콜 상수로 명시하고 초과 시 아카이빙 트리거</li></ul><hr><h3 id=검증과-회귀-방지>검증과 회귀 방지<a hidden class=anchor aria-hidden=true href=#검증과-회귀-방지>#</a></h3><ul><li><strong>가스 예산 테스트</strong> 최대 예상 n에 대해 단위·통합 테스트로 가스 사용량을 프로파일링</li><li><strong>일관성 테스트</strong> 배열·매핑 동기화가 항상 유지되는지 경계 케이스로 검증</li><li><strong>모니터링</strong> 트랜잭션 실패율, 가스 사용 추세, <code>out of gas</code> 류 에러 알람을 운영 대시보드에 포함</li><li><strong>프로퍼티 기반 테스트</strong> 삽입·삭제·재삽입을 무작위 시퀀스로 실행해 인버리언트를 검증</li></ul><hr><h3 id=감사-체크리스트>감사 체크리스트<a hidden class=anchor aria-hidden=true href=#감사-체크리스트>#</a></h3><ul><li>사용자 입력에 의해 <strong>루프 길이가 통제 불가</strong>한 경로가 있는지</li><li>외부 호출이 루프 내부에 존재하는지</li><li>반복 상한을 보장하는 <code>require</code> 검사가 있는지</li><li>로컬 캐시 없이 동일 SLOAD를 반복하는지</li><li>상태 구조가 장기적으로 <strong>가스가 비단조 증가</strong>하도록 설계됐는지</li><li>실패 시 롤백으로 <strong>상태 일관성</strong>이 유지되는지</li></ul><hr><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>스마트 컨트랙트의 O(n) 루프는 단순한 비효율이 아니라 <strong>운영 불능</strong>으로 연결될 수 있는 위험 요소임
<strong>매핑</strong>과 <strong>배열+매핑</strong> 패턴으로 상수 시간 검사를 확보하고, 배치·풀·오프체인 인덱싱을 결합해 열거와 성능을 균형 있게 달성할 것
배포 전에는 <strong>최악 케이스 가스</strong>를 기준으로 테스트하고, 배포 후에는 모니터링과 프루닝 정책으로 장기 안정성을 유지할 것</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>OpenZeppelin EnumerableSet
<a href=https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol>https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol</a></li><li>EIP‑2929 Gas cost increases for state access
<a href=https://eips.ethereum.org/EIPS/eip-2929>https://eips.ethereum.org/EIPS/eip-2929</a></li><li>EIP‑3529 Reduction in refunds
<a href=https://eips.ethereum.org/EIPS/eip-3529>https://eips.ethereum.org/EIPS/eip-3529</a></li><li>The Graph 문서 인덱싱 개요
<a href=https://thegraph.com/docs>https://thegraph.com/docs</a></li><li>MerkleProof 유틸리티
<a href=https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography>https://docs.openzeppelin.com/contracts/4.x/utilities#cryptography</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/solidity/>Solidity</a></li><li><a href=https://handsupmin.github.io/tags/smart-contracts/>Smart-Contracts</a></li><li><a href=https://handsupmin.github.io/tags/gas-optimization/>Gas-Optimization</a></li><li><a href=https://handsupmin.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://handsupmin.github.io/tags/ethereum/>Ethereum</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>