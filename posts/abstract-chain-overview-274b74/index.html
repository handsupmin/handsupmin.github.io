<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리 | HandsLog</title>
<meta name=keywords content="zk-rollup,layer-2,account-abstraction,smart-contract-wallet"><meta name=description content="개요
이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함
목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것

주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/abstract-chain-overview-274b74/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/abstract-chain-overview-274b74/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://handsupmin.github.io/posts/abstract-chain-overview-274b74/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리"><meta property="og:description" content="개요 이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함 목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것
주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-24T13:09:24+00:00"><meta property="article:modified_time" content="2025-09-24T13:09:24+00:00"><meta property="article:tag" content="Zk-Rollup"><meta property="article:tag" content="Layer-2"><meta property="article:tag" content="Account-Abstraction"><meta property="article:tag" content="Smart-Contract-Wallet"><meta name=twitter:card content="summary"><meta name=twitter:title content="Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리"><meta name=twitter:description content="개요
이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함
목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것

주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리","item":"https://handsupmin.github.io/posts/abstract-chain-overview-274b74/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리","name":"Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리","description":"개요 이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함 목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것\n주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요\n","keywords":["zk-rollup","layer-2","account-abstraction","smart-contract-wallet"],"articleBody":"개요 이 글은 ‘Abstract’로 지칭되는 ZK Rollup 기반 L2 체인의 구조와 핵심 컴포넌트를 실무 관점에서 정리함 목표는 트랜잭션 흐름, 증명 생성·검증 파이프라인, 데이터 가용성(DA), 네이티브 계정 추상화(AA), 스마트 컨트랙트 지갑의 동작 방식과 운영·보안·성능 관점의 실무 포인트를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 정확성을 보강하는 것\n주의: 본 문서는 일반적인 ZK Rollup 아키텍처를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 구현체 문서를 병행 참고 필요\n배경과 목적 배경: L1(예: 이더리움)의 처리량·가스비 제약을 보완하기 위해 L2 도입이 필요 ZK Rollup의 목적: 메인넷 보안성을 활용하면서 트랜잭션 처리량을 확대하고 온체인 비용을 절감. 유효성 증명(validity proof) 으로 상태 전이가 올바름을 보장해 도전 기간 없이 빠른 확정을 지향 핵심 개념과 정의 ZK Rollup: 트랜잭션을 L2에서 실행·집계하고, 그 결과에 대한 유효성 증명을 L1로 제출해 상태 변경을 확정하는 확장 방식 ZK Stack(일반): ZK Rollup 구축을 위한 회로/프루버/런타임/배포 도구의 모음(구현체별 상이) Sequencer: L2 트랜잭션을 수신·정렬·블록화하고, 배치를 생성하는 컴포넌트(중앙/탈중앙 설계 가능) Prover / Verifier: Prover가 증인(witness) 을 생성하고 회로를 실행해 증명을 만들면, L1의 Verifier(스마트 컨트랙트)가 이를 검증 네이티브 Account Abstraction(AA): 모든 계정이 컨트랙트 계정으로 동작(예: zkSync·Starknet 스타일). EIP-4337과는 별개 경로의 네이티브 모델일 수 있음 아키텍처 개요 Sequencer 영역\nRPC 게이트웨이: 트랜잭션 제출·조회 API 제공(JSON-RPC 호환/확장) 시퀀싱/실행: 멤풀에서 트랜잭션을 읽어 정렬·블록화, 실행 결과를 즉시 반환할 수 있음(체인별 정책) L1 동기화: 입출금 브리지, 시스템 이벤트 추적 Prover \u0026 Verifier 영역\n증인 생성 → 회로 실행 → 증명 생성/집계 → (선택) 재귀 증명 일부 구현은 STARK → SNARK 래핑 또는 재귀 SNARK로 L1 검증 비용 최적화(구현체별 다름) L1 Rollup Contracts\n배치 커밋(DA 확립), 증명 검증, 상태 루트 업데이트, 크로스체인 메시지 처리(Inbox/Outbox) 데이터 가용성(DA)\nEIP-4844 블롭을 활용해 Rollup 데이터(입력/차분)를 저비용으로 게시. 블롭은 EVM에서 직접 읽히지 않으며 일정 기간 후 가비지 컬렉션될 수 있으므로, L2 재현성은 블롭 + 노드 아카이빙 조합으로 확보 트랜잭션 생명주기(일반화) 제출: 클라이언트가 JSON-RPC로 트랜잭션 전송 → L2 멤풀 적재 시퀀싱 \u0026 실행: Sequencer가 트랜잭션을 정렬·실행. 결과(성공/실패, tx hash)를 즉시 응답 가능(정책에 따름) 배치 생성: 특정 주기/조건에 따라 블록들을 묶어 배치(batch) 구성 증명 준비: Prover가 배치에 대한 witness 생성 → 회로 실행 → 유효성 증명 생성(필요 시 재귀/집계) L1 게시(DA) \u0026 증명 제출: 블롭(EIP-4844) 등으로 데이터 가용성 확보 후, 증명을 Rollup Verifier에 제출 검증·확정: L1에서 증명 검증 성공 시 해당 배치의 상태 루트가 확정(finality). 브리지 메시지 처리 등 후속 로직 실행 용어 주의: 구현 문서에 나오는 proveBatches, finalize/executeBatches 등 함수명은 예시적 표현이며, 실제 명칭·시맨틱은 스택별로 다름\n증명 파이프라인(좀 더 구체적으로) witness 생성: VM 실행 트레이스, 스토리지 읽기/쓰기, precompile 호출 등을 회로 입력으로 변환\n회로 구성: 범용 VM 회로(예: RISC-V/LLVM IR 스타일) 또는 EVM 친화 회로, Merkle/KZG 등 커밋먼트 검증 서브회로 포함\n재귀·집계: 여러 증명을 트리 형태로 합성(aggregation)해 L1 검증 비용을 상수/로그 수준으로 유도\n성능 팁(운영):\n배치 크기/가짓수, 회로 분해(granularity) 설정으로 TTP(Time-To-Proof) 최적화 프루버 팜(HW 가속: GPU/FPGA/ASIC)과 큐 동시성으로 증명 처리량 보장 L1 가스/블롭 비용 변동에 맞춘 배치 시점/크기 튜닝 데이터 가용성(DA) \u0026 EIP-4844 블롭(Blob): EVM에 직접 접근 불가한 대용량 데이터 영역. KZG 커밋먼트로 무결성 보장 장점: calldata 대비 저렴한 데이터 게시. 롤업 비용 구조의 핵심 운영 포인트: 블롭 보존 기간 이후를 대비해 오프체인 아카이브·재생성 전략 필요. 프루닝 정책과 동기화 도구 점검 L1 Rollup Contract 주요 기능(일반화) commitBatch: 입력 데이터/상태 요약을 게시(DA) verifyBatch: 제출된 증명의 유효성 검증 finalizeBatch: 상태 루트 업데이트 및 교차메시지 확정 Bridge(입·출금): L1↔L2 메시지 박스(Inbox/Outbox), 강제 포함(Force Inclusion) 메커니즘으로 검열 대응 네이티브 계정 추상화(AA) 개요 핵심: EOA 없이 모든 계정이 컨트랙트로 동작 → 서명 검증·nonce·가스 지불 로직을 계정이 스스로 정의 장점: 키 회전/멀티시그/세션키/소셜 복구/가스 대납 등 유연한 UX 주의: mempool 정책, 부트로더/시스템 컨트랙트 인터페이스, 가스 회계 방식이 EIP-4337과 다를 수 있음 (예시) 네이티브 AA 처리 흐름 (zkSync 계열 유사 개념, 체인별 상이) 제출: JSON-RPC로 트랜잭션 제출(from이 컨트랙트 주소) 부트로더/시스템: 멤풀→배치, nonce 검증·서명 검증·가스 계산 계정 훅: validate* → execute* → paymaster/fee settlement 순으로 훅 호출 페이마스터: 정책에 맞춰 가스 대납/토큰 지불 결정, 사후 정산 훅 실행 EIP-4337(번들러/EntryPoint 기반)과 동일하지 않음. “네이티브 AA”는 프로토콜 레벨에서 계정이 컨트랙트로 정의되는 모델임\n페이마스터(가스 대납) 설계 포인트 정책: 허용 토큰·한도·쿨다운·화이트리스트/블랙리스트 검증: 오프체인 서명·쿼터 점검·리플레이 방지(nonce·만료) 리스크 관리: 불로소득(arbitrage) 악용·스팸 방지(예: 최소 잔액·인증)·실패 시 롤백 범위 최소화 스마트 컨트랙트 지갑 설계(일반) 배포 패턴: 팩토리+프록시(미니멀 프록시)로 가스 절감·업그레이드 용이 키 관리: 멀티시그·세션키(권한·만료)·키 회전·소셜 복구 서명 표준: 온체인 서명 검증은 EIP-1271 구현 권장 // 30줄 미만 예시 contract ERC1271 { bytes4 constant internal MAGICVALUE = 0x1626ba7e; function isValidSignature(bytes32 _hash, bytes memory _sig) public view returns (bytes4) { // 구현부는 지갑 정책에 맞게 작성 return MAGICVALUE; } } 보안 모델 및 리스크 유효성 증명 안전성: 회로 사운드니스, 트러스트 설정(예: SRS), 업그레이드 키 관리 시퀀서 리스크: 다운타임/검열 → 강제 포함 경로(L1 큐), 시퀀서 탈중앙화 로드맵 검토 브리지 안전성: L1 검증 완료 전 출금 불가. 메시지 재생성·체인 재조직(Reorg) 처리 방침 명확화 AA·페이마스터 남용: 스팸·사기 유입을 계정/페이마스터 레벨에서 선제 차단 운영·모니터링 지표(KPI) TTI(Time-To-Inclusion): 제출→L2 포함까지 지연 TTP(Time-To-Proof): 배치→증명 생성 완료까지 지연 TTF(Time-To-Finality): L1 검증 완료까지 전체 시간 비용 지표: L1 데이터(블롭/칼데이터) 비용, 증명 가스/수수료, L2 가스 신뢰도: 시퀀서 가용성, 강제 포함 성공률, 브리지 처리 성공률 성능·운영 베스트 프랙티스 배치 전략: 가스 시황·트래픽 패턴에 맞춘 동적 배치 크기/주기 프루버 팜: GPU/FPGA 활용·큐 병렬화·증명 집계로 지연 단축 비용 최적화: EIP-4844 블롭 우선 활용, 상태 쓰기 최소화, 재귀 증명으로 L1 검증 상수화 개발자 경험(DX): JSON-RPC 차이점 문서화, 트레이스/디버깅 도구 제공, 에러 코드 일관성 간단 운영 시나리오(요약) 사용자가 트랜잭션 제출 → Sequencer가 실행 결과를 빠르게 응답 → 일정 주기마다 배치 생성 → Prover가 증명 생성 및 집계 → L1에 블롭 데이터 게시 + 증명 제출 → Verifier가 검증하면 상태 확정 → 브리지 메시지 처리 자주 헷갈리는 포인트 교정 “ZK Rollup은 항상 STARK→SNARK 압축을 한다” → 체인별로 다름. SNARK만 쓰거나, STARK 검증을 L1에서 직접 하거나, 재귀 SNARK만 쓰는 경우도 있음 “네이티브 AA = EIP-4337” → 아님. 네이티브 AA는 프로토콜 계정 모델 자체가 컨트랙트 기반. 4337은 EOA 유지 + 번들러/EntryPoint 레이어임 “블롭 데이터는 영구 상태” → 아님. 블롭은 일시적 보존이며 EVM에서 바로 읽을 수 없음. KZG 커밋먼트로 무결성만 보장 “증명 올라가면 즉시 확정” → L1 검증 트랜잭션 확정(재조직 위험 해소)까지 감안해야 운영상 최종 확정으로 처리 마무리 본 문서는 Abstract 계열 ZK Rollup L2를 염두에 둔 일반적 아키텍처와 AA·지갑·페이마스터 동작을 설명했음\n실제 배포·운영 시에는 다음을 우선 검토 권장\n증명 백엔드 설계(회로 범위·재귀·프루버 팜) 배치·DA 전략(블롭 활용, 비용·지연 균형점) AA/페이마스터 보안 정책(남용·스팸 방지) 브리지 \u0026 강제 포함 경로(검열/다운타임 대비) 체인·스택 문서를 병행하여 용어·함수명·정책 차이를 확인하고, 위 원칙을 현장에 맞게 보수적으로 적용할 것\n참고자료 EIP-1271: https://eips.ethereum.org/EIPS/eip-1271 EIP-4844(Proto-Danksharding): https://eips.ethereum.org/EIPS/eip-4844 롤업 설계 원리(Buterin): https://vitalik.ca/general/2021/06/15/rollups.html ","wordCount":"1021","inLanguage":"en","datePublished":"2025-09-24T13:09:24.81Z","dateModified":"2025-09-24T13:09:24.81Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://handsupmin.github.io/posts/abstract-chain-overview-274b74/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://handsupmin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Abstract 체인이란? zkRollup 기반 L2 체인 구조와 핵심 컴포넌트 정리</h1><div class=post-meta><span title='2025-09-24 13:09:24.81 +0000 UTC'>September 24, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>이 글은 ‘Abstract’로 지칭되는 <strong>ZK Rollup 기반 L2 체인</strong>의 구조와 핵심 컴포넌트를 <strong>실무 관점</strong>에서 정리함
목표는 <strong>트랜잭션 흐름</strong>, <strong>증명 생성·검증 파이프라인</strong>, <strong>데이터 가용성(DA)</strong>, <strong>네이티브 계정 추상화(AA)</strong>, <strong>스마트 컨트랙트 지갑</strong>의 동작 방식과 <strong>운영·보안·성능 관점의 실무 포인트</strong>를 초보자도 이해할 수 있게 설명하면서, 전문가가 보아도 무리가 없도록 <strong>정확성</strong>을 보강하는 것</p><blockquote><p>주의: 본 문서는 <strong>일반적인 ZK Rollup 아키텍처</strong>를 기준으로 설명함. 체인/스택별 명칭과 세부 동작(예: 함수명, 회로 구성, 수수료 정책)은 다를 수 있으므로 <strong>구현체 문서</strong>를 병행 참고 필요</p></blockquote><hr><h3 id=배경과-목적>배경과 목적<a hidden class=anchor aria-hidden=true href=#배경과-목적>#</a></h3><ul><li><strong>배경</strong>: L1(예: 이더리움)의 처리량·가스비 제약을 보완하기 위해 L2 도입이 필요</li><li><strong>ZK Rollup의 목적</strong>: 메인넷 보안성을 활용하면서 <strong>트랜잭션 처리량을 확대</strong>하고 <strong>온체인 비용을 절감</strong>. <strong>유효성 증명(validity proof)</strong> 으로 상태 전이가 올바름을 보장해 <strong>도전 기간 없이</strong> 빠른 확정을 지향</li></ul><hr><h3 id=핵심-개념과-정의>핵심 개념과 정의<a hidden class=anchor aria-hidden=true href=#핵심-개념과-정의>#</a></h3><ul><li><strong>ZK Rollup</strong>: 트랜잭션을 L2에서 실행·집계하고, 그 결과에 대한 <strong>유효성 증명</strong>을 L1로 제출해 상태 변경을 확정하는 확장 방식</li><li><strong>ZK Stack(일반)</strong>: ZK Rollup 구축을 위한 회로/프루버/런타임/배포 도구의 모음(구현체별 상이)</li><li><strong>Sequencer</strong>: L2 트랜잭션을 수신·정렬·블록화하고, 배치를 생성하는 컴포넌트(중앙/탈중앙 설계 가능)</li><li><strong>Prover / Verifier</strong>: Prover가 <strong>증인(witness)</strong> 을 생성하고 회로를 실행해 증명을 만들면, L1의 Verifier(스마트 컨트랙트)가 이를 검증</li><li><strong>네이티브 Account Abstraction(AA)</strong>: <strong>모든 계정이 컨트랙트 계정</strong>으로 동작(예: zkSync·Starknet 스타일). EIP-4337과는 별개 경로의 <strong>네이티브 모델</strong>일 수 있음</li></ul><hr><h3 id=아키텍처-개요>아키텍처 개요<a hidden class=anchor aria-hidden=true href=#아키텍처-개요>#</a></h3><ul><li><p><strong>Sequencer 영역</strong></p><ul><li><strong>RPC 게이트웨이</strong>: 트랜잭션 제출·조회 API 제공(JSON-RPC 호환/확장)</li><li><strong>시퀀싱/실행</strong>: 멤풀에서 트랜잭션을 읽어 정렬·블록화, 실행 결과를 즉시 반환할 수 있음(체인별 정책)</li><li><strong>L1 동기화</strong>: 입출금 브리지, 시스템 이벤트 추적</li></ul></li><li><p><strong>Prover & Verifier 영역</strong></p><ul><li><strong>증인 생성 → 회로 실행 → 증명 생성/집계 → (선택) 재귀 증명</strong></li><li>일부 구현은 <strong>STARK → SNARK 래핑</strong> 또는 <strong>재귀 SNARK</strong>로 L1 검증 비용 최적화(구현체별 다름)</li></ul></li><li><p><strong>L1 Rollup Contracts</strong></p><ul><li><strong>배치 커밋</strong>(DA 확립), <strong>증명 검증</strong>, <strong>상태 루트 업데이트</strong>, <strong>크로스체인 메시지 처리</strong>(Inbox/Outbox)</li></ul></li><li><p><strong>데이터 가용성(DA)</strong></p><ul><li><strong>EIP-4844 블롭</strong>을 활용해 Rollup 데이터(입력/차분)를 저비용으로 게시. 블롭은 <strong>EVM에서 직접 읽히지 않으며</strong> 일정 기간 후 <strong>가비지 컬렉션</strong>될 수 있으므로, <strong>L2 재현성</strong>은 블롭 + 노드 아카이빙 조합으로 확보</li></ul></li></ul><hr><h3 id=트랜잭션-생명주기일반화>트랜잭션 생명주기(일반화)<a hidden class=anchor aria-hidden=true href=#트랜잭션-생명주기일반화>#</a></h3><ul><li><strong>제출</strong>: 클라이언트가 JSON-RPC로 트랜잭션 전송 → L2 멤풀 적재</li><li><strong>시퀀싱 & 실행</strong>: Sequencer가 트랜잭션을 정렬·실행. 결과(성공/실패, tx hash)를 즉시 응답 가능(정책에 따름)</li><li><strong>배치 생성</strong>: 특정 주기/조건에 따라 블록들을 묶어 <strong>배치(batch)</strong> 구성</li><li><strong>증명 준비</strong>: Prover가 배치에 대한 <strong>witness</strong> 생성 → 회로 실행 → <strong>유효성 증명</strong> 생성(필요 시 재귀/집계)</li><li><strong>L1 게시(DA) & 증명 제출</strong>: 블롭(EIP-4844) 등으로 <strong>데이터 가용성 확보</strong> 후, 증명을 <strong>Rollup Verifier</strong>에 제출</li><li><strong>검증·확정</strong>: L1에서 증명 검증 성공 시 해당 배치의 <strong>상태 루트가 확정(finality)</strong>. 브리지 메시지 처리 등 후속 로직 실행</li></ul><blockquote><p>용어 주의: 구현 문서에 나오는 <code>proveBatches</code>, <code>finalize/executeBatches</code> 등 함수명은 <strong>예시적 표현</strong>이며, 실제 명칭·시맨틱은 스택별로 다름</p></blockquote><hr><h3 id=증명-파이프라인좀-더-구체적으로>증명 파이프라인(좀 더 구체적으로)<a hidden class=anchor aria-hidden=true href=#증명-파이프라인좀-더-구체적으로>#</a></h3><ul><li><p><strong>witness 생성</strong>: VM 실행 트레이스, 스토리지 읽기/쓰기, precompile 호출 등을 회로 입력으로 변환</p></li><li><p><strong>회로 구성</strong>: 범용 VM 회로(예: RISC-V/LLVM IR 스타일) 또는 EVM 친화 회로, <strong>Merkle/KZG</strong> 등 커밋먼트 검증 서브회로 포함</p></li><li><p><strong>재귀·집계</strong>: 여러 증명을 트리 형태로 합성(aggregation)해 L1 검증 비용을 상수/로그 수준으로 유도</p></li><li><p><strong>성능 팁(운영)</strong>:</p><ul><li>배치 크기/가짓수, 회로 분해(granularity) 설정으로 <strong>TTP(Time-To-Proof)</strong> 최적화</li><li>프루버 팜(HW 가속: GPU/FPGA/ASIC)과 큐 동시성으로 <strong>증명 처리량</strong> 보장</li><li><strong>L1 가스/블롭 비용</strong> 변동에 맞춘 배치 시점/크기 튜닝</li></ul></li></ul><hr><h3 id=데이터-가용성da--eip-4844>데이터 가용성(DA) & EIP-4844<a hidden class=anchor aria-hidden=true href=#데이터-가용성da--eip-4844>#</a></h3><ul><li><strong>블롭(Blob)</strong>: EVM에 직접 접근 불가한 <strong>대용량 데이터 영역</strong>. <strong>KZG 커밋먼트</strong>로 무결성 보장</li><li><strong>장점</strong>: calldata 대비 <strong>저렴한 데이터 게시</strong>. 롤업 비용 구조의 핵심</li><li><strong>운영 포인트</strong>: 블롭 보존 기간 이후를 대비해 <strong>오프체인 아카이브</strong>·재생성 전략 필요. <strong>프루닝 정책</strong>과 <strong>동기화 도구</strong> 점검</li></ul><hr><h3 id=l1-rollup-contract-주요-기능일반화>L1 Rollup Contract 주요 기능(일반화)<a hidden class=anchor aria-hidden=true href=#l1-rollup-contract-주요-기능일반화>#</a></h3><ul><li><strong>commitBatch</strong>: 입력 데이터/상태 요약을 게시(DA)</li><li><strong>verifyBatch</strong>: 제출된 증명의 유효성 검증</li><li><strong>finalizeBatch</strong>: 상태 루트 업데이트 및 교차메시지 확정</li><li><strong>Bridge(입·출금)</strong>: L1↔L2 <strong>메시지 박스(Inbox/Outbox)</strong>, <strong>강제 포함(Force Inclusion)</strong> 메커니즘으로 검열 대응</li></ul><hr><h3 id=네이티브-계정-추상화aa-개요>네이티브 계정 추상화(AA) 개요<a hidden class=anchor aria-hidden=true href=#네이티브-계정-추상화aa-개요>#</a></h3><ul><li><strong>핵심</strong>: <strong>EOA 없이</strong> 모든 계정이 <strong>컨트랙트</strong>로 동작 → 서명 검증·nonce·가스 지불 로직을 <strong>계정이 스스로 정의</strong></li><li><strong>장점</strong>: 키 회전/멀티시그/세션키/소셜 복구/가스 대납 등 <strong>유연한 UX</strong></li><li><strong>주의</strong>: mempool 정책, 부트로더/시스템 컨트랙트 인터페이스, 가스 회계 방식이 <strong>EIP-4337과 다를 수 있음</strong></li></ul><h4 id=예시-네이티브-aa-처리-흐름-zksync-계열-유사-개념-체인별-상이>(예시) 네이티브 AA 처리 흐름 <em>(zkSync 계열 유사 개념, 체인별 상이)</em><a hidden class=anchor aria-hidden=true href=#예시-네이티브-aa-처리-흐름-zksync-계열-유사-개념-체인별-상이>#</a></h4><ul><li>제출: JSON-RPC로 트랜잭션 제출(<code>from</code>이 컨트랙트 주소)</li><li>부트로더/시스템: 멤풀→배치, <strong>nonce 검증</strong>·<strong>서명 검증</strong>·<strong>가스 계산</strong></li><li>계정 훅: <code>validate* → execute* → paymaster/fee settlement</code> 순으로 훅 호출</li><li>페이마스터: 정책에 맞춰 <strong>가스 대납/토큰 지불</strong> 결정, 사후 정산 훅 실행</li></ul><blockquote><p>EIP-4337(번들러/EntryPoint 기반)과 <strong>동일하지 않음</strong>. “네이티브 AA”는 <strong>프로토콜 레벨</strong>에서 계정이 컨트랙트로 정의되는 모델임</p></blockquote><hr><h3 id=페이마스터가스-대납-설계-포인트>페이마스터(가스 대납) 설계 포인트<a hidden class=anchor aria-hidden=true href=#페이마스터가스-대납-설계-포인트>#</a></h3><ul><li><strong>정책</strong>: 허용 토큰·한도·쿨다운·화이트리스트/블랙리스트</li><li><strong>검증</strong>: <strong>오프체인 서명</strong>·쿼터 점검·리플레이 방지(nonce·만료)</li><li><strong>리스크 관리</strong>: <strong>불로소득(arbitrage) 악용</strong>·스팸 방지(예: 최소 잔액·인증)·실패 시 롤백 범위 최소화</li></ul><hr><h3 id=스마트-컨트랙트-지갑-설계일반>스마트 컨트랙트 지갑 설계(일반)<a hidden class=anchor aria-hidden=true href=#스마트-컨트랙트-지갑-설계일반>#</a></h3><ul><li><strong>배포 패턴</strong>: 팩토리+프록시(미니멀 프록시)로 <strong>가스 절감</strong>·업그레이드 용이</li><li><strong>키 관리</strong>: 멀티시그·세션키(권한·만료)·키 회전·소셜 복구</li><li><strong>서명 표준</strong>: 온체인 서명 검증은 <strong>EIP-1271</strong> 구현 권장</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// 30줄 미만 예시
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>ERC1271</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bytes4</span> <span style=color:#66d9ef>constant</span> <span style=color:#66d9ef>internal</span> MAGICVALUE <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1626ba7e</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isValidSignature</span>(<span style=color:#66d9ef>bytes32</span> _hash, <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> _sig)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bytes4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 구현부는 지갑 정책에 맞게 작성
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> MAGICVALUE;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=보안-모델-및-리스크>보안 모델 및 리스크<a hidden class=anchor aria-hidden=true href=#보안-모델-및-리스크>#</a></h3><ul><li><strong>유효성 증명 안전성</strong>: 회로 사운드니스, 트러스트 설정(예: SRS), 업그레이드 키 관리</li><li><strong>시퀀서 리스크</strong>: 다운타임/검열 → <strong>강제 포함 경로(L1 큐)</strong>, 시퀀서 탈중앙화 로드맵 검토</li><li><strong>브리지 안전성</strong>: L1 검증 완료 전 출금 불가. 메시지 재생성·체인 재조직(Reorg) 처리 방침 명확화</li><li><strong>AA·페이마스터 남용</strong>: 스팸·사기 유입을 계정/페이마스터 레벨에서 <strong>선제 차단</strong></li></ul><hr><h3 id=운영모니터링-지표kpi>운영·모니터링 지표(KPI)<a hidden class=anchor aria-hidden=true href=#운영모니터링-지표kpi>#</a></h3><ul><li><strong>TTI(Time-To-Inclusion)</strong>: 제출→L2 포함까지 지연</li><li><strong>TTP(Time-To-Proof)</strong>: 배치→증명 생성 완료까지 지연</li><li><strong>TTF(Time-To-Finality)</strong>: L1 검증 완료까지 전체 시간</li><li><strong>비용 지표</strong>: L1 데이터(블롭/칼데이터) 비용, 증명 가스/수수료, L2 가스</li><li><strong>신뢰도</strong>: 시퀀서 가용성, 강제 포함 성공률, 브리지 처리 성공률</li></ul><hr><h3 id=성능운영-베스트-프랙티스>성능·운영 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#성능운영-베스트-프랙티스>#</a></h3><ul><li><strong>배치 전략</strong>: 가스 시황·트래픽 패턴에 맞춘 <strong>동적 배치 크기/주기</strong></li><li><strong>프루버 팜</strong>: GPU/FPGA 활용·큐 병렬화·증명 집계로 <strong>지연 단축</strong></li><li><strong>비용 최적화</strong>: <strong>EIP-4844 블롭</strong> 우선 활용, 상태 쓰기 최소화, 재귀 증명으로 L1 검증 상수화</li><li><strong>개발자 경험(DX)</strong>: JSON-RPC 차이점 문서화, 트레이스/디버깅 도구 제공, 에러 코드 일관성</li></ul><hr><h3 id=간단-운영-시나리오요약>간단 운영 시나리오(요약)<a hidden class=anchor aria-hidden=true href=#간단-운영-시나리오요약>#</a></h3><ul><li>사용자가 트랜잭션 제출 → Sequencer가 실행 결과를 빠르게 응답 → 일정 주기마다 배치 생성 → Prover가 증명 생성 및 집계 → L1에 <strong>블롭 데이터 게시 + 증명 제출</strong> → Verifier가 검증하면 <strong>상태 확정</strong> → 브리지 메시지 처리</li></ul><hr><h3 id=자주-헷갈리는-포인트-교정>자주 헷갈리는 포인트 교정<a hidden class=anchor aria-hidden=true href=#자주-헷갈리는-포인트-교정>#</a></h3><ul><li>“ZK Rollup은 항상 STARK→SNARK 압축을 한다” → <strong>체인별로 다름</strong>. SNARK만 쓰거나, STARK 검증을 L1에서 직접 하거나, 재귀 SNARK만 쓰는 경우도 있음</li><li>“네이티브 AA = EIP-4337” → <strong>아님</strong>. 네이티브 AA는 프로토콜 계정 모델 자체가 컨트랙트 기반. 4337은 <strong>EOA 유지 + 번들러/EntryPoint</strong> 레이어임</li><li>“블롭 데이터는 영구 상태” → <strong>아님</strong>. 블롭은 <strong>일시적 보존</strong>이며 EVM에서 바로 읽을 수 없음. <strong>KZG 커밋먼트</strong>로 무결성만 보장</li><li>“증명 올라가면 즉시 확정” → L1 <strong>검증 트랜잭션 확정</strong>(재조직 위험 해소)까지 감안해야 <strong>운영상 최종 확정</strong>으로 처리</li></ul><hr><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>본 문서는 <strong>Abstract 계열 ZK Rollup L2</strong>를 염두에 둔 <strong>일반적 아키텍처</strong>와 <strong>AA·지갑·페이마스터</strong> 동작을 설명했음</p><p>실제 배포·운영 시에는 다음을 우선 검토 권장</p><ul><li><strong>증명 백엔드 설계</strong>(회로 범위·재귀·프루버 팜)</li><li><strong>배치·DA 전략</strong>(블롭 활용, 비용·지연 균형점)</li><li><strong>AA/페이마스터 보안 정책</strong>(남용·스팸 방지)</li><li><strong>브리지 & 강제 포함 경로</strong>(검열/다운타임 대비)</li></ul><p>체인·스택 문서를 병행하여 <strong>용어·함수명·정책 차이</strong>를 확인하고, 위 원칙을 현장에 맞게 <strong>보수적으로</strong> 적용할 것</p><hr><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li>EIP-1271: <a href=https://eips.ethereum.org/EIPS/eip-1271>https://eips.ethereum.org/EIPS/eip-1271</a></li><li>EIP-4844(Proto-Danksharding): <a href=https://eips.ethereum.org/EIPS/eip-4844>https://eips.ethereum.org/EIPS/eip-4844</a></li><li>롤업 설계 원리(Buterin): <a href=https://vitalik.ca/general/2021/06/15/rollups.html>https://vitalik.ca/general/2021/06/15/rollups.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://handsupmin.github.io/tags/zk-rollup/>Zk-Rollup</a></li><li><a href=https://handsupmin.github.io/tags/layer-2/>Layer-2</a></li><li><a href=https://handsupmin.github.io/tags/account-abstraction/>Account-Abstraction</a></li><li><a href=https://handsupmin.github.io/tags/smart-contract-wallet/>Smart-Contract-Wallet</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>