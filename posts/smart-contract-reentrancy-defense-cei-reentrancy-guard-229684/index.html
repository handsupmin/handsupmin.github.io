<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard | HandsLog</title>
<meta name=keywords content="solidity,smart-contract,security,reentrancy,openzeppelin,ethereum"><meta name=description content="개요
리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함
상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음
대표적 피해 사례로 The DAO 사건이 알려져 있음
실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임
두 방법을 함께 쓰는 것이 표준에 가까움
유명한 사례와 최소 취약 패턴
취약한 순서 패턴 핵심

외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생
이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능

최소 취약 스니펫 예시"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard"><meta property="og:description" content="개요 리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함 상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음 대표적 피해 사례로 The DAO 사건이 알려져 있음
실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임 두 방법을 함께 쓰는 것이 표준에 가까움
유명한 사례와 최소 취약 패턴 취약한 순서 패턴 핵심
외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생 이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능 최소 취약 스니펫 예시"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-15T13:14:49+00:00"><meta property="article:modified_time" content="2026-01-15T13:14:49+00:00"><meta property="article:tag" content="Solidity"><meta property="article:tag" content="Smart-Contract"><meta property="article:tag" content="Security"><meta property="article:tag" content="Reentrancy"><meta property="article:tag" content="Openzeppelin"><meta property="article:tag" content="Ethereum"><meta name=twitter:card content="summary"><meta name=twitter:title content="스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard"><meta name=twitter:description content="개요
리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함
상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음
대표적 피해 사례로 The DAO 사건이 알려져 있음
실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임
두 방법을 함께 쓰는 것이 표준에 가까움
유명한 사례와 최소 취약 패턴
취약한 순서 패턴 핵심

외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생
이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능

최소 취약 스니펫 예시"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard","item":"https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard","name":"스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard","description":"개요 리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함 상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음 대표적 피해 사례로 The DAO 사건이 알려져 있음\n실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임 두 방법을 함께 쓰는 것이 표준에 가까움\n유명한 사례와 최소 취약 패턴 취약한 순서 패턴 핵심\n외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생 이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능 최소 취약 스니펫 예시\n","keywords":["solidity","smart-contract","security","reentrancy","openzeppelin","ethereum"],"articleBody":"개요 리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함 상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음 대표적 피해 사례로 The DAO 사건이 알려져 있음\n실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임 두 방법을 함께 쓰는 것이 표준에 가까움\n유명한 사례와 최소 취약 패턴 취약한 순서 패턴 핵심\n외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생 이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능 최소 취약 스니펫 예시\nfunction withdraw(uint256 amount) external { require(balances[msg.sender] \u003e= amount, \"insufficient\"); (bool ok, ) = msg.sender.call{value: amount}(\"\"); // 외부 호출 선행 require(ok, \"transfer failed\"); balances[msg.sender] -= amount; // 상태 변경이 뒤늦게 발생 }공격자는 수신 훅에서 재호출하여 동일 검증을 반복 통과함\nreceive() external payable { target.withdraw(1 ether); // 재진입 시도 }결과적으로 예치액 대비 과도한 출금이 가능해짐 Solidity 0.8+ 에서는 언더플로우 자체는 revert되나 핵심 피해는 차감 전 다중 송금이 이미 발생한 지점에 있음\n공격 흐름 요약 1차 호출에서 require 통과 후 외부 전송 발생 수신 훅 receive 또는 fallback에서 동일 함수 또는 다른 취약 함수 재호출 상태 차감 전이라 동일 검증 재통과 반복 전송 발생 후 마지막에 상태 차감 또는 revert 최종적으로 컨트랙트 자금 고갈 또는 비정상 상태 유발 The DAO 2016 사례에서 대규모 자금 유출과 체인 하드포크까지 이어짐\n방어 전략 방법 1 CEI 패턴 우선 상태 변경을 먼저 반영하고 외부 상호작용은 나중에 실행하는 패턴\nfunction withdraw(uint256 amount) external { require(balances[msg.sender] \u003e= amount, \"insufficient\"); // Checks balances[msg.sender] -= amount; // Effects (bool ok, ) = msg.sender.call{value: amount}(\"\"); // Interactions require(ok, \"transfer failed\"); }공격자가 재진입을 시도해도 이미 잔액이 차감되어 require 단계에서 즉시 차단됨\n방법 2 ReentrancyGuard로 추가 안전벨트 OpenZeppelin ReentrancyGuard의 nonReentrant로 진입 중 재진입을 전역 플래그로 차단\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; contract C is ReentrancyGuard { function withdraw(uint256 amount) external nonReentrant { // CEI와 함께 사용할 것을 권장 } }nonReentrant는 함수 진입 시 상태를 ENTERED로 설정하고 종료 시 복구하는 간단한 락을 제공 재진입 시 즉시 revert 발생\n방법 3 CEI + ReentrancyGuard 병행 CEI 패턴으로 논리적 안전성 확보 ReentrancyGuard로 실수와 교차 함수 재진입을 방어 코드 리뷰와 리팩터링 과정에서 순서가 어긋나는 사고를 줄이는 효과 ReentrancyGuard 동작 원리 내부 구조 요약 핵심은 단일 상태 변수로 진입 상태를 토글하는 락 패턴\nuint256 private _status; uint256 private constant _NOT_ENTERED = 1; uint256 private constant _ENTERED = 2; modifier nonReentrant() { require(_status != _ENTERED, \"reentrant call\"); _status = _ENTERED; // 락 _; // 본문 실행 _status = _NOT_ENTERED; // 언락 }왜 0 대신 1과 2를 사용하나 가스 관점 SSTORE는 0에서 비영 값으로 변경 시 비용이 크게 발생하는 반면 비영 값에서 비영 값 변경은 상대적으로 저렴함\n0 → 비영 값 전환 비용이 높음 비영 값 ↔ 비영 값 전환은 저렴 따라서 초기값을 1로 두고 1과 2 사이에서 토글하여 저장 비용을 줄이는 설계가 일반적임 네트워크 업그레이드에 따라 세부 비용 모델은 변동될 수 있으나 방향성은 동일함 실무 주의사항 교차 함수 재진입 가능성 인지 같은 함수만 위험한 것이 아님 다른 외부 함수가 동일한 공유 상태에 접근하면 재진입 벡터가 열림 두 함수 모두 nonReentrant 적용 또는 공유 상태 접근 순서를 CEI로 정렬 필요\nnonReentrant 함수 간 내부 호출 금지 제약 nonReentrant가 적용된 함수에서 또 다른 nonReentrant 함수를 직접 호출하면 즉시 revert 발생 해결 패턴\nfunction a() external nonReentrant { _b(); // internal로 분리하여 호출 } function _b() internal { // 실제 로직 분리 }외부 진입점만 nonReentrant를 두고 내부 로직은 internal로 분리하는 계층화 권장\nERC20 대비 ERC721의 상대적 위험도 차이 ERC20 전송 transfer 및 transferFrom은 표준 구현에서 외부 콜백이 없는 경우가 일반적이라 상대적으로 안전 ERC721 safeTransferFrom은 수신자가 컨트랙트이면 onERC721Received 훅을 호출하므로 재진입 표면이 존재 function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4);NFT 마켓플레이스, 경매, 커스터디 로직 등에서는 nonReentrant 적용을 기본값으로 두는 편이 안전 커스텀 ERC20 구현에서 훅이나 외부 콜을 숨겨두는 경우도 있으므로 신뢰할 수 없는 토큰에 대해서는 보수적으로 대응 필요\n언제 nonReentrant가 필요한가 꼭 필요한 경우 ETH 전송 또는 낮은 수준 호출을 포함하는 함수 safeTransferFrom 기반의 NFT 전송 로직 신뢰할 수 없는 외부 컨트랙트 호출 포함 공유 상태를 변경한 뒤 외부 상호작용이 이어지는 복합 트랜잭션 경로 조건부 적용 표준적 ERC20 전송만 포함된 경로 토큰 구현이 안전하고 외부 훅이 없음을 확신할 때는 생략 가능하나 방어적 적용을 고려 불필요한 경우 view 또는 pure 함수 외부 호출이 전혀 없는 단순 상태 변경 함수 private 또는 internal 전용 헬퍼 함수 자체에는 불필요하나 외부 진입점에서 보호해야 함 가스와 설계 트레이드오프 CEI는 설계 원칙이며 추가 가스 비용 없이 얻는 이점이 큼 ReentrancyGuard는 SLOAD SSTORE가 추가되어 소폭의 가스 비용 증가가 있으나 보안 이득이 훨씬 큼 1과 2를 사용하는 토글 방식으로 SSTORE 비용을 낮추는 최적화 적용 필요 함수에만 nonReentrant를 제한적으로 부여해 가스와 복잡도 균형 유지 테스트와 검증 포인트 재진입 시나리오를 흉내내는 테스트 컨트랙트로 receive fallback을 활용한 재호출 여부 검증 상태 변경 전 외부 호출이 없는지 정적 분석 및 리뷰 수행 다중 함수 경로 교차 검증 동일한 저장소에 접근하는 외부 함수 조합에서 재진입 가능성 체크 업그레이어블 패턴 사용 시 초기화 순서와 가드 상태 변수 초기값 검증 핵심 정리 1순위 CEI 패턴 적용 상태를 먼저 바꾸고 외부 상호작용은 나중에 배치 2순위 ReentrancyGuard로 재진입 락 추가 실수 방지와 교차 함수 재진입 차단 nonReentrant 함수 간 직접 호출 금지 외부 진입점만 보호하고 내부로 로직 분리 ERC721은 훅 존재로 위험도 높음 기본적으로 nonReentrant 적용 권장 가스 최적화는 1과 2 토글 사용 및 필요한 경로에만 가드 적용으로 균형 추구 한 줄 요약 코드 순서는 CEI로 지키고 재진입 락은 ReentrancyGuard로 걸어 이중 방어 구축\n참고자료 https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy https://eips.ethereum.org/EIPS/eip-721 https://eips.ethereum.org/EIPS/eip-2200 https://consensys.net/blog/developers/what-is-a-reentrancy-attack/ ","wordCount":"878","inLanguage":"en","datePublished":"2026-01-15T13:14:49.232Z","dateModified":"2026-01-15T13:14:49.232Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard</h1><div class=post-meta><span title='2026-01-15 13:14:49.232 +0000 UTC'>January 15, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함
상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음
대표적 피해 사례로 The DAO 사건이 알려져 있음</p><p>실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임
두 방법을 함께 쓰는 것이 표준에 가까움</p><h3 id=유명한-사례와-최소-취약-패턴>유명한 사례와 최소 취약 패턴<a hidden class=anchor aria-hidden=true href=#유명한-사례와-최소-취약-패턴>#</a></h3><p>취약한 순서 패턴 핵심</p><ul><li>외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생</li><li>이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능</li></ul><p>최소 취약 스니펫 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>withdraw</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>uint256</span> amount<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>external</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>require</span><span style=color:#eceff4>(</span>balances<span style=color:#eceff4>[</span><span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>]</span> <span style=color:#81a1c1>&gt;=</span> amount<span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;insufficient&#34;</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>    <span style=color:#eceff4>(</span><span style=color:#81a1c1>bool</span> ok<span style=color:#eceff4>,</span> <span style=color:#eceff4>)</span> <span style=color:#81a1c1>=</span> <span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>call</span><span style=color:#eceff4>{</span><span style=color:#81a1c1>value</span><span style=color:#81a1c1>:</span> amount<span style=color:#eceff4>}(</span><span style=color:#a3be8c>&#34;&#34;</span><span style=color:#eceff4>);</span> <span style=color:#616e87;font-style:italic>// 외부 호출 선행
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    <span style=color:#81a1c1>require</span><span style=color:#eceff4>(</span>ok<span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;transfer failed&#34;</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>    balances<span style=color:#eceff4>[</span><span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>]</span> <span style=color:#81a1c1>-=</span> amount<span style=color:#eceff4>;</span> <span style=color:#616e87;font-style:italic>// 상태 변경이 뒤늦게 발생
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span></span></span></code></pre></div><p>공격자는 수신 훅에서 재호출하여 동일 검증을 반복 통과함</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>receive<span style=color:#eceff4>()</span> <span style=color:#81a1c1;font-weight:700>external</span> <span style=color:#81a1c1;font-weight:700>payable</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    target<span style=color:#eceff4>.</span>withdraw<span style=color:#eceff4>(</span><span style=color:#b48ead>1</span> <span style=color:#81a1c1;font-weight:700>ether</span><span style=color:#eceff4>);</span> <span style=color:#616e87;font-style:italic>// 재진입 시도
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span></span></span></code></pre></div><p>결과적으로 예치액 대비 과도한 출금이 가능해짐
Solidity 0.8+ 에서는 언더플로우 자체는 revert되나 핵심 피해는 차감 전 다중 송금이 이미 발생한 지점에 있음</p><h3 id=공격-흐름-요약>공격 흐름 요약<a hidden class=anchor aria-hidden=true href=#공격-흐름-요약>#</a></h3><ul><li>1차 호출에서 require 통과 후 외부 전송 발생</li><li>수신 훅 receive 또는 fallback에서 동일 함수 또는 다른 취약 함수 재호출</li><li>상태 차감 전이라 동일 검증 재통과</li><li>반복 전송 발생 후 마지막에 상태 차감 또는 revert</li><li>최종적으로 컨트랙트 자금 고갈 또는 비정상 상태 유발</li></ul><p>The DAO 2016 사례에서 대규모 자금 유출과 체인 하드포크까지 이어짐</p><h3 id=방어-전략>방어 전략<a hidden class=anchor aria-hidden=true href=#방어-전략>#</a></h3><h4 id=방법-1-cei-패턴-우선>방법 1 CEI 패턴 우선<a hidden class=anchor aria-hidden=true href=#방법-1-cei-패턴-우선>#</a></h4><p>상태 변경을 먼저 반영하고 외부 상호작용은 나중에 실행하는 패턴</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>withdraw</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>uint256</span> amount<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>external</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>require</span><span style=color:#eceff4>(</span>balances<span style=color:#eceff4>[</span><span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>]</span> <span style=color:#81a1c1>&gt;=</span> amount<span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;insufficient&#34;</span><span style=color:#eceff4>);</span> <span style=color:#616e87;font-style:italic>// Checks
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    balances<span style=color:#eceff4>[</span><span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>]</span> <span style=color:#81a1c1>-=</span> amount<span style=color:#eceff4>;</span>                            <span style=color:#616e87;font-style:italic>// Effects
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    <span style=color:#eceff4>(</span><span style=color:#81a1c1>bool</span> ok<span style=color:#eceff4>,</span> <span style=color:#eceff4>)</span> <span style=color:#81a1c1>=</span> <span style=color:#81a1c1>msg</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>sender</span><span style=color:#eceff4>.</span><span style=color:#81a1c1>call</span><span style=color:#eceff4>{</span><span style=color:#81a1c1>value</span><span style=color:#81a1c1>:</span> amount<span style=color:#eceff4>}(</span><span style=color:#a3be8c>&#34;&#34;</span><span style=color:#eceff4>);</span>         <span style=color:#616e87;font-style:italic>// Interactions
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    <span style=color:#81a1c1>require</span><span style=color:#eceff4>(</span>ok<span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;transfer failed&#34;</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><p>공격자가 재진입을 시도해도 이미 잔액이 차감되어 require 단계에서 즉시 차단됨</p><h4 id=방법-2-reentrancyguard로-추가-안전벨트>방법 2 ReentrancyGuard로 추가 안전벨트<a hidden class=anchor aria-hidden=true href=#방법-2-reentrancyguard로-추가-안전벨트>#</a></h4><p>OpenZeppelin ReentrancyGuard의 nonReentrant로 진입 중 재진입을 전역 플래그로 차단</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>import</span> <span style=color:#a3be8c>&#34;@openzeppelin/contracts/utils/ReentrancyGuard.sol&#34;</span><span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>contract</span> <span style=color:#8fbcbb>C</span> <span style=color:#81a1c1;font-weight:700>is</span> ReentrancyGuard <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>withdraw</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>uint256</span> amount<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>external</span> nonReentrant <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>        <span style=color:#616e87;font-style:italic>// CEI와 함께 사용할 것을 권장
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span></span></span></code></pre></div><p>nonReentrant는 함수 진입 시 상태를 ENTERED로 설정하고 종료 시 복구하는 간단한 락을 제공
재진입 시 즉시 revert 발생</p><h4 id=방법-3-cei--reentrancyguard-병행>방법 3 CEI + ReentrancyGuard 병행<a hidden class=anchor aria-hidden=true href=#방법-3-cei--reentrancyguard-병행>#</a></h4><ul><li>CEI 패턴으로 논리적 안전성 확보</li><li>ReentrancyGuard로 실수와 교차 함수 재진입을 방어</li><li>코드 리뷰와 리팩터링 과정에서 순서가 어긋나는 사고를 줄이는 효과</li></ul><h3 id=reentrancyguard-동작-원리>ReentrancyGuard 동작 원리<a hidden class=anchor aria-hidden=true href=#reentrancyguard-동작-원리>#</a></h3><h4 id=내부-구조-요약>내부 구조 요약<a hidden class=anchor aria-hidden=true href=#내부-구조-요약>#</a></h4><p>핵심은 단일 상태 변수로 진입 상태를 토글하는 락 패턴</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1>uint256</span> <span style=color:#81a1c1;font-weight:700>private</span> _status<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1>uint256</span> <span style=color:#81a1c1;font-weight:700>private</span> <span style=color:#81a1c1;font-weight:700>constant</span> _NOT_ENTERED <span style=color:#81a1c1>=</span> <span style=color:#b48ead>1</span><span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1>uint256</span> <span style=color:#81a1c1;font-weight:700>private</span> <span style=color:#81a1c1;font-weight:700>constant</span> _ENTERED <span style=color:#81a1c1>=</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>modifier</span> <span style=color:#88c0d0>nonReentrant</span><span style=color:#eceff4>()</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>require</span><span style=color:#eceff4>(</span>_status <span style=color:#81a1c1>!=</span> _ENTERED<span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;reentrant call&#34;</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>    _status <span style=color:#81a1c1>=</span> _ENTERED<span style=color:#eceff4>;</span> <span style=color:#616e87;font-style:italic>// 락
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    <span style=color:#81a1c1;font-weight:700>_</span><span style=color:#eceff4>;</span>                  <span style=color:#616e87;font-style:italic>// 본문 실행
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>    _status <span style=color:#81a1c1>=</span> _NOT_ENTERED<span style=color:#eceff4>;</span> <span style=color:#616e87;font-style:italic>// 언락
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span></span></span></code></pre></div><h4 id=왜-0-대신-1과-2를-사용하나-가스-관점>왜 0 대신 1과 2를 사용하나 가스 관점<a hidden class=anchor aria-hidden=true href=#왜-0-대신-1과-2를-사용하나-가스-관점>#</a></h4><p>SSTORE는 0에서 비영 값으로 변경 시 비용이 크게 발생하는 반면 비영 값에서 비영 값 변경은 상대적으로 저렴함</p><ul><li>0 → 비영 값 전환 비용이 높음</li><li>비영 값 ↔ 비영 값 전환은 저렴
따라서 초기값을 1로 두고 1과 2 사이에서 토글하여 저장 비용을 줄이는 설계가 일반적임
네트워크 업그레이드에 따라 세부 비용 모델은 변동될 수 있으나 방향성은 동일함</li></ul><h3 id=실무-주의사항>실무 주의사항<a hidden class=anchor aria-hidden=true href=#실무-주의사항>#</a></h3><h4 id=교차-함수-재진입-가능성-인지>교차 함수 재진입 가능성 인지<a hidden class=anchor aria-hidden=true href=#교차-함수-재진입-가능성-인지>#</a></h4><p>같은 함수만 위험한 것이 아님
다른 외부 함수가 동일한 공유 상태에 접근하면 재진입 벡터가 열림
두 함수 모두 nonReentrant 적용 또는 공유 상태 접근 순서를 CEI로 정렬 필요</p><h4 id=nonreentrant-함수-간-내부-호출-금지-제약>nonReentrant 함수 간 내부 호출 금지 제약<a hidden class=anchor aria-hidden=true href=#nonreentrant-함수-간-내부-호출-금지-제약>#</a></h4><p>nonReentrant가 적용된 함수에서 또 다른 nonReentrant 함수를 직접 호출하면 즉시 revert 발생
해결 패턴</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>a</span><span style=color:#eceff4>()</span> <span style=color:#81a1c1;font-weight:700>external</span> nonReentrant <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    _b<span style=color:#eceff4>();</span> <span style=color:#616e87;font-style:italic>// internal로 분리하여 호출
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>_b</span><span style=color:#eceff4>()</span> <span style=color:#81a1c1;font-weight:700>internal</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#616e87;font-style:italic>// 실제 로직 분리
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span></span></span></code></pre></div><p>외부 진입점만 nonReentrant를 두고 내부 로직은 internal로 분리하는 계층화 권장</p><h4 id=erc20-대비-erc721의-상대적-위험도-차이>ERC20 대비 ERC721의 상대적 위험도 차이<a hidden class=anchor aria-hidden=true href=#erc20-대비-erc721의-상대적-위험도-차이>#</a></h4><ul><li>ERC20 전송 transfer 및 transferFrom은 표준 구현에서 외부 콜백이 없는 경우가 일반적이라 상대적으로 안전</li><li>ERC721 safeTransferFrom은 수신자가 컨트랙트이면 onERC721Received 훅을 호출하므로 재진입 표면이 존재</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> <span style=color:#88c0d0>onERC721Received</span><span style=color:#eceff4>(</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>address</span> operator<span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>address</span> <span style=color:#81a1c1;font-weight:700>from</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>uint256</span> tokenId<span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>bytes</span> calldata <span style=color:#81a1c1>data</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>external</span> <span style=color:#81a1c1;font-weight:700>returns</span> <span style=color:#eceff4>(</span><span style=color:#81a1c1>bytes4</span><span style=color:#eceff4>);</span></span></span></code></pre></div><p>NFT 마켓플레이스, 경매, 커스터디 로직 등에서는 nonReentrant 적용을 기본값으로 두는 편이 안전
커스텀 ERC20 구현에서 훅이나 외부 콜을 숨겨두는 경우도 있으므로 신뢰할 수 없는 토큰에 대해서는 보수적으로 대응 필요</p><h3 id=언제-nonreentrant가-필요한가>언제 nonReentrant가 필요한가<a hidden class=anchor aria-hidden=true href=#언제-nonreentrant가-필요한가>#</a></h3><h4 id=꼭-필요한-경우>꼭 필요한 경우<a hidden class=anchor aria-hidden=true href=#꼭-필요한-경우>#</a></h4><ul><li>ETH 전송 또는 낮은 수준 호출을 포함하는 함수</li><li>safeTransferFrom 기반의 NFT 전송 로직</li><li>신뢰할 수 없는 외부 컨트랙트 호출 포함</li><li>공유 상태를 변경한 뒤 외부 상호작용이 이어지는 복합 트랜잭션 경로</li></ul><h4 id=조건부-적용>조건부 적용<a hidden class=anchor aria-hidden=true href=#조건부-적용>#</a></h4><ul><li>표준적 ERC20 전송만 포함된 경로</li><li>토큰 구현이 안전하고 외부 훅이 없음을 확신할 때는 생략 가능하나 방어적 적용을 고려</li></ul><h4 id=불필요한-경우>불필요한 경우<a hidden class=anchor aria-hidden=true href=#불필요한-경우>#</a></h4><ul><li>view 또는 pure 함수</li><li>외부 호출이 전혀 없는 단순 상태 변경 함수</li><li>private 또는 internal 전용 헬퍼 함수 자체에는 불필요하나 외부 진입점에서 보호해야 함</li></ul><h3 id=가스와-설계-트레이드오프>가스와 설계 트레이드오프<a hidden class=anchor aria-hidden=true href=#가스와-설계-트레이드오프>#</a></h3><ul><li>CEI는 설계 원칙이며 추가 가스 비용 없이 얻는 이점이 큼</li><li>ReentrancyGuard는 SLOAD SSTORE가 추가되어 소폭의 가스 비용 증가가 있으나 보안 이득이 훨씬 큼</li><li>1과 2를 사용하는 토글 방식으로 SSTORE 비용을 낮추는 최적화 적용</li><li>필요 함수에만 nonReentrant를 제한적으로 부여해 가스와 복잡도 균형 유지</li></ul><h3 id=테스트와-검증-포인트>테스트와 검증 포인트<a hidden class=anchor aria-hidden=true href=#테스트와-검증-포인트>#</a></h3><ul><li>재진입 시나리오를 흉내내는 테스트 컨트랙트로 receive fallback을 활용한 재호출 여부 검증</li><li>상태 변경 전 외부 호출이 없는지 정적 분석 및 리뷰 수행</li><li>다중 함수 경로 교차 검증 동일한 저장소에 접근하는 외부 함수 조합에서 재진입 가능성 체크</li><li>업그레이어블 패턴 사용 시 초기화 순서와 가드 상태 변수 초기값 검증</li></ul><h3 id=핵심-정리>핵심 정리<a hidden class=anchor aria-hidden=true href=#핵심-정리>#</a></h3><ul><li>1순위 CEI 패턴 적용 상태를 먼저 바꾸고 외부 상호작용은 나중에 배치</li><li>2순위 ReentrancyGuard로 재진입 락 추가 실수 방지와 교차 함수 재진입 차단</li><li>nonReentrant 함수 간 직접 호출 금지 외부 진입점만 보호하고 내부로 로직 분리</li><li>ERC721은 훅 존재로 위험도 높음 기본적으로 nonReentrant 적용 권장</li><li>가스 최적화는 1과 2 토글 사용 및 필요한 경로에만 가드 적용으로 균형 추구</li></ul><h3 id=한-줄-요약>한 줄 요약<a hidden class=anchor aria-hidden=true href=#한-줄-요약>#</a></h3><p>코드 순서는 CEI로 지키고 재진입 락은 ReentrancyGuard로 걸어 이중 방어 구축</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard>https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard</a></li><li><a href=https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy>https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy</a></li><li><a href=https://eips.ethereum.org/EIPS/eip-721>https://eips.ethereum.org/EIPS/eip-721</a></li><li><a href=https://eips.ethereum.org/EIPS/eip-2200>https://eips.ethereum.org/EIPS/eip-2200</a></li><li><a href=https://consensys.net/blog/developers/what-is-a-reentrancy-attack/>https://consensys.net/blog/developers/what-is-a-reentrancy-attack/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/solidity/>Solidity</a></li><li><a href=https://blog.jsontapose.com/tags/smart-contract/>Smart-Contract</a></li><li><a href=https://blog.jsontapose.com/tags/security/>Security</a></li><li><a href=https://blog.jsontapose.com/tags/reentrancy/>Reentrancy</a></li><li><a href=https://blog.jsontapose.com/tags/openzeppelin/>Openzeppelin</a></li><li><a href=https://blog.jsontapose.com/tags/ethereum/>Ethereum</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/><span class=title>« Prev</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span>
</a><a class=next href=https://blog.jsontapose.com/posts/erc-721-approve-vs-setapprovalforall-50a1bb/><span class=title>Next »</span><br><span>ERC-721 승인 패턴 정리 approve vs setApprovalForAll 사용법과 권한 확인</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on x" href="https://x.com/intent/tweet/?text=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f&amp;hashtags=solidity%2csmart-contract%2csecurity%2creentrancy%2copenzeppelin%2cethereum"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f&amp;title=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard&amp;summary=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f&title=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on whatsapp" href="https://api.whatsapp.com/send?text=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on telegram" href="https://telegram.me/share/url?text=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ec%8a%a4%eb%a7%88%ed%8a%b8%20%ec%bb%a8%ed%8a%b8%eb%9e%99%ed%8a%b8%20%ec%9e%ac%ec%a7%84%ec%9e%85%20%ea%b3%b5%ea%b2%a9%20%eb%b0%a9%ec%a7%80%20%ea%b0%80%ec%9d%b4%eb%93%9c%20%e2%80%94%20CEI%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20ReentrancyGuard&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fsmart-contract-reentrancy-defense-cei-reentrancy-guard-229684%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>