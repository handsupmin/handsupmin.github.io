<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on HandsLog</title>
    <link>https://blog.jsontapose.com/posts/</link>
    <description>Recent content in Posts on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 20 Feb 2026 13:24:06 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>오프체인 서명 검증(Off-chain Signature Verification)이란?</title>
      <link>https://blog.jsontapose.com/posts/off-chain-signature-verification-542a33/</link>
      <pubDate>Sun, 21 Sep 2025 03:11:23 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/off-chain-signature-verification-542a33/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음
이때 &lt;strong&gt;오프체인 서명 검증&lt;/strong&gt;(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨&lt;/p&gt;
&lt;p&gt;쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음
가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨&lt;/p&gt;
&lt;p&gt;이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄&lt;/p&gt;</description>
    </item>
    <item>
      <title>안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)</title>
      <link>https://blog.jsontapose.com/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</link>
      <pubDate>Sun, 21 Sep 2025 02:14:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 &lt;strong&gt;가스비&lt;/strong&gt;(Gas Fee)임
아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임
이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 &lt;strong&gt;가스리스 트랜잭션&lt;/strong&gt;(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음&lt;/p&gt;
&lt;p&gt;zkSync Era는 이를 위해 &lt;strong&gt;페이마스터&lt;/strong&gt;(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임&lt;/p&gt;</description>
    </item>
    <item>
      <title>SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)</title>
      <link>https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</link>
      <pubDate>Sat, 25 Oct 2025 13:06:24 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</guid>
      <description>&lt;h1 id=&#34;sseserver-sent-events란-무엇인가&#34;&gt;SSE(Server-Sent Events)란 무엇인가&lt;/h1&gt;
&lt;p&gt;SSE는 &lt;strong&gt;Server-Sent Events&lt;/strong&gt;의 약자로, 서버가 클라이언트로 &lt;strong&gt;실시간 데이터를 단방향으로 푸시&lt;/strong&gt;(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임&lt;/p&gt;
&lt;p&gt;주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sse-vs-웹소켓-그리고-한계&#34;&gt;SSE vs 웹소켓, 그리고 한계&lt;/h2&gt;
&lt;p&gt;SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함&lt;/p&gt;</description>
    </item>
    <item>
      <title>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</title>
      <link>https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/</link>
      <pubDate>Sat, 20 Sep 2025 17:15:26 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;머클트리는 블록체인에서 거래 집합을 &lt;strong&gt;안전하고 효율적으로 요약·검증&lt;/strong&gt;하기 위해 쓰이는 핵심 자료구조임
블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 &lt;strong&gt;고정 크기 해시 하나&lt;/strong&gt;로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임
이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념과-구조&#34;&gt;핵심 개념과 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;머클트리는 보통 &lt;strong&gt;이진 트리&lt;/strong&gt; 형태로 구현함&lt;/li&gt;
&lt;li&gt;거래들을 &lt;strong&gt;리프(leaf)&lt;/strong&gt; 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 &lt;strong&gt;루트 해시&lt;/strong&gt;를 얻음&lt;/li&gt;
&lt;li&gt;해시 함수는 체인별로 다르며 비트코인은 &lt;strong&gt;더블 SHA‑256&lt;/strong&gt;, 이더리움은 트라이 구조에서 &lt;strong&gt;Keccak‑256&lt;/strong&gt; 을 사용함&lt;/li&gt;
&lt;li&gt;최상단 해시를 &lt;strong&gt;머클루트(Merkle root)&lt;/strong&gt; 라 부르며 크기는 해시 함수에 따라 고정됨&lt;/li&gt;
&lt;li&gt;리프 수가 홀수일 때는 마지막 리프를 &lt;strong&gt;복제해 짝을 맞추는 방식&lt;/strong&gt;이 일반적이며 비트코인은 이 규칙을 사용함&lt;/li&gt;
&lt;li&gt;트리 깊이는 리프 수 N에 대해 &lt;strong&gt;⌈log₂ N⌉&lt;/strong&gt; 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동작-원리와-장점&#34;&gt;동작 원리와 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인접 노드 해시 &lt;strong&gt;H_left || H_right&lt;/strong&gt; 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;무결성 검증&lt;/strong&gt;
단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;효율적 포함 증명&lt;/strong&gt;
특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 &lt;strong&gt;형제 해시들만&lt;/strong&gt; 있으면 됨
필요한 해시 개수는 &lt;strong&gt;O(log N)&lt;/strong&gt; 으로 작아 대역폭과 검증 비용이 작음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확장성 보조&lt;/strong&gt;
리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;블록-헤더와-경량-노드spv&#34;&gt;블록 헤더와 경량 노드(SPV)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함&lt;/li&gt;
&lt;li&gt;경량 노드(SPV)는 &lt;strong&gt;블록 전체가 아니라 헤더 체인만&lt;/strong&gt; 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 &lt;strong&gt;머클 증명&lt;/strong&gt; 을 받아 포함 여부를 검증함&lt;/li&gt;
&lt;li&gt;이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨&lt;/li&gt;
&lt;li&gt;이더리움은 전통적인 이진 머클트리 대신 &lt;strong&gt;머클‑패트리샤 트라이(MPT)&lt;/strong&gt; 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;구현-세부와-체인별-차이&#34;&gt;구현 세부와 체인별 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;비트코인&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>robots.txt 기초와 전체 사이트 크롤링 차단 예시</title>
      <link>https://blog.jsontapose.com/posts/robots-txt-block-all-crawling-60f08c/</link>
      <pubDate>Fri, 20 Feb 2026 13:24:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/robots-txt-block-all-crawling-60f08c/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;robots.txt는 검색 엔진 크롤러에 대한 크롤링 규칙을 선언하는 공개 텍스트 파일임
사이트 루트 경로에 위치하며 접근 제어나 보안 수단으로 사용 불가&lt;/p&gt;
&lt;h3 id=&#34;전체-차단-예시&#34;&gt;전체 차단 예시&lt;/h3&gt;
&lt;p&gt;모든 크롤러에 대해 사이트 전체 경로 크롤링 금지 설정
User-agent: *
Disallow: /
위 규칙은 크롤링 거부 의사를 표명하는 표준 관례이며 비준수 크롤러까지 강제 불가&lt;/p&gt;
&lt;h3 id=&#34;주의&#34;&gt;주의&lt;/h3&gt;
&lt;p&gt;운영 환경 적용 시 검색 트래픽 전면 차단 위험
크롤링 차단과 인덱싱 차단은 다름
이미 색인된 문서는 별도 제거 절차 필요&lt;/p&gt;</description>
    </item>
    <item>
      <title>Foreign Key 컬럼은 NULL을 가질 수 있는가</title>
      <link>https://blog.jsontapose.com/posts/foreign-key-nullable-5cab66/</link>
      <pubDate>Thu, 19 Feb 2026 13:28:26 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/foreign-key-nullable-5cab66/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;결론부터 말하면 가능함
Foreign Key 컬럼의 NULL 허용 여부는 해당 컬럼의 NULL 혹은 NOT NULL 제약으로 결정됨
FK 제약은 NULL이 아닌 값만 검증하므로 값이 NULL인 경우 참조 무결성 검사를 생략함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컬럼이 NOT NULL이면 NULL 저장 불가&lt;/li&gt;
&lt;li&gt;컬럼이 NULL 허용이면 NULL 저장 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;FK 제약은 입력값이 존재할 때만 참조 대상 테이블에 키가 있는지 검사&lt;/li&gt;
&lt;li&gt;NULL은 미지정 상태로 간주되어 검증 대상 아님&lt;/li&gt;
&lt;li&gt;대부분의 RDBMS에서 기본은 NULL 허용 컬럼이며, 명시적으로 NOT NULL을 지정해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;INSERT 또는 UPDATE 시 FK 컬럼이 NULL이면 무결성 검사 스킵&lt;/li&gt;
&lt;li&gt;값이 존재하면 참조 테이블의 대상 키 존재 여부 검사&lt;/li&gt;
&lt;li&gt;복합 FK의 경우 참조 컬럼 중 하나라도 NULL이면 전체 FK 검사를 생략하는 동작이 일반적임&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; parent &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  id &lt;span style=&#34;color:#81a1c1&#34;&gt;INT&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;KEY&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; child &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  parent_id &lt;span style=&#34;color:#81a1c1&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FOREIGN&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;parent_id&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;REFERENCES&lt;/span&gt; parent&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;child.parent_id는 기본적으로 NULL 허용 상태&lt;/li&gt;
&lt;li&gt;parent_id에 NULL을 넣어도 FK 위반 아님&lt;/li&gt;
&lt;li&gt;parent_id에 NOT NULL을 추가하면 parent에 존재하는 id만 허용됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의-사항&#34;&gt;주의 사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ON DELETE SET NULL을 사용할 경우 FK 컬럼이 NULL 허용이어야 함&lt;/li&gt;
&lt;li&gt;FK 컬럼 인덱스는 필수는 아니나 삭제·업데이트 시 성능과 잠금 범위 측면에서 권장&lt;/li&gt;
&lt;li&gt;관계가 필수라면 애플리케이션 규칙이 아닌 스키마에서 NOT NULL로 모델링하는 편이 안전함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;FK 컬럼은 NULL 허용 설정이면 NULL을 저장할 수 있으며, 이 경우 FK 검사는 수행되지 않음
NULL을 금지하고 참조 무결성을 강제하려면 NOT NULL을 함께 적용하면 됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript에서 unary plus(&#43;)와 parseInt 비교 및 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/unary-plus-vs-parseint-160cb0/</link>
      <pubDate>Wed, 18 Feb 2026 13:27:34 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/unary-plus-vs-parseint-160cb0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 &lt;code&gt;+&lt;/code&gt; 단항 연산자는 &lt;code&gt;Number&lt;/code&gt; 호출의 축약형으로 동작함
문자열이나 다양한 타입을 숫자로 바꾸려는 순간에 &lt;code&gt;+value&lt;/code&gt;와 &lt;code&gt;Number(value)&lt;/code&gt;는 같은 의미이고, &lt;code&gt;parseInt&lt;/code&gt;는 문자열에서 정수 접두부만 뽑아내는 파서에 가까움
같아 보이지만 목적과 실패 조건이 다르므로 상황에 맞게 선택 필요&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;unary plus &lt;code&gt;+x&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;ECMAScript의 ToNumber 규칙 적용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number(x)&lt;/code&gt;와 동일한 변환 결과 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number(value)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;숫자 전체 표현식이어야 함&lt;/li&gt;
&lt;li&gt;공백 트림은 허용하지만 유효하지 않은 문자가 섞이면 &lt;code&gt;NaN&lt;/code&gt; 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(string, radix)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;문자열의 왼쪽부터 주어진 기수(radix, 2~36)로 해석 가능한 정수 접두부만 파싱&lt;/li&gt;
&lt;li&gt;유효하지 않은 문자를 만나면 거기서 파싱 중단&lt;/li&gt;
&lt;li&gt;접두부 숫자가 하나도 없으면 &lt;code&gt;NaN&lt;/code&gt; 반환&lt;/li&gt;
&lt;li&gt;ES5+에서 기본 기수는 10이지만, &lt;code&gt;0x&lt;/code&gt;/&lt;code&gt;0X&lt;/code&gt; 접두사는 16진수로 처리됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-차이와-사례&#34;&gt;동작 차이와 사례&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전체 일치 vs 접두 파싱
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number(&#39;12px&#39;)&lt;/code&gt; → &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(&#39;12px&#39;, 10)&lt;/code&gt; → &lt;code&gt;12&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소수와 지수 표기
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number(&#39;10.5&#39;)&lt;/code&gt; → &lt;code&gt;10.5&lt;/code&gt;, &lt;code&gt;Number(&#39;1e3&#39;)&lt;/code&gt; → &lt;code&gt;1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(&#39;10.5&#39;, 10)&lt;/code&gt; → &lt;code&gt;10&lt;/code&gt; (소수부 절삭)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;빈 문자열과 공백
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number(&#39;&#39;)&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Number(&#39;   &#39;)&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(&#39;&#39;)&lt;/code&gt; → &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비문자열 입력
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+true&lt;/code&gt; → &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;+false&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;+null&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;+undefined&lt;/code&gt; → &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(true, 10)&lt;/code&gt; → &lt;code&gt;NaN&lt;/code&gt; (문자열로 변환 시 &amp;rsquo;true&amp;rsquo;라서 숫자 접두부 없음)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;진법 접두사 처리 차이
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number(&#39;0x10&#39;)&lt;/code&gt; → &lt;code&gt;16&lt;/code&gt;, &lt;code&gt;parseInt(&#39;0x10&#39;)&lt;/code&gt; → &lt;code&gt;16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number(&#39;0b101&#39;)&lt;/code&gt; → &lt;code&gt;5&lt;/code&gt; (ES2015+), &lt;code&gt;parseInt(&#39;0b101&#39;)&lt;/code&gt; → &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
참고로 &lt;code&gt;parseInt(&#39;101&#39;, 2)&lt;/code&gt; → &lt;code&gt;5&lt;/code&gt; 처럼 radix를 명시해야 기대대로 동작함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BigInt 관련
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+10n&lt;/code&gt;은 TypeError 발생&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number(10n)&lt;/code&gt;은 &lt;code&gt;10&lt;/code&gt;으로 변환되나 정밀도 손실 가능성 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;선택-기준&#34;&gt;선택 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전체 문자열이 유효한 숫자여야 하고 실수, 지수 표기도 허용해야 함
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+value&lt;/code&gt; 또는 &lt;code&gt;Number(value)&lt;/code&gt; 선택&lt;/li&gt;
&lt;li&gt;가독성 우선이면 &lt;code&gt;Number(value)&lt;/code&gt; 추천, 축약을 선호하면 &lt;code&gt;+value&lt;/code&gt; 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;문자열 앞부분에서 정수만 뽑고 싶거나 비 10진수 파싱 필요
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parseInt(str, radix)&lt;/code&gt; 선택&lt;/li&gt;
&lt;li&gt;항상 &lt;code&gt;radix&lt;/code&gt; 명시 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소수부를 보존하면서 부분 파싱이 필요
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parseFloat&lt;/code&gt; 고려&lt;/li&gt;
&lt;li&gt;다만 &lt;code&gt;parseFloat&lt;/code&gt;도 접두 파싱이므로 전체 일치 검증이 필요하면 &lt;code&gt;Number&lt;/code&gt; 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스&#34;&gt;베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;숫자 변환 의도 전달이 중요할 때 &lt;code&gt;Number(value)&lt;/code&gt; 사용&lt;/li&gt;
&lt;li&gt;정수 파싱 시 &lt;code&gt;parseInt(str, 10)&lt;/code&gt;처럼 radix를 항상 명시&lt;/li&gt;
&lt;li&gt;사용자 입력 검증이 필요하면 정규식 또는 스키마 검증으로 전체 형식 검증 후 &lt;code&gt;Number&lt;/code&gt; 변환&lt;/li&gt;
&lt;li&gt;성능 미세 최적화보다 가독성과 실패 조건의 명확성을 우선&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;12&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;      &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;12&amp;#39;&lt;/span&gt;             &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;parseInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;12&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;12px&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// NaN
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;parseInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;12px&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;0b101&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;   &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;parseInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;0b101&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 0, radix 명시 필요
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;parseInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;101&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;결론&#34;&gt;결론&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;는 &lt;code&gt;Number&lt;/code&gt;의 축약형이 맞음
전체 숫자 표현식으로서의 유효성을 요구할 때 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;Number&lt;/code&gt; 사용, 접두부 정수 추출이나 진법 파싱에는 &lt;code&gt;parseInt&lt;/code&gt; 사용
의도를 코드에 드러내고, 실패 조건을 일관되게 가져가는 쪽으로 선택하는 것이 유지보수에 유리함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Selenium WebDriver pageLoadStrategy 동작 원리와 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/selenium-webdriver-pageloadstrategy-guide-8cac26/</link>
      <pubDate>Tue, 17 Feb 2026 13:27:05 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/selenium-webdriver-pageloadstrategy-guide-8cac26/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;pageLoadStrategy는 WebDriver가 페이지 이동 명령을 언제 완료로 판단할지 결정하는 세션 단위 설정값임. 핵심은 document.readyState 조회 시점을 어떻게 보느냐이며 전략별 대기 조건이 다름. 기본값은 normal이며, 네트워크 리소스가 많아 느린 페이지에서 eager 또는 none으로 바꿔 세션 체감 속도를 높일 수 있음&lt;/p&gt;
&lt;p&gt;SPA처럼 자바스크립트가 동적으로 화면을 채우는 사이트에서는 readyState가 complete여도 실제 사용자 관점의 완료와 다를 수 있음. 전략 변경 시 명시적 대기 조합 설계가 필수임&lt;/p&gt;
&lt;p&gt;주의할 점은 get 등 URL 기반 내비게이션과 달리, 클릭이나 폼 제출로 발생한 내비게이션에는 동일한 대기 규칙이 그대로 적용되지 않을 수 있음. 이 경우에도 별도의 대기 전략으로 안정성을 확보해야 함&lt;/p&gt;</description>
    </item>
    <item>
      <title>CTE(Common Table Expression) 개념과 WITH 사용법 요약</title>
      <link>https://blog.jsontapose.com/posts/cte-common-table-expression-with-usage-4e5d41/</link>
      <pubDate>Mon, 16 Feb 2026 13:26:25 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/cte-common-table-expression-with-usage-4e5d41/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;CTE는 WITH로 정의하는 이름 있는 임시 결과셋
바로 다음 한 개 DML에서만 참조 가능하며 실행이 끝나면 범위 소멸
가독성 향상과 쿼리 구조 분리에 유용함&lt;/p&gt;
&lt;h3 id=&#34;사용법&#34;&gt;사용법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;WITH&lt;/span&gt; cte_name &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;col1&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; col2&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DML&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;필요 시 컬럼 목록 생략 가능하나 명시를 권장&lt;/p&gt;
&lt;h3 id=&#34;주의사항&#34;&gt;주의사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일부 DBMS에서는 배치 내에서 CTE 앞에 오는 쿼리를 세미콜론으로 종료 필요&lt;/li&gt;
&lt;li&gt;CTE 범위는 바로 뒤 한 개 DML로 한정됨&lt;/li&gt;
&lt;li&gt;복잡한 쿼리에서 과도한 중첩 사용은 계획 복잡도 증가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://s2choco.tistory.com/34&#34;&gt;https://s2choco.tistory.com/34&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/sql/t-sql/queries/with-common-table-expression-transact-sql&#34;&gt;https://learn.microsoft.com/sql/t-sql/queries/with-common-table-expression-transact-sql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Unobtrusive JavaScript와 HTML·JS 분리 원칙</title>
      <link>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</link>
      <pubDate>Sun, 15 Feb 2026 13:17:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Unobtrusive JavaScript는 HTML 구조와 JS 동작을 분리하는 접근 철학
HTML은 의미와 콘텐츠, CSS는 표현, JS는 상호작용과 상태 제어 담당
인라인 스크립트와 이벤트 속성 제거, 외부 스크립트에서 안전하게 바인딩하는 방식 지향&lt;/p&gt;
&lt;p&gt;핵심 목표는 접근성 보장, 점진적 향상, 유지보수성과 테스트 용이성 개선, 캐시 효율 상승, 보안 취약점 노출 감소&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTML은 의미 중심 마크업 유지&lt;/li&gt;
&lt;li&gt;CSS는 표현만 담당&lt;/li&gt;
&lt;li&gt;JS는 DOMContentLoaded 이후 동작 주입&lt;/li&gt;
&lt;li&gt;인라인 onclick 등 이벤트 속성 사용 금지&lt;/li&gt;
&lt;li&gt;기능 감지 우선, UA 스니핑 지양&lt;/li&gt;
&lt;li&gt;데이터 훅은 data-* 속성 사용, 스타일 훅과 분리&lt;/li&gt;
&lt;li&gt;JS 미동작 상황에서도 기본 기능 유지, 점진적 향상 고려&lt;/li&gt;
&lt;li&gt;모듈 분리와 의존성 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;p&gt;마크업은 링크와 폼이 기본 동작을 스스로 제공하도록 설계
JS는 존재하면 기본 동작을 확장하거나 향상
이벤트 바인딩은 외부 스크립트에서 선택자 기반으로 수행, 인라인 스크립트 제거&lt;/p&gt;</description>
    </item>
    <item>
      <title>C# Hashtable vs Dictionary 비교와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/csharp-hashtable-vs-dictionary-f52312/</link>
      <pubDate>Sat, 14 Feb 2026 13:16:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/csharp-hashtable-vs-dictionary-f52312/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;C#에서 키와 값으로 데이터를 저장하는 대표 컬렉션은 Hashtable과 Dictionary 두 가지가 있음
표면적인 사용법은 비슷하지만 제네릭 지원 여부와 타입 처리 방식이 달라 성능과 안정성에서 차이 발생
핵심 차이와 간단 예시, 선택 기준 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-차이&#34;&gt;핵심 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hashtable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비제네릭 컬렉션, Key와 Value가 object로 저장됨&lt;/li&gt;
&lt;li&gt;값 형식 저장 시 박싱 발생, 꺼낼 때 언박싱 또는 캐스팅 비용 발생&lt;/li&gt;
&lt;li&gt;컴파일 타임 타입 체크 부재, 런타임 캐스팅 오류 위험 높음&lt;/li&gt;
&lt;li&gt;레거시 코드와의 호환성은 높으나 일반적으로 권장되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer</title>
      <link>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</link>
      <pubDate>Fri, 13 Feb 2026 13:25:25 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;링크를 새 탭에서 열 때 a 태그에 target=&amp;quot;_blank&amp;quot;를 많이 사용함
이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음
rel=&amp;ldquo;noopener noreferrer&amp;quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;target: 링크 대상 브라우징 컨텍스트 지정&lt;/li&gt;
&lt;li&gt;window.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체&lt;/li&gt;
&lt;li&gt;rel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지&lt;/li&gt;
&lt;li&gt;rel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target-값-정리&#34;&gt;target 값 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;_self: 현재 탭에서 열기, 기본값이라 명시 생략 가능&lt;/li&gt;
&lt;li&gt;_blank: 새 탭에서 열기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target_blank만-사용할-때의-문제&#34;&gt;target=&amp;quot;_blank&amp;quot;만 사용할 때의 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;보안 취약점 발생 가능
악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재
원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음&lt;/li&gt;
&lt;li&gt;성능 간섭 가능성
새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음
무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rel=&amp;ldquo;noopener&amp;rdquo;
새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단
탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화&lt;/li&gt;
&lt;li&gt;rel=&amp;ldquo;noreferrer&amp;rdquo;
이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지
분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;필수 최소 속성만 명시&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.map 완전 가이드: 동작 원리, 주의점, 실전 패턴</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/</link>
      <pubDate>Thu, 12 Feb 2026 13:28:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-map-guide-17b880/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Array.prototype.map은 배열의 각 요소에 대해 지정한 콜백을 호출하고 그 반환값으로 새 배열을 만드는 메서드임
원본 배열은 변경하지 않으며 콜백의 부수효과로만 변형이 일어날 수 있음
희소 배열의 빈 슬롯은 유지되며 콜백은 값이 존재하는 인덱스에만 호출됨&lt;/p&gt;
&lt;h3 id=&#34;구문&#34;&gt;구문&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arr.map(callback(currentValue[, index[, array]])[, thisArg])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callback 현재 요소를 변환해 새 요소를 생성하는 함수&lt;/li&gt;
&lt;li&gt;currentValue 현재 요소 값&lt;/li&gt;
&lt;li&gt;index 선택 현재 요소의 인덱스&lt;/li&gt;
&lt;li&gt;array 선택 map을 호출한 원본 배열&lt;/li&gt;
&lt;li&gt;thisArg 선택 콜백 실행 시 this로 사용할 값&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;반환값&#34;&gt;반환값&lt;/h3&gt;
&lt;p&gt;각 요소에 대해 callback을 실행한 결과로 구성된 새 배열 반환
원본 배열과 길이는 동일하고 희소성도 보존됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>CSS 미디어 쿼리 기본기와 prefers-color-scheme 적용</title>
      <link>https://blog.jsontapose.com/posts/css-media-queries-prefers-color-scheme-9b1dbe/</link>
      <pubDate>Wed, 11 Feb 2026 13:29:11 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/css-media-queries-prefers-color-scheme-9b1dbe/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;미디어 쿼리는 뷰포트나 사용자 환경에 따라 CSS를 조건부로 적용하기 위한 기능임
다른 언어의 if 조건문과 유사하게 조건이 참일 때만 특정 스타일이 활성화됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;@media 규칙과 하나 이상의 조건으로 구성
조건은 화면 폭, 해상도, 사용자 선호도 등 미디어 특성으로 표현됨
조건이 참이면 블록 내부 스타일이 캐스케이딩에 참여하고 거짓이면 무시됨&lt;/p&gt;
&lt;h3 id=&#34;문법과-구조&#34;&gt;문법과 구조&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;media&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;조건&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;/* 스타일 */&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;조건 예시&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;max-width: 상한 폭 이하에서 적용&lt;/li&gt;
&lt;li&gt;min-width: 하한 폭 이상에서 적용&lt;/li&gt;
&lt;li&gt;논리 결합 and, not 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;p&gt;브라우저가 런타임에 조건을 평가함
윈도우 리사이즈나 기기 회전, OS 설정 변경 시 즉시 재평가되어 스타일 재적용됨
충돌 시 일반 CSS 우선순위 규칙을 따름 우선순위 &amp;gt; 특이성 &amp;gt; 선언 순서
모바일 퍼스트 전략 권장 min-width 기준으로 점진적 확장 구성&lt;/p&gt;</description>
    </item>
    <item>
      <title>window load vs document DOMContentLoaded 트리거 차이와 사용 시점</title>
      <link>https://blog.jsontapose.com/posts/window-load-vs-document-domcontentloaded-b80cb4/</link>
      <pubDate>Tue, 10 Feb 2026 13:29:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/window-load-vs-document-domcontentloaded-b80cb4/</guid>
      <description>&lt;p&gt;window load는 js css 이미지 등 모든 리소스 로드 완료 시점 발생
document DOMContentLoaded는 초기 DOM 파싱 완료 시점 발생, 외부 리소스 비대기&lt;/p&gt;
&lt;p&gt;UI 바인딩 초기화는 DOMContentLoaded
이미지 크기 등 전체 리소스 필요 계산은 load&lt;/p&gt;
&lt;p&gt;body onload window.onload에 매핑됨 마지막 할당만 유효
덮어쓰기 방지용 addEventListener 권장&lt;/p&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>SQL Server nvarchar와 nchar 길이 단위 오해 바로잡기</title>
      <link>https://blog.jsontapose.com/posts/sql-server-nvarchar-nchar-length-misconception-c1f1aa/</link>
      <pubDate>Mon, 09 Feb 2026 13:28:52 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sql-server-nvarchar-nchar-length-misconception-c1f1aa/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;nvarchar와 nchar를 사용할 때 n이 곧 문자 개수라고 가정하는 경우가 많음
하지만 SQL Server에서 nchar(n), nvarchar(n)의 n은 문자 개수가 아니라 2바이트 단위의 길이, 즉 바이트 페어(byte-pair) 개수로 정의됨
문자 집합 범위에 따라 한 문자가 1개 혹은 2개의 바이트 페어를 사용할 수 있어 저장 가능한 문자의 실제 개수는 달라짐&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;nchar(n), nvarchar(n)의 n은 0~4000 바이트 페어 범위의 길이 의미&lt;/li&gt;
&lt;li&gt;하나의 바이트 페어는 2바이트로, 내부적으로 UTF-16 코드 유닛 단위로 이해 가능&lt;/li&gt;
&lt;li&gt;유니코드 BMP 범위(0~65,535) 문자는 보통 1 바이트 페어 사용&lt;/li&gt;
&lt;li&gt;보조 평면 범위(65,536~1,114,111) 문자는 서러게이트 페어로 2 바이트 페어 사용&lt;/li&gt;
&lt;li&gt;따라서 n이 문자의 최대 개수를 보장하지 않음&lt;/li&gt;
&lt;li&gt;char(n), varchar(n)은 n이 바이트 수 의미라는 점에서 유사한 맥락이나, nvarchar/nchar는 바이트 페어 기준이라는 차이 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추가 기본값 규칙&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.reduce 개념과 안전한 활용 가이드</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-reduce-guide-677e4e/</link>
      <pubDate>Sun, 08 Feb 2026 13:16:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-reduce-guide-677e4e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Array.prototype.reduce는 배열을 하나의 값으로 축약하는 표준 API
배열의 각 요소에 대해 리듀서 함수를 순차 실행하고 누산기 값을 반환
집계, 변환, 그룹핑, 파이프라인 구성 등 다양한 패턴에 사용&lt;/p&gt;
&lt;h3 id=&#34;구문&#34;&gt;구문&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arr.reduce(callback[, initialValue])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callback에 누산 로직 정의&lt;/li&gt;
&lt;li&gt;initialValue가 있으면 누산기의 시작값으로 사용, 없으면 배열의 첫 요소가 시작값&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;매개변수&#34;&gt;매개변수&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;callback(accumulator, currentValue, currentIndex, array)
&lt;ul&gt;
&lt;li&gt;accumulator: 누산된 값&lt;/li&gt;
&lt;li&gt;currentValue: 현재 요소 값&lt;/li&gt;
&lt;li&gt;currentIndex: 현재 인덱스&lt;/li&gt;
&lt;li&gt;array: 원본 배열&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;initialValue (옵션)
&lt;ul&gt;
&lt;li&gt;누산기의 초기값&lt;/li&gt;
&lt;li&gt;제공하지 않으면 배열 첫 요소가 초기값이 되어 콜백은 두 번째 요소부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;반환값&#34;&gt;반환값&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;축약 결과로 얻은 최종 누산값&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽에서 오른쪽으로 순회하며 callback을 한 번씩 호출&lt;/li&gt;
&lt;li&gt;initialValue 미제공
&lt;ul&gt;
&lt;li&gt;빈 배열이면 TypeError 발생&lt;/li&gt;
&lt;li&gt;요소가 하나뿐이면 그 요소를 그대로 반환하며 callback은 호출되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;initialValue 제공
&lt;ul&gt;
&lt;li&gt;배열이 비어 있어도 initialValue를 그대로 반환하며 callback은 호출되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;희소 배열의 빈 슬롯은 건너뜀&lt;/li&gt;
&lt;li&gt;누산기는 어떤 타입도 가능하며 객체, 맵, 프라미스 등으로 확장 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의-사항과-베스트-프랙티스&#34;&gt;주의 사항과 베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가능한 항상 initialValue 지정 권장
&lt;ul&gt;
&lt;li&gt;빈 배열 입력 시 예외 방지, 타입 안정성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;누산기 불변성 유지 권장
&lt;ul&gt;
&lt;li&gt;객체 누산 시 얕은 복사 또는 구조 분해 사용 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;콜백은 순수 함수 지향
&lt;ul&gt;
&lt;li&gt;외부 상태 변경 최소화, 테스트 용이성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 어려운 과도한 축약 로직은 map, filter, for&amp;hellip;of 등으로 분리 고려&lt;/li&gt;
&lt;li&gt;희소 배열에서 빈 슬롯은 콜백이 호출되지 않음에 유의&lt;/li&gt;
&lt;li&gt;오른쪽에서 왼쪽으로 처리해야 하면 reduceRight 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;합계 계산&lt;/p&gt;</description>
    </item>
    <item>
      <title>class-transformer와 class-validator로 DTO 변환·검증 패턴 정리</title>
      <link>https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/</link>
      <pubDate>Sat, 07 Feb 2026 13:16:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;클라이언트에서 서버로 들어오는 요청 데이터를 DTO로 다루면 변환과 검증의 경계를 명확히 유지 가능함
class-transformer는 입력을 클래스 인스턴스로 변환하는 역할, class-validator는 변환된 인스턴스의 유효성 검증 역할
두 라이브러리를 함께 쓰면 DTO 레이어에서 데이터 정합성을 선제적으로 보장 가능함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DTO 데이터 전송 객체, 외부 입력을 내부 도메인으로 들이기 전 구조와 제약을 고정하는 경계&lt;/li&gt;
&lt;li&gt;class-transformer plain object ↔ 클래스 인스턴스 변환, 노출/제외 필드 제어&lt;/li&gt;
&lt;li&gt;class-validator 데코레이터 기반 유효성 규칙 선언, 실행 시 검증 에러 수집&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;설치&#34;&gt;설치&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm install class-transformer class-validator&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;사용-흐름과-최소-예시&#34;&gt;사용 흐름과 최소 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;입력 JSON 수신 → DTO 클래스로 변환 → DTO 인스턴스 검증 → 실패 시 에러 응답, 성공 시 비즈니스 로직으로 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; Expose&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Exclude&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; plainToInstance &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;class-transformer&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; IsInt&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; IsString&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; validate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;class-validator&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; UserDTO &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@IsString&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Expose&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@IsInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Expose&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Exclude&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  password?: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; dto &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; plainToInstance&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;UserDTO&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; payload&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; errors &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; validate&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dto&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;errors&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;length&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 검증 실패 처리
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;포인트&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript에서 declare function의 개념과 사용 시점</title>
      <link>https://blog.jsontapose.com/posts/typescript-declare-function-53e697/</link>
      <pubDate>Fri, 06 Feb 2026 13:24:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-declare-function-53e697/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript의 declare 키워드는 외부에서 이미 구현된 값의 타입 정보를 컴파일러에 알려주는 용도임
실제 구현은 다른 런타임 환경이나 스크립트에 존재하고, TypeScript는 타입 검사만 수행함
선언은 자바스크립트 코드로 출력되지 않음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;declare function: 외부에 존재하는 함수의 시그니처만 제공하는 선언&lt;/li&gt;
&lt;li&gt;사용 위치: 주로 .d.ts 선언 파일, 필요 시 .ts에서도 가능하지만 빌드 결과물에는 코드가 생성되지 않음&lt;/li&gt;
&lt;li&gt;목적: 컴파일 타임에 타입을 인지시켜 오류를 줄이고, IDE 보조 기능을 활성화함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;언제-사용하나&#34;&gt;언제 사용하나&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타입 정보가 없는 외부 자바스크립트 라이브러리 사용 시&lt;/li&gt;
&lt;li&gt;글로벌로 노출된 함수나 변수를 TypeScript가 모를 때&lt;/li&gt;
&lt;li&gt;JS와 TS 혼용 프로젝트에서 점진적 마이그레이션을 진행할 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;글로벌 함수 선언&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 이미 어딘가에서 구현된 전역 함수가 있다고 가정
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// my-globals.d.ts
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;declare&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; myGlobalFunction&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;msg: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 선언하면 TypeScript가 함수 존재와 시그니처를 인식함&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript 깊은 복사 vs 얕은 복사, structuredClone 사용 가이드</title>
      <link>https://blog.jsontapose.com/posts/javascript-structuredclone-deep-copy-shallow-copy-7cdc3a/</link>
      <pubDate>Thu, 05 Feb 2026 13:26:26 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-structuredclone-deep-copy-shallow-copy-7cdc3a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;값 복사에서 가장 흔한 실수는 얕은 복사와 깊은 복사의 차이를 간과하는 것임
이 글은 JSON 해킹이나 라이브러리 대신 브라우저와 런타임이 제공하는 structuredClone으로 깊은 복사를 안정적으로 수행하는 방법과 주의점을 정리함&lt;/p&gt;
&lt;h3 id=&#34;얕은-복사&#34;&gt;얕은 복사&lt;/h3&gt;
&lt;p&gt;JavaScript의 전개 연산자 &amp;hellip;로 만드는 복사는 기본적으로 얕은 복사임
겉 모양과 1단계 속성은 복제되지만 중첩된 객체는 동일 참조를 공유함&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; myOriginal &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  someProp&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;with a string value&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  anotherProp&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    withAnotherProp&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    andAnotherProp&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; myShallowCopy &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;myOriginal &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myShallowCopy&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;aNewProp &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;a new value&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;myOriginal&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;aNewProp&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ^ logs `undefined`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;myShallowCopy&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;anotherProp&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;aNewProp &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;a new value&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;myOriginal&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;anotherProp&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;aNewProp&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ^ logs `a new value`
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;기본형 값은 값 자체가 복사되지만 객체 같은 참조형은 레퍼런스가 복사됨
따라서 중첩된 구조를 안전하게 분리하려면 깊은 복사가 필요함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항</title>
      <link>https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/</link>
      <pubDate>Wed, 04 Feb 2026 13:25:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임
순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦
이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;rprop-개념과-문법&#34;&gt;R.prop 개념과 문법&lt;/h3&gt;
&lt;p&gt;목적과 동작 원리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구&lt;/li&gt;
&lt;li&gt;속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환&lt;/li&gt;
&lt;li&gt;커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시그니처&lt;/p&gt;</description>
    </item>
    <item>
      <title>SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트</title>
      <link>https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/</link>
      <pubDate>Tue, 03 Feb 2026 13:24:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;SWC는 Rust로 작성된 초고속 TypeScript/JavaScript 컴파일러 겸 트랜스파일러
동일한 작업을 수행하는 Babel이나 tsc 대비 10~20배 수준의 성능 향상이 보고됨
Rust로 구현되어 JS 런타임 기반 도구 대비 낮은 오버헤드와 높은 병렬 처리 효율 확보&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;목적  TS/JS 소스 코드를 목표 런타임에서 실행 가능한 코드로 빠르게 변환
특징  타입 체크 미포함, 변환에 집중해 극단적 속도 추구
적용 범위  컴파일 단계와 테스트 실행, 개발 서버 부팅, CI 빌드 가속에 유효
채택 사례  Next.js에 기본 통합됨, 서버 프레임워크에서도 선택지로 확산 중&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드</title>
      <link>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</link>
      <pubDate>Mon, 02 Feb 2026 13:24:37 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;차세대 프론트엔드 빌드 도구 Vite 요약
Vue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤
프랑스어로 vite는 빠름을 의미함&lt;/p&gt;
&lt;p&gt;핵심 가치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발 서버 즉시 기동에 가까운 체감 속도&lt;/li&gt;
&lt;li&gt;HMR이 가볍고 빠르게 동작&lt;/li&gt;
&lt;li&gt;의존성 프리번들을 esbuild로 처리해 개발 경험 가속&lt;/li&gt;
&lt;li&gt;프로덕션 빌드는 Rollup으로 안정적 번들 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;배경과-문제&#34;&gt;배경과 문제&lt;/h3&gt;
&lt;p&gt;기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 규모가 커질수록 첫 기동이 지연&lt;/li&gt;
&lt;li&gt;코드 변경 반영 또한 번들 재생성 비용으로 지연 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발 체감 문제&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vitest 완벽 가이드</title>
      <link>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</link>
      <pubDate>Sun, 01 Feb 2026 13:16:32 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Vite 기반의 테스트 프레임워크 Vitest 소개 및 실무 사용 패턴 정리
Jest와 거의 동일한 API를 제공하고, Vite의 ESM/HMR을 활용해 빠른 재실행을 제공함
Vite 프로젝트에서는 최소 설정으로 바로 사용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;빠른 실행과 재실행, watch 효율 높음&lt;/li&gt;
&lt;li&gt;Jest API 호환성 높아 러닝 커브 낮음&lt;/li&gt;
&lt;li&gt;TypeScript 네이티브 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-기본-구조&#34;&gt;1. 기본 구조&lt;/h2&gt;
&lt;h3 id=&#34;테스트-파일-명명-규칙&#34;&gt;테스트 파일 명명 규칙&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*.spec.ts     또는     *.test.ts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;describename-fn&#34;&gt;describe(name, fn)&lt;/h3&gt;
&lt;p&gt;관련 테스트를 그룹화하는 컨테이너&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; describe&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; it&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; expect &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;vitest&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;describe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;계산기&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 더한다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 뺀다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;첫 번째 인자: 그룹 이름&lt;/li&gt;
&lt;li&gt;두 번째 인자: 테스트 콜백&lt;/li&gt;
&lt;li&gt;중첩 describe 구성 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;itname-fn--testname-fn&#34;&gt;it(name, fn) / test(name, fn)&lt;/h3&gt;
&lt;p&gt;개별 테스트 케이스 정의, 두 API는 동일 동작&lt;/p&gt;</description>
    </item>
    <item>
      <title>class-transformer의 @Expose/@Exclude, @Type, plainToInstance, excludeExtraneousValues 정확히 이해하고 쓰기</title>
      <link>https://blog.jsontapose.com/posts/class-transformer-expose-exclude-type-plain-to-instance-exclude-extraneous-values-8baf8a/</link>
      <pubDate>Sat, 31 Jan 2026 13:16:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/class-transformer-expose-exclude-type-plain-to-instance-exclude-extraneous-values-8baf8a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API DTO를 다룰 때 class-transformer의 @Expose, @Exclude, @Type와 plainToInstance, excludeExtraneousValues 옵션을 정확히 이해해야 데이터 노출 제어와 변환 일관성을 확보할 수 있음
아래는 개념 정의와 동작 방향, 자주 생기는 오해 정리 및 최소 예시&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;expose와-exclude&#34;&gt;@Expose와 @Exclude&lt;/h3&gt;
&lt;p&gt;핵심 개념&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Expose: 변환 대상으로 명시적 노출 표시&lt;/li&gt;
&lt;li&gt;@Exclude: 변환에서 제외 표시&lt;/li&gt;
&lt;li&gt;기본 전략은 include-all에 가까움. 즉 아무 옵션 없이 변환하면 대부분의 필드가 그대로 따라옴. 진짜 필드 필터링을 원하면 @Exclude 사용 또는 excludeExtraneousValues 옵션과 함께 @Expose 사용 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;동작 원리&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeORM JOIN vs 코드 레벨 매핑 선택 기준과 실무 트레이드오프</title>
      <link>https://blog.jsontapose.com/posts/typeorm-join-vs-code-level-mapping-a0eaa9/</link>
      <pubDate>Fri, 30 Jan 2026 13:22:31 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typeorm-join-vs-code-level-mapping-a0eaa9/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;동일한 문제를 TypeORM의 JOIN으로 해결할 수도 있고, 각 테이블을 개별 조회한 뒤 코드에서 매핑할 수도 있음
어떤 접근이 더 효율적인지는 데이터 크기, 관계 복잡도, 인덱스 상태, 네트워크 제약, 성능 요구사항에 따라 달라짐
핵심 장단점과 선택 기준을 정리함&lt;/p&gt;
&lt;h3 id=&#34;typeorm에서-join-사용하는-경우&#34;&gt;TypeORM에서 JOIN 사용하는 경우&lt;/h3&gt;
&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 쿼리로 필요한 데이터 수집 가능, 왕복 횟수 감소로 지연시간 이점&lt;/li&gt;
&lt;li&gt;DB가 JOIN과 실행계획을 최적화하는 경우 비용 최소화 기대&lt;/li&gt;
&lt;li&gt;1:N, N:M 같은 관계 질의를 쿼리로 명시적으로 표현 가능&lt;/li&gt;
&lt;li&gt;필터링, 정렬, 그룹화 등 집계성 처리에서 DB 연산 활용 용이&lt;/li&gt;
&lt;li&gt;페이지네이션과 함께 일관된 결과를 만들기 수월함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단점&lt;/p&gt;</description>
    </item>
    <item>
      <title>tsconfig.json 핵심 옵션 가이드: module과 moduleResolution</title>
      <link>https://blog.jsontapose.com/posts/tsconfig-json-module-module-resolution-guide-05bc37/</link>
      <pubDate>Thu, 29 Jan 2026 13:23:24 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/tsconfig-json-module-module-resolution-guide-05bc37/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;tsconfig.json은 TypeScript 컴파일러 tsc의 설정 파일이며 프로젝트를 어떻게 컴파일할지 정의함&lt;/p&gt;
&lt;p&gt;TypeScript 코드가 JavaScript로 변환되는 경로에 대한 스위치 보드 역할 수행&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TypeScript (.ts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ tsc ]  ← tsconfig.json이 규칙 제공
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;JavaScript (.js)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;module-옵션&#34;&gt;module 옵션&lt;/h3&gt;
&lt;p&gt;출력되는 JavaScript의 모듈 시스템 선택&lt;/p&gt;
&lt;p&gt;모듈 시스템의 변화 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;없음, 전역 스코프 공유&lt;/li&gt;
&lt;li&gt;CommonJS, require/module.exports 중심&lt;/li&gt;
&lt;li&gt;AMD, 브라우저 환경 define/require&lt;/li&gt;
&lt;li&gt;ES Modules, 표준 import/export&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;주요 값과 용도&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commonjs  Node.js 구버전 호환&lt;/li&gt;
&lt;li&gt;es2015/es6  표준 ESM, 브라우저·번들러 환경&lt;/li&gt;
&lt;li&gt;es2020  ESM + dynamic import 사용 환경&lt;/li&gt;
&lt;li&gt;es2022  ESM + top-level await 사용 환경&lt;/li&gt;
&lt;li&gt;esnext  최신 ESM 기능 추적&lt;/li&gt;
&lt;li&gt;nodenext  Node.js 16+의 ESM 출력·해석 규칙 반영&lt;/li&gt;
&lt;li&gt;node16  Node.js 16의 ESM과 CJS 혼합 환경 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;같은 코드의 다른 출력 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 PoS에서 트랜잭션이 블록에 포함되고 최종화되기까지</title>
      <link>https://blog.jsontapose.com/posts/ethereum-pos-tx-to-finality-ef6889/</link>
      <pubDate>Wed, 28 Jan 2026 13:17:37 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-pos-tx-to-finality-ef6889/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;이더리움 PoS에서 한 트랜잭션이 네트워크에 전파되고 블록에 포함된 뒤 최종화되기까지의 핵심 흐름 정리
노드별 로컬 mempool, 슬롯 기반 제안자 선정, 검증자 attestation, 포크 선택, 최종화 순서로 진행
현실적으로 일부 제안자는 외부 빌더를 사용할 수 있으나 프로토콜 관점의 기본 흐름을 기준으로 설명&lt;/p&gt;
&lt;h3 id=&#34;전체-흐름&#34;&gt;전체 흐름&lt;/h3&gt;
&lt;p&gt;1 트랜잭션 발생 및 전파&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 서명된 트랜잭션 전송&lt;/li&gt;
&lt;li&gt;여러 노드가 트랜잭션을 수신하고 각자 로컬 mempool에 저장&lt;/li&gt;
&lt;li&gt;mempool은 전역 공유가 아닌 노드 로컬 데이터 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 슬롯과 제안자 선정&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리</title>
      <link>https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/</link>
      <pubDate>Tue, 27 Jan 2026 13:17:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/</guid>
      <description>&lt;p&gt;배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for&amp;hellip;of, 그리고 객체 속성에 적합한 for&amp;hellip;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함&lt;/p&gt;
&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용&lt;/li&gt;
&lt;li&gt;forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가&lt;/li&gt;
&lt;li&gt;for&amp;hellip;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능&lt;/li&gt;
&lt;li&gt;for&amp;hellip;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이터러블과 이터레이터 프로토콜을 따르는 객체에 for&amp;hellip;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 PoS 노드의 종류와 역할 정리</title>
      <link>https://blog.jsontapose.com/posts/ethereum-pos-node-types-and-roles-e8a3b8/</link>
      <pubDate>Mon, 26 Jan 2026 13:16:23 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-pos-node-types-and-roles-e8a3b8/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;이더리움 PoS 환경에서 노드 역할은 레이어 분리로 명확해졌음. 실행을 담당하는 EL, 합의를 담당하는 CL, 검증자 키와 서명을 담당하는 VC로 나뉨. 이 조합으로 일반 풀노드와 밸리데이터 노드가 구성됨. 아래는 각 컴포넌트와 노드 타입의 역할 차이를 실무 관점에서 정리함&lt;/p&gt;
&lt;h3 id=&#34;레이어-기준-정의&#34;&gt;레이어 기준 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;EL (Execution Layer)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 실행과 상태 전이 수행&lt;/li&gt;
&lt;li&gt;EVM 실행과 가스 계산 담당&lt;/li&gt;
&lt;li&gt;mempool 유지 및 트랜잭션 선별&lt;/li&gt;
&lt;li&gt;블록 본문에 담기는 실제 tx 처리 관할&lt;/li&gt;
&lt;li&gt;무슨 일이 일어났는지 계산하는 층&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CL (Consensus Layer)&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript 고급 타입 패턴 정리 — 제네릭, 유니온·인터섹션, 매핑, 조건부, 유틸리티</title>
      <link>https://blog.jsontapose.com/posts/typescript-advanced-type-patterns-d8ee0f/</link>
      <pubDate>Sun, 25 Jan 2026 13:12:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-advanced-type-patterns-d8ee0f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript의 고급 타입은 단순 오류 방지 수준을 넘어 재사용성과 유지보수성을 끌어올리는 핵심 도구임
제네릭, 유니온·인터섹션, 매핑 타입, 조건부 타입, 그리고 실무에서 자주 쓰는 유틸리티 타입을 간단 예시와 함께 정리함&lt;/p&gt;
&lt;h3 id=&#34;제네릭&#34;&gt;제네릭&lt;/h3&gt;
&lt;p&gt;타입을 값처럼 받아서 사용하는 패턴으로, 선언 시점이 아니라 사용 시점에 타입을 결정함
any 대비 타입 정보를 잃지 않으면서 다양한 타입을 수용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본 형태 &lt;!-- raw HTML omitted --&gt; 사용&lt;/li&gt;
&lt;li&gt;입력과 출력 타입의 관계를 보존하는 데 초점&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; wrap&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;value: &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;gt;(&lt;/span&gt;value: &lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; stringBox &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; numberBox &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;T는 관습적 이름이며 의미가 드러나는 이름 사용 권장&lt;/li&gt;
&lt;li&gt;제네릭 제한이 필요한 경우 extends를 사용해 제약 가능 ex) &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;유니온과-인터섹션&#34;&gt;유니온과 인터섹션&lt;/h3&gt;
&lt;p&gt;여러 타입을 조합해 표현력을 높이는 방법&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxJS 핵심 가이드와 내부 동작 이해 Observable Subject Teardown Scheduler Operator</title>
      <link>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</link>
      <pubDate>Sat, 24 Jan 2026 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;RxJS는 Reactive Extensions for JavaScript의 약자이며 비동기 데이터 흐름을 스트림 Observable로 다루는 라이브러리임
이벤트, API 응답, 클릭, WebSocket처럼 시간에 따라 변하는 값을 하나의 연속 흐름으로 모델링 가능&lt;/p&gt;
&lt;p&gt;핵심 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise는 값 1개 처리&lt;/li&gt;
&lt;li&gt;Observable은 값 0개부터 무한대까지 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;observable-핵심&#34;&gt;Observable 핵심&lt;/h3&gt;
&lt;p&gt;정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간에 따라 변경되는 데이터를 push 기반 스트림으로 표현한 객체&lt;/li&gt;
&lt;li&gt;구독 subscribe 시점에만 실행되는 lazy 특성&lt;/li&gt;
&lt;li&gt;구독 해제 unsubscribe 시 리소스 정리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lazy 실행으로 불필요한 작업 방지&lt;/li&gt;
&lt;li&gt;cancel 가능으로 누수 방지&lt;/li&gt;
&lt;li&gt;0~무한개의 값 연속 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript/ESM import 경로 정리: &#39;@&#39;, &#39;#&#39;, 상대 경로의 의미와 설정</title>
      <link>https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/</link>
      <pubDate>Fri, 23 Jan 2026 13:15:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;@&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;#&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;@&amp;lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능&lt;/li&gt;
&lt;li&gt;&amp;lsquo;&amp;hellip;&amp;lsquo;는 상대·절대 경로로 파일 시스템 기준 해석&lt;/li&gt;
&lt;li&gt;&amp;lsquo;#&amp;lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함&lt;/p&gt;
&lt;h3 id=&#34;-경로의-두-가지-의미&#34;&gt;&amp;lsquo;@&amp;hellip;&amp;rsquo; 경로의 두 가지 의미&lt;/h3&gt;
&lt;h4 id=&#34;1-경로-별칭-path-alias&#34;&gt;1) 경로 별칭 path alias&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;의도: 길고 복잡한 상대 경로를 짧게 추상화&lt;/li&gt;
&lt;li&gt;설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;compilerOptions&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;baseUrl&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;./&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;paths&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;@models/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;src/models/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;@utils/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;src/utils/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;@models/User&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; calculate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;@utils/math&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;상대 경로를 단순화, 가독성 및 리팩터링 내성 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주의
&lt;ul&gt;
&lt;li&gt;tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님&lt;/li&gt;
&lt;li&gt;Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요&lt;/li&gt;
&lt;li&gt;예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-스코프된-패키지-scoped-package&#34;&gt;2) 스코프된 패키지 scoped package&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합&lt;/li&gt;
&lt;li&gt;표기: @scope/package-name 형태
&lt;ul&gt;
&lt;li&gt;@nestjs/swagger, @angular/core 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용 이유
&lt;ul&gt;
&lt;li&gt;네임스페이스로 이름 충돌 회피&lt;/li&gt;
&lt;li&gt;관련 패키지의 그룹화와 공개·비공개 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;설치&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm install @nestjs/swagger&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;해석
&lt;ul&gt;
&lt;li&gt;이 경우 &amp;lsquo;@&amp;lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작&lt;/li&gt;
&lt;li&gt;tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-상대절대-경로-import&#34;&gt;&amp;lsquo;&amp;hellip;&amp;rsquo; 상대·절대 경로 import&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상대 경로 &amp;lsquo;./&amp;rsquo;, &amp;lsquo;../&amp;rsquo; 기준으로 현재 파일 위치에서 탐색&lt;/li&gt;
&lt;li&gt;절대 경로 &amp;lsquo;/path&amp;rsquo;는 실행 환경마다 기준이 다름
&lt;ul&gt;
&lt;li&gt;브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석&lt;/li&gt;
&lt;li&gt;Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;./models/User&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; calculate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;../utils/math&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델&lt;/li&gt;
&lt;li&gt;모듈 간 물리적 의존 관계가 드러남&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승&lt;/li&gt;
&lt;li&gt;구조 변경 시 경로 대량 수정 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-경로의-의미&#34;&gt;&amp;lsquo;#&amp;hellip;&amp;rsquo; 경로의 의미&lt;/h3&gt;
&lt;p&gt;&amp;lsquo;#{name}&amp;rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의&lt;/p&gt;</description>
    </item>
    <item>
      <title>CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용</title>
      <link>https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/</link>
      <pubDate>Thu, 22 Jan 2026 13:16:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;목표  이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기
Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음&lt;/p&gt;
&lt;h3 id=&#34;cpu-코어와-os-스레드의-물리적-의미&#34;&gt;CPU 코어와 OS 스레드의 물리적 의미&lt;/h3&gt;
&lt;p&gt;하드웨어와 OS 레벨 정의를 먼저 정리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개&lt;/li&gt;
&lt;li&gt;스레드  OS 스케줄러가 CPU를 할당하는 최소 단위&lt;/li&gt;
&lt;li&gt;동시성 vs 병렬성
&lt;ul&gt;
&lt;li&gt;코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성&lt;/li&gt;
&lt;li&gt;코어 여러 개일 때만 실제 병렬 실행 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 관점의 핵심 비용&lt;/p&gt;</description>
    </item>
    <item>
      <title>nonce가 꼬인다? 트랜잭션 상태별 nonce의 변화</title>
      <link>https://blog.jsontapose.com/posts/ethereum-transaction-nonce-states-7cf0f0/</link>
      <pubDate>Wed, 21 Jan 2026 13:16:50 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-transaction-nonce-states-7cf0f0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Ethereum에서 트랜잭션 순서를 보장하는 핵심 메커니즘은 nonce임. 네트워크에서 자주 겪는 &amp;ldquo;nonce 꼬임&amp;quot;은 대개 트랜잭션 상태와 nonce 소비 규칙을 혼동해서 발생함. 아래는 EOA와 트랜잭션 관계, nonce 정의, 트랜잭션 상태별 nonce 변화 정리&lt;/p&gt;
&lt;h3 id=&#34;eoa와-트랜잭션&#34;&gt;EOA와 트랜잭션&lt;/h3&gt;
&lt;p&gt;Ethereum 계정은 두 종류로 구분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EOA, 개인 키로 서명해 트랜잭션 전송 가능&lt;/li&gt;
&lt;li&gt;Contract Account, 스스로 트랜잭션 전송 불가, 외부에서 온 트랜잭션의 실행 흐름 내에서만 호출됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;트랜잭션을 보낸다는 것은 EOA가 서명 후 네트워크에 브로드캐스트한다는 의미. 컨트랙트는 내부 호출과 생성 같은 메시지 호출을 발생시킬 수 있지만 이는 트랜잭션이 아님. 최상위 트랜잭션의 발신자는 항상 EOA&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 단위 정리: ETH, Gwei, Wei와 ERC-20 decimals 18</title>
      <link>https://blog.jsontapose.com/posts/ethereum-units-eth-gwei-wei-decimals-18-83ba11/</link>
      <pubDate>Tue, 20 Jan 2026 13:17:15 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-units-eth-gwei-wei-decimals-18-83ba11/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;이더리움 단위 체계는 10의 지수 기반으로 딱 떨어지게 설계됨
EVM은 부동소수점을 지원하지 않으므로 모든 값은 정수로 표현, 단위 나눔과 스케일링이 필수&lt;/p&gt;
&lt;h3 id=&#34;단위-환산&#34;&gt;단위 환산&lt;/h3&gt;
&lt;p&gt;1 ETH = 10^9 Gwei = 10^18 Wei&lt;/p&gt;
&lt;p&gt;풀어서 보면 다음과 같음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 ETH&lt;/li&gt;
&lt;li&gt;= 1,000,000,000 Gwei (10억 그웨이)&lt;/li&gt;
&lt;li&gt;= 1,000,000,000,000,000,000 Wei (100경 웨이)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;용도별-구분&#34;&gt;용도별 구분&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Wei: 최소 단위, 스마트 컨트랙트 내부 연산에 사용. Solidity에 소수점 개념 없음&lt;/li&gt;
&lt;li&gt;Gwei: 10^9 Wei. 가스 가격 표시 단위로 사용, 사람이 읽고 비교하기 쉬움&lt;/li&gt;
&lt;li&gt;Ether: 10^18 Wei. 지갑 잔고, 일상적 송금 금액 표시에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발자-상식-erc-20-decimals--18&#34;&gt;개발자 상식: ERC-20 decimals = 18&lt;/h3&gt;
&lt;p&gt;ERC-20 토큰에서 decimals를 18로 두는 관례는 이더리움 기본 최소 단위(Wei) 스케일을 그대로 따름
의미: 토큰 1개가 10^18의 최소 단위로 분할 가능
예외: 스테이블 코인처럼 법정화폐 소수 자리를 맞추는 토큰은 decimals 6 등으로 설정하는 경우 있음&lt;/p&gt;</description>
    </item>
    <item>
      <title>ERC-4337 Account Abstraction의 장단점과 EntryPoint 병목 정리</title>
      <link>https://blog.jsontapose.com/posts/erc-4337-account-abstraction-pros-cons-entrypoint-bottleneck-221231/</link>
      <pubDate>Mon, 19 Jan 2026 13:16:36 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/erc-4337-account-abstraction-pros-cons-entrypoint-bottleneck-221231/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Account Abstraction(AA, 계정 추상화)은 키 기반 EOA에 고정된 지갑 모델을 스마트 컨트랙트로 일반화해 UX를 끌어올리는 접근법. ERC-4337은 이를 프로토콜 변경 없이 애플리케이션 레이어에서 구현하는 표준. 목적은 블록체인을 몰라도 쓸 수 있는 경험을 제공하는 것. 대가로 추가 가스비와 인프라 복잡도가 뒤따름&lt;/p&gt;
&lt;h3 id=&#34;장점-요약&#34;&gt;장점 요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가스비 대납과 가스 추상화 지원. Paymaster를 통해 사용자가 ETH 없이도 트랜잭션 가능. 서비스가 대납하거나 보유 토큰으로 지불하는 경로 구성 가능&lt;/li&gt;
&lt;li&gt;소셜 복구 및 프로그래머블 보안. 시드 문구 분실 시 다중 승인 기반 복구, 전송 한도, 화이트리스트 등 정책 내장 가능&lt;/li&gt;
&lt;li&gt;트랜잭션 배치. Approve → Swap 같은 연속 작업을 한 번의 서명으로 처리, 서명 피로와 왕복 비용 감소&lt;/li&gt;
&lt;li&gt;세션 키. 제한된 권한과 기간으로 자동 서명 흐름 구성 가능. 게임 등 빈번한 액션에 유효&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단점-요약&#34;&gt;단점 요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;높은 가스비. EntryPoint를 경유하며 검증/실행 로직이 추가되어 오버헤드 발생. 메인넷에서는 체감 비용 큼, L2에서는 상대적으로 부담 완화 가능&lt;/li&gt;
&lt;li&gt;인프라 복잡도 증가. 노드만으로 부족, Bundler·Paymaster·Aggregator 등 별도 컴포넌트 필요. 이들 장애 시 트랜잭션 정지 리스크 존재&lt;/li&gt;
&lt;li&gt;DApp 호환성 이슈. EOA 전제 코드와 충돌 가능. EIP-1271 기반 서명 검증 경로를 지원하지 않는 레거시 DApp에서 로그인/서명 실패 발생 여지&lt;/li&gt;
&lt;li&gt;지갑 생성 비용. AA 지갑은 컨트랙트이므로 최초 배포 비용 발생. 첫 트랜잭션 시 지연 배포로 UX 노출 최소화 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;entrypoint-병목-구조&#34;&gt;EntryPoint 병목 구조&lt;/h3&gt;
&lt;p&gt;ERC-4337에서는 사용자 요청(UserOperation)이 단일 싱글톤 컨트랙트인 EntryPoint를 통해 처리됨. Bundler가 여러 UserOp를 모아 EntryPoint의 &lt;code&gt;handleOps&lt;/code&gt;를 호출하는 구조. 병목의 핵심은 서버 과부하라기보다 가스비 오버헤드와 검증 복잡도 증가&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript readonly 이해와 사용법, 배열·객체 읽기 전용 타입 지정</title>
      <link>https://blog.jsontapose.com/posts/typescript-readonly-usage-immutable-arrays-objects-d79456/</link>
      <pubDate>Sun, 18 Jan 2026 13:10:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-readonly-usage-immutable-arrays-objects-d79456/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;readonly는 TypeScript 전용 타입 수정자이며 JavaScript 런타임에는 존재하지 않음
컴파일 타임에만 효력이 있으며, 읽기 전용으로 선언된 배열·객체 속성을 수정하려는 코드에 대해 타입 오류를 발생시킴&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;배열 또는 객체 속성의 변경 금지 의도를 타입 수준에서 명시
예를 들어 onChainResult: readonly bigint[]는 블록체인에서 읽어온 결과 배열이 이후 코드 흐름에서 변형되지 않음을 보장하려는 의도 표현
읽기 전용 제약은 타입 체크 시점에만 적용되며, 트랜스파일된 JavaScript에는 제약이 남지 않음&lt;/p&gt;
&lt;h3 id=&#34;동작과-제한&#34;&gt;동작과 제한&lt;/h3&gt;
&lt;p&gt;읽기 전용 배열은 변경 메서드가 제거된 ReadonlyArray 형태로 다뤄짐
객체의 readonly 속성은 재할당 금지, 단 객체 참조 자체는 다른 값으로 교체 가능할 수 있으므로 설계 시 구분 필요
타입 수준 readonly는 얕은 불변성에 해당하는 경우가 많음. 중첩된 구조까지 불변으로 보장하려면 계층별로 readonly를 적용하거나 별도 불변 모델을 설계해야 함&lt;/p&gt;</description>
    </item>
    <item>
      <title>CEI 패턴 Checks-Effects-Interactions로 재진입 방어</title>
      <link>https://blog.jsontapose.com/posts/cei-pattern-checks-effects-interactions-940c92/</link>
      <pubDate>Sat, 17 Jan 2026 13:10:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/cei-pattern-checks-effects-interactions-940c92/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;CEI 패턴은 Checks-Effects-Interactions의 약자
스마트 컨트랙트 함수에서 실행 순서를 명확히 해 재진입 공격을 줄이는 코드 규칙
핵심은 검증 후 상태 변경을 먼저 완료하고, 외부 호출을 마지막에 수행하는 흐름 유지&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3단계-순서&#34;&gt;3단계 순서&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1. Checks (검증)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2. Effects (상태 변경)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3. Interactions (외부 호출)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 순서를 지키면 외부로 제어권이 나가기 전에 내부 상태가 이미 안전하게 반영됨
재진입 시도는 변경된 상태에 의해 자연스럽게 차단됨&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;예시로-이해하기&#34;&gt;예시로 이해하기&lt;/h3&gt;
&lt;h4 id=&#34;잘못된-순서-위험&#34;&gt;잘못된 순서 위험&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#88c0d0&#34;&gt;withdraw&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;uint256&lt;/span&gt; amount&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;external&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 1. Checks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;require&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;balances&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;sender&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;=&lt;/span&gt; amount&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 2. Interactions ← 너무 빠름
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;bool&lt;/span&gt; success&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;sender&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;call&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; amount&lt;span style=&#34;color:#eceff4&#34;&gt;}(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;require&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;success&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 3. Effects ← 너무 늦음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    balances&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;sender&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-=&lt;/span&gt; amount&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;문제점&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS 전역 예외 필터와 표준 오류 응답 설계 가이드</title>
      <link>https://blog.jsontapose.com/posts/nestjs-global-exception-filter-standard-error-response-81191e/</link>
      <pubDate>Fri, 16 Jan 2026 13:13:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-global-exception-filter-standard-error-response-81191e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API 에러 응답을 일관된 JSON 포맷으로 통일하고, 비즈니스 예외와 프레임워크 예외를 한 경로로 수집하는 전역 예외 필터 설계와 구현 정리
핵심은 표준 에러 코드 정의, AppError 기반의 명시적 예외 던지기, GlobalExceptionFilter에서의 단일 포맷 출력, ValidationPipe 결과의 구조화, traceId 기반 상관관계 추적&lt;/p&gt;
&lt;p&gt;요청 흐름 개요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청 진입 → ValidationPipe 검증&lt;/li&gt;
&lt;li&gt;검증 실패 → 전역 필터에서 표준 응답 변환&lt;/li&gt;
&lt;li&gt;검증 통과 → Controller/Service 실행&lt;/li&gt;
&lt;li&gt;비즈니스 로직 예외 → AppError 서브클래스 throw → 전역 필터 처리&lt;/li&gt;
&lt;li&gt;알 수 없는 예외 → 500으로 표준 응답 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;최종 응답 포맷은 단일 구조 유지&lt;/p&gt;</description>
    </item>
    <item>
      <title>스마트 컨트랙트 재진입 공격 방지 가이드 — CEI 패턴과 ReentrancyGuard</title>
      <link>https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/</link>
      <pubDate>Thu, 15 Jan 2026 13:14:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/smart-contract-reentrancy-defense-cei-reentrancy-guard-229684/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;리엔트란시 재진입은 외부 호출 중 컨트랙트의 같은 함수 또는 다른 함수가 다시 호출되는 상황을 의미함
상태 변경 전 외부 호출이 발생하면 공격자가 재진입을 통해 상태 검증을 우회하거나 중복 실행을 유도할 수 있음
대표적 피해 사례로 The DAO 사건이 알려져 있음&lt;/p&gt;
&lt;p&gt;실무 기본 원칙은 CEI 패턴 Checks-Effects-Interactions 준수와 ReentrancyGuard를 통한 보강 적용임
두 방법을 함께 쓰는 것이 표준에 가까움&lt;/p&gt;
&lt;h3 id=&#34;유명한-사례와-최소-취약-패턴&#34;&gt;유명한 사례와 최소 취약 패턴&lt;/h3&gt;
&lt;p&gt;취약한 순서 패턴 핵심&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;외부 전송 또는 외부 컨트랙트 호출이 상태 변경보다 먼저 발생&lt;/li&gt;
&lt;li&gt;이후 상태 변경이 이루어져도 재진입 시점에는 이전 상태가 유효하여 중복 집행 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;최소 취약 스니펫 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>ERC-721 승인 패턴 정리 approve vs setApprovalForAll 사용법과 권한 확인</title>
      <link>https://blog.jsontapose.com/posts/erc-721-approve-vs-setapprovalforall-50a1bb/</link>
      <pubDate>Wed, 14 Jan 2026 13:15:05 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/erc-721-approve-vs-setapprovalforall-50a1bb/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;ERC-721에서 전송 권한 위임을 처리하는 두 가지 승인 방식 정리
권한 범위와 사용 시나리오가 달라 오용 시 과권한 위험 발생 가능
핵심 동작과 권한 확인 패턴 중심으로 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;approve(address to, uint256 tokenId)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 NFT 1개에 대한 전송 권한만 부여&lt;/li&gt;
&lt;li&gt;예 123번 토큰만 지정한 대상이 전송 가능&lt;/li&gt;
&lt;li&gt;토큰별 개별 승인 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;setApprovalForAll(address operator, bool approved)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소유한 모든 NFT에 대한 전송 권한 일괄 부여&lt;/li&gt;
&lt;li&gt;한 번 승인 시 현재 보유분 + 이후 수령분까지 포함&lt;/li&gt;
&lt;li&gt;관리 편의성 높지만 권한 범위 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;권한-확인-패턴&#34;&gt;권한 확인 패턴&lt;/h3&gt;
&lt;p&gt;컨트랙트에서 호출 주체가 대상 토큰에 대해 승인 받았는지 확인 필요
두 방식 모두 대응하는 조건을 만족해야 안전&lt;/p&gt;</description>
    </item>
    <item>
      <title>API 성능 테스트와 모니터링 표준 가이드</title>
      <link>https://blog.jsontapose.com/posts/api-performance-testing-and-monitoring-guide-2b9e24/</link>
      <pubDate>Tue, 13 Jan 2026 13:15:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-performance-testing-and-monitoring-guide-2b9e24/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;신규 API 개발 또는 로직 변경 시 서비스의 안정성과 성능을 사전에 검증하기 위한 표준 테스트 프로세스 정의 목적
코드 수준의 비효율 제거와 인프라 병목 식별을 분리해 진행하며, 동일 스택으로 로컬과 서버 환경을 일관되게 관찰하는 것을 권장&lt;/p&gt;
&lt;h3 id=&#34;테스트-전략-개요&#34;&gt;테스트 전략 개요&lt;/h3&gt;
&lt;p&gt;성능 테스트는 환경과 목적에 따라 두 단계로 구분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Phase 1 Local
&lt;ul&gt;
&lt;li&gt;목표  코드 레벨 최적화와 비효율 제거&lt;/li&gt;
&lt;li&gt;관점  CPU 스파이크, 메모리 누수, 이벤트 루프 지연, 불필요한 I O 대기&lt;/li&gt;
&lt;li&gt;도구  k6 로컬, Clinic.js&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phase 2 Dev 서버
&lt;ul&gt;
&lt;li&gt;목표  시스템 레벨 검증과 병목 지점 확인&lt;/li&gt;
&lt;li&gt;관점  DB Redis MQ 한계, 연결 풀 고갈, 큐 적체, 에러율&lt;/li&gt;
&lt;li&gt;도구  k6 원격, Prometheus Grafana&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도구-구성&#34;&gt;도구 구성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;부하 생성  k6
&lt;ul&gt;
&lt;li&gt;JS 기반 스크립팅으로 학습 비용 낮음&lt;/li&gt;
&lt;li&gt;CI CD 파이프라인 연동 용이&lt;/li&gt;
&lt;li&gt;로컬과 서버 환경 모두에서 실행 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모니터링  Grafana Prometheus
&lt;ul&gt;
&lt;li&gt;인프라 통합 관제에 적합 Redis DB MQ WAS 지표를 일관된 대시보드로 관찰&lt;/li&gt;
&lt;li&gt;테스트 중 실시간 병목 구간 가시화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로파일링  Clinic.js
&lt;ul&gt;
&lt;li&gt;Node.js 내부 지표 심층 분석에 특화&lt;/li&gt;
&lt;li&gt;CPU 스파이크, 메모리 누수, 이벤트 루프 지연 원인 파악에 유용&lt;/li&gt;
&lt;li&gt;로컬 디버깅 우선 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단계별-진행&#34;&gt;단계별 진행&lt;/h3&gt;
&lt;h4 id=&#34;step-1-로컬-프로파일링-local-profiling&#34;&gt;Step 1 로컬 프로파일링 Local Profiling&lt;/h4&gt;
&lt;p&gt;질문  내 코드에 논리적 비효율이 없는가
배포 전 로컬에서 가벼운 부하를 주고 코드 결함을 조기에 식별&lt;/p&gt;</description>
    </item>
    <item>
      <title>Atomic Swap 스마트 컨트랙트 개념과 설계 포인트</title>
      <link>https://blog.jsontapose.com/posts/atomic-swap-smart-contract-3c92dc/</link>
      <pubDate>Mon, 12 Jan 2026 13:15:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/atomic-swap-smart-contract-3c92dc/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Atomic Swap 스마트 컨트랙트는 블록체인에서 두 당사자의 자산을 맞교환할 때 모든 동작이 한 번에 완료되거나 전혀 일어나지 않음을 보장하는 메커니즘을 제공함
사용자 간 신뢰 없이도 안전하게 교환할 수 있게 만드는 자동화 에스크로 역할의 코드임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념-원자성&#34;&gt;핵심 개념: 원자성&lt;/h3&gt;
&lt;p&gt;원자성은 트랜잭션이 더 쪼갤 수 없는 단위로 실행됨을 의미함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성공 시: A가 B에게 자산 X를 이전 AND B가 A에게 자산 Y를 이전, 두 동작이 한 묶음으로 처리됨&lt;/li&gt;
&lt;li&gt;실패 시: 아무 변경 없음, 각자 자산 유지
중간 상태가 발생하지 않도록 보장하는 것이 핵심임&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;p&gt;서로 신뢰가 없을 때 누가 먼저 보낼지에 대한 교착 상태 발생함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS @Module 핵심 정리: imports, providers, exports, forRoot, Symbol 토큰, useFactory</title>
      <link>https://blog.jsontapose.com/posts/nestjs-module-imports-providers-exports-forroot-symbol-usefactory-025aae/</link>
      <pubDate>Sun, 11 Jan 2026 13:10:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-module-imports-providers-exports-forroot-symbol-usefactory-025aae/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS에서 @Module은 기능 단위 의존성을 묶는 단위이자 DI 경계를 정의하는 컨테이너 개념임
핵심은 imports로 외부 의존성 수입, providers로 내부 의존성 등록, exports로 외부 공개 대상을 결정하는 흐름 이해가 전부임&lt;/p&gt;
&lt;h3 id=&#34;module의-imports-providers-exports&#34;&gt;Module의 imports, providers, exports&lt;/h3&gt;
&lt;p&gt;@Module 선언의 기본 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Module&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; imports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...],&lt;/span&gt; providers&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...],&lt;/span&gt; exports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...]&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; SomeModule &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;providers
&lt;ul&gt;
&lt;li&gt;이 모듈에서 새로 생성해 DI 컨테이너에 등록할 대상 목록&lt;/li&gt;
&lt;li&gt;@Injectable 클래스들 중심 Service, Repository, Adapter 등&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;providers&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;BatchService&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; PortFetcher&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; StoreService&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; MergeService&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;imports
&lt;ul&gt;
&lt;li&gt;다른 모듈이 exports로 공개한 provider를 이 모듈에서 사용하겠다는 선언&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;imports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;RepositoryModule&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; HttpModule&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; LoggerModule&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;exports
&lt;ul&gt;
&lt;li&gt;이 모듈 바깥에서도 사용 가능하도록 내보낼 provider 목록&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;JSON_REPOSITORY&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; LogRepository&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;정리하면 providers는 내부 생성, imports는 외부 수입, exports는 외부 공개 대상 지정임&lt;/p&gt;</description>
    </item>
    <item>
      <title>자바스크립트 비동기와 이터레이터 정리 — 기다림, 동시성, 백프레셔</title>
      <link>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</link>
      <pubDate>Sat, 10 Jan 2026 13:10:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;비동기는 강력한 도구임. 다만 배열과 스트림 같은 이터레이터와 결합되면 누가 무엇을 언제 기다리는지 불명확해지기 쉬움
핵심 포인트 세 가지 기억&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완료 보장 확보했는지&lt;/li&gt;
&lt;li&gt;동시성 제어를 명시했는지&lt;/li&gt;
&lt;li&gt;백프레셔로 생산 속도 ≤ 소비 속도 유지했는지&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비동기가-의도대로-동작하지-않는-케이스&#34;&gt;비동기가 의도대로 동작하지 않는 케이스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;forEach + async 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;콜백이 반환한 프로미스를 외부가 수집하지 않음 → 완료 보장 깨짐, 레이스와 누락 가능성 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;items&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;forEach&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; doAsync&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 외부에서 기다리지 않음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map + async 이후 기다리지 않음&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript에서 type과 interface 차이와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/</link>
      <pubDate>Fri, 09 Jan 2026 13:14:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름
객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐
핵심 차이 포인트 중심으로 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입 별칭 정의 수단&lt;/li&gt;
&lt;li&gt;기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리&lt;/li&gt;
&lt;li&gt;선언 병합 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 구조 정의 수단&lt;/li&gt;
&lt;li&gt;확장과 선언 병합 지원&lt;/li&gt;
&lt;li&gt;주로 객체와 클래스와의 계약 정의에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// type 별칭 최소 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; ID &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Point &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Person &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// interface 최소 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;interface&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;interface&lt;/span&gt; Employee &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;extends&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; employeeId: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;차이점과-동작&#34;&gt;차이점과 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표현 범위&lt;/p&gt;</description>
    </item>
    <item>
      <title>데이터베이스 Collation 정렬·비교 규칙과 인코딩 차이</title>
      <link>https://blog.jsontapose.com/posts/database-collation-and-character-set-320bf2/</link>
      <pubDate>Thu, 08 Jan 2026 13:15:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/database-collation-and-character-set-320bf2/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Collation은 문자열 정렬과 비교 규칙 정의
테이블에 저장되는 바이트 표현은 인코딩(character set)으로 결정되며, 정렬과 비교 결과는 Collation으로 결정됨
둘은 목적과 적용 지점이 다름&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;Character set은 문자 ↔ 바이트 매핑
Collation은 특정 문자 집합 위에서 정렬 순서와 동일성 판단 규칙 정의
대소문자 민감도(cs), 대소문자 비민감도(ci), 악센트 민감도(as), 악센트 비민감도(ai) 같은 속성으로 비교 엄격도 제어
언어별 규칙 존재하며 같은 인코딩이라도 Collation에 따라 결과 달라짐&lt;/p&gt;
&lt;h3 id=&#34;동작-원리와-적용-범위&#34;&gt;동작 원리와 적용 범위&lt;/h3&gt;
&lt;p&gt;적용 레벨 계층 구조: 서버 기본값 → 데이터베이스 → 테이블 → 컬럼 → 표현식 단위 오버라이드 가능
영향 받는 연산: ORDER BY, GROUP BY, DISTINCT, LIKE, = 등 문자열 비교 연산 전반
인덱스는 해당 컬럼의 Collation 기준으로 구성되며 정렬 규칙이 범위 검색과 정렬 최적화에 직접 영향
다국어 환경에선 ICU 기반 Collation이나 언어 특화 Collation 선택 필요&lt;/p&gt;</description>
    </item>
    <item>
      <title>ERC-1155 vs ERC-721: 멀티 토큰 표준과 단일 NFT 표준의 차이와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/erc-1155-vs-erc-721-multi-token-standard-vs-single-nft-03f5a7/</link>
      <pubDate>Wed, 07 Jan 2026 13:14:32 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/erc-1155-vs-erc-721-multi-token-standard-vs-single-nft-03f5a7/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;ERC-1155는 게임 아이템처럼 대량의 토큰을 효율적으로 관리하기 위해 등장한 멀티 토큰 표준으로, ERC-721의 전송·배포 측면 비효율을 줄이려는 목적을 가짐&lt;/p&gt;
&lt;p&gt;편의점 비유로 직관화 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ERC-721 개별 포장 모델, 물건 10개 결제에 결제 10번·영수증 10장&lt;/li&gt;
&lt;li&gt;ERC-1155 장바구니 모델, 물건 10개를 한 번에 결제·영수증 1장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ERC-721 단일 NFT 표준, 토큰 ID 하나가 유일한 자산을 대표&lt;/li&gt;
&lt;li&gt;ERC-1155 멀티 토큰 표준, 하나의 컨트랙트에서 다수의 ID 발행과 각 ID별 수량 관리&lt;/li&gt;
&lt;li&gt;동일 ID에 수량이 붙는 구조로 FT·NFT·SFT를 한 컨트랙트에서 혼합 가능&lt;/li&gt;
&lt;li&gt;세미 펀지블 SFT, 같은 ID를 공유하는 동일 품질의 여러 개 토큰을 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작과-구조&#34;&gt;동작과 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 컨트랙트에 다수의 tokenId와 balance 맵핑 보유&lt;/li&gt;
&lt;li&gt;전송 함수 &lt;code&gt;safeTransferFrom&lt;/code&gt; 단건, &lt;code&gt;safeBatchTransferFrom&lt;/code&gt; 묶음 전송 지원&lt;/li&gt;
&lt;li&gt;이벤트는 &lt;code&gt;TransferSingle&lt;/code&gt;과 &lt;code&gt;TransferBatch&lt;/code&gt;로 발행, 동일 ID 다건 이동에 최적화&lt;/li&gt;
&lt;li&gt;메타데이터는 ID 기반 템플릿 URI 방식 활용이 일반적 &lt;code&gt;{id}&lt;/code&gt; 플레이스홀더 패턴 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점-비교&#34;&gt;장점 비교&lt;/h3&gt;
&lt;p&gt;A. 가스비 및 처리량 개선&lt;/p&gt;</description>
    </item>
    <item>
      <title>TID 전파 베스트 프랙티스: HTTP 헤더와 메시지 큐 Payload 기준</title>
      <link>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</link>
      <pubDate>Tue, 06 Jan 2026 13:13:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스와 비동기 작업이 섞인 환경에서 요청의 전 흐름을 좇기 위한 상관 식별자 필요
일반적으로 trace id를 tid로 표기해 서비스 경계를 넘나들며 전파함
HTTP 같은 동기 호출과 메시지 큐 같은 비동기 처리의 전파 매체가 다르므로 매체별 규칙을 명확히 두는 것이 핵심
산업 표준은 W3C Trace Context와 OpenTelemetry가 사실상 기본값
프로세스 내부 전파에는 비동기 컨텍스트 저장소 사용 권장&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TID(trace id)와 span id 구분, tid는 전체 요청 상관을 위한 루트 식별자 역할&lt;/li&gt;
&lt;li&gt;W3C Trace Context의 traceparent와 tracestate 헤더로 표준 전파&lt;/li&gt;
&lt;li&gt;OpenTelemetry는 위 표준을 구현하고 언어별 SDK 제공&lt;/li&gt;
&lt;li&gt;프로세스 내 컨텍스트 전파는 AsyncLocalStorage 등 런타임 컨텍스트로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-패턴&#34;&gt;표준 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 및 gRPC 같은 동기 네트워크 통신은 헤더 사용이 기본 원칙&lt;/li&gt;
&lt;li&gt;메시지 큐나 비동기 작업은 메시지 Body 또는 시스템이 제공하는 메시지 속성 사용&lt;/li&gt;
&lt;li&gt;지원되는 경우 메시지 헤더를 우선 사용, 없으면 Payload에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요약&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL 인덱스와 디스크 I/O 이해로 시작하는 쿼리 튜닝 기본</title>
      <link>https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/</link>
      <pubDate>Mon, 05 Jan 2026 13:15:15 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-index-io-basics-query-tuning-1-0f2ad2/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;인덱스는 데이터베이스 성능 최적화의 출발점임을 부정하기 어려움
MySQL은 스토리지 엔진에 따라 인덱싱과 검색 방식이 달라질 수 있어 기본 개념을 정확히 이해하는 것이 쿼리 튜닝의 기반이 됨
또한 디스크 접근 특성인 랜덤 I/O와 순차 I/O의 차이는 실무 성능에 직접적인 영향을 주므로 반드시 짚고 가야 함&lt;/p&gt;
&lt;h3 id=&#34;디스크-io가-성능을-좌우하는-이유&#34;&gt;디스크 I/O가 성능을 좌우하는 이유&lt;/h3&gt;
&lt;p&gt;CPU와 메모리 성능은 가파르게 개선됐지만 디스크 장치는 물리적 한계로 개선 속도가 상대적으로 느림
DB 성능 튜닝의 많은 부분이 디스크 I/O를 얼마나 줄이느냐로 귀결됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>유한 상태 머신(FSM) 기본 개념과 적용 포인트</title>
      <link>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</link>
      <pubDate>Sun, 04 Jan 2026 13:10:43 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</guid>
      <description>&lt;p&gt;유한 상태 머신(FSM, Finite State Machine)은 시스템이 가질 수 있는 상태와 그 사이 전이를 명확히 정의하는 모델
복잡한 비즈니스 로직을 단순화하고 예측 가능하게 만들어 결제나 주문처럼 순서와 무결성이 중요한 도메인에 적합&lt;/p&gt;
&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;상태와 규칙을 명시적으로 모델링해 허용되지 않은 동작을 구조적으로 차단하는 접근
요구사항이 늘어도 상태 전이 규칙을 중심으로 변경 범위를 제한해 안정성 확보에 유리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 State
시스템이 존재할 수 있는 유한한 조건 집합
예 로그인 전, 로그인 후, 결제 대기, 결제 완료&lt;/li&gt;
&lt;li&gt;이벤트 또는 입력 Event/Input
상태 변화를 유발하는 외부 행위나 신호
예 버튼 클릭, 네트워크 끊김, 시간 초과&lt;/li&gt;
&lt;li&gt;전이 또는 규칙 Transition/Rule
어떤 상태에서 어떤 이벤트가 발생하면 다음 상태로 이동한다는 정의
규칙에 없는 전이는 거부 또는 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 상태와 입력을 받아 다음 상태를 결정하는 전이 함수 관점으로 해석 가능 f(state, event) -&amp;gt; nextState 형태&lt;/li&gt;
&lt;li&gt;전이에는 가드 조건과 부수효과가 수반될 수 있음
가드는 전이 허용 여부 판단, 부수효과는 알림 전송이나 로그 기록 등 외부 행동을 명시적으로 수행&lt;/li&gt;
&lt;li&gt;정의되지 않은 전이를 막아 비정상 흐름 차단
재진입이나 중복 이벤트 처리 시에도 일관된 행동을 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시-자판기-모델&#34;&gt;예시 자판기 모델&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 대기 중, 이벤트 동전 투입 -&amp;gt; 다음 상태 금액 충족
돈이 들어와야만 다음 상태로 이동&lt;/li&gt;
&lt;li&gt;상태 금액 충족, 이벤트 상품 버튼 누름 -&amp;gt; 다음 상태 상품 배출 중
상품 선택 가능&lt;/li&gt;
&lt;li&gt;상태 상품 배출 중, 이벤트 배출 완료 -&amp;gt; 다음 상태 대기 중
초기 상태로 복귀&lt;/li&gt;
&lt;li&gt;상태 대기 중, 이벤트 상품 버튼 누름 -&amp;gt; 상태 변화 없음
금액 미충족 시 입력 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점과-효과&#34;&gt;장점과 효과&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정합성 보장
정의된 전이 외 동작 불가하므로 데이터 꼬임 예방
결제가 완료 상태에서 결제 요청 이벤트가 다시 들어오면 규칙에 없는 전이로 처리되어 거부 또는 무시되어 중복 결제 차단에 기여 멱등 처리 전략과 결합 시 효과적&lt;/li&gt;
&lt;li&gt;예측 가능성 향상
몇 개의 상태와 전이 규칙으로 복잡도를 축소해 로직 이해와 디버깅 용이&lt;/li&gt;
&lt;li&gt;테스트 용이성
상태 x 이벤트 조합별로 기대 결과가 명확해 단위 테스트 케이스 설계가 단순&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-베스트-프랙티스&#34;&gt;주의와 베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 폭발 주의
의미 있는 상태만 유지하고 파생 속성은 별도 데이터로 관리&lt;/li&gt;
&lt;li&gt;전이 정의의 단일 소스 유지
가드와 부수효과를 전이 정의 근처에 모아 산재된 분기 로직을 제거&lt;/li&gt;
&lt;li&gt;잘못된 전이 로깅과 모니터링 활성화
무시된 입력을 계측해 모델 누락이나 외부 시스템 이상 조기 탐지&lt;/li&gt;
&lt;li&gt;멱등성 고려
중복 이벤트 재수신 가능 환경에서는 전이와 부수효과를 멱등하게 설계&lt;/li&gt;
&lt;li&gt;분산 환경에서는 상태 영속화와 재시도 정책을 명시
크래시 후 재기동 시 일관성 있는 상태 복원 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;FSM은 상태와 전이를 중심으로 시스템 동작을 제한하고 드러내며, 규칙 밖 동작을 원천 차단해 안정성을 끌어올림
결제나 주문 같은 순서 기반 도메인에 특히 유용하며, 상태 정의와 전이 규칙만 명확히 유지하면 변경에도 견고하게 대응 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>분산 추적 표준 패턴 정리: HTTP 헤더와 메시지 페이로드, OpenTelemetry와 W3C Trace Context</title>
      <link>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</link>
      <pubDate>Sat, 03 Jan 2026 13:10:13 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;분산 추적 컨텍스트를 어디에 어떻게 실어 나를지에 대한 표준 패턴 정리. HTTP 같은 동기식 통신과 메시지 큐 같은 비동기식 통신은 전달 수단이 다름. 업계 표준은 W3C Trace Context와 이를 구현한 OpenTelemetry를 따르는 흐름임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;trace-id, span-id, sampling 플래그 등 추적 컨텍스트 전달 필요&lt;/li&gt;
&lt;li&gt;동기식 요청/응답 채널은 헤더 기반 메타데이터 전달이 자연스러움&lt;/li&gt;
&lt;li&gt;비동기 메시징은 메시지 자체가 전달 단위이므로 페이로드 또는 메시지 속성 이용&lt;/li&gt;
&lt;li&gt;채널이 헤더 개념을 지원하면 헤더 우선, 없으면 페이로드에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;통신별-패턴&#34;&gt;통신별 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/REST 통신: 요청/응답 헤더에 trace 컨텍스트 실어 전달&lt;/li&gt;
&lt;li&gt;gRPC: 메타데이터(헤더 개념)로 전달&lt;/li&gt;
&lt;li&gt;Kafka: 메시지 헤더 지원. 가능하면 헤더 사용 권장&lt;/li&gt;
&lt;li&gt;RabbitMQ: 메시지 프로퍼티의 headers 사용 가능&lt;/li&gt;
&lt;li&gt;AWS SQS: Message Attributes 사용 가능. 미지원 시 Body에 포함&lt;/li&gt;
&lt;li&gt;BullMQ/Redis 기반 잡 큐: 헤더 개념 없음. Job data에 포함&lt;/li&gt;
&lt;li&gt;WebSocket: 초기 핸드셰이크 단계에서 허용된 메타데이터 채널 또는 쿼리로 전달, 이후 각 메시지 페이로드에 포함. 환경 제약으로 커스텀 헤더 불가한 경우 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;산업-표준&#34;&gt;산업 표준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry는 W3C Trace Context를 구현하는 업계 표준 스택&lt;/li&gt;
&lt;li&gt;HTTP는 W3C traceparent, tracestate 헤더 사용&lt;/li&gt;
&lt;li&gt;비동기 메시징은 채널이 헤더를 지원하면 헤더 사용, 아니면 데이터에 포함하는 전략 일반화&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Source of Truth(SSOT)의 의미와 적용 예시</title>
      <link>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</link>
      <pubDate>Fri, 02 Jan 2026 13:11:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함
핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함
원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 불일치 발생 위험 증가
&lt;ul&gt;
&lt;li&gt;위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유지보수 비용 급증
&lt;ul&gt;
&lt;li&gt;수정 시 흩어진 모든 복제본을 찾아 변경해야 함&lt;/li&gt;
&lt;li&gt;일부 누락 시 버그와 장애로 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 전파가 느림
&lt;ul&gt;
&lt;li&gt;캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실생활-비유&#34;&gt;실생활 비유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재
은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음&lt;/li&gt;
&lt;li&gt;스마트폰 연락처가 전화번호의 원본 역할을 수행
연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발-적용-예시&#34;&gt;개발 적용 예시&lt;/h3&gt;
&lt;h4 id=&#34;프론트엔드-상태-관리&#34;&gt;프론트엔드 상태 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리&lt;/li&gt;
&lt;li&gt;부모 변경이 자식에 반영되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;상위 컴포넌트 또는 중앙 스토어에만 userData 보관&lt;/li&gt;
&lt;li&gt;자식은 props나 selector로 읽기 전용 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터베이스-모델링&#34;&gt;데이터베이스 모델링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;회원 테이블에만 주소 저장&lt;/li&gt;
&lt;li&gt;주문 테이블은 회원 ID를 참조해 조인으로 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;타입-정의-공유typescript&#34;&gt;타입 정의 공유(TypeScript)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스와-주의&#34;&gt;베스트 프랙티스와 주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 경로 단일화
&lt;ul&gt;
&lt;li&gt;원본에 대한 쓰기는 반드시 한 경로로만 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 복제본과 캐시 관리
&lt;ul&gt;
&lt;li&gt;캐시는 파생물로 취급&lt;/li&gt;
&lt;li&gt;만료 정책, 동기화 주기, 재검증 전략을 명시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;식별자 기반 참조 우선
&lt;ul&gt;
&lt;li&gt;파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양방향 복제와 수동 동기화 지양
&lt;ul&gt;
&lt;li&gt;충돌 해결 복잡도와 데이터 드리프트 위험 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마이그레이션 단계 관리
&lt;ul&gt;
&lt;li&gt;이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;p&gt;원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부
이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음
프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙</title>
      <link>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</link>
      <pubDate>Thu, 01 Jan 2026 13:12:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장&lt;/p&gt;
&lt;h3 id=&#34;시스템-설계의-정의와-접근&#34;&gt;시스템 설계의 정의와 접근&lt;/h3&gt;
&lt;p&gt;소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앱 서버&lt;/li&gt;
&lt;li&gt;데이터베이스&lt;/li&gt;
&lt;li&gt;캐시&lt;/li&gt;
&lt;li&gt;큐와 잡 러너&lt;/li&gt;
&lt;li&gt;이벤트 버스&lt;/li&gt;
&lt;li&gt;프록시와 게이트웨이&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;좋은 설계의 징후&lt;/p&gt;</description>
    </item>
    <item>
      <title>API 에러 응답 설계 가이드 — HTTP Status는 대분류, 비즈니스 의미는 바디</title>
      <link>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</link>
      <pubDate>Wed, 31 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;HTTP Status Code만으로는 서비스 로직의 원인을 전달하기 부족함
400대와 500대는 네트워크 관점의 대분류 신호에 가깝고 실제로 필요한 것은 비즈니스 맥락의 구체적 사유임
결론은 단순함
HTTP Status는 대분류 신호로 두고 실제 의미와 추가 컨텍스트는 Response Body에 싣는 구조가 현실적 해법임&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Status는 큰 범주 신호등 역할
&lt;ul&gt;
&lt;li&gt;2xx 성공&lt;/li&gt;
&lt;li&gt;4xx 클라이언트 오류&lt;/li&gt;
&lt;li&gt;5xx 서버 오류&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비즈니스 의미는 Response Body의 커스텀 에러 구조로 표현&lt;/li&gt;
&lt;li&gt;클라이언트가 코드 기반으로 분기하고 UI를 결정할 수 있어야 함&lt;/li&gt;
&lt;li&gt;운영 관측을 위해 traceId 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;업계에서-검증된-기본-구조&#34;&gt;업계에서 검증된 기본 구조&lt;/h3&gt;
&lt;p&gt;아래 형태가 가장 보편적으로 쓰이는 패턴임&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript 객체 구조 분해 할당으로 프로퍼티 이름 변경하기</title>
      <link>https://blog.jsontapose.com/posts/typescript-object-destructuring-rename-property-ba20ff/</link>
      <pubDate>Tue, 30 Dec 2025 13:13:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-object-destructuring-rename-property-ba20ff/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;객체 구조 분해 할당에서 프로퍼티 이름을 바꾸는 기본형은 { 기존프로퍼티명: 새변수명 } 형태임&lt;/p&gt;
&lt;h3 id=&#34;사용법예시&#34;&gt;사용법/예시&lt;/h3&gt;
&lt;p&gt;아래는 request 프로퍼티를 revealRequest라는 이름으로 받는 예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; request: &lt;span style=&#34;color:#81a1c1&#34;&gt;revealRequest&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; client&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;doSomething&lt;span style=&#34;color:#eceff4&#34;&gt;({...})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;의미는 다음과 같음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;doSomething이 반환하는 객체에서 request 프로퍼티 추출&lt;/li&gt;
&lt;li&gt;추출한 값을 revealRequest 변수에 바인딩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래 전개 코드와 동일함&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; result &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; client&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;doSomething&lt;span style=&#34;color:#eceff4&#34;&gt;({...})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; revealRequest &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; result&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;왜-쓰는가&#34;&gt;왜 쓰는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드 간결화&lt;/li&gt;
&lt;li&gt;필요한 프로퍼티만 선택 추출&lt;/li&gt;
&lt;li&gt;문맥에 맞게 변수명 명확화, 의도 드러남&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>트래픽을 일정 비율로 안전하게 나누는 방법: 해시 코호트와 구성 기반 롤아웃</title>
      <link>https://blog.jsontapose.com/posts/safe-traffic-splitting-with-hash-cohorts-and-config-rollout-f5b03f/</link>
      <pubDate>Mon, 29 Dec 2025 13:13:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/safe-traffic-splitting-with-hash-cohorts-and-config-rollout-f5b03f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;운영 중인 서비스에서 전체 트래픽을 한 번에 신규 기능이나 신규 인프라로 전환하지 않고, 일정 비율만 점진적으로 이동하는 전략이 필요함&lt;/p&gt;
&lt;p&gt;주요 활용 맥락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A/B 테스트로 실험군과 통제군 분리&lt;/li&gt;
&lt;li&gt;카나리 배포로 신규 버전을 소수 사용자에게만 적용&lt;/li&gt;
&lt;li&gt;신규 데이터베이스, 캐시, 인덱스 전환 검증&lt;/li&gt;
&lt;li&gt;신규 알고리즘, 추천 엔진, 정책 점진 적용&lt;/li&gt;
&lt;li&gt;서버 비용 최적화를 위한 점진적 트래픽 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 대부분의 시나리오에 적용 가능한 일반화된 트래픽 분배 기법 정리&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요구-조건&#34;&gt;요구 조건&lt;/h3&gt;
&lt;h4 id=&#34;deterministic--같은-사용자나-리소스는-항상-같은-그룹에-속해야-함&#34;&gt;Deterministic — 같은 사용자나 리소스는 항상 같은 그룹에 속해야 함&lt;/h4&gt;
&lt;p&gt;요청마다 그룹이 바뀌면 실험 신뢰성이 떨어지고 디버깅이 어려움
안정적 해시 기반 결정 방식 필요&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observer 패턴 제대로 이해하기 — 동작 원리와 RxJS 확장</title>
      <link>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</link>
      <pubDate>Sun, 28 Dec 2025 13:10:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름
발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름
핵심은 느슨한 결합과 자동 알림 흐름 유지&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-구성요소&#34;&gt;핵심 개념과 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Subject 또는 Observable
&lt;ul&gt;
&lt;li&gt;이벤트를 발생시키는 주체&lt;/li&gt;
&lt;li&gt;Observer 목록을 관리&lt;/li&gt;
&lt;li&gt;상태가 변하면 observers에 알림 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer
&lt;ul&gt;
&lt;li&gt;상태 변화를 알고 싶은 소비자&lt;/li&gt;
&lt;li&gt;update 같은 콜백 보유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;notify
&lt;ul&gt;
&lt;li&gt;Subject가 모든 Observer에게 브로드캐스트하는 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Observer가 Subject에 구독 등록&lt;/li&gt;
&lt;li&gt;Subject 상태 변화 발생&lt;/li&gt;
&lt;li&gt;Subject가 notify 실행, 등록된 Observer의 콜백 호출&lt;/li&gt;
&lt;li&gt;Observer는 전달된 값에 따라 자체 로직 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필수 인터페이스의 최소 형태는 아래와 같음&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object.entries 사용법과 주의사항</title>
      <link>https://blog.jsontapose.com/posts/object-entries-usage-and-notes-329c74/</link>
      <pubDate>Sat, 27 Dec 2025 13:09:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/object-entries-usage-and-notes-329c74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Object.entries는 객체의 키-값 쌍을 [key, value] 형태의 배열 리스트로 반환하는 표준 메서드임. 객체를 배열로 바꿔 순회, 변환, 자료구조 간 변환 같은 작업을 단순화하는 데 유용함&lt;/p&gt;
&lt;h3 id=&#34;문법&#34;&gt;문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;entries&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;obj&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;매개변수 obj: 키-값 쌍을 가진 객체 값&lt;/li&gt;
&lt;li&gt;반환값: [key, value] 쌍의 2차원 배열&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;기본-예시&#34;&gt;기본 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; user &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; age&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;25&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;entries&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// [[&amp;#39;name&amp;#39;, &amp;#39;Alice&amp;#39;], [&amp;#39;age&amp;#39;, 25]]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;배열로 변환되므로 for&amp;hellip;of, map 같은 배열 API에 바로 연결 가능&lt;/p&gt;
&lt;h3 id=&#34;순회와-변환&#34;&gt;순회와 변환&lt;/h3&gt;
&lt;p&gt;for&amp;hellip;of로 키와 값을 동시에 순회 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴</title>
      <link>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</link>
      <pubDate>Fri, 26 Dec 2025 13:12:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함
직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함&lt;/p&gt;
&lt;h3 id=&#34;왜-중요한가&#34;&gt;왜 중요한가&lt;/h3&gt;
&lt;p&gt;처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자 1000 req/s, 소비자 100 req/s 가정&lt;/li&gt;
&lt;li&gt;매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험&lt;/li&gt;
&lt;li&gt;큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능
백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Producer: 데이터를 생성·전송하는 주체&lt;/li&gt;
&lt;li&gt;Consumer: 데이터를 수신·처리하는 주체&lt;/li&gt;
&lt;li&gt;Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위&lt;/li&gt;
&lt;li&gt;전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리전략&#34;&gt;동작 원리/전략&lt;/h3&gt;
&lt;p&gt;A. 조절 Control/Throttling&lt;/p&gt;</description>
    </item>
    <item>
      <title>API ErrorCode Enum 설계 베스트 프랙티스</title>
      <link>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</link>
      <pubDate>Thu, 25 Dec 2025 13:11:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API 에러 규격의 핵심은 에러를 안정적으로 식별할 수 있는 Code 체계 확보임
HTTP Status만으로는 부족하고 메시지는 언어·맥락에 따라 바뀔 수 있음
실제로 계약으로서 신뢰할 수 있는 값은 error.code 임
아래는 다수의 글로벌 서비스에서 공통적으로 쓰는 Error Code 설계 원칙 정리&lt;/p&gt;
&lt;h3 id=&#34;설계-원칙&#34;&gt;설계 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;error.code 는 서비스 전반의 안정적인 식별자여야 함&lt;/li&gt;
&lt;li&gt;메시지나 HTTP Status는 변경 가능하지만 error.code 는 변경 불가&lt;/li&gt;
&lt;li&gt;구버전 클라이언트도 동일 코드를 신뢰해야 하므로 호환성 보장 필수&lt;/li&gt;
&lt;li&gt;숫자형 대신 의미가 드러나는 문자열 기반 Enum 권장
&lt;ul&gt;
&lt;li&gt;숫자형은 의미 파악 어려움, 매뉴얼 의존, 협업 비용 증가&lt;/li&gt;
&lt;li&gt;문자열 Enum은 가독성, 검색성, 커뮤니케이션 효율 우수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes 스케줄링 제어를 위한 Taints와 Tolerations 개념과 사용법</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-taints-tolerations-c1d4eb/</link>
      <pubDate>Wed, 24 Dec 2025 13:11:44 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-taints-tolerations-c1d4eb/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Kubernetes에서 Taints는 노드에 거는 출입 제한 설정이고 Tolerations는 파드가 가진 출입 허용 키에 해당함
이 조합으로 스케줄러가 특정 파드를 특정 노드에서 배제하거나 허용하도록 제어 가능
비용이 높은 노드 보호, 장애 노드 격리, 점검 중 노드 비우기 같은 운영 시나리오에서 효과적임&lt;/p&gt;
&lt;h3 id=&#34;비유로-이해하기&#34;&gt;비유로 이해하기&lt;/h3&gt;
&lt;p&gt;노드가 VIP 라운지, Taint는 라운지 입구의 안내 표지, 파드는 손님, Toleration은 출입증에 해당함
Taint가 있는 노드에는 아무 파드나 배치되지 않음
해당 Taint를 허용하는 Toleration을 가진 파드만 스케줄링 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>자바스크립트에서 균등한 배열 셔플 구현 피셔‑예이츠와 sort&#43;random 편향 이슈</title>
      <link>https://blog.jsontapose.com/posts/javascript-fisher-yates-shuffle-and-sort-random-bias-96c3c0/</link>
      <pubDate>Tue, 23 Dec 2025 13:13:24 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-fisher-yates-shuffle-and-sort-random-bias-96c3c0/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;배열을 무작위로 섞을 때 Array.prototype.sort와 Math.random을 조합한 패턴이 흔히 보임&lt;/p&gt;
&lt;p&gt;array.sort(() =&amp;gt; Math.random() - 0.5) 형태는 간단해 보이지만 결과 분포가 한쪽으로 치우치는 편향이 발생함&lt;/p&gt;
&lt;p&gt;간단한 실험으로 [1, 2, 3]을 백만 회 섞어 빈도를 집계해 보면 특정 순열이 과도하게 많이 나오거나 적게 나오는 경향 관찰됨&lt;/p&gt;
&lt;p&gt;핵심은 Math.random 자체보다 sort에 전달된 비교 함수가 랜덤하게 일관성 없이 값을 내놓는 구조라는 점임&lt;/p&gt;
&lt;h3 id=&#34;왜-sort--random이-편향되는가&#34;&gt;왜 sort + random이 편향되는가&lt;/h3&gt;
&lt;p&gt;정렬 알고리즘은 비교 함수가 다음 성질을 만족한다고 가정함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes 아키텍처와 핵심 컴포넌트 정리</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/</link>
      <pubDate>Mon, 22 Dec 2025 13:12:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;쿠버네티스는 명령을 조율하는 Control Plane과 실제 워크로드가 실행되는 Data Plane으로 구성됨
각 컴포넌트의 역할과 흐름을 이해하면 트러블슈팅, 성능 최적화, 보안 구성에 필요한 기준이 생김
클라우드 매니지드 쿠버네티스의 경우 Control Plane은 보통 제공자가 관리하지만 동작 원리 이해는 필수&lt;/p&gt;
&lt;h3 id=&#34;control-plane&#34;&gt;Control Plane&lt;/h3&gt;
&lt;p&gt;API Server&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클러스터 유일 진입점&lt;/li&gt;
&lt;li&gt;모든 컴포넌트와 사용자는 API Server를 통해 통신&lt;/li&gt;
&lt;li&gt;인증과 권한 확인 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;etcd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클러스터 상태와 스펙을 보관하는 분산 키밸류 저장소&lt;/li&gt;
&lt;li&gt;API Server만 직접 접근 가능&lt;/li&gt;
&lt;li&gt;상태 복구의 근간이 되는 데이터 원장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scheduler&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유</title>
      <link>https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/</link>
      <pubDate>Sun, 21 Dec 2025 13:09:33 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님
키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함
중복 없는 집합 연산에는 Set이 자연스러운 선택지&lt;/p&gt;
&lt;h3 id=&#34;언제-객체-대신-map을-고려할까&#34;&gt;언제 객체 대신 Map을 고려할까&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;키를 자주 추가·삭제하는 동적 해시맵 패턴&lt;/li&gt;
&lt;li&gt;안전한 반복과 구조 분해가 필요한 경우&lt;/li&gt;
&lt;li&gt;키의 삽입 순서 유지가 중요한 경우&lt;/li&gt;
&lt;li&gt;비문자열 키가 필요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; mapOfThingsObj &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThingsObj&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; thing&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; mapOfThingsObj&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// Map은 동적 추가·삭제에 최적화
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; mapOfThings &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; Map&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThings&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; thing&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThings&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;성능-배경&#34;&gt;성능 배경&lt;/h3&gt;
&lt;p&gt;객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재
Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨
마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>EIP-712 기반 signTypedData 가이드와 지갑 연동 핵심</title>
      <link>https://blog.jsontapose.com/posts/eip-712-signtypeddata-guide-29efde/</link>
      <pubDate>Sat, 20 Dec 2025 13:08:51 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/eip-712-signtypeddata-guide-29efde/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;signTypedData는 EIP-712 표준을 구현한 서명 메서드로 구조화된 데이터에 서명하기 위한 표준 인터페이스를 제공함
지갑은 사람이 읽을 수 있는 형태로 서명 내용을 표시하고, 서명은 특정 도메인과 체인에 귀속되어 재사용 공격을 줄임&lt;/p&gt;
&lt;h3 id=&#34;signtypeddata와-eip-712의-관계&#34;&gt;signTypedData와 EIP-712의 관계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정의
&lt;ul&gt;
&lt;li&gt;signTypedData는 EIP-712 규격을 따르는 구조화 데이터 서명 메서드&lt;/li&gt;
&lt;li&gt;이더리움 지갑 및 제공자에서 eth_signTypedData, eth_signTypedData_v3, eth_signTypedData_v4 형태로 노출&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;버전
&lt;ul&gt;
&lt;li&gt;signTypedData 최초 버전&lt;/li&gt;
&lt;li&gt;signTypedData_v3&lt;/li&gt;
&lt;li&gt;signTypedData_v4 가장 널리 사용되는 최신 버전&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;라이브러리 사용
&lt;ul&gt;
&lt;li&gt;ethers에서는 _signTypedData로 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; signature &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; signer&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;_signTypedData&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;domain&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; types&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; value&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;지갑 연동은 일반적으로 provider에 직접 요청하는 방식 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; signature &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; ethereum&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  method&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;eth_signTypedData_v4&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  params&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;account&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; JSON&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;stringify&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; domain&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; types&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; message&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;})],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;동작-원리-요약&#34;&gt;동작 원리 요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타입화된 구조체 정의
&lt;ul&gt;
&lt;li&gt;예시 구조체와 필드 타입을 정형화해 명세&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;도메인 분리자 사용
&lt;ul&gt;
&lt;li&gt;이름, 버전, 체인 ID, 검증 컨트랙트 주소를 포함해 서명 범위 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;타입 해시와 데이터 해시 생성
&lt;ul&gt;
&lt;li&gt;타입 정의를 keccak256으로 해싱 후 데이터 인코딩 해시 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;최종 해시에 서명 및 검증
&lt;ul&gt;
&lt;li&gt;지갑에서 서명 생성, 컨트랙트에서 도메인과 타입을 동일하게 재현해 검증&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;간단한 도메인, 타입, 메시지 구성 예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; domain &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;MyApp&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; version&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; chainId&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; verifyingContract &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; types &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; Action&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; type&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;address&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;amount&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; type&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;uint256&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; value &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; user&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; userAddress&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; amount &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// ethers 서명
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; sig &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; signer&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;_signTypedData&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;domain&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; types&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; value&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 지갑 요청 v4 서명
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; sig2 &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; ethereum&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;request&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  method&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;eth_signTypedData_v4&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  params&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;account&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; JSON&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;stringify&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; domain&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; types&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; message&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;})],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;컨트랙트 검증 예시 요약&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-solidity&#34; data-lang=&#34;solidity&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// OpenZeppelin EIP712, ECDSA 사용 가정
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;bytes32&lt;/span&gt; digest &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; _hashTypedDataV4&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1&#34;&gt;keccak256&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;abi&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;encode&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;keccak256&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Action(address user,uint256 amount)&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;require&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;ECDSA&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;recover&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;digest&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; signature&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;==&lt;/span&gt; signer&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Invalid signature&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;eip-712-핵심-개념-정리&#34;&gt;EIP-712 핵심 개념 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;목적
&lt;ul&gt;
&lt;li&gt;사람이 읽을 수 있는 서명 메시지 제공&lt;/li&gt;
&lt;li&gt;도메인에 귀속된 서명으로 리플레이 공격 저감&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;구조
&lt;ul&gt;
&lt;li&gt;타입화된 데이터 스키마와 도메인 분리자&lt;/li&gt;
&lt;li&gt;타입 해시와 데이터 해시를 조합한 최종 해시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;지갑 UI에서 의미 있는 정보 노출로 UX 개선&lt;/li&gt;
&lt;li&gt;다른 dApp이나 체인에서 재사용 어려움으로 보안 강화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의사항과-팁&#34;&gt;주의사항과 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v4 사용 권장
&lt;ul&gt;
&lt;li&gt;v4는 가장 널리 지원되고 구조체 및 배열 표현이 안정적임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;provider 요청 방식
&lt;ul&gt;
&lt;li&gt;web3 라이브러리 함수보다 ethereum.request의 eth_signTypedData_v4 사용이 호환성 측면에서 안전함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;타입 정의 일치
&lt;ul&gt;
&lt;li&gt;컨트랙트와 클라이언트의 타입 이름, 필드 순서, 정수 크기 등 완전 일치 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;도메인 정합성
&lt;ul&gt;
&lt;li&gt;chainId와 verifyingContract가 실제 네트워크와 배포 주소와 일치해야 검증 성공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 인코딩
&lt;ul&gt;
&lt;li&gt;JS 측 정수값은 문자열 또는 BigNumber 형태 사용 권장, 오버플로와 반올림 이슈 회피&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ethers 사용 시
&lt;ul&gt;
&lt;li&gt;types에 EIP712Domain을 포함하지 않음, _signTypedData가 도메인을 별도로 처리함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;v4 메시지 포맷
&lt;ul&gt;
&lt;li&gt;params에 JSON.stringify로 { domain, types, message } 형태 전달 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;signTypedData는 곧 EIP-712 사용을 의미하며 구조화된 데이터에 대한 안전한 서명을 가능하게 함
ethers의 _signTypedData 또는 지갑의 eth_signTypedData_v4를 사용해 서명하고, 컨트랙트에서는 동일한 도메인과 타입으로 해시를 재현해 검증하면 됨
명세 일치와 도메인 정합성만 확보하면 안전하고 예측 가능한 서명 흐름을 구현 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS 핵심 개념과 11.x 변화 정리 — 구조, DI, 데코레이터, 성능 업데이트</title>
      <link>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</link>
      <pubDate>Fri, 19 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS는 대규모 서버 애플리케이션을 위한 구조화된 Node.js 프레임워크임
핵심은 Angular 스타일의 아키텍처, 강력한 의존성 주입 컨테이너, 데코레이터 기반 메타프로그래밍 조합
팀 규모가 커질수록 일관성과 유지보수성이 살아나는 타입스크립트 퍼스트 선택지임&lt;/p&gt;
&lt;h3 id=&#34;구조적-강제의-이점&#34;&gt;구조적 강제의 이점&lt;/h3&gt;
&lt;p&gt;Nest는 모듈 Module, 컨트롤러 Controller, 서비스 Service 구조를 강제함
계층 분리 패턴 BLL, DAL, 도메인 레이어 등 적용 용이
아키텍처가 일관되게 유지되어 4~10명 규모 팀에서 코드 스타일과 책임 경계가 흐트러지지 않음&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fastify, Express 같은 미니멀 프레임워크 대비 생산성과 일관성 측면에서 팀 단위 효율 우위&lt;/p&gt;</description>
    </item>
    <item>
      <title>개발자 커리어에서 마주치는 임포스터와 우월감 증후군 정리</title>
      <link>https://blog.jsontapose.com/posts/imposter-and-superiority-syndrome-in-developer-careers-81a0d5/</link>
      <pubDate>Thu, 18 Dec 2025 13:13:27 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/imposter-and-superiority-syndrome-in-developer-careers-81a0d5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;개발 현장은 기술 변화가 빠르고 학습 범위가 넓음
이 환경에서 임포스터 증후군과 우월감 증후군은 자주 관찰되는 심리 상태이며, 같은 사람이 커리어 단계에 따라 두 상태를 오가기도 함
핵심 개념과 개발자 맥락에서의 징후, 발생 배경, 성장 곡선 상의 위치, 건강한 마인드셋을 정리함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;임포스터 증후군&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스스로 실력을 과소평가하고 운이나 타인의 공 덕분에 현재 위치에 있다고 여기는 불안 심리&lt;/li&gt;
&lt;li&gt;들킬 것 같은 두려움이 동반됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;개발자 맥락에서 보이는 징후&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글링 의존을 부끄러워하며 자신을 가짜 개발자로 규정함&lt;/li&gt;
&lt;li&gt;성과를 팀 운이나 외부 요인으로만 해석함&lt;/li&gt;
&lt;li&gt;질문을 회피하고 비난을 두려워해 홀로 고립됨&lt;/li&gt;
&lt;li&gt;더 알수록 모르는 영역이 보이며 시니어가 되어도 불안 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우월감 증후군&lt;/p&gt;</description>
    </item>
    <item>
      <title>date-fns로 자바스크립트 날짜·시간 처리 23가지 실전 패턴</title>
      <link>https://blog.jsontapose.com/posts/date-fns-javascript-date-time-23-patterns-d70145/</link>
      <pubDate>Wed, 17 Dec 2025 13:13:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/date-fns-javascript-date-time-23-patterns-d70145/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 날짜·시간을 다루는 일은 사소해 보이지만 버그가 가장 잦은 영역 중 하나임
day.js, moment.js, luxon 등 대안 존재하나 date-fns는 모듈화, 작은 크기, 불변성 중심 설계로 프런트엔드와 백엔드 모두에 적합함
아래는 date-fns와 date-fns-tz를 활용해 바로 써먹을 수 있는 23가지 패턴 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Date 객체는 타임존이 아닌 UTC 타임스탬프를 보유하는 값이라는 점이 핵심&lt;/li&gt;
&lt;li&gt;date-fns 함수는 대부분 불변 동작, 인자로 받은 Date를 변경하지 않음&lt;/li&gt;
&lt;li&gt;포맷팅은 format, 상대 표기는 formatDistance 계열, 구간 계산은 differenceIn*, intervalToDuration 등 사용&lt;/li&gt;
&lt;li&gt;파싱은 parseISO 또는 parse로 명시적 포맷 지정 권장&lt;/li&gt;
&lt;li&gt;타임존 변환은 date-fns-tz의 utcToZonedTime, zonedTimeToUtc, formatInTimeZone 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실전-패턴&#34;&gt;실전 패턴&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;현재 날짜와 시간 가져오기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; now &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;특정 날짜·시간 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; setMinutes&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; setHours &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; specific &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; setHours&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;setMinutes&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;17&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 17:30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;날짜 포맷팅&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; format &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; ymd &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; format&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;yyyy-MM-dd&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;기간 더하기·빼기&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; addDays&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; subMonths &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; inAWeek &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; addDays&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; aMonthAgo &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; subMonths&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;특정 요일까지 남은 일수&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; nextDay&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; differenceInDays &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; nextMon &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; nextDay&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 0 일요일, 1 월요일
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; d &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; differenceInDays&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;nextMon&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;())&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;두 날짜 차이 계산&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; differenceInDays &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; diff &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; differenceInDays&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;31&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;동일한 날짜 비교&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; isSameDay &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; same &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; isSameDay&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2023&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;2023-01-01T05:00:00Z&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;윤년 확인&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; isLeapYear &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; isLeap &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; isLeapYear&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2024&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;날짜 유효성 검사&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; isValid &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; ok &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; isValid&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;2023-02-30&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;로컬과 특정 타임존 간 변환&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; utcToZonedTime&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; zonedTimeToUtc&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; formatInTimeZone &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns-tz&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; tz &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;America/New_York&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; utc &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; zonedTimeToUtc&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; tz&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; inNY &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; utcToZonedTime&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; tz&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; shown &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; formatInTimeZone&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(),&lt;/span&gt; tz&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;yyyy-MM-dd HH:mm:ssXXX&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;문자열 파싱&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; parseISO&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; parse &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; a &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; parseISO&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;2023-01-01&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; b &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; parse&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;01/02/2023 17:30&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;MM/dd/yyyy HH:mm&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;())&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;상대 시간 표현&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; formatDistanceToNow &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; ko &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns/locale&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; rel &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; formatDistanceToNow&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;now&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;60&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;60&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1000&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; addSuffix&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; locale&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; ko &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;과거·미래 판별&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; isPast&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; isFuture &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; from &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;date-fns&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; past &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; isPast&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;2023-01-01&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; future &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; isFuture&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;now&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;60_000&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;특정 기간의 날짜 배열 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;루프 대신 eachDayOfInterval 사용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 모듈 시스템 정리: CommonJS와 ESM의 차이, 선택 기준, 상호 운용</title>
      <link>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</link>
      <pubDate>Tue, 16 Dec 2025 13:14:04 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 CommonJS(CJS)와 ESM(ES Modules)은 공존 상태이며, 신규 프로젝트는 ESM으로 전환되는 추세임. 두 시스템의 차이를 이해하면 번들 크기, 로딩 성능, 정적 분석, 생태계 호환에서 불필요한 시행착오 감소 가능&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2009년 Node.js는 표준 모듈 시스템이 없던 시기라 CommonJS 채택&lt;/li&gt;
&lt;li&gt;2015년 ES6에서 ESM이 언어 차원의 공식 표준으로 확정&lt;/li&gt;
&lt;li&gt;2020년대 들어 Node.js가 ESM을 정식 지원, 브라우저와 규약 수렴 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commonjs-요약&#34;&gt;CommonJS 요약&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// export
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;module&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;exports &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exports&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;bar &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// import
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; bar &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; require&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;./utils&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;특성&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 가스 이해하기: Gas Limit, Gas Price, EIP-1559 정리</title>
      <link>https://blog.jsontapose.com/posts/ethereum-gas-gas-limit-gas-price-eip-1559-157947/</link>
      <pubDate>Mon, 15 Dec 2025 13:15:00 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-gas-gas-limit-gas-price-eip-1559-157947/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EVM 트랜잭션 수수료 모델은 자동차 연료 비유가 직관적임
Gas는 연료, 트랜잭션 수행은 목적지까지 주행이라는 맥락으로 이해하면 됨
핵심은 두 파라미터, Gas Limit와 Gas Price이며 EIP-1559 이후에는 Base Fee와 Priority Fee로 세분됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Gas Limit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 트랜잭션이 최대 얼마만큼의 연산을 사용할 수 있는지에 대한 상한&lt;/li&gt;
&lt;li&gt;단순 ETH 송금은 21,000 가스 고정값 수준&lt;/li&gt;
&lt;li&gt;컨트랙트 실행은 로직 복잡도, 저장소 접근, 반복 등에 비례해 증가&lt;/li&gt;
&lt;li&gt;사용하지 않은 가스는 환불, 부족하면 Out of Gas로 실패 후 사용한 가스 비용만큼 청구&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gas Price&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</link>
      <pubDate>Sun, 14 Dec 2025 13:09:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Primary Key 지정 시 클러스터드 인덱스 생성&lt;/li&gt;
&lt;li&gt;Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념-정리&#34;&gt;핵심 개념 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;클러스터드 인덱스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 데이터가 인덱스 키 순서로 정리되는 구조&lt;/li&gt;
&lt;li&gt;테이블당 하나만 존재&lt;/li&gt;
&lt;li&gt;리프 노드가 실제 레코드(전체 컬럼)를 보유&lt;/li&gt;
&lt;li&gt;InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨&lt;/li&gt;
&lt;li&gt;PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;논클러스터드 인덱스(보조 인덱스, Secondary Index)&lt;/p&gt;</description>
    </item>
    <item>
      <title>사이드카 패턴 이해와 도입 판단 가이드: 마이크로서비스·쿠버네티스에서의 활용</title>
      <link>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</link>
      <pubDate>Sat, 13 Dec 2025 13:09:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스로 분산이 심화되면 로깅, 모니터링, 보안, 네트워킹 같은 공통 기능을 어디에 둘지 결정이 어려워짐
애플리케이션 코드에 공통 기능을 계속 끼워 넣으면 침투와 중복 증가, 배포와 버전 관리 복잡도 상승
사이드카 패턴은 공통 기능을 별도 컨테이너로 분리해 메인 서비스는 비즈니스 로직에 집중하게 하는 접근법
컨테이너 오케스트레이션 환경에서 일관된 운영 모델을 제공한다는 점이 실무적 장점&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;사이드카 패턴의 구성 요소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메인 컨테이너: 비즈니스 로직 담당, 웹 서비스나 API 서버 등&lt;/li&gt;
&lt;li&gt;사이드카 컨테이너: 횡단 관심사 처리, 로그 수집, 모니터링 에이전트, 프록시, 보안 검사 등
같은 파드 내 배치로 네트워크 네임스페이스와 볼륨 공유 가능, 표준 출력/공유 볼륨 등을 통해 데이터 연계
업데이트와 배포를 컨테이너 단위로 분리해 독립적 버전 관리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;p&gt;하나의 파드에 메인 컨테이너와 사이드카 컨테이너를 함께 배치&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 글로벌 에러 핸들러 가이드</title>
      <link>https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/</link>
      <pubDate>Fri, 12 Dec 2025 13:13:05 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Node.js 프로세스 레벨에서 잡히지 않은 에러를 마지막으로 처리하는 안전망을 두는 목적 정리
애플리케이션 어디에서도 처리되지 못한 오류를 기록하고 종료 경로를 일관되게 관리하기 위함
프로덕션 환경에서 원인 파악과 사후 조치 자동화를 위한 최소 장치로 간주&lt;/p&gt;
&lt;h3 id=&#34;핵심-이벤트&#34;&gt;핵심 이벤트&lt;/h3&gt;
&lt;p&gt;두 가지 이벤트가 글로벌 핸들러의 대상&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uncaughtException
&lt;ul&gt;
&lt;li&gt;try-catch로 포착되지 않은 동기 오류가 호출 스택 끝까지 전파될 때 발생&lt;/li&gt;
&lt;li&gt;핸들러가 없으면 프로세스가 비정상 종료됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 동기 에러가 상위에서 잡히지 않은 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; boom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Error&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;폭발&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;boom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;unhandledRejection
&lt;ul&gt;
&lt;li&gt;Promise가 reject되었으나 await 혹은 .catch로 처리되지 않은 경우 발생&lt;/li&gt;
&lt;li&gt;Node.js 15+ 기본 동작은 핸들러가 없을 때 프로세스 종료&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// reject가 소비되지 않은 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; asyncBoom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Error&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;비동기 폭발&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;asyncBoom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;왜-글로벌-핸들러인가&#34;&gt;왜 글로벌 핸들러인가&lt;/h3&gt;
&lt;p&gt;코드 최상위에서 아무도 잡지 못한 에러에 대한 마지막 안전망 역할&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/</link>
      <pubDate>Thu, 11 Dec 2025 13:14:28 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행
Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침&lt;/p&gt;
&lt;h3 id=&#34;핵심-차이&#34;&gt;핵심 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행&lt;/li&gt;
&lt;li&gt;Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행&lt;/li&gt;
&lt;li&gt;본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nodejs-맥락&#34;&gt;Node.js 맥락&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Liveness Probe 대상 상황
&lt;ul&gt;
&lt;li&gt;이벤트 루프 블로킹으로 요청 처리 불가 상태&lt;/li&gt;
&lt;li&gt;무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능&lt;/li&gt;
&lt;li&gt;메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Readiness Probe 대상 상황
&lt;ul&gt;
&lt;li&gt;프로세스는 떠 있으나 초기화 작업 진행 중인 상태&lt;/li&gt;
&lt;li&gt;DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유의점
&lt;ul&gt;
&lt;li&gt;Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험&lt;/li&gt;
&lt;li&gt;Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-스니펫&#34;&gt;구현 스니펫&lt;/h3&gt;
&lt;p&gt;Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.flatMap 개념과 사용 예시</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-flatmap-22e1f3/</link>
      <pubDate>Wed, 10 Dec 2025 13:14:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-flatmap-22e1f3/</guid>
      <description>&lt;h3 id=&#34;개념&#34;&gt;개념&lt;/h3&gt;
&lt;p&gt;flatMap은 각 요소를 매핑한 결과를 한 단계만 평탄화하는 배열 메서드
arr.map(fn).flat(1)과 동등&lt;/p&gt;
&lt;h3 id=&#34;동작&#34;&gt;동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;콜백 시그니처 (value, index, array)&lt;/li&gt;
&lt;li&gt;콜백이 배열을 반환하면 concat 후 depth 1 평탄화&lt;/li&gt;
&lt;li&gt;더 깊은 중첩은 유지됨&lt;/li&gt;
&lt;li&gt;희소 배열의 빈 슬롯은 평탄화 과정에서 제거됨&lt;/li&gt;
&lt;li&gt;ES2019 이후 표준 지원 범위 넓음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; arr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;arr&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;flatMap&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;x &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;])&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// =&amp;gt; [2, 4, 6, 8]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;arr&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;flatMap&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[[&lt;/span&gt;x &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]])&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// =&amp;gt; [[2], [4], [6], [8]]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; s &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;it&amp;#39;s Sunny in&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;California&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;flatMap&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; x&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;split&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// =&amp;gt; [&amp;#34;it&amp;#39;s&amp;#34;,&amp;#34;Sunny&amp;#34;,&amp;#34;in&amp;#34;,&amp;#34;&amp;#34;,&amp;#34;California&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;깊이 2 이상 평탄화 필요 시 flat(depth) 사용 또는 map + flat 조합 고려&lt;/li&gt;
&lt;li&gt;콜백은 배열을 반환하는 패턴 권장, 스칼라를 섞으면 의도치 않은 구조 발생 가능&lt;/li&gt;
&lt;li&gt;희소 배열 처리 시 구멍이 사라지는 특성 주의&lt;/li&gt;
&lt;li&gt;성능상 불필요한 중첩 생성은 피하고 필요한 경우에만 flatMap 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>NestJS forRoot()의 동작 원리와 싱글톤에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</link>
      <pubDate>Sun, 07 Dec 2025 13:07:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS을 다루다 보면 &lt;code&gt;ConfigModule.forRoot()&lt;/code&gt;, &lt;code&gt;TypeOrmModule.forRoot()&lt;/code&gt; 같은 코드를 보게 됨
보통 &amp;ldquo;이건 전역 설정이니까 한 번만 하면 끝이고 알아서 싱글톤 유지되겠지?&amp;ldquo;라고 생각하기 쉬움&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;forRoot()&lt;/code&gt;를 호출한다고 프레임워크가 알아서 물리적인 싱글톤 인스턴스를 강제하는 건 아님
특히 &lt;code&gt;ScheduleModule&lt;/code&gt;처럼 사이드 이펙트(이벤트 리스너, 타이머 등)를 유발하는 모듈을 잘못 다루면, 기능이 중복 실행되는 심각한 버그가 터질 수 있음&lt;/p&gt;
&lt;p&gt;이 글에서는 &lt;code&gt;forRoot()&lt;/code&gt;의 진짜 의미와 내부 동작, 그리고 &lt;code&gt;ScheduleModule&lt;/code&gt; 중복 실행 문제가 왜 생기는지 코드로 뜯어보겠음&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;forroot란-무엇인가&#34;&gt;forRoot()란 무엇인가&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;forRoot()&lt;/code&gt;는 NestJS의 &lt;strong&gt;동적 모듈&lt;/strong&gt;(Dynamic Module)을 생성하기 위해 관례적으로 쓰는 메서드 이름임&lt;/p&gt;</description>
    </item>
    <item>
      <title>전략 패턴 (Strategy Pattern) - 유연한 코드 만들기</title>
      <link>https://blog.jsontapose.com/posts/strategy-pattern-with-typescript-mermaid-6618f4/</link>
      <pubDate>Sat, 06 Dec 2025 13:08:38 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/strategy-pattern-with-typescript-mermaid-6618f4/</guid>
      <description>&lt;h3 id=&#34;전략-패턴이란&#34;&gt;전략 패턴이란?&lt;/h3&gt;
&lt;p&gt;객체의 특정 행동(알고리즘)을 직접 구현하지 않고, &lt;strong&gt;외부에서 &amp;lsquo;전략&amp;rsquo;을 주입받아 갈아 끼우는 방식&lt;/strong&gt;임&lt;/p&gt;
&lt;p&gt;쉽게 말해 &amp;ldquo;본체는 그대로 두고, 부품만 바꿔서 기능을 바꾸는 것&amp;quot;이라 보면 됨&lt;/p&gt;
&lt;h3 id=&#34;전략-패턴이-적용되지-않은-코드&#34;&gt;전략 패턴이 적용되지 않은 코드&lt;/h3&gt;
&lt;p&gt;전략 패턴을 쓰지 않으면 보통 이렇게 구현하게 됨&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; Vehicle &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;constructor&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;road&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;rail&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  move() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;road&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;부릉부릉 도로로 감 🚌&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;rail&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;칙칙폭폭 선로로 감 🚂&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 방식이 가지는 문제는 다음과 같음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조건문이 계속 늘어남
새로운 이동 방식이 생길 때마다 move()를 수정해야 함
→ OCP(Open-Closed Principle) 위반&lt;/p&gt;</description>
    </item>
    <item>
      <title>VARCHAR(n) 길이 기준 정리 — 글자 수인가 바이트 수인가</title>
      <link>https://blog.jsontapose.com/posts/varchar-n-length-characters-vs-bytes-99b017/</link>
      <pubDate>Fri, 05 Dec 2025 13:11:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/varchar-n-length-characters-vs-bytes-99b017/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;VARCHAR(n)에서 n을 글자 수로 볼지 바이트 수로 볼지 혼동 많음
표준 SQL의 character varying(n)은 최대 글자 수 의미이나, 실제 구현은 DBMS와 문자셋 설정에 따라 달라짐
멀티바이트 문자셋에서는 저장 바이트 수와 글자 수가 다름. 길이 제한은 글자 수 기준일 수 있으나 내부 저장은 바이트 단위로 이뤄짐&lt;/p&gt;
&lt;h3 id=&#34;dbms별-동작&#34;&gt;DBMS별 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL
&lt;ul&gt;
&lt;li&gt;VARCHAR(n)에서 n은 글자 수 의미&lt;/li&gt;
&lt;li&gt;utf8mb4 사용 시 글자 하나가 최대 4바이트까지 소요. 행 크기 제한 등으로 인해 저장 가능 여부는 바이트 한계에도 영향 받음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PostgreSQL
&lt;ul&gt;
&lt;li&gt;character varying(n)에서 n은 글자 수 의미&lt;/li&gt;
&lt;li&gt;저장은 바이트 단위이나 제약은 글자 수 기준으로 평가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SQL Server
&lt;ul&gt;
&lt;li&gt;varchar(n)은 n이 바이트 수. 멀티바이트 문자 사용 시 같은 n이라도 담을 수 있는 글자 수 감소&lt;/li&gt;
&lt;li&gt;nvarchar(n)은 n이 글자 수. 유니코드 2바이트 단위 저장. 글자 수 기준 제약 필요 시 nvarchar 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Oracle
&lt;ul&gt;
&lt;li&gt;VARCHAR2(n)은 기본이 바이트 기준. 세션/시스템에서 CHAR semantics 또는 컬럼 정의 시 VARCHAR2(n CHAR)로 명시하면 글자 수 기준&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실무-팁&#34;&gt;실무 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한글 100자, 영어 100자 모두 허용 기대라면 글자 수 기준 타입 필요
&lt;ul&gt;
&lt;li&gt;MySQL VARCHAR(100), PostgreSQL varchar(100), SQL Server에서는 nvarchar(100), Oracle에서는 VARCHAR2(100 CHAR) 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;저장 바이트 한계 고려 필요. MySQL은 행 크기 한계, Oracle/SQL Server도 페이지 크기 등 제약 존재&lt;/li&gt;
&lt;li&gt;길이 함수 차이 주의. 바이트 길이와 글자 길이 함수가 다른 경우 존재. 예를 들어 글자 길이 검증은 문자 길이 함수 사용 권장&lt;/li&gt;
&lt;li&gt;이모지, 결합 문자 등 특수 유니코드 조합은 사용자 체감 글자 수와 코드 포인트 수가 다를 수 있음. 제품 요구사항에 맞는 길이 기준 정의 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VARCHAR(n)이 항상 바이트 무관이라는 주장은 오해&lt;/li&gt;
&lt;li&gt;많은 DBMS에서 n은 글자 수지만, SQL Server의 varchar처럼 바이트 기준인 구현 존재&lt;/li&gt;
&lt;li&gt;문자셋과 저장 한계를 함께 고려해야 안정적인 길이 설계 가능&lt;/li&gt;
&lt;li&gt;한글도 100글자, 영어도 100글자라는 기대를 보장하려면 글자 수 기준 타입과 설정을 명시적으로 선택할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/char.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/char.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/datatype-character.html&#34;&gt;https://www.postgresql.org/docs/current/datatype-character.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql&#34;&gt;https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673&#34;&gt;https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Kubernetes Controllers 핵심 개념과 실전 가이드</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-controllers-core-practical-guide-ecd5cd/</link>
      <pubDate>Thu, 04 Dec 2025 13:13:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-controllers-core-practical-guide-ecd5cd/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;쿠버네티스에서 컨트롤러는 제어 루프를 통해 원하는 상태와 현재 상태를 맞추는 두뇌 역할 수행
사용자가 선언한 스펙을 지속 관찰하고 차이를 줄이기 위해 리소스를 생성·수정·삭제하는 자동화 구성 요소
이 문서는 주요 컨트롤러를 실무 맥락과 비유를 곁들여 정리하며, 디버깅 관점에서의 관계와 주의점을 함께 정리&lt;/p&gt;
&lt;h3 id=&#34;워크로드-컨트롤러&#34;&gt;워크로드 컨트롤러&lt;/h3&gt;
&lt;p&gt;Deployment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;역할: 상태 비저장 앱의 표준 배포 단위, 버전 관리와 롤링 업데이트 담당&lt;/li&gt;
&lt;li&gt;특기: 롤링 업데이트로 무중단에 가까운 배포, 이슈 시 손쉬운 롤백&lt;/li&gt;
&lt;li&gt;관계: 파드 직접 관리 대신 ReplicaSet을 통해 간접 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ReplicaSet&lt;/p&gt;</description>
    </item>
    <item>
      <title>이벤트 루프와 비동기, await에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</link>
      <pubDate>Wed, 03 Dec 2025 13:13:33 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;nodejs-기본-구조&#34;&gt;Node.js 기본 구조&lt;/h2&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TB
    subgraph STACK[Call Stack]
        S1[현재 실행 중인 함수]
    end

    subgraph LOOP[Event Loop]
        EL[Call Stack 비었나?&amp;lt;br/&amp;gt;→ Queue에서 가져오기]
    end

    subgraph QUEUES[Queues]
        MQ[Microtask Queue&amp;lt;br/&amp;gt;Promise, await 완료]
        TQ[Task Queue&amp;lt;br/&amp;gt;setTimeout, I/O, Cron]
    end

    STACK --&amp;gt; |비어있을 때만| LOOP
    LOOP --&amp;gt; MQ
    MQ --&amp;gt; |비었으면| TQ
    TQ --&amp;gt; STACK

    style STACK fill:#ff6b6b
    style MQ fill:#4ecdc4
    style TQ fill:#45b7d1&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;핵심 규칙: Call Stack이 비어야만 다음 작업 실행&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;오해-1-settimeout0은-즉시-실행된다&#34;&gt;오해 1: &amp;ldquo;setTimeout(0)은 즉시 실행된다&amp;rdquo;&lt;/h2&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;setTimeout&lt;span style=&#34;color:#eceff4&#34;&gt;(()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;실행-흐름&#34;&gt;실행 흐름&lt;/h3&gt;
&lt;pre class=&#34;mermaid&#34;&gt;sequenceDiagram
    participant CS as Call Stack
    participant TQ as Task Queue
    participant OUT as 출력

    Note over CS: console.log(&amp;#39;1&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;1&amp;#34;

    Note over CS: setTimeout 등록
    CS-&amp;gt;&amp;gt;TQ: 콜백 등록 (0ms여도!)

    Note over CS: console.log(&amp;#39;3&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;3&amp;#34;

    Note over CS: Call Stack 비었음!
    TQ-&amp;gt;&amp;gt;CS: 콜백 가져오기

    Note over CS: 콜백 실행
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;2&amp;#34;&lt;/pre&gt;&lt;h3 id=&#34;출력-1--3--2&#34;&gt;출력: &lt;code&gt;1 → 3 → 2&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setTimeout(0)은 &amp;ldquo;다음 Event Loop에 실행&amp;quot;이라는 뜻!&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript Record 제대로 이해하기 — 인덱스 시그니처와 맵드 타입 비교, 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-record-mapped-type-index-signature-d67f80/</link>
      <pubDate>Tue, 02 Dec 2025 13:13:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-record-mapped-type-index-signature-d67f80/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Record&amp;lt;Key, Value&amp;gt;는 키와 값 타입을 고정해 객체 형태를 만드는 타입스크립트 유틸리티 타입임
인덱스 시그니처와 유사하지만 문자열 리터럴 유니온을 키로 직접 사용할 수 있고, 맵드 타입으로도 같은 효과를 낼 수 있음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Record&amp;lt;Key, Value&amp;gt;
&lt;ul&gt;
&lt;li&gt;키 타입 Key, 값 타입 Value를 갖는 객체 타입 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;인덱스 시그니처와의 차이
&lt;ul&gt;
&lt;li&gt;[key: string]: T 형태는 키 집합을 특정 리터럴 유니온으로 제한 불가&lt;/li&gt;
&lt;li&gt;Record는 &amp;lsquo;A&amp;rsquo; | &amp;lsquo;B&amp;rsquo; 같은 리터럴 유니온을 키로 직접 지정 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;맵드 타입과의 관계
&lt;ul&gt;
&lt;li&gt;{ [K in Keys]: V }와 Record&amp;lt;Keys, V&amp;gt;는 구조적으로 동일한 결과를 만들 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 스니펫&lt;/p&gt;</description>
    </item>
    <item>
      <title>스프레드 연산자로 배열 요소와 객체 속성 조건부 추가</title>
      <link>https://blog.jsontapose.com/posts/conditional-add-with-spread-array-object-940699/</link>
      <pubDate>Mon, 01 Dec 2025 13:13:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/conditional-add-with-spread-array-object-940699/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;리터럴 선언 시 조건에 따라 요소나 속성을 넣었다 뺄 수 있는 패턴 정리
분기문 없이 스프레드 연산자만으로 가독성 유지&lt;/p&gt;
&lt;h3 id=&#34;사용법예시&#34;&gt;사용법/예시&lt;/h3&gt;
&lt;p&gt;배열은 피연산자가 이터러블이어야 하므로 삼항 연산자 사용&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; arr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...(&lt;/span&gt;cond &lt;span style=&#34;color:#81a1c1&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === true =&amp;gt; [1, 2, 3, 4, 5, 6]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === false =&amp;gt; [4, 5, 6]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체는 원시값을 스프레드해도 자체 속성이 없어 무시됨
불리언화로 안전성 확보&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; obj &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;!!&lt;/span&gt;cond &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; a&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; b&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  d&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === true =&amp;gt; { a: 1, b: 2, c: 3, d: 4 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === false =&amp;gt; { c: 3, d: 4 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주의-사항&#34;&gt;주의 사항&lt;/h3&gt;
&lt;p&gt;배열에서 &amp;hellip;(cond &amp;amp;&amp;amp; [1,2,3]) 사용 금지, cond가 false면 이터러블 아님 오류 발생
객체에서 null이나 undefined를 그대로 스프레드하면 오류 가능, !!cond로 불리언화하거나 cond ? {..} : {} 형태 권장
타입스크립트에서는 &amp;amp;&amp;amp; 패턴이 타입 좁히기 미흡할 수 있음, 삼항으로 빈 객체 반환 또는 적절한 타입 주석 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 복합 인덱스와 Left-most Prefix 원칙 정리</title>
      <link>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</link>
      <pubDate>Sun, 30 Nov 2025 13:07:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</guid>
      <description>&lt;p&gt;InnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 &lt;code&gt;(colA, colB, colC)&lt;/code&gt; 인덱스면 &lt;code&gt;colA&lt;/code&gt; 기준으로 정렬되고 같은 &lt;code&gt;colA&lt;/code&gt; 그룹 내에서 &lt;code&gt;colB&lt;/code&gt;, 이어서 &lt;code&gt;colC&lt;/code&gt; 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐&lt;/p&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장&lt;/li&gt;
&lt;li&gt;InnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향&lt;/li&gt;
&lt;li&gt;left-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식-예시-cola-colb&#34;&gt;동작 방식 예시 &lt;code&gt;(colA, colB)&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;인덱스 구조&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정렬 키 순서: &lt;code&gt;colA&lt;/code&gt; → &lt;code&gt;colB&lt;/code&gt; → 내부적으로 PK 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;왼쪽 컬럼 우선 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE colA = ?&lt;/code&gt; 또는 &lt;code&gt;WHERE colA = ? AND colB = ?&lt;/code&gt; 형태는 인덱스를 온전히 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE colB = ?&lt;/code&gt;처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;왼쪽 접두사 부분 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(colA, colB)&lt;/code&gt;에서 &lt;code&gt;colA&lt;/code&gt;만 조건으로 사용해도 인덱스 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colA&lt;/code&gt;와 &lt;code&gt;colB&lt;/code&gt;를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colB&lt;/code&gt;만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;정렬과 결합 사용의 기본&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 키 순서와 같은 &lt;code&gt;ORDER BY colA, colB&lt;/code&gt;는 추가 정렬 비용 감소에 도움&lt;/li&gt;
&lt;li&gt;WHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;여러-컬럼을-묶는-이유&#34;&gt;여러 컬럼을 묶는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다중 조건 검색 성능 향상. 예: &lt;code&gt;WHERE colA = ? AND colB BETWEEN ? AND ?&lt;/code&gt;는 &lt;code&gt;(colA, colB)&lt;/code&gt;로 빠른 범위 스캔 가능&lt;/li&gt;
&lt;li&gt;커버링 인덱스 활용. 예: &lt;code&gt;SELECT colA, colB FROM T WHERE colA = ? AND colB = ?&lt;/code&gt;에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능&lt;/li&gt;
&lt;li&gt;쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장&lt;/li&gt;
&lt;li&gt;너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A, B, C)&lt;/code&gt;일 때 &lt;code&gt;WHERE B = ?&lt;/code&gt;처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 &lt;code&gt;(B, A)&lt;/code&gt; 같은 보완 인덱스 검토&lt;/li&gt;
&lt;li&gt;InnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리&lt;/li&gt;
&lt;li&gt;ORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락&lt;/li&gt;
&lt;li&gt;범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 &lt;code&gt;colA BETWEEN ...&lt;/code&gt;가 선두에 오면 그 뒤 &lt;code&gt;colB&lt;/code&gt;는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨&lt;/li&gt;
&lt;li&gt;다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음&lt;/li&gt;
&lt;li&gt;불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>JavaScript에서 빈 배열은 truthy인가 falsy인가</title>
      <link>https://blog.jsontapose.com/posts/javascript-empty-array-truthy-falsy-32e6fe/</link>
      <pubDate>Sat, 29 Nov 2025 13:08:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-empty-array-truthy-falsy-32e6fe/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;JavaScript에서 조건식은 내부적으로 ToBoolean 연산을 거쳐 참거짓을 판정함
이때 객체 타입은 모두 truthy로 간주되며 배열도 객체에 해당함
따라서 빈 배열 []과 빈 객체 {} 역시 조건문에서 true로 평가됨
반대로 falsy는 정해진 값만 해당됨 false, 0, -0, 0n, &amp;ldquo;&amp;rdquo;, null, undefined, NaN&lt;/p&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;p&gt;다음은 빈 배열이 조건문에서 어떻게 평가되는지 확인하는 간단한 코드&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;([])&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;빈 배열은 truthy입니다!&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;빈 배열은 falsy입니다!&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 출력: &amp;#34;빈 배열은 truthy입니다!&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;배열이 비어 있는지를 논리적으로 구분하려면 길이를 확인해야 함&lt;/p&gt;</description>
    </item>
    <item>
      <title>백오프 Backoff 재시도 전략 정리 고정·선형·지수·지터</title>
      <link>https://blog.jsontapose.com/posts/backoff-retry-strategy-fixed-linear-exponential-jitter-6d23a5/</link>
      <pubDate>Fri, 28 Nov 2025 13:10:38 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backoff-retry-strategy-fixed-linear-exponential-jitter-6d23a5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;백오프는 실패한 작업을 즉시 재시도하지 않고 일정 시간 대기 후 다시 시도하는 전략을 말함
연속 실패 시 대기 시간을 점진적으로 늘려 서비스와 네트워크에 가해지는 부하를 낮추는 목적
RPC, 데이터베이스, 외부 API 호출, 트랜잭션 재시도 등에서 일반적으로 사용&lt;/p&gt;
&lt;h3 id=&#34;왜-쓰는가&#34;&gt;왜 쓰는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;과부하 방지
실패 직후 동시 재시도를 막아 서버와 네트워크 폭주를 예방&lt;/li&gt;
&lt;li&gt;일시적 장애 흡수
순간적인 지연이나 혼잡이 해소될 시간을 벌어 성공 확률을 높임&lt;/li&gt;
&lt;li&gt;비용 절감
불필요한 재시도 횟수와 리소스 낭비 감소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;대표-백오프-패턴&#34;&gt;대표 백오프 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;고정 백오프 Fixed
매번 동일 대기 시간 사용
예) 1초 → 1초 → 1초&lt;/li&gt;
&lt;li&gt;선형 백오프 Linear
시도할 때마다 일정 간격으로 증가
예) 1초 → 2초 → 3초 → 4초&lt;/li&gt;
&lt;li&gt;지수 백오프 Exponential
보통 2배로 증가하는 지수 증가 사용, 실무에서 기본값으로 가장 흔함
예) 1초 → 2초 → 4초 → 8초 → 16초&lt;/li&gt;
&lt;li&gt;지수 백오프 + 지터 Jitter
지수 증가에 무작위성을 섞어 동시 재시도 동기화를 깨뜨림
예) 1초 → 2.3초 → 4.1초 → 8.6초&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실전-포인트&#34;&gt;실전 포인트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동시성 환경에서는 지터 필수
동일한 주기 백오프만으로는 다수 클라이언트가 같은 타이밍에 몰려 서버를 다시 두들김&lt;/li&gt;
&lt;li&gt;상한 설정
최대 대기 시간과 최대 재시도 횟수 캡을 두어 꼬리 길어짐 방지&lt;/li&gt;
&lt;li&gt;실패 예산과 타임아웃 연계
전체 호출 타임아웃 내에서 재시도 예산을 배분, 1회 호출과 재시도들이 전체 SLA를 초과하지 않도록 관리&lt;/li&gt;
&lt;li&gt;멱등성 보장
재시도 가능한 작업은 멱등성을 만족해야 안전, 아니면 보상 로직 필요&lt;/li&gt;
&lt;li&gt;서버 힌트 활용
Retry-After 등 서버가 제시하는 대기 힌트가 있으면 우선 적용&lt;/li&gt;
&lt;li&gt;지터 방식 선택
전체 구간 무작위 분포 Full jitter가 단순하고 효과적이라는 보고가 많음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;아래는 지수 백오프의 최소 구현 예시이며, 지터와 최대 대기 시간 제한은 상황에 맞게 추가 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>AMM DEX에서 슬리피지 이해와 허용치 설정</title>
      <link>https://blog.jsontapose.com/posts/amm-dex-slippage-4c7cd0/</link>
      <pubDate>Tue, 25 Nov 2025 13:11:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/amm-dex-slippage-4c7cd0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;슬리피지(slippage)는 내가 예상한 가격과 실제 체결 가격의 차이를 의미함
분산형 거래소 환경에서는 블록 포함 지연과 유동성 구조 때문에 발생 빈도가 높음&lt;/p&gt;
&lt;h3 id=&#34;슬리피지가-발생하는-이유&#34;&gt;슬리피지가 발생하는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;유동성 부족
특정 토큰 페어의 유동성 풀이 얕으면 작은 주문에도 가격 영향 커짐&lt;/li&gt;
&lt;li&gt;대량 주문
시장 규모 대비 큰 금액을 한 번에 실행 시 풀 내 토큰 비율이 급격히 변해 체결 평균가가 악화됨&lt;/li&gt;
&lt;li&gt;시장 변동성
트랜잭션 제출 시점과 블록에 포함되는 시점 사이 외부 가격 급변으로 기대 가격과 괴리 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;amm에서의-동작&#34;&gt;AMM에서의 동작&lt;/h3&gt;
&lt;p&gt;대부분의 DEX는 AMM을 사용하며 풀 내 두 토큰의 비율로 가격이 정해짐. 단순화된 상수곱 x·y=k 모델 기준으로 설명함&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL 테이블 이름 변경 RENAME TABLE vs ALTER TABLE 정리</title>
      <link>https://blog.jsontapose.com/posts/mysql-rename-table-vs-alter-table-470e90/</link>
      <pubDate>Mon, 24 Nov 2025 13:12:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-rename-table-vs-alter-table-470e90/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 이름 변경은 ALTER TABLE로도 가능하지만, RENAME TABLE을 쓰면 다수 테이블을 한 번에 처리 가능하며 같은 서버 내 다른 데이터베이스로 이동까지 가능함&lt;/p&gt;
&lt;h3 id=&#34;핵심-차이&#34;&gt;핵심 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ALTER TABLE RENAME은 단일 테이블 대상&lt;/li&gt;
&lt;li&gt;RENAME TABLE은 여러 테이블을 한 문장으로 변경 가능&lt;/li&gt;
&lt;li&gt;스키마 간 이동 지원 current_db.table에서 other_db.table로 변경 가능&lt;/li&gt;
&lt;li&gt;동일 트랜잭션처럼 동작하는 원자성 제공, 다중 변경 중 하나라도 실패 시 전체 미적용&lt;/li&gt;
&lt;li&gt;권한 요구 사항 존재, 원본 테이블에 ALTER와 DROP, 대상 스키마에 CREATE 권한 필요&lt;/li&gt;
&lt;li&gt;트리거와 외래키 메타데이터는 함께 유지되나, 뷰나 저장 프로시저의 하드코딩된 참조는 자동 갱신되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용법&#34;&gt;사용법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 테이블 이름 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RENAME&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; old_table &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TO&lt;/span&gt; new_table&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;단일 테이블 이름 변경 ALTER 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; old_table &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RENAME&lt;/span&gt; new_table&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;다수 테이블 이름 일괄 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RENAME&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; old_table1 &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TO&lt;/span&gt; new_table1&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             old_table2 &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TO&lt;/span&gt; new_table2&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             old_table3 &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TO&lt;/span&gt; new_table3&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;다른 데이터베이스로 이동 같은 서버 내&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;RENAME&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; current_db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;TO&lt;/span&gt; other_db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;table_name&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주의-사항&#34;&gt;주의 사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대상 이름이 이미 존재하면 실패&lt;/li&gt;
&lt;li&gt;교차 서버 이동 불가, 같은 서버 인스턴스 내 스키마 간 이동만 가능&lt;/li&gt;
&lt;li&gt;실행 시 메타데이터 락 획득, 짧은 구간 동안 읽기나 쓰기 대기 가능&lt;/li&gt;
&lt;li&gt;배치 변경 전 사전 검증 권장, 이름 충돌 여부와 권한 확인&lt;/li&gt;
&lt;li&gt;뷰나 프로시저 참조는 수동 점검 필요, 린트나 간단한 탐색 쿼리로 영향 범위 확인 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;p&gt;단일 변경만 필요하면 ALTER로 충분하나, 다수 변경이나 스키마 이동까지 고려하면 RENAME TABLE이 더 실용적 선택
원자적 일괄 변경과 스키마 간 이동을 활용하되, 권한과 의존성 영향 검증을 선행할 것&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리</title>
      <link>https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/</link>
      <pubDate>Sun, 23 Nov 2025 13:06:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음
Prisma에서는 JOIN이 어디로 갔나 하는 질문임
개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음
정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함&lt;/p&gt;
&lt;h3 id=&#34;orm이란-무엇인가&#34;&gt;ORM이란 무엇인가&lt;/h3&gt;
&lt;p&gt;ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함
애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공
SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능
데이터베이스 의존성 완화 효과 기대&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Promise.all과 Map 정리 – 동시 비동기 처리와 키-값 컬렉션 기본</title>
      <link>https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/</link>
      <pubDate>Fri, 21 Nov 2025 13:09:50 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음
키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함
이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함&lt;/p&gt;
&lt;h3 id=&#34;promiseall-개념과-정의&#34;&gt;Promise.all 개념과 정의&lt;/h3&gt;
&lt;p&gt;여러 Promise를 단일 Promise로 집계하는 유틸리티
모든 입력이 이행되면 결과를 같은 순서의 배열로 반환
하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유
입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>MECE 개념 정리: 상호배제와 전체포괄로 구조화하는 분류 원칙</title>
      <link>https://blog.jsontapose.com/posts/mece-structured-classification-principle-c7252d/</link>
      <pubDate>Thu, 20 Nov 2025 13:10:44 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mece-structured-classification-principle-c7252d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;MECE는 Mutually Exclusive Collectively Exhaustive의 약자이며 상호배제와 전체포괄을 뜻함
겹치지 않게 나누되 합치면 전체가 되는 분류 원칙을 말함
영어권에서는 미씨로 읽고, 한국어로는 엠이씨이 또는 미시로 불림
컨설팅 실무에서 대중화된 사고 틀로 문제 분해, 요건 정의, 케이스 분류에 자주 사용됨&lt;/p&gt;
&lt;h3 id=&#34;개념과-정의&#34;&gt;개념과 정의&lt;/h3&gt;
&lt;p&gt;상호배제는 요소들이 서로 겹치지 않는 상태를 의미함
중복 없이 하나의 요소가 정확히 하나의 범주에만 속함
전체포괄은 분류된 요소들을 모두 합치면 전체 모수를 빠짐없이 덮는 상태를 의미함
누락 없이 전체 공간을 커버하는 분할이 목표임&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma where 관계 필터 some vs every 동작 차이와 주의점</title>
      <link>https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/</link>
      <pubDate>Mon, 17 Nov 2025 13:11:31 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/</guid>
      <description>&lt;p&gt;관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요&lt;/p&gt;
&lt;h3 id=&#34;개념&#34;&gt;개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;some
&lt;ul&gt;
&lt;li&gt;관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함&lt;/li&gt;
&lt;li&gt;존재성 검사에 해당, 하나라도 매칭되면 true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;every
&lt;ul&gt;
&lt;li&gt;모든 관계된 레코드가 조건을 만족해야 부모 포함&lt;/li&gt;
&lt;li&gt;단 하나라도 위배되면 제외됨&lt;/li&gt;
&lt;li&gt;관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;some은 존재량화, every는 전칭량화에 해당함&lt;/li&gt;
&lt;li&gt;차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음&lt;/li&gt;
&lt;li&gt;특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;model Post {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  id       Int       @id @default(autoincrement())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  title    String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  comments Comment[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;model Comment {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  id     Int    @id @default(autoincrement())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  text   String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  postId Int
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  post   Post   @relation(fields: [postId], references: [id])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;댓글 text가 &amp;lsquo;interesting&amp;rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.map 개념과 사용법 정리</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</link>
      <pubDate>Sat, 15 Nov 2025 13:07:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Array.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임
원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임&lt;/p&gt;
&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; newArray &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; index&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;element 현재 요소&lt;/li&gt;
&lt;li&gt;index 현재 인덱스&lt;/li&gt;
&lt;li&gt;array 원본 배열 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨&lt;/p&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;숫자 배열 변환&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; numbers &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; doubled &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;n&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; n &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// [2, 4, 6, 8, 10]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체 배열에서 특정 속성 추출&lt;/p&gt;</description>
    </item>
    <item>
      <title>커링과 부분 적용 이해하기: 함수형 자바스크립트 핵심 패턴</title>
      <link>https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/</link>
      <pubDate>Thu, 13 Nov 2025 13:11:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법
n개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해
함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환&lt;/li&gt;
&lt;li&gt;부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법&lt;/li&gt;
&lt;li&gt;관계: 커링된 함수는 부분 적용을 자연스럽게 지원함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동작-원리와-간단-예시&#34;&gt;동작 원리와 간단 예시&lt;/h3&gt;
&lt;p&gt;일반 함수&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findUnique에서 where와 include 제대로 쓰기</title>
      <link>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</link>
      <pubDate>Wed, 12 Nov 2025 13:12:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;findUnique&lt;/code&gt;로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 &lt;code&gt;where&lt;/code&gt;와 &lt;code&gt;include&lt;/code&gt;를 어떻게 조합해야 하는지 정리함
관계 필터링을 &lt;code&gt;where&lt;/code&gt;에 넣을 수 있는지, &lt;code&gt;include&lt;/code&gt;에서 필터가 가능한지 헷갈리기 쉬운 지점 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;는 유니크 키로 정확히 &lt;strong&gt;하나&lt;/strong&gt;의 레코드를 찾는 용도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;의 &lt;code&gt;where&lt;/code&gt;는 &lt;strong&gt;유니크 필드만&lt;/strong&gt; 허용됨, 관계 필터나 일반 조건 결합 불가&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;to-many 관계&lt;/strong&gt;에 한해 &lt;code&gt;include&lt;/code&gt; 내부에서 &lt;code&gt;where&lt;/code&gt; 사용 가능, to-one 관계는 &lt;code&gt;where&lt;/code&gt; 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where-사용-패턴&#34;&gt;where 사용 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;잘못된 예시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// findUnique에 관계 필터 결합 시도 → 타입 에러
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// (User(1) → Post(N) → Metadata(1) 관계)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;posts&amp;#39;는 유니크 필드가 아니므로 &amp;#39;where&amp;#39;에서 관계 필터링 불가
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;올바른 최소 조건&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;id&amp;#39;는 유니크 필드
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;관계 조건이 필요하면 findFirst 또는 findMany 사용&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;findUnique&amp;#39;가 아닌 &amp;#39;findFirst&amp;#39;를 사용하면
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;where&amp;#39;에 관계 필터를 포함할 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findFirst&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;요약하면 &lt;code&gt;findUnique&lt;/code&gt;에는 유니크 조건만, 관계 기반 필터는 &lt;code&gt;findFirst&lt;/code&gt; 또는 &lt;code&gt;findMany&lt;/code&gt;로 처리함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 실행 흐름과 이벤트 루프 단계 정리</title>
      <link>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</link>
      <pubDate>Tue, 11 Nov 2025 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리
바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V8 엔진, Ignition 바이트코드와 JIT 최적화&lt;/li&gt;
&lt;li&gt;libuv, 비동기 I O 백엔드와 이벤트 루프 단계&lt;/li&gt;
&lt;li&gt;모듈 시스템, CommonJS와 ES Module의 로딩 차이&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트와 런타임 내장 객체&lt;/li&gt;
&lt;li&gt;마이크로태스크 큐와 process.nextTick의 우선순위&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행-순서-요약&#34;&gt;실행 순서 요약&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Node 바이너리 시작&lt;/li&gt;
&lt;li&gt;런타임 초기화와 내부 바인딩 준비&lt;/li&gt;
&lt;li&gt;모듈 로더 기동 및 엔트리 파일 로드&lt;/li&gt;
&lt;li&gt;V8 파싱과 바이트코드 컴파일&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트 구성과 최상위 코드 실행&lt;/li&gt;
&lt;li&gt;비동기 작업 등록&lt;/li&gt;
&lt;li&gt;이벤트 루프 진입&lt;/li&gt;
&lt;li&gt;비동기 콜백 처리 반복&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TD
A[Node 시작] --&amp;gt; B[V8, libuv 초기화]
B --&amp;gt; C[모듈 로딩]
C --&amp;gt; D[파싱 및 컴파일]
D --&amp;gt; E[최상위 코드 실행]
E --&amp;gt; F[이벤트 루프]
F --&amp;gt; G[비동기 처리 반복]&lt;/pre&gt;&lt;h3 id=&#34;단계별-동작&#34;&gt;단계별 동작&lt;/h3&gt;
&lt;h4 id=&#34;1단계-node-바이너리-시작&#34;&gt;1단계 Node 바이너리 시작&lt;/h4&gt;
&lt;p&gt;node yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨
V8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>DI가 결합도를 낮추는 원리와 최소 예시</title>
      <link>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</link>
      <pubDate>Sun, 09 Nov 2025 13:06:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</guid>
      <description>&lt;h2 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h2&gt;
&lt;p&gt;DI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함
&lt;strong&gt;객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용&lt;/strong&gt;하는 것임
이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;문제-상황-강한-결합-tight-coupling&#34;&gt;문제 상황: 강한 결합 (Tight Coupling)&lt;/h2&gt;
&lt;p&gt;전형적인 문제 패턴은 클래스 내부에서 다른 &lt;strong&gt;구체적인 클래스&lt;/strong&gt;(Concrete Class)를 &lt;code&gt;new&lt;/code&gt; 키워드로 직접 생성하여 사용하는 것임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 &lt;strong&gt;반드시 함께 수정&lt;/strong&gt;해야 함&lt;/li&gt;
&lt;li&gt;단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 &lt;code&gt;Gamer&lt;/code&gt;가 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;를 직접 생성해 사용한다면, &lt;code&gt;Gamer&lt;/code&gt;는 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;라는 구체적인 구현에 영구적으로 고정됨
만약 키보드 종류를 &lt;code&gt;RedSwitchSilentKeyboard&lt;/code&gt;로 바꾸려면 &lt;code&gt;Gamer&lt;/code&gt; 클래스의 내부 코드를 직접 수정해야 함
이 상태를 &lt;strong&gt;결합도가 높다&lt;/strong&gt;고 부름&lt;/p&gt;</description>
    </item>
    <item>
      <title>KISS 원리: 소프트웨어 설계에서 불필요한 복잡성 줄이기</title>
      <link>https://blog.jsontapose.com/posts/kiss-principle-software-design-799a74/</link>
      <pubDate>Mon, 03 Nov 2025 13:10:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kiss-principle-software-design-799a74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;KISS는 Keep It Simple, Stupid 또는 Keep It Simple and Straightforward의 약자이며 1960년대 미 해군에서 출발한 설계 원칙입니다. 소프트웨어에서는 불필요한 복잡성을 제거하고 이해와 변경이 쉬운 구조를 지향합니다. 목표는 적은 개념과 짧은 경로로 같은 가치를 제공하는 시스템을 만드는 것임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단순함 추구: 필요 최소의 개념, 규칙, 구성 요소 유지&lt;/li&gt;
&lt;li&gt;이해 용이성: 읽고 추론하기 쉬운 흐름과 명명&lt;/li&gt;
&lt;li&gt;유지보수 용이성: 응집도 높이고 결합도 낮춰 변경 영향 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;적용-방법&#34;&gt;적용 방법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 모든 시나리오를 포괄하려 하지 말고 현재 요구에 맞춘 최소 기능으로 시작&lt;/li&gt;
&lt;li&gt;큰 만능 모듈 대신 작고 역할이 분리된 구성으로 나누기&lt;/li&gt;
&lt;li&gt;공개 인터페이스를 최소화하고 기본값을 합리적으로 설계&lt;/li&gt;
&lt;li&gt;데이터 흐름을 단방향으로 단순화하고 예외 경로는 명시적으로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;관련-원칙&#34;&gt;관련 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DRY: 중복 제거로 변경 비용과 오류 가능성 감소&lt;/li&gt;
&lt;li&gt;YAGNI: 지금 필요 없는 기능은 만들지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;모든 옵션을 받는 doSomething(config) 하나로 처리하려는 유혹을 경계. 대신 doSimpleA, doSimpleB처럼 명확한 역할의 작은 함수로 분리하고 기본 동작을 안전하게 설계함. 설정이 꼭 필요할 때만 제한된 형태로 노출&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript Parameters 유틸리티 타입 개념과 안전한 활용</title>
      <link>https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/</link>
      <pubDate>Sat, 01 Nov 2025 13:06:40 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Parameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨
함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함&lt;/p&gt;
&lt;h3 id=&#34;문법&#34;&gt;문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Parameters&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;...args&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; T &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;args: &lt;span style=&#34;color:#81a1c1&#34;&gt;infer&lt;/span&gt; P
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1&#34;&gt;?&lt;/span&gt; P
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  : &lt;span style=&#34;color:#81a1c1&#34;&gt;never&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;T가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출&lt;/li&gt;
&lt;li&gt;T가 함수 타입이 아니면 never 반환&lt;/li&gt;
&lt;li&gt;추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;기본 추출&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</link>
      <pubDate>Fri, 31 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 &lt;strong&gt;메모리에 캐싱&lt;/strong&gt;하는 영역임
디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임
InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 &lt;strong&gt;심장부&lt;/strong&gt;라 할 수 있음&lt;/p&gt;
&lt;p&gt;쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;버퍼-풀-구성-요소&#34;&gt;버퍼 풀 구성 요소&lt;/h2&gt;
&lt;p&gt;버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터 페이지&lt;/strong&gt;: 실제 테이블 로우(Row)가 저장된 페이지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인덱스 페이지&lt;/strong&gt;: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기타 관리 페이지&lt;/strong&gt;: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;페이지-캐싱&#34;&gt;페이지 캐싱&lt;/h3&gt;
&lt;p&gt;InnoDB는 디스크 데이터를 페이지 단위로 다룸
클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 &lt;strong&gt;페이지 전체&lt;/strong&gt;를 버퍼 풀로 가져옴
이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법</title>
      <link>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</link>
      <pubDate>Thu, 30 Oct 2025 13:11:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임
DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함
핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임&lt;/p&gt;
&lt;h3 id=&#34;apiproperty-개념과-사용&#34;&gt;ApiProperty 개념과 사용&lt;/h3&gt;
&lt;p&gt;@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임
타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공
코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함&lt;/p&gt;
&lt;p&gt;간단 사용 예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; CreateUserDto &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@ApiProperty&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; description&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;사용자 이름&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; example&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미</title>
      <link>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</link>
      <pubDate>Wed, 29 Oct 2025 13:11:51 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함
skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함&lt;/p&gt;
&lt;h3 id=&#34;핵심-동작&#34;&gt;핵심 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cursor는 그 지점부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 100부터 시작해 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;skip: 1은 cursor에 해당하는 레코드를 건너뜀&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  skip: &lt;span style=&#34;color:#81a1c1&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 101부터 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;예시로-보는-차이&#34;&gt;예시로 보는 차이&lt;/h3&gt;
&lt;p&gt;데이터가 아래와 같다고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자</title>
      <link>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</link>
      <pubDate>Tue, 28 Oct 2025 13:10:28 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma의 findMany는 다중 레코드 조회용 메서드
기본값은 대상 모델의 모든 레코드 반환
where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원
옵션 조합으로 조건 기반 조회를 간결하게 구성 가능&lt;/p&gt;
&lt;h3 id=&#34;기본-사용법&#34;&gt;기본 사용법&lt;/h3&gt;
&lt;p&gt;가장 단순한 호출 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; users &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주요-옵션&#34;&gt;주요 옵션&lt;/h3&gt;
&lt;p&gt;옵션은 필요한 것만 선택적으로 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where: 조건 필터링&lt;/li&gt;
&lt;li&gt;select: 필드 서브셋 선택&lt;/li&gt;
&lt;li&gt;include: 관계 데이터 로드&lt;/li&gt;
&lt;li&gt;orderBy: 정렬 기준 지정&lt;/li&gt;
&lt;li&gt;skip, take: 오프셋 기반 페이징&lt;/li&gt;
&lt;li&gt;distinct: 특정 필드 기준 중복 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where로-조건-필터링&#34;&gt;where로 조건 필터링&lt;/h3&gt;
&lt;p&gt;단일 조건부터 복합 조건까지 표현 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript 함수는 왜 일급 객체인가 — 의미와 활용</title>
      <link>https://blog.jsontapose.com/posts/javascript-first-class-functions-5dcc7e/</link>
      <pubDate>Mon, 27 Oct 2025 13:11:11 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-first-class-functions-5dcc7e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;JavaScript에서 함수는 일급 객체로 취급됨
이는 함수가 값처럼 변수에 담기고, 인수로 전달되고, 반환값으로 나오며, 객체의 프로퍼티로 저장될 수 있음을 의미함
이 특성 덕분에 고차 함수, 콜백, 클로저, 함수 합성 같은 패턴이 자연스럽게 구현됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;변수에 할당 가능&lt;/li&gt;
&lt;li&gt;다른 함수의 인수로 전달 가능&lt;/li&gt;
&lt;li&gt;다른 함수의 반환값으로 사용 가능&lt;/li&gt;
&lt;li&gt;객체의 프로퍼티로 저장 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;변수에 할당&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; greet &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;name&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;`Hello, &lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;${&lt;/span&gt;name&lt;span style=&#34;color:#a3be8c&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;인수로 전달&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; run &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;fn&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; v&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; fn&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;run&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;greet&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;반환값으로 사용 및 클로저&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; mul &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;m&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;v&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; v &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; m&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mul&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체 프로퍼티로 저장해 메서드 구성&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</title>
      <link>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</link>
      <pubDate>Sun, 26 Oct 2025 13:07:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임
대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함
사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함
이때 결정 규칙이 존재함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용&lt;/li&gt;
&lt;li&gt;그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함
따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 환경에서 디버깅하기</title>
      <link>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</link>
      <pubDate>Thu, 23 Oct 2025 13:11:27 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함&lt;/p&gt;
&lt;h3 id=&#34;문제를-명확히-하기&#34;&gt;문제를 명확히 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작성한 코드의 기대 동작 정의&lt;/li&gt;
&lt;li&gt;실제 관측된 동작과의 차이 정리&lt;/li&gt;
&lt;li&gt;실패 조건과 재현 절차 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript enum, const enum, as const 차이와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/</link>
      <pubDate>Tue, 21 Oct 2025 13:12:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임
각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음&lt;/p&gt;
&lt;h3 id=&#34;enum-개념과-동작&#34;&gt;enum 개념과 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;열거형 타입을 선언하는 문법&lt;/li&gt;
&lt;li&gt;숫자 기반과 문자열 기반 모두 지원&lt;/li&gt;
&lt;li&gt;컴파일 결과로 양방향 매핑을 담은 JS 객체 생성
&lt;ul&gt;
&lt;li&gt;키로 값 조회, 값으로 키 역조회 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;enum&lt;/span&gt; BooleanType &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  False &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  True &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징</title>
      <link>https://blog.jsontapose.com/posts/sql-limit-offset-basics-4a9880/</link>
      <pubDate>Mon, 20 Oct 2025 13:10:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sql-limit-offset-basics-4a9880/</guid>
      <description>&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;p&gt;LIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문
WHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치&lt;/p&gt;
&lt;p&gt;두 가지 형태 사용&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;개수&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;개수&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;OFFSET&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;시작&lt;/span&gt;_인덱스&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;일부 dialect에서는 아래 축약형도 존재&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;-- MySQL, SQLite
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;컬럼명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;테이블명&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;시작&lt;/span&gt;_인덱스&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;개수&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;1-limit-개수&#34;&gt;1. LIMIT 개수&lt;/h3&gt;
&lt;p&gt;LIMIT 뒤 숫자는 인덱스가 아닌 개수&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;FROM&lt;/span&gt; Book
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;현재 정렬 기준에서 맨 위 행 1개만 반환
ORDER BY가 없으면 반환되는 행은 비결정적일 수 있음&lt;/p&gt;
&lt;h3 id=&#34;2-limit-개수-offset-시작&#34;&gt;2. LIMIT 개수 OFFSET 시작&lt;/h3&gt;
&lt;p&gt;OFFSET은 0부터 시작
다음 예시는 4번째 행부터 1개 반환&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법</title>
      <link>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</link>
      <pubDate>Sun, 19 Oct 2025 13:06:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음
Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 &amp;ndash;debug는 폐기, &amp;ndash;inspect로 통일됨
CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함&lt;/p&gt;
&lt;p&gt;이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v8-inspector 프로토콜
&lt;ul&gt;
&lt;li&gt;V8이 노출하는 디버깅 프로토콜&lt;/li&gt;
&lt;li&gt;Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect vs &amp;ndash;inspect-brk
&lt;ul&gt;
&lt;li&gt;&amp;ndash;inspect는 바로 실행하면서 디버거 접속 대기&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;포트
&lt;ul&gt;
&lt;li&gt;기본 포트 9229 사용&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect=PORT, &amp;ndash;inspect-brk=PORT 형태로 변경 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프론트엔드
&lt;ul&gt;
&lt;li&gt;Chromium 기반 개발자도구로 연결 가능&lt;/li&gt;
&lt;li&gt;chrome://inspect 에서 Node 대상 탐색 및 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;node-inspect
&lt;ul&gt;
&lt;li&gt;Node 내장 CLI 디버거&lt;/li&gt;
&lt;li&gt;동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;크롬-개발자도구로-디버깅&#34;&gt;크롬 개발자도구로 디버깅&lt;/h3&gt;
&lt;p&gt;Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-control-plane-eks-2af164/</link>
      <pubDate>Sat, 18 Oct 2025 13:06:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-control-plane-eks-2af164/</guid>
      <description>&lt;p&gt;컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음
조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함&lt;/p&gt;
&lt;h3 id=&#34;개념과-정의&#34;&gt;개념과 정의&lt;/h3&gt;
&lt;p&gt;컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층
사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴&lt;/p&gt;
&lt;h3 id=&#34;핵심-구성요소&#34;&gt;핵심 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes 핵심 구성요소와 동작 흐름</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-core-components-and-flow-915d3a/</link>
      <pubDate>Thu, 16 Oct 2025 13:10:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-core-components-and-flow-915d3a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템
핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프
각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능&lt;/p&gt;
&lt;h3 id=&#34;구성요소-관계-한눈에&#34;&gt;구성요소 관계 한눈에&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl / CI
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kube-apiserver ──&amp;gt; etcd
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │  ▲
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │  └(상태 영속)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├─ kube-scheduler(어디 배치할지 결정)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[각 워커 노드]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubelet ──(CRI gRPC)──&amp;gt; container runtime ──(OCI)──&amp;gt; runc/crun ──&amp;gt; cgroup 설정 + 컨테이너 시작
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │                                        │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├─(CNI 호출) 네트워크/IP 할당            └─ 네임스페이스/마운트 등 격리
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └─ kube-proxy(서비스 라우팅: iptables/ipvs)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;모든 컴포넌트의 권위자이자 입구는 apiserver&lt;/li&gt;
&lt;li&gt;etcd와 직접 통신하는 주체는 apiserver만 존재&lt;/li&gt;
&lt;li&gt;kubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지&lt;/li&gt;
&lt;li&gt;container runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pod-생성에서-running까지&#34;&gt;Pod 생성에서 Running까지&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화&lt;/li&gt;
&lt;li&gt;controller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등&lt;/li&gt;
&lt;li&gt;scheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩&lt;/li&gt;
&lt;li&gt;대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지&lt;/li&gt;
&lt;li&gt;kubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당&lt;/li&gt;
&lt;li&gt;kubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달&lt;/li&gt;
&lt;li&gt;runtime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행&lt;/li&gt;
&lt;li&gt;kubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고&lt;/li&gt;
&lt;li&gt;kube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립&lt;/li&gt;
&lt;li&gt;클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cgroup과-리소스-제한-연결&#34;&gt;cgroup과 리소스 제한 연결&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정&lt;/li&gt;
&lt;li&gt;CPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여&lt;/li&gt;
&lt;li&gt;메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제&lt;/li&gt;
&lt;li&gt;쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장애스케일자체-복구-흐름&#34;&gt;장애·스케일·자체 복구 흐름&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행&lt;/li&gt;
&lt;li&gt;노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택&lt;/li&gt;
&lt;li&gt;HPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;용어-핵심-정리&#34;&gt;용어 핵심 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;control plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소&lt;/li&gt;
&lt;li&gt;worker node 파드를 실제로 실행하는 머신 풀&lt;/li&gt;
&lt;li&gt;kubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당&lt;/li&gt;
&lt;li&gt;container runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수&lt;/li&gt;
&lt;li&gt;cgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;apiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL EXPLAIN 실행 계획 해석 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</link>
      <pubDate>Wed, 15 Oct 2025 13:10:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구
병목 파악과 인덱스 전략 점검에 사용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select_type
&lt;ul&gt;
&lt;li&gt;SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음&lt;/li&gt;
&lt;li&gt;PRIMARY 가장 바깥쪽 SELECT&lt;/li&gt;
&lt;li&gt;SUBQUERY 서브쿼리&lt;/li&gt;
&lt;li&gt;DERIVED FROM 절의 서브쿼리&lt;/li&gt;
&lt;li&gt;UNION UNION의 두 번째 이후 SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 실행 품질 지표, 위에서 아래로 유리
&lt;ul&gt;
&lt;li&gt;system 테이블에 단 하나의 행&lt;/li&gt;
&lt;li&gt;const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회&lt;/li&gt;
&lt;li&gt;eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭&lt;/li&gt;
&lt;li&gt;ref 인덱스를 사용한 동등 조건 검색&lt;/li&gt;
&lt;li&gt;range 인덱스를 사용한 범위 검색&lt;/li&gt;
&lt;li&gt;index 인덱스 전체 스캔&lt;/li&gt;
&lt;li&gt;ALL 테이블 전체 스캔, 최악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음&lt;/li&gt;
&lt;li&gt;key 실제 사용된 인덱스, NULL이면 인덱스 미사용&lt;/li&gt;
&lt;li&gt;rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리&lt;/li&gt;
&lt;li&gt;filtered 조건 후 남는 행 비율 추정치, 높을수록 유리&lt;/li&gt;
&lt;li&gt;Extra 추가 단서
&lt;ul&gt;
&lt;li&gt;Using index 커버링 인덱스 사용, 유리&lt;/li&gt;
&lt;li&gt;Using where WHERE 조건으로 필터링 수행&lt;/li&gt;
&lt;li&gt;Using filesort 추가 정렬 필요, 비용 큼&lt;/li&gt;
&lt;li&gt;Using temporary 임시 테이블 사용, 비용 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해석-기준&#34;&gt;해석 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type이 const, ref, range 범주에 위치&lt;/li&gt;
&lt;li&gt;key가 NULL이 아니고 적절한 인덱스 선택&lt;/li&gt;
&lt;li&gt;rows 추정치가 작고 filtered 비율이 높음&lt;/li&gt;
&lt;li&gt;Extra에 Using filesort, Using temporary 부재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시와-해석&#34;&gt;예시와 해석&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;type: ALL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;possible_keys: NULL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rows: 3527425
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Extra: Using where; Using filesort&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;테이블 전체 스캔으로 많은 행을 읽게 됨&lt;/li&gt;
&lt;li&gt;인덱스 후보와 실제 사용 인덱스가 없음&lt;/li&gt;
&lt;li&gt;WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승&lt;/li&gt;
&lt;li&gt;현재 계획은 인덱스 설계와 조건식 재검토 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rows와 filtered는 통계 기반 추정치라 실제와 오차 가능&lt;/li&gt;
&lt;li&gt;filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용&lt;/li&gt;
&lt;li&gt;Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려&lt;/li&gt;
&lt;li&gt;커버링 인덱스 구성 시 Extra의 Using index로 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기
위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 인덱서 가이드</title>
      <link>https://blog.jsontapose.com/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/</link>
      <pubDate>Mon, 13 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-indexer-concepts-architecture-checklist-e452a9/</guid>
      <description>&lt;h1 id=&#34;블록체인-인덱서-가이드&#34;&gt;블록체인 인덱서 가이드&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;인덱서는 원장 데이터를 제품 요구에 맞게 재구성해 저지연으로 제공하는 데이터 레이어임
디앱 체감 속도와 신뢰도를 좌우하는 핵심 인프라임&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;왜-인덱서가-필요한가&#34;&gt;왜 인덱서가 필요한가&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;블록체인 원장은 블록 단위 직렬 구조라 임의 접근과 조건 검색 비용 큼&lt;/li&gt;
&lt;li&gt;디앱은 지갑 이력, 포지션, NFT 보유 등 사용자 맥락 데이터를 수십~수백 ms 내에 필요로 함&lt;/li&gt;
&lt;li&gt;전체 원장을 매번 스캔하는 대신 목적형 보조 인덱스를 사전 구축해 API로 제공하는 전략이 효율적임&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;인덱싱-대상-데이터-유형&#34;&gt;인덱싱 대상 데이터 유형&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;블록 헤더와 트랜잭션 메타데이터&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용</title>
      <link>https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</link>
      <pubDate>Sat, 11 Oct 2025 13:05:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함
이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름
합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함
PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임
실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함&lt;/p&gt;
&lt;h3 id=&#34;합의가-필요한-이유와-기준&#34;&gt;합의가 필요한 이유와 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음&lt;/li&gt;
&lt;li&gt;활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨&lt;/li&gt;
&lt;li&gt;최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨&lt;/li&gt;
&lt;li&gt;시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요&lt;/li&gt;
&lt;li&gt;성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건&lt;/li&gt;
&lt;li&gt;탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pow-작업증명-핵심&#34;&gt;PoW 작업증명 핵심&lt;/h3&gt;
&lt;p&gt;정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조
구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요
난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행
보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미
장점&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 채굴 개념과 동작 원리 PoW 보상 구조 이더리움 전환 사례</title>
      <link>https://blog.jsontapose.com/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/</link>
      <pubDate>Mon, 06 Oct 2025 13:09:34 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-mining-explained-pow-rewards-ethereum-merge-1c487a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;채굴은 트랜잭션을 묶어 블록을 만들고 블록체인에 추가하는 행위이자, 네트워크를 공격으로부터 방어하는 핵심 보안 메커니즘임
역사적으로 비트코인과 이더리움은 작업증명 PoW 기반 채굴에 의존해 합의를 유지했음
이더리움은 2022년 9월 The Merge로 지분증명 PoS로 전환하여 블록 생성에 소모되는 에너지를 크게 줄였고, 지금은 채굴 대신 검증자 스테이킹이 사용됨
아래 내용은 채굴이 사용되던 시기의 개념과 동작 원리를 정리한 것으로, PoW 계열 네트워크나 역사적 맥락을 이해하는 데 목적이 있음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;블록체인 원장 네트워크 참여자가 공유하는 불변 기록 장부&lt;/li&gt;
&lt;li&gt;트랜잭션 계정 상태를 변화시키는 요청 또는 메시지&lt;/li&gt;
&lt;li&gt;채굴자 PoW 네트워크에서 블록을 제안하고 검증하는 주체&lt;/li&gt;
&lt;li&gt;작업증명 PoW 특정 해시 조건을 만족하는 값을 찾는 계산을 통해 블록의 정당성을 증명하는 합의 규칙&lt;/li&gt;
&lt;li&gt;난이도 difficulty 해시 조건의 엄격함을 조절하는 파라미터, 블록 생성 간격을 목표치로 수렴시키는 역할&lt;/li&gt;
&lt;li&gt;넌스 nonce 해시 목표를 만족하기 위해 반복적으로 변경하는 값&lt;/li&gt;
&lt;li&gt;메모리풀 mempool 블록에 포함되기 전 대기 중인 트랜잭션 집합&lt;/li&gt;
&lt;li&gt;블록 보상 block reward 채굴자가 새 블록을 유효하게 제안했을 때 받는 기본 보상과 수수료 총합&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;왜-채굴이-필요한가&#34;&gt;왜 채굴이 필요한가&lt;/h3&gt;
&lt;p&gt;탈중앙 시스템에서는 트랜잭션의 순서에 모두가 합의해야 이중지불을 막을 수 있음
예시 Alice가 Bob에게 1 단위를 보내고 Bob이 그 1 단위를 Charlie에게 보낼 때, 순서가 뒤섞이면 Bob이 실제 보유하지 않은 금액을 전송하려 시도하는 문제가 발생함
채굴자는 유효한 트랜잭션을 모아 순서 있게 블록에 넣고, 작업증명으로 해당 블록이 정당함을 증명함
PoW의 설계는 두 가지 속성을 가짐 생성은 어렵지만 검증은 쉬움&lt;/p&gt;</description>
    </item>
    <item>
      <title>Abstract L2 체인 개요와 설계 핵심: ZK Rollup, ZK Stack, 네이티브 계정 추상화, AGW</title>
      <link>https://blog.jsontapose.com/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/</link>
      <pubDate>Fri, 03 Oct 2025 13:07:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/abstract-l2-zk-rollup-zk-stack-account-abstraction-agw-dc7ec0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Abstract는 이더리움 보안을 상속하는 ZK Rollup 기반 L2 체인으로, 고비용·저처리량 한계를 완화하는 확장 층 제공 목표
ZK Stack으로 구축되어 체인 개발과 운영 구성 요소를 모듈화하고, 데이터 가용성은 EIP-4844 블롭을 활용해 비용을 절감하는 방향 추구
핵심 차별점은 네이티브 계정 추상화 기반의 트랜잭션 수명주기와 글로벌 지갑 레이어를 통한 사용자 온보딩 간소화에 있음&lt;/p&gt;
&lt;h3 id=&#34;배경과-목적&#34;&gt;배경과 목적&lt;/h3&gt;
&lt;p&gt;이더리움 메인넷의 처리량은 대략 초당 수십 건 수준이며, 수수료 변동성도 큼
저가치 대량 트랜잭션을 직접 L1에서 처리하는 것은 비현실적
L2의 목표는 탈중앙성과 보안을 유지하면서 처리량과 비용 효율을 동시에 개선하는 것
ZK Rollup은 유효성 증명을 통해 상태 전이를 압축·검증하여 온체인 데이터 요구량과 확정 시간을 줄이는 확장 경로 제공&lt;/p&gt;</description>
    </item>
    <item>
      <title>Viem으로 이더리움 읽기·쓰기 시작하기 가이드</title>
      <link>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</link>
      <pubDate>Thu, 02 Oct 2025 13:07:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임
ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음
프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Public Client&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트&lt;/li&gt;
&lt;li&gt;블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wallet Client&lt;/p&gt;</description>
    </item>
    <item>
      <title>영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이</title>
      <link>https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</link>
      <pubDate>Mon, 29 Sep 2025 13:10:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함
블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임
이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함&lt;/p&gt;
&lt;h2 id=&#34;목적과-맥락&#34;&gt;목적과 맥락&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비밀을 공개하지 않고 유효성만 검증하려는 요구 증가&lt;/li&gt;
&lt;li&gt;퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대&lt;/li&gt;
&lt;li&gt;오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체&lt;/li&gt;
&lt;li&gt;Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체&lt;/li&gt;
&lt;li&gt;Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식&lt;/li&gt;
&lt;li&gt;Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명&lt;/li&gt;
&lt;li&gt;Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제&lt;/li&gt;
&lt;li&gt;Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;영지식-증명의-세-가지-성질&#34;&gt;영지식 증명의 세 가지 성질&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨&lt;/li&gt;
&lt;li&gt;건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤&lt;/li&gt;
&lt;li&gt;영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;직관적-예시-알리바바-동굴&#34;&gt;직관적 예시 알리바바 동굴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음&lt;/li&gt;
&lt;li&gt;검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함&lt;/li&gt;
&lt;li&gt;Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2&lt;/li&gt;
&lt;li&gt;k회 독립 반복하면 모두 속일 확률 2^-k로 급감&lt;/li&gt;
&lt;li&gt;검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심 포인트&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 Reorg(체인 재구성) 이해</title>
      <link>https://blog.jsontapose.com/posts/blockchain-reorg-chain-reorganization-f4966a/</link>
      <pubDate>Sun, 28 Sep 2025 13:05:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-reorg-chain-reorganization-f4966a/</guid>
      <description>&lt;h2 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h2&gt;
&lt;p&gt;Reorg는 동시에 생성된 블록로 체인이 잠시 분기된 뒤 합의 규칙에 따라 더 우세한 분기로 갈아타는 상황을 뜻함
짧아진 분기에 있던 블록은 활성 체인에서 제외되어 존재하지 않았던 것으로 취급됨
노드는 자신의 로컬 관점에서 더 우세한 체인을 발견하면 그 체인으로 교체하는데 이 현상은 네트워크 전체가 동시에 일어나는 게 아니라 각 노드에서 국소적으로 발생함&lt;/p&gt;
&lt;h2 id=&#34;핵심-용어-정리&#34;&gt;핵심 용어 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스테일 블록 best chain에 편입되지 못한 정상 블록을 말함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오펀 블록 전통적으로 부모를 모르는 블록을 의미하지만 커뮤니티에선 스테일 블록과 혼용되는 경우가 많음&lt;/p&gt;</description>
    </item>
    <item>
      <title>커스토디얼 vs 논커스토디얼 월렛 비교</title>
      <link>https://blog.jsontapose.com/posts/custodial-vs-noncustodial-wallets-274b74/</link>
      <pubDate>Tue, 23 Sep 2025 13:09:26 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/custodial-vs-noncustodial-wallets-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;프라이빗키 관리 방식에 따라 암호화폐 월렛은 &lt;strong&gt;커스토디얼(custodial)&lt;/strong&gt; 과 &lt;strong&gt;논커스토디얼(noncustodial)&lt;/strong&gt; 로 구분됨
각 방식의 차이와 선택 기준, 보안·운영 리스크와 대응 방안을 &lt;strong&gt;초보자도 이해할 수 있게&lt;/strong&gt; 정리하면서 &lt;strong&gt;실무자가 바로 적용할 수 있는 체크리스트&lt;/strong&gt;까지 제시함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;커스토디얼 월렛&lt;/strong&gt;
제3자 서비스가 사용자의 프라이빗키를 보관하고 서명을 대행하는 구조
로그인·출금 등은 서비스 인증 절차를 거쳐 처리됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;논커스토디얼 월렛&lt;/strong&gt;
사용자가 프라이빗키를 직접 보유·관리하는 구조
브라우저 확장 지갑·모바일 앱 지갑·하드웨어 지갑이 대표적 사례임&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;핵심 차이 한 줄 정리&lt;/strong&gt;
키의 &lt;strong&gt;소유·통제 주체&lt;/strong&gt;가 제3자인가 사용자 본인인가의 차이&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인이란? 블록체인 개념 총정리</title>
      <link>https://blog.jsontapose.com/posts/blockchain-principles-mining-hash-274b74/</link>
      <pubDate>Mon, 22 Sep 2025 13:10:11 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-principles-mining-hash-274b74/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;블록체인은 &lt;strong&gt;중앙 기관 없이&lt;/strong&gt; 참여자들이 거래를 기록·검증·공유하는 &lt;strong&gt;분산 원장&lt;/strong&gt; 기술임
이 글은 블록체인을 &lt;strong&gt;초보자 친화적으로&lt;/strong&gt; 설명하고, &lt;strong&gt;실무 체크리스트&lt;/strong&gt;까지 정리함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;큰-그림-시스템-구성&#34;&gt;큰 그림: 시스템 구성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;노드(Node)&lt;/strong&gt;: 블록체인 소프트웨어 실행 주체&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;풀노드&lt;/strong&gt;: 모든 블록·트랜잭션 검증·저장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;라이트 클라이언트&lt;/strong&gt;: 헤더·머클 증명 기반 최소 검증&lt;/li&gt;
&lt;li&gt;(참고) &lt;strong&gt;아카이브 노드&lt;/strong&gt;: 오래된 상태 포함 전체 상태 유지(필수 아님)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;블록(Block)&lt;/strong&gt;: 트랜잭션 묶음 + 메타데이터(블록헤더). 블록들이 선형 체인으로 연결됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;합의(Consensus)&lt;/strong&gt;: 어떤 블록이 정식 이력인지 네트워크가 &lt;strong&gt;공동으로&lt;/strong&gt; 결정하는 규칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PoW: 작업증명(연산 경쟁)&lt;/li&gt;
&lt;li&gt;PoS: 지분증명(검증자·보증금 기반)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;해시hash와-위변조-방지&#34;&gt;해시(Hash)와 위·변조 방지&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;해시 함수(SHA-256, Keccak-256 등)&lt;/strong&gt;: 입력을 고정 길이로 압축하는 일방향 함수임&lt;/p&gt;</description>
    </item>
    <item>
      <title>이더리움 PoS(Proof of Stake) 소개</title>
      <link>https://blog.jsontapose.com/posts/ethereum-pos-proof-of-stake-274b74/</link>
      <pubDate>Sat, 20 Sep 2025 17:04:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ethereum-pos-proof-of-stake-274b74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;이 문서는 이더리움의 PoS 합의 구조와 구성 요소를 정리함
개념 정의에 그치지 않고 &lt;strong&gt;운영 시 주의점&lt;/strong&gt;, &lt;strong&gt;보상·출금 흐름&lt;/strong&gt;, &lt;strong&gt;짧은 체인 재구성(Reorg) 원인과 완화책&lt;/strong&gt;까지 다룸&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;PoS는 PoW의 에너지 경쟁을 대체해 &lt;strong&gt;예치된 지분을 바탕으로 검증자를 선정&lt;/strong&gt;하는 합의 메커니즘임
이더리움은 2022년 9월 더 머지 이후 PoS로 전환했고 전력 소비를 크게 줄이며 &lt;strong&gt;검증자 기반 보안 모델&lt;/strong&gt;로 이행함&lt;/p&gt;
&lt;p&gt;주요 속성 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에너지 소비 대폭 축소&lt;/li&gt;
&lt;li&gt;스테이킹한 ETH 규모에 비례해 역할 참여 기회가 부여됨&lt;/li&gt;
&lt;li&gt;위반 시 슬래싱과 페널티로 예치금이 감소함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;계층-분리와-beacon-chain의-역할&#34;&gt;계층 분리와 Beacon Chain의 역할&lt;/h3&gt;
&lt;p&gt;이더리움은 &lt;strong&gt;합의 계층(Beacon Chain)&lt;/strong&gt; 과 &lt;strong&gt;실행 계층(Execution Layer)&lt;/strong&gt; 를 분리해 설계함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFT 핵심 용어 정리</title>
      <link>https://blog.jsontapose.com/posts/nft-23q12akw/</link>
      <pubDate>Sat, 20 Sep 2025 16:56:17 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nft-23q12akw/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NFT 커뮤니티 초입에서 마주치는 용어 장벽을 낮추기 위해 &lt;strong&gt;리빌&lt;/strong&gt;, &lt;strong&gt;에어드롭&lt;/strong&gt;, &lt;strong&gt;화이트리스트&lt;/strong&gt;, &lt;strong&gt;마켓플레이스&lt;/strong&gt;를 실무 관점으로 정리함
핵심은 개념 이해를 넘어 &lt;strong&gt;운영 체크리스트&lt;/strong&gt;, &lt;strong&gt;보안 리스크&lt;/strong&gt;, &lt;strong&gt;가격 형성 메커니즘&lt;/strong&gt;까지 파악해 프로젝트 참여와 거래 판단에 바로 쓰도록 하는 것임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;공통-전제와-기본-개념&#34;&gt;공통 전제와 기본 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFT 표준&lt;/strong&gt;
주로 ERC‑721과 ERC‑1155를 사용함
721은 1토큰 1소유 형태에 적합, 1155는 대량 발행·세미펀지블에 유리함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메타데이터와 저장소&lt;/strong&gt;
토큰 URI가 가리키는 메타데이터는 IPFS나 Arweave 등 영속 스토리지 사용 권장
중앙화 서버만 쓰면 리빌 이후 임의 변경 리스크가 커짐&lt;/p&gt;</description>
    </item>
    <item>
      <title>NFT란? NFT 핵심 개념 정리</title>
      <link>https://blog.jsontapose.com/posts/nft-concept-20gd0fl/</link>
      <pubDate>Sat, 20 Sep 2025 16:41:07 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nft-concept-20gd0fl/</guid>
      <description>&lt;h3 id=&#34;서문&#34;&gt;서문&lt;/h3&gt;
&lt;p&gt;NFT는 몇 년 새 대중의 관심을 받았지만 개념과 절차가 분산돼 있어 입문자가 막히기 쉬움
이 글은 &lt;strong&gt;실무자 관점&lt;/strong&gt;에서 NFT의 핵심 개념을 단계적으로 정리하고 &lt;strong&gt;구매·발행·보관 시 유의사항&lt;/strong&gt;과 &lt;strong&gt;운영 관행&lt;/strong&gt;을 담는 것을 목표로 함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;NFT는 Non‑Fungible Token의 약자이며 대체 불가능한 토큰을 의미함
동일 단위끼리 교환 가능한 자산은 펀저블 토큰이라 부르고 NFT는 각 토큰이 &lt;strong&gt;고유 식별자와 속성&lt;/strong&gt;을 가져 상호 교환 시 동일 가치를 보장하지 않음
블록체인에 기록된 소유권은 변경이 어렵고 거래 이력이 투명하게 남는다는 장점이 있음
온체인 소유권이 &lt;strong&gt;저작권·초상권 등 법적 권리와 자동 동치가 아님&lt;/strong&gt;에 유의해야 함&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
