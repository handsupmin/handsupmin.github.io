<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 | HandsLog</title>
<meta name=keywords content="mysql,innodb,indexing,clustered-index,secondary-index,b-tree,query-optimization,execution-plan"><meta name=description content="개요
테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함

Primary Key 지정 시 클러스터드 인덱스 생성
Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성

MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함
핵심 개념 정리


클러스터드 인덱스

테이블 데이터가 인덱스 키 순서로 정리되는 구조
테이블당 하나만 존재
리프 노드가 실제 레코드(전체 컬럼)를 보유
InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨
PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용



논클러스터드 인덱스(보조 인덱스, Secondary Index)"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준"><meta property="og:description" content="개요 테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임 인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함
Primary Key 지정 시 클러스터드 인덱스 생성 Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성 MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함
핵심 개념 정리 클러스터드 인덱스
테이블 데이터가 인덱스 키 순서로 정리되는 구조 테이블당 하나만 존재 리프 노드가 실제 레코드(전체 컬럼)를 보유 InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨 PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용 논클러스터드 인덱스(보조 인덱스, Secondary Index)"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-14T13:09:03+00:00"><meta property="article:modified_time" content="2025-12-14T13:09:03+00:00"><meta property="article:tag" content="Mysql"><meta property="article:tag" content="Innodb"><meta property="article:tag" content="Indexing"><meta property="article:tag" content="Clustered-Index"><meta property="article:tag" content="Secondary-Index"><meta property="article:tag" content="B-Tree"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준"><meta name=twitter:description content="개요
테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함

Primary Key 지정 시 클러스터드 인덱스 생성
Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성

MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함
핵심 개념 정리


클러스터드 인덱스

테이블 데이터가 인덱스 키 순서로 정리되는 구조
테이블당 하나만 존재
리프 노드가 실제 레코드(전체 컬럼)를 보유
InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨
PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용



논클러스터드 인덱스(보조 인덱스, Secondary Index)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준","item":"https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준","name":"MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준","description":"개요 테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임 인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함\nPrimary Key 지정 시 클러스터드 인덱스 생성 Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성 MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함\n핵심 개념 정리 클러스터드 인덱스\n테이블 데이터가 인덱스 키 순서로 정리되는 구조 테이블당 하나만 존재 리프 노드가 실제 레코드(전체 컬럼)를 보유 InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨 PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용 논클러스터드 인덱스(보조 인덱스, Secondary Index)\n","keywords":["mysql","innodb","indexing","clustered-index","secondary-index","b-tree","query-optimization","execution-plan"],"articleBody":"개요 테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임 인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함\nPrimary Key 지정 시 클러스터드 인덱스 생성 Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성 MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함\n핵심 개념 정리 클러스터드 인덱스\n테이블 데이터가 인덱스 키 순서로 정리되는 구조 테이블당 하나만 존재 리프 노드가 실제 레코드(전체 컬럼)를 보유 InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨 PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용 논클러스터드 인덱스(보조 인덱스, Secondary Index)\n테이블에 여러 개 생성 가능 리프 노드가 인덱스 키와 함께 클러스터드 인덱스 키(PK 또는 내부 Row ID)를 보유 보조 인덱스로 찾은 키로 다시 클러스터드 인덱스를 탐색하는 백투테이블 단계 발생 인덱스는 조회 성능 향상을 위해 쓰되, 인덱스가 늘어날수록 CUD 비용과 저장 공간이 증가하는 트레이드오프 존재\n동작 원리와 구조 B+Tree 탐색 흐름\n수직 탐색에서 루트 → 브랜치 → 리프 순으로 키 범위를 좁힘 보조 인덱스 사용 시 리프에서 얻은 클러스터드 키로 한 번 더 수직 탐색 수행 수평 탐색으로 리프 레벨에서 연속 키 스캔 가능 커버링 인덱스\n쿼리에 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 없이 인덱스만으로 결과 생성 추가 I/O 회피로 레이턴시 절감 접근 패턴과 I/O 특성\n시퀀셜 액세스: 물리적으로 인접한 페이지를 연속 읽기, 멀티 블록 I/O 활용, 대량 읽기에 유리 랜덤 액세스: 물리적으로 떨어진 페이지에 임의 접근, 단일 블록 I/O 빈번, 보조 인덱스 사용 시 다수 발생 SSD 환경에서도 무작위 접근 비용은 존재, 범위 스캔 대량 발생 시 체감 가능 InnoDB에서의 물리 정렬에 대한 오해 정리\n클러스터드 인덱스는 페이지 단위로 키 순서를 유지하도록 관리되지만, 디스크 상에서 완전한 순차 배치가 되는 것은 아님 랜덤 삽입이나 페이지 분할이 반복되면 물리적 연속성이 낮아질 수 있음 단조 증가 PK(auto increment 등) 사용 시 페이지 분할과 랜덤 쓰기 감소 효과 기대 MySQL 실행 흐름과 옵티마이저 관점 쿼리 캐시\nMySQL 8.0에서 제거됨 파싱과 전처리\n문법 검증 및 의미 분석 수행 최적화 단계\n실행계획 생성 조건 절 분류, 인덱스 선택, 조인 순서 결정 통계 정보와 비용 모델 기반으로 테이블 풀 스캔과 인덱스 스캔 중 비용이 낮은 경로 선택 스토리지 엔진 핸들러\nInnoDB가 페이지 읽기와 버퍼풀 관리를 담당 MySQL 엔진은 반환된 레코드로 조인, 정렬, 집계를 수행 실행 계획 확인\nEXPLAIN으로 실제 접근 경로 점검 권장 테이블 풀 스캔 vs 인덱스 레인지 스캔 Table Full Scan\n테이블 전체를 시퀀셜 액세스로 읽으며 멀티 블록 I/O 활용 큰 테이블에서 대량 결과 반환 시 효율적 Index Range Scan\n인덱스 트리에서 범위 탐색 후 필요 시 백투테이블 단계 수행 랜덤 액세스와 단일 블록 I/O가 많아지는 경향 작은 결과 집합을 빠르게 찾는 데 유리 손익분기점 관찰치\n데이터 규모와 하드웨어, 버퍼풀 히트율에 따라 달라짐 업무 환경에서 5~20% 선택도 구간에서 테이블 풀 스캔이 더 빠르게 전환되는 사례 빈번 빅테이블에서 결과 비율이 높아질수록 인덱스 경로는 점진적으로 불리 인덱스 설계 시 주의와 베스트 프랙티스 모든 WHERE 조건에 인덱스 남발 금지\n각 인덱스는 쓰기 비용과 저장 공간 증가를 동반 다수 인덱스는 옵티마이저 선택 혼선을 키울 수 있음 PK 설계\n짧고 단조 증가하는 키 선호 무작위 UUID v4는 페이지 분할과 랜덤 쓰기 유발 위험, 시간순 UUID 대안 고려 보조 인덱스 구성\n선택도 높은 컬럼 우선 결합 인덱스는 좌측 접두사 규칙 고려, 자주 결합되는 조건 묶기 커버링 인덱스가 큰 이득을 주는 빈도 높은 쿼리에 한정 적용 SARGable 조건 유지\n인덱스 컬럼에 함수 적용, 계산, 캐스팅이 있으면 인덱스 사용 저해 가능성 가능한 원형 비교 유지, 필요한 경우 생성 칼럼과 인덱스 조합 검토 통계와 실행 계획 점검\nANALYZE TABLE로 통계 최신화 EXPLAIN, 실행 프로파일링으로 계획 검증 저장 공간과 CUD 비용 이해\n추가 인덱스마다 페이지 유지와 분할, 리밸런싱 비용 증가 저장 공간 증가는 인덱스 키 길이와 카디널리티에 의존, 대략 테이블 크기의 두 자릿수 퍼센트까지 늘어날 수 있음 간단 예시 인덱스 생성 예\n단일 컬럼 ALTER TABLE UserTable ADD INDEX idx_closed_at (closed_at) 다중 컬럼 ALTER TABLE UserTable ADD INDEX idx_created_lastmod (created_at, last_modified_at) 조회 예\n전체 조회는 테이블 풀 스캔 경로 선택 가능성 높음 SELECT * FROM EmployeeTable PK로 단건 조회는 클러스터드 인덱스 탐색 경로 SELECT * FROM EmployeeTable WHERE employee_id = 1 보조 인덱스 컬럼 조회는 인덱스 레인지 스캔 후 백투테이블 SELECT * FROM EmployeeTable WHERE name = 'Kim' 커버링 인덱스 예\nINDEX(name, created_at)가 있고 SELECT name, created_at FROM EmployeeTable WHERE name = 'Kim' 처럼 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 생략 가능 언제 풀 스캔이 더 나은가 결과 비율이 높아 랜덤 액세스가 폭증하는 경우 조건이 낮은 선택도로 인덱스 이득이 미미한 경우 정렬이나 조인 전략 관점에서 풀 스캔이 총비용이 낮게 추정되는 경우 경계값은 시스템마다 상이하므로 실제 데이터로 벤치마킹하여 결정하는 것이 안전\n요약과 결론 클러스터드 인덱스는 테이블 자체의 정렬 구조, 보조 인덱스는 검색 보조 구조 소량 결과를 빠르게 찾을 때는 보조 인덱스 경로, 대량 읽기에는 풀 스캔이 유리한 구간 존재 인덱스는 비용이 있는 도구, 자주 쓰이는 고선택도 조건과 커버링 효과가 큰 쿼리에 집중 투자 PK는 짧고 단조 증가하는 키가 안전, 보조 인덱스는 쿼리 패턴 기반으로 최소 집합 유지 EXPLAIN과 통계 최신화를 통해 계획을 검증하고, 쿼리와 데이터 특성에 맞춰 지속 조정 참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html https://dev.mysql.com/doc/refman/8.0/en/query-cache.html https://www.sqlservercentral.com/articles/nonclustered-index-structure https://sihyung92.oopy.io/database/mysql-index ","wordCount":"809","inLanguage":"en","datePublished":"2025-12-14T13:09:03.639Z","dateModified":"2025-12-14T13:09:03.639Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준</h1><div class=post-meta><span title='2025-12-14 13:09:03.639 +0000 UTC'>December 14, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함</p><ul><li>Primary Key 지정 시 클러스터드 인덱스 생성</li><li>Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성</li></ul><p>MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함</p><h3 id=핵심-개념-정리>핵심 개념 정리<a hidden class=anchor aria-hidden=true href=#핵심-개념-정리>#</a></h3><ul><li><p>클러스터드 인덱스</p><ul><li>테이블 데이터가 인덱스 키 순서로 정리되는 구조</li><li>테이블당 하나만 존재</li><li>리프 노드가 실제 레코드(전체 컬럼)를 보유</li><li>InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨</li><li>PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용</li></ul></li><li><p>논클러스터드 인덱스(보조 인덱스, Secondary Index)</p><ul><li>테이블에 여러 개 생성 가능</li><li>리프 노드가 인덱스 키와 함께 클러스터드 인덱스 키(PK 또는 내부 Row ID)를 보유</li><li>보조 인덱스로 찾은 키로 다시 클러스터드 인덱스를 탐색하는 백투테이블 단계 발생</li></ul></li><li><p>인덱스는 조회 성능 향상을 위해 쓰되, 인덱스가 늘어날수록 CUD 비용과 저장 공간이 증가하는 트레이드오프 존재</p></li></ul><h3 id=동작-원리와-구조>동작 원리와 구조<a hidden class=anchor aria-hidden=true href=#동작-원리와-구조>#</a></h3><ul><li><p>B+Tree 탐색 흐름</p><ul><li>수직 탐색에서 루트 → 브랜치 → 리프 순으로 키 범위를 좁힘</li><li>보조 인덱스 사용 시 리프에서 얻은 클러스터드 키로 한 번 더 수직 탐색 수행</li><li>수평 탐색으로 리프 레벨에서 연속 키 스캔 가능</li></ul></li><li><p>커버링 인덱스</p><ul><li>쿼리에 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 없이 인덱스만으로 결과 생성</li><li>추가 I/O 회피로 레이턴시 절감</li></ul></li><li><p>접근 패턴과 I/O 특성</p><ul><li>시퀀셜 액세스: 물리적으로 인접한 페이지를 연속 읽기, 멀티 블록 I/O 활용, 대량 읽기에 유리</li><li>랜덤 액세스: 물리적으로 떨어진 페이지에 임의 접근, 단일 블록 I/O 빈번, 보조 인덱스 사용 시 다수 발생</li><li>SSD 환경에서도 무작위 접근 비용은 존재, 범위 스캔 대량 발생 시 체감 가능</li></ul></li><li><p>InnoDB에서의 물리 정렬에 대한 오해 정리</p><ul><li>클러스터드 인덱스는 페이지 단위로 키 순서를 유지하도록 관리되지만, 디스크 상에서 완전한 순차 배치가 되는 것은 아님</li><li>랜덤 삽입이나 페이지 분할이 반복되면 물리적 연속성이 낮아질 수 있음</li><li>단조 증가 PK(auto increment 등) 사용 시 페이지 분할과 랜덤 쓰기 감소 효과 기대</li></ul></li></ul><h3 id=mysql-실행-흐름과-옵티마이저-관점>MySQL 실행 흐름과 옵티마이저 관점<a hidden class=anchor aria-hidden=true href=#mysql-실행-흐름과-옵티마이저-관점>#</a></h3><ul><li><p>쿼리 캐시</p><ul><li>MySQL 8.0에서 제거됨</li></ul></li><li><p>파싱과 전처리</p><ul><li>문법 검증 및 의미 분석 수행</li></ul></li><li><p>최적화 단계</p><ul><li>실행계획 생성</li><li>조건 절 분류, 인덱스 선택, 조인 순서 결정</li><li>통계 정보와 비용 모델 기반으로 테이블 풀 스캔과 인덱스 스캔 중 비용이 낮은 경로 선택</li></ul></li><li><p>스토리지 엔진 핸들러</p><ul><li>InnoDB가 페이지 읽기와 버퍼풀 관리를 담당</li><li>MySQL 엔진은 반환된 레코드로 조인, 정렬, 집계를 수행</li></ul></li><li><p>실행 계획 확인</p><ul><li>EXPLAIN으로 실제 접근 경로 점검 권장</li></ul></li></ul><h3 id=테이블-풀-스캔-vs-인덱스-레인지-스캔>테이블 풀 스캔 vs 인덱스 레인지 스캔<a hidden class=anchor aria-hidden=true href=#테이블-풀-스캔-vs-인덱스-레인지-스캔>#</a></h3><ul><li><p>Table Full Scan</p><ul><li>테이블 전체를 시퀀셜 액세스로 읽으며 멀티 블록 I/O 활용</li><li>큰 테이블에서 대량 결과 반환 시 효율적</li></ul></li><li><p>Index Range Scan</p><ul><li>인덱스 트리에서 범위 탐색 후 필요 시 백투테이블 단계 수행</li><li>랜덤 액세스와 단일 블록 I/O가 많아지는 경향</li><li>작은 결과 집합을 빠르게 찾는 데 유리</li></ul></li><li><p>손익분기점 관찰치</p><ul><li>데이터 규모와 하드웨어, 버퍼풀 히트율에 따라 달라짐</li><li>업무 환경에서 5~20% 선택도 구간에서 테이블 풀 스캔이 더 빠르게 전환되는 사례 빈번</li><li>빅테이블에서 결과 비율이 높아질수록 인덱스 경로는 점진적으로 불리</li></ul></li></ul><h3 id=인덱스-설계-시-주의와-베스트-프랙티스>인덱스 설계 시 주의와 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#인덱스-설계-시-주의와-베스트-프랙티스>#</a></h3><ul><li><p>모든 WHERE 조건에 인덱스 남발 금지</p><ul><li>각 인덱스는 쓰기 비용과 저장 공간 증가를 동반</li><li>다수 인덱스는 옵티마이저 선택 혼선을 키울 수 있음</li></ul></li><li><p>PK 설계</p><ul><li>짧고 단조 증가하는 키 선호</li><li>무작위 UUID v4는 페이지 분할과 랜덤 쓰기 유발 위험, 시간순 UUID 대안 고려</li></ul></li><li><p>보조 인덱스 구성</p><ul><li>선택도 높은 컬럼 우선</li><li>결합 인덱스는 좌측 접두사 규칙 고려, 자주 결합되는 조건 묶기</li><li>커버링 인덱스가 큰 이득을 주는 빈도 높은 쿼리에 한정 적용</li></ul></li><li><p>SARGable 조건 유지</p><ul><li>인덱스 컬럼에 함수 적용, 계산, 캐스팅이 있으면 인덱스 사용 저해 가능성</li><li>가능한 원형 비교 유지, 필요한 경우 생성 칼럼과 인덱스 조합 검토</li></ul></li><li><p>통계와 실행 계획 점검</p><ul><li>ANALYZE TABLE로 통계 최신화</li><li>EXPLAIN, 실행 프로파일링으로 계획 검증</li></ul></li><li><p>저장 공간과 CUD 비용 이해</p><ul><li>추가 인덱스마다 페이지 유지와 분할, 리밸런싱 비용 증가</li><li>저장 공간 증가는 인덱스 키 길이와 카디널리티에 의존, 대략 테이블 크기의 두 자릿수 퍼센트까지 늘어날 수 있음</li></ul></li></ul><h3 id=간단-예시>간단 예시<a hidden class=anchor aria-hidden=true href=#간단-예시>#</a></h3><ul><li><p>인덱스 생성 예</p><ul><li>단일 컬럼<ul><li><code>ALTER TABLE UserTable ADD INDEX idx_closed_at (closed_at)</code></li></ul></li><li>다중 컬럼<ul><li><code>ALTER TABLE UserTable ADD INDEX idx_created_lastmod (created_at, last_modified_at)</code></li></ul></li></ul></li><li><p>조회 예</p><ul><li>전체 조회는 테이블 풀 스캔 경로 선택 가능성 높음</li><li><code>SELECT * FROM EmployeeTable</code></li><li>PK로 단건 조회는 클러스터드 인덱스 탐색 경로</li><li><code>SELECT * FROM EmployeeTable WHERE employee_id = 1</code></li><li>보조 인덱스 컬럼 조회는 인덱스 레인지 스캔 후 백투테이블</li><li><code>SELECT * FROM EmployeeTable WHERE name = 'Kim'</code></li></ul></li><li><p>커버링 인덱스 예</p><ul><li><code>INDEX(name, created_at)</code>가 있고 <code>SELECT name, created_at FROM EmployeeTable WHERE name = 'Kim'</code> 처럼 필요한 컬럼이 인덱스에 모두 포함된 경우 백투테이블 생략 가능</li></ul></li></ul><h3 id=언제-풀-스캔이-더-나은가>언제 풀 스캔이 더 나은가<a hidden class=anchor aria-hidden=true href=#언제-풀-스캔이-더-나은가>#</a></h3><ul><li>결과 비율이 높아 랜덤 액세스가 폭증하는 경우</li><li>조건이 낮은 선택도로 인덱스 이득이 미미한 경우</li><li>정렬이나 조인 전략 관점에서 풀 스캔이 총비용이 낮게 추정되는 경우</li></ul><p>경계값은 시스템마다 상이하므로 실제 데이터로 벤치마킹하여 결정하는 것이 안전</p><h3 id=요약과-결론>요약과 결론<a hidden class=anchor aria-hidden=true href=#요약과-결론>#</a></h3><ul><li>클러스터드 인덱스는 테이블 자체의 정렬 구조, 보조 인덱스는 검색 보조 구조</li><li>소량 결과를 빠르게 찾을 때는 보조 인덱스 경로, 대량 읽기에는 풀 스캔이 유리한 구간 존재</li><li>인덱스는 비용이 있는 도구, 자주 쓰이는 고선택도 조건과 커버링 효과가 큰 쿼리에 집중 투자</li><li>PK는 짧고 단조 증가하는 키가 안전, 보조 인덱스는 쿼리 패턴 기반으로 최소 집합 유지</li><li>EXPLAIN과 통계 최신화를 통해 계획을 검증하고, 쿼리와 데이터 특성에 맞춰 지속 조정</li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html>https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html>https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/query-cache.html>https://dev.mysql.com/doc/refman/8.0/en/query-cache.html</a></li><li><a href=https://www.sqlservercentral.com/articles/nonclustered-index-structure>https://www.sqlservercentral.com/articles/nonclustered-index-structure</a></li><li><a href=https://sihyung92.oopy.io/database/mysql-index>https://sihyung92.oopy.io/database/mysql-index</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/mysql/>Mysql</a></li><li><a href=https://blog.jsontapose.com/tags/innodb/>Innodb</a></li><li><a href=https://blog.jsontapose.com/tags/indexing/>Indexing</a></li><li><a href=https://blog.jsontapose.com/tags/clustered-index/>Clustered-Index</a></li><li><a href=https://blog.jsontapose.com/tags/secondary-index/>Secondary-Index</a></li><li><a href=https://blog.jsontapose.com/tags/b-tree/>B-Tree</a></li><li><a href=https://blog.jsontapose.com/tags/query-optimization/>Query-Optimization</a></li><li><a href=https://blog.jsontapose.com/tags/execution-plan/>Execution-Plan</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/ethereum-gas-gas-limit-gas-price-eip-1559-157947/><span class=title>« Prev</span><br><span>이더리움 가스 이해하기: Gas Limit, Gas Price, EIP-1559 정리</span>
</a><a class=next href=https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/><span class=title>Next »</span><br><span>사이드카 패턴 이해와 도입 판단 가이드: 마이크로서비스·쿠버네티스에서의 활용</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on x" href="https://x.com/intent/tweet/?text=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f&amp;hashtags=mysql%2cinnodb%2cindexing%2cclustered-index%2csecondary-index%2cb-tree%2cquery-optimization%2cexecution-plan"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f&amp;title=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;summary=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f&title=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on whatsapp" href="https://api.whatsapp.com/send?text=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on telegram" href="https://telegram.me/share/url?text=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준 on ycombinator" href="https://news.ycombinator.com/submitlink?t=MySQL%20%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%ec%99%80%20%eb%85%bc%ed%81%b4%eb%9f%ac%ec%8a%a4%ed%84%b0%eb%93%9c%20%ec%9d%b8%eb%8d%b1%ec%8a%a4%20%ec%9d%b4%ed%95%b4%ec%99%80%20%ec%84%a0%ed%83%9d%20%ea%b8%b0%ec%a4%80&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fmysql-clustered-vs-nonclustered-index-f925e0%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>