<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 | HandsLog</title>
<meta name=keywords content="prisma,orm,join,sql,data-mapper,active-record,database,nodejs"><meta name=description content="개요
Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음
Prisma에서는 JOIN이 어디로 갔나 하는 질문임
개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음
정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함
ORM이란 무엇인가
ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함
애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공
SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능
데이터베이스 의존성 완화 효과 기대"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리"><meta property="og:description" content="개요 Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음 Prisma에서는 JOIN이 어디로 갔나 하는 질문임 개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음 정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함
ORM이란 무엇인가 ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함 애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공 SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능 데이터베이스 의존성 완화 효과 기대"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-23T13:06:21+00:00"><meta property="article:modified_time" content="2025-11-23T13:06:21+00:00"><meta property="article:tag" content="Prisma"><meta property="article:tag" content="Orm"><meta property="article:tag" content="Join"><meta property="article:tag" content="Sql"><meta property="article:tag" content="Data-Mapper"><meta property="article:tag" content="Active-Record"><meta name=twitter:card content="summary"><meta name=twitter:title content="Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리"><meta name=twitter:description content="개요
Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음
Prisma에서는 JOIN이 어디로 갔나 하는 질문임
개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음
정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함
ORM이란 무엇인가
ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함
애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공
SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능
데이터베이스 의존성 완화 효과 기대"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리","item":"https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리","name":"Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리","description":"개요 Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음 Prisma에서는 JOIN이 어디로 갔나 하는 질문임 개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음 정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함\nORM이란 무엇인가 ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함 애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공 SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능 데이터베이스 의존성 완화 효과 기대\n","keywords":["prisma","orm","join","sql","data-mapper","active-record","database","nodejs"],"articleBody":"개요 Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음 Prisma에서는 JOIN이 어디로 갔나 하는 질문임 개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음 정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함\nORM이란 무엇인가 ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함 애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공 SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능 데이터베이스 의존성 완화 효과 기대\nActive Record vs Data Mapper ORM 구현 패턴은 크게 두 가지로 요약됨\nActive Record 패턴\n클래스와 테이블의 동치에 가까운 모델링 필드가 컬럼, 인스턴스가 레코드에 대응 접근·조작 로직이 모델에 함께 존재 데이터베이스 스키마 변화에 코드가 민감하게 결합되는 단점 Data Mapper 패턴\n모델과 데이터베이스를 분리하는 매핑 계층 존재 엔티티 클래스와 매퍼 클래스를 분리 정의 유연성 증가 대신 클래스 수 증가와 변화 추적 복잡도 상승 가능 일반적으로 ORM은 공통 CRUD와 쿼리 API를 제공하고, 세부 패턴은 프레임워크가 선택하거나 혼합 지원함\nPrisma와 스키마 중심 모델링 Prisma는 Data Mapper 계열이지만, 자체 스키마를 중심으로 모델·마이그레이션·Client를 모두 생성하는 점이 특징임 단일 스키마 파일에서 데이터베이스 스키마와 Prisma Client가 동시에 파생됨 @map()을 통해 애플리케이션의 명명 규칙과 데이터베이스 물리명 분리 가능\n예시 스키마 최소 발췌\nmodel Notice { id Int @id @default(autoincrement()) createdBy User @relation(fields: [createdById], references: [id]) createdById Int @map(\"created_by_id\") group Group @relation(fields: [groupId], references: [id]) groupId Int @map(\"group_id\") title String } Prisma Client는 이 스키마를 근거로 타입 안정성이 확보된 쿼리 API를 제공함\nPrisma에는 JOIN이 없나 Prisma Client 메소드 목록에는 JOIN이 존재하지 않음 서브쿼리도 직접 제공되지 않음 그렇다면 관계형 조회는 어떻게 수행되는가가 핵심 포인트임\n기본적인 include 사용 예시\nawait prisma.notice.findMany({ include: { group: true, }, }) 특정 컬럼만 선택하고 싶다면 select 사용\nconst notices: Array\u003c{ id: number title: string group: { groupName: string } }\u003e = await prisma.notice.findMany({ select: { id: true, title: true, group: { select: { groupName: true }, }, }, }) 내부적으로 JOIN을 쓰는가 직관적으로는 JOIN 또는 서브쿼리로 변환될 것 같지만, Prisma는 관계 쿼리를 다중 SELECT로 분해해 전송함 일반적인 패턴은 부모 테이블 조회 후 자식 테이블을 IN 절로 한 번 더 조회하는 형태임\n예시 로그 형태 요약\nSELECT Notice.id, Notice.title, Notice.groupId FROM Notice ... SELECT Group.id, Group.groupName FROM Group WHERE Group.id IN (...) ... 코어 엔진이 이 결과들을 클라이언트 메모리에서 합성하고, include 또는 select로 요청한 nested 구조를 만들어 반환함 스키마의 @relation 정보는 실제 데이터베이스 컬럼으로 생기지 않지만, 타입 안전성과 결과 합성에 필요한 메타로 쓰임\n성능과 트레이드오프 JOIN이 없는 전략은 범용성 측면에서 장점이 있음\n다중 데이터베이스 지원 용이 커넥터 구현 부담 감소 쿼리 엔진이 공통 로직을 재사용하기 쉬움 반면 성능 리스크 존재\n다중 SELECT에 따른 왕복 비용 증가 가능 넓은 테이블 스캔 또는 부적절한 WHERE 인덱스 사용 시 비용 급증 대용량 데이터셋에서 JOIN 대비 비효율 가능성 높음 결론적으로 관계형 데이터베이스에서 최적화된 조인 실행 계획을 활용하지 못할 수 있음 크리티컬 경로에서는 성능 검증 필요\n필요한 경우 JOIN을 쓰는 방법 ORM 순수 사용 원칙에서는 벗어나지만, Prisma에서는 raw query로 JOIN 사용 가능 핫패스나 리포트성 대용량 집계처럼 조인이 본질적인 영역에서는 고려 가치 있음 프로그래밍 모델은 Prisma Client를 유지하되 특정 쿼리만 raw로 대체하는 하이브리드 전략 권장\n단일 책임 함수로 캡슐화 입력 검증과 SQL 인젝션 방지 매개 API 사용 스키마 변경 시 회귀 테스트로 커버 참고 문서 확인 권장\n왜 처음부터 JOIN을 쓰지 않았나 역사적 배경상 Prisma의 목표는 전통적 ORM 최적화가 아니라 다중 데이터베이스를 아우르는 가상 데이터베이스 레이어에 가까웠음\n코어 엔진에 공통 로직 집중, 커넥터는 최소한의 변환만 수행하는 구조 지향 MongoDB처럼 JOIN이 없는 시스템도 지원해야 했음 따라서 쿼리를 가장 단순한 형태로 쪼개어 처리하는 전략이 합리적 선택이었음 현 시점에서는 사용자 기반이 커지며 전통적 ORM 기대치도 함께 커짐 Prisma 팀 역시 크리티컬 케이스에서 JOIN 기반 생성 지원을 추진 중이라고 알려짐 과거의 범용성 우선 전략에서, 실용적 성능과 개발 경험을 균형 있게 보완하는 과도기로 보는 편이 타당함\n마무리 Prisma에는 개발자 API 차원에서 JOIN이 없음 실행 단계에서도 기본적으로 다중 SELECT 후 결과 합성 전략을 사용함 다만 실무에서는 핫패스에 한해 raw JOIN을 병행해 성능 보완 가능 장기적으로 Prisma가 선택적 JOIN 생성 옵션을 제공하면, 현재 전략과의 성능 차이를 정량적으로 검증하는 것이 합리적임 현재도 Prisma의 타입 안전성, 스키마 중심 워크플로우, 범용성은 충분히 매력적임 팀의 쿼리 특성과 트래픽 패턴을 기준으로 선택과 집중이 필요함\n참고자료 https://www.prisma.io/ https://typeorm.io/active-record-data-mapper https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access https://github.com/prisma/prisma/issues/5184 https://codedamn.com/news/product/dont-use-prisma https://www.prisma.io/day-2019 https://www.youtube.com/watch?v=RAoXdyI_PH4 ","wordCount":"662","inLanguage":"en","datePublished":"2025-11-23T13:06:21.001Z","dateModified":"2025-11-23T13:06:21.001Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리</h1><div class=post-meta><span title='2025-11-23 13:06:21.001 +0000 UTC'>November 23, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음
Prisma에서는 JOIN이 어디로 갔나 하는 질문임
개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음
정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함</p><h3 id=orm이란-무엇인가>ORM이란 무엇인가<a hidden class=anchor aria-hidden=true href=#orm이란-무엇인가>#</a></h3><p>ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함
애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공
SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능
데이터베이스 의존성 완화 효과 기대</p><h3 id=active-record-vs-data-mapper>Active Record vs Data Mapper<a hidden class=anchor aria-hidden=true href=#active-record-vs-data-mapper>#</a></h3><p>ORM 구현 패턴은 크게 두 가지로 요약됨</p><ul><li><p>Active Record 패턴</p><ul><li>클래스와 테이블의 동치에 가까운 모델링</li><li>필드가 컬럼, 인스턴스가 레코드에 대응</li><li>접근·조작 로직이 모델에 함께 존재</li><li>데이터베이스 스키마 변화에 코드가 민감하게 결합되는 단점</li></ul></li><li><p>Data Mapper 패턴</p><ul><li>모델과 데이터베이스를 분리하는 매핑 계층 존재</li><li>엔티티 클래스와 매퍼 클래스를 분리 정의</li><li>유연성 증가 대신 클래스 수 증가와 변화 추적 복잡도 상승 가능</li></ul></li></ul><p>일반적으로 ORM은 공통 CRUD와 쿼리 API를 제공하고, 세부 패턴은 프레임워크가 선택하거나 혼합 지원함</p><h3 id=prisma와-스키마-중심-모델링>Prisma와 스키마 중심 모델링<a hidden class=anchor aria-hidden=true href=#prisma와-스키마-중심-모델링>#</a></h3><p>Prisma는 Data Mapper 계열이지만, 자체 스키마를 중심으로 모델·마이그레이션·Client를 모두 생성하는 점이 특징임
단일 스키마 파일에서 데이터베이스 스키마와 Prisma Client가 동시에 파생됨
<code>@map()</code>을 통해 애플리케이션의 명명 규칙과 데이터베이스 물리명 분리 가능</p><p>예시 스키마 최소 발췌</p><pre tabindex=0><code class=language-prisma data-lang=prisma>model Notice {
  id          Int   @id @default(autoincrement())
  createdBy   User  @relation(fields: [createdById], references: [id])
  createdById Int   @map(&#34;created_by_id&#34;)
  group       Group @relation(fields: [groupId], references: [id])
  groupId     Int   @map(&#34;group_id&#34;)
  title       String
}
</code></pre><p>Prisma Client는 이 스키마를 근거로 타입 안정성이 확보된 쿼리 API를 제공함</p><h3 id=prisma에는-join이-없나>Prisma에는 JOIN이 없나<a hidden class=anchor aria-hidden=true href=#prisma에는-join이-없나>#</a></h3><p>Prisma Client 메소드 목록에는 JOIN이 존재하지 않음
서브쿼리도 직접 제공되지 않음
그렇다면 관계형 조회는 어떻게 수행되는가가 핵심 포인트임</p><p>기본적인 include 사용 예시</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>notice</span>.<span style=color:#a6e22e>findMany</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>include</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>group</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>특정 컬럼만 선택하고 싶다면 select 사용</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>notices</span>: <span style=color:#66d9ef>Array</span><span style=color:#f92672>&lt;</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>number</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>title</span>: <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>group</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>groupName</span>: <span style=color:#66d9ef>string</span> }
</span></span><span style=display:flex><span>}<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>prisma</span>.<span style=color:#a6e22e>notice</span>.<span style=color:#a6e22e>findMany</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>select</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>id</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>group</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>select</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>groupName</span>: <span style=color:#66d9ef>true</span> },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=내부적으로-join을-쓰는가>내부적으로 JOIN을 쓰는가<a hidden class=anchor aria-hidden=true href=#내부적으로-join을-쓰는가>#</a></h3><p>직관적으로는 JOIN 또는 서브쿼리로 변환될 것 같지만, Prisma는 관계 쿼리를 다중 SELECT로 분해해 전송함
일반적인 패턴은 부모 테이블 조회 후 자식 테이블을 IN 절로 한 번 더 조회하는 형태임</p><p>예시 로그 형태 요약</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> Notice.id, Notice.title, Notice.groupId <span style=color:#66d9ef>FROM</span> Notice ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>Group</span>.id, <span style=color:#66d9ef>Group</span>.groupName <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>Group</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#66d9ef>Group</span>.id <span style=color:#66d9ef>IN</span> (...) ...
</span></span></code></pre></div><p>코어 엔진이 이 결과들을 클라이언트 메모리에서 합성하고, include 또는 select로 요청한 nested 구조를 만들어 반환함
스키마의 <code>@relation</code> 정보는 실제 데이터베이스 컬럼으로 생기지 않지만, 타입 안전성과 결과 합성에 필요한 메타로 쓰임</p><h3 id=성능과-트레이드오프>성능과 트레이드오프<a hidden class=anchor aria-hidden=true href=#성능과-트레이드오프>#</a></h3><p>JOIN이 없는 전략은 범용성 측면에서 장점이 있음</p><ul><li>다중 데이터베이스 지원 용이</li><li>커넥터 구현 부담 감소</li><li>쿼리 엔진이 공통 로직을 재사용하기 쉬움</li></ul><p>반면 성능 리스크 존재</p><ul><li>다중 SELECT에 따른 왕복 비용 증가 가능</li><li>넓은 테이블 스캔 또는 부적절한 WHERE 인덱스 사용 시 비용 급증</li><li>대용량 데이터셋에서 JOIN 대비 비효율 가능성 높음</li></ul><p>결론적으로 관계형 데이터베이스에서 최적화된 조인 실행 계획을 활용하지 못할 수 있음
크리티컬 경로에서는 성능 검증 필요</p><h3 id=필요한-경우-join을-쓰는-방법>필요한 경우 JOIN을 쓰는 방법<a hidden class=anchor aria-hidden=true href=#필요한-경우-join을-쓰는-방법>#</a></h3><p>ORM 순수 사용 원칙에서는 벗어나지만, Prisma에서는 raw query로 JOIN 사용 가능
핫패스나 리포트성 대용량 집계처럼 조인이 본질적인 영역에서는 고려 가치 있음
프로그래밍 모델은 Prisma Client를 유지하되 특정 쿼리만 raw로 대체하는 하이브리드 전략 권장</p><ul><li>단일 책임 함수로 캡슐화</li><li>입력 검증과 SQL 인젝션 방지 매개 API 사용</li><li>스키마 변경 시 회귀 테스트로 커버</li></ul><p>참고 문서 확인 권장</p><h3 id=왜-처음부터-join을-쓰지-않았나>왜 처음부터 JOIN을 쓰지 않았나<a hidden class=anchor aria-hidden=true href=#왜-처음부터-join을-쓰지-않았나>#</a></h3><p>역사적 배경상 Prisma의 목표는 전통적 ORM 최적화가 아니라 다중 데이터베이스를 아우르는 가상 데이터베이스 레이어에 가까웠음</p><ul><li>코어 엔진에 공통 로직 집중, 커넥터는 최소한의 변환만 수행하는 구조 지향</li><li>MongoDB처럼 JOIN이 없는 시스템도 지원해야 했음</li><li>따라서 쿼리를 가장 단순한 형태로 쪼개어 처리하는 전략이 합리적 선택이었음</li></ul><p>현 시점에서는 사용자 기반이 커지며 전통적 ORM 기대치도 함께 커짐
Prisma 팀 역시 크리티컬 케이스에서 JOIN 기반 생성 지원을 추진 중이라고 알려짐
과거의 범용성 우선 전략에서, 실용적 성능과 개발 경험을 균형 있게 보완하는 과도기로 보는 편이 타당함</p><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>Prisma에는 개발자 API 차원에서 JOIN이 없음
실행 단계에서도 기본적으로 다중 SELECT 후 결과 합성 전략을 사용함
다만 실무에서는 핫패스에 한해 raw JOIN을 병행해 성능 보완 가능
장기적으로 Prisma가 선택적 JOIN 생성 옵션을 제공하면, 현재 전략과의 성능 차이를 정량적으로 검증하는 것이 합리적임
현재도 Prisma의 타입 안전성, 스키마 중심 워크플로우, 범용성은 충분히 매력적임
팀의 쿼리 특성과 트래픽 패턴을 기준으로 선택과 집중이 필요함</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.prisma.io/>https://www.prisma.io/</a></li><li><a href=https://typeorm.io/active-record-data-mapper>https://typeorm.io/active-record-data-mapper</a></li><li><a href=https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access>https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access</a></li><li><a href=https://github.com/prisma/prisma/issues/5184>https://github.com/prisma/prisma/issues/5184</a></li><li><a href=https://codedamn.com/news/product/dont-use-prisma>https://codedamn.com/news/product/dont-use-prisma</a></li><li><a href=https://www.prisma.io/day-2019>https://www.prisma.io/day-2019</a></li><li><a href="https://www.youtube.com/watch?v=RAoXdyI_PH4">https://www.youtube.com/watch?v=RAoXdyI_PH4</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/prisma/>Prisma</a></li><li><a href=https://blog.jsontapose.com/tags/orm/>Orm</a></li><li><a href=https://blog.jsontapose.com/tags/join/>Join</a></li><li><a href=https://blog.jsontapose.com/tags/sql/>Sql</a></li><li><a href=https://blog.jsontapose.com/tags/data-mapper/>Data-Mapper</a></li><li><a href=https://blog.jsontapose.com/tags/active-record/>Active-Record</a></li><li><a href=https://blog.jsontapose.com/tags/database/>Database</a></li><li><a href=https://blog.jsontapose.com/tags/nodejs/>Nodejs</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/><span class=title>« Prev</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span>
</a><a class=next href=https://blog.jsontapose.com/posts/prisma-client-index-d-ts-objektinventory-aggregation-groupby-types-fec621/><span class=title>Next »</span><br><span>Prisma Client index.d.ts로 읽는 ObjektInventory 집계·그룹화 타입 구조</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on x" href="https://x.com/intent/tweet/?text=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f&amp;hashtags=prisma%2corm%2cjoin%2csql%2cdata-mapper%2cactive-record%2cdatabase%2cnodejs"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f&amp;title=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac&amp;summary=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f&title=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on whatsapp" href="https://api.whatsapp.com/send?text=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on telegram" href="https://telegram.me/share/url?text=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Prisma%ec%97%90%eb%8a%94%20%ec%99%9c%20JOIN%ec%9d%b4%20%ec%97%86%ec%9d%84%ea%b9%8c%3a%20ORM%20%ed%8c%a8%ed%84%b4%2c%20%ec%8a%a4%ed%82%a4%eb%a7%88%2c%20%eb%82%b4%eb%b6%80%20%eb%8f%99%ec%9e%91%20%ec%a0%95%eb%a6%ac&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fwhy-prisma-has-no-join-ed7155%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>