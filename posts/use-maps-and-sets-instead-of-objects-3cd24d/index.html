<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 | HandsLog</title>
<meta name=keywords content="javascript,map,set,weakmap,weakset,performance,data-structures"><meta name=description content="개요
객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님
키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함
중복 없는 집합 연산에는 Set이 자연스러운 선택지
언제 객체 대신 Map을 고려할까

키를 자주 추가·삭제하는 동적 해시맵 패턴
안전한 반복과 구조 분해가 필요한 경우
키의 삽입 순서 유지가 중요한 경우
비문자열 키가 필요한 경우

// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음
const mapOfThingsObj = {};
mapOfThingsObj[thing.id] = thing;
delete mapOfThingsObj[thing.id];

// Map은 동적 추가·삭제에 최적화
const mapOfThings = new Map();
mapOfThings.set(thing.id, thing);
mapOfThings.delete(thing.id);성능 배경
객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재
Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨
마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유"><meta property="og:description" content="개요 객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님 키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함 중복 없는 집합 연산에는 Set이 자연스러운 선택지
언제 객체 대신 Map을 고려할까 키를 자주 추가·삭제하는 동적 해시맵 패턴 안전한 반복과 구조 분해가 필요한 경우 키의 삽입 순서 유지가 중요한 경우 비문자열 키가 필요한 경우 // 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음 const mapOfThingsObj = {}; mapOfThingsObj[thing.id] = thing; delete mapOfThingsObj[thing.id]; // Map은 동적 추가·삭제에 최적화 const mapOfThings = new Map(); mapOfThings.set(thing.id, thing); mapOfThings.delete(thing.id);성능 배경 객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재 Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨 마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-21T13:09:33+00:00"><meta property="article:modified_time" content="2025-12-21T13:09:33+00:00"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Map"><meta property="article:tag" content="Set"><meta property="article:tag" content="Weakmap"><meta property="article:tag" content="Weakset"><meta property="article:tag" content="Performance"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유"><meta name=twitter:description content="개요
객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님
키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함
중복 없는 집합 연산에는 Set이 자연스러운 선택지
언제 객체 대신 Map을 고려할까

키를 자주 추가·삭제하는 동적 해시맵 패턴
안전한 반복과 구조 분해가 필요한 경우
키의 삽입 순서 유지가 중요한 경우
비문자열 키가 필요한 경우

// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음
const mapOfThingsObj = {};
mapOfThingsObj[thing.id] = thing;
delete mapOfThingsObj[thing.id];

// Map은 동적 추가·삭제에 최적화
const mapOfThings = new Map();
mapOfThings.set(thing.id, thing);
mapOfThings.delete(thing.id);성능 배경
객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재
Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨
마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유","item":"https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유","name":"JavaScript에서 객체 대신 Map\/Set을 선택해야 하는 경우와 이유","description":"개요 객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님 키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함 중복 없는 집합 연산에는 Set이 자연스러운 선택지\n언제 객체 대신 Map을 고려할까 키를 자주 추가·삭제하는 동적 해시맵 패턴 안전한 반복과 구조 분해가 필요한 경우 키의 삽입 순서 유지가 중요한 경우 비문자열 키가 필요한 경우 // 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음 const mapOfThingsObj = {}; mapOfThingsObj[thing.id] = thing; delete mapOfThingsObj[thing.id]; // Map은 동적 추가·삭제에 최적화 const mapOfThings = new Map(); mapOfThings.set(thing.id, thing); mapOfThings.delete(thing.id);성능 배경 객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재 Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨 마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능\n","keywords":["javascript","map","set","weakmap","weakset","performance","data-structures"],"articleBody":"개요 객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님 키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함 중복 없는 집합 연산에는 Set이 자연스러운 선택지\n언제 객체 대신 Map을 고려할까 키를 자주 추가·삭제하는 동적 해시맵 패턴 안전한 반복과 구조 분해가 필요한 경우 키의 삽입 순서 유지가 중요한 경우 비문자열 키가 필요한 경우 // 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음 const mapOfThingsObj = {}; mapOfThingsObj[thing.id] = thing; delete mapOfThingsObj[thing.id]; // Map은 동적 추가·삭제에 최적화 const mapOfThings = new Map(); mapOfThings.set(thing.id, thing); mapOfThings.delete(thing.id);성능 배경 객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재 Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨 마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능\n참고 개념\n객체 셰이프 변화는 모노모픽 → 폴리모픽 전이 유발 가능 Map은 내부적으로 동적 키 공간에 최적화된 경로 제공 내장 키 오염 문제 객체는 프로토타입 체인에 의해 비어 있어도 여러 키가 이미 존재함\nconst myMapLikeObj = {}; myMapLikeObj.valueOf; myMapLikeObj.toString; myMapLikeObj.hasOwnProperty;임의 키-값 저장에서 우연히 충돌하거나 방어 코드가 필요해짐\n반복의 일관성 for..in은 상속된 키까지 순회 가능해 방어 코드 필요해짐\nfor (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { // 안전하지만 장황함 } } Object.keys(obj).forEach((key) =\u003e { // 키만 순회 });Map은 표준 이터레이터를 제공하며 키와 값을 구조 분해로 즉시 획득 가능\nfor (const [key, value] of myMap) { // 깔끔한 순회 }키 순서 유지 Map은 삽입 순서를 보존함 정확한 순서로 구조 분해 가능\nconst [[firstKey, firstValue]] = myMap;LRU 캐시 같은 순서 기반 전략 구현에 유리함\n복사 객체는 전개나 assign으로 얕은 복사 쉬움\nconst copyObj = { ...obj }; const copyObj2 = Object.assign({}, obj);Map도 생성자에 이터러블을 넘겨 간단히 복사 가능\nconst copyMap = new Map(myMap);깊은 복사는 structuredClone 사용 가능\nconst deepCopyMap = structuredClone(myMap);Map ↔ 객체 상호 변환 Map → 객체\nconst objFromMap = Object.fromEntries(myMap);객체 → Map\nconst mapFromObj = new Map(Object.entries(obj));선언 시 객체 리터럴을 이용해 가독성 개선 가능\nconst myMap = new Map( Object.entries({ key: \"value\", keyTwo: \"valueTwo\", }) ); // 간단 헬퍼 const makeMap = (o) =\u003e new Map(Object.entries(o)); const m = makeMap({ key: \"value\" });TypeScript 제네릭 형태\nconst makeMap = \u003cV = unknown\u003e(o: Record\u003cstring, V\u003e) =\u003e new Map\u003cstring, V\u003e(Object.entries(o));키 타입 유연성과 WeakMap 객체 키는 문자열 또는 심볼로 제한됨 Map은 임의 객체를 키로 사용 가능\nmyMap.set({}, value); myMap.set([], value); myMap.set(document.body, value); myMap.set(() =\u003e {}, value); myMap.set(myObj, value);메타데이터를 원본 객체에 오염 없이 부착하는 패턴에 유용함\nconst metadata = new Map(); metadata.set(myDomNode, { internalId: \"...\" }); metadata.get(myDomNode);단점은 참조를 보유하면 가비지 컬렉션이 지연되어 메모리 누수 위험 존재 이 경우 WeakMap 사용\nconst metadata = new WeakMap(); metadata.set(myTodo, { focused: true }); // 다른 강한 참조가 사라지면 자동으로 수거됨 Map 유틸리티 메서드 요약 map.clear() 전체 비우기 map.size 크기 조회 map.keys() 키 이터레이터 map.values() 값 이터레이터 Set과 WeakSet Set은 고유 요소 집합 표현에 적합하며 추가·삭제·조회가 단순하고 종종 배열 대비 성능상 유리\nconst set = new Set([1, 2, 3]); set.add(3); set.delete(4); set.has(5);객체 참조 집합에 대해 GC 친화성을 원하면 WeakSet 사용\nconst checked = new WeakSet([todo1, todo2]);직렬화 전략 JSON은 Map/Set을 직접 직렬화하지 않음 replacer와 reviver를 이용해 직렬화 규칙을 커스터마이즈 가능\nMap/Set을 직렬화를 위해 객체/배열로 변환\nfunction replacer(key, value) { if (value instanceof Map) return Object.fromEntries(value); if (value instanceof Set) return Array.from(value); return value; } const payload = { set: new Set([1, 2, 3]), map: new Map([[\"k\", \"v\"]]) }; const json = JSON.stringify(payload, replacer);역직렬화 시 객체와 배열을 무조건 Map/Set으로 바꾸면 구분 불가 이슈 발생 타입 태그를 추가해 손실 없이 왕복 가능\nfunction taggedReplacer(key, value) { if (value instanceof Map) return { __type: \"Map\", value: Object.fromEntries(value) }; if (value instanceof Set) return { __type: \"Set\", value: Array.from(value) }; return value; } function taggedReviver(key, value) { if (value?.__type === \"Map\") return new Map(Object.entries(value.value)); if (value?.__type === \"Set\") return new Set(value.value); return value; } const obj = { set: new Set([1, 2]), map: new Map([[\"key\", \"value\"]]) }; const str = JSON.stringify(obj, taggedReplacer); const roundTripped = JSON.parse(str, taggedReviver);언제 무엇을 쓸까 요약 구조가 고정된 도메인 객체는 객체 사용, 예 title, date 같은 명확한 스키마 const event = { title: \"Conf\", date: new Date() }; 동적 키-값 저장과 빈번한 추가·삭제는 Map 사용 const events = new Map(); events.set(event.id, event); events.delete(event.id); 순서가 중요하고 중복 허용 목록은 배열 const list = [1, 2, 3, 2]; 중복 없는 집합이고 순서 중요하지 않으면 Set const uniq = new Set([1, 2, 3]);정리 객체는 구조화된 데이터 모델에, Map은 동적 해시맵 패턴에, Set은 고유 집합에 최적 성능은 실제 시나리오에서 검증하되, 키 추가·삭제와 반복·키타입 유연성 측면에서 Map이 갖는 일관된 장점이 큼 메모리 안전성이 필요한 참조 기반 메타데이터에는 WeakMap과 WeakSet 고려 권장\n참고자료 https://www.builder.io/blog/maps https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects https://developer.mozilla.org/en-US/docs/Web/API/structuredClone https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza ","wordCount":"749","inLanguage":"en","datePublished":"2025-12-21T13:09:33.703Z","dateModified":"2025-12-21T13:09:33.703Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유</h1><div class=post-meta><span title='2025-12-21 13:09:33.703 +0000 UTC'>December 21, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님
키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함
중복 없는 집합 연산에는 Set이 자연스러운 선택지</p><h3 id=언제-객체-대신-map을-고려할까>언제 객체 대신 Map을 고려할까<a hidden class=anchor aria-hidden=true href=#언제-객체-대신-map을-고려할까>#</a></h3><ul><li>키를 자주 추가·삭제하는 동적 해시맵 패턴</li><li>안전한 반복과 구조 분해가 필요한 경우</li><li>키의 삽입 순서 유지가 중요한 경우</li><li>비문자열 키가 필요한 경우</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>const</span> mapOfThingsObj <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{};</span>
</span></span><span style=display:flex><span>mapOfThingsObj<span style=color:#eceff4>[</span>thing<span style=color:#eceff4>.</span>id<span style=color:#eceff4>]</span> <span style=color:#81a1c1>=</span> thing<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>delete</span> mapOfThingsObj<span style=color:#eceff4>[</span>thing<span style=color:#eceff4>.</span>id<span style=color:#eceff4>];</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// Map은 동적 추가·삭제에 최적화
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>const</span> mapOfThings <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>();</span>
</span></span><span style=display:flex><span>mapOfThings<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span>thing<span style=color:#eceff4>.</span>id<span style=color:#eceff4>,</span> thing<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>mapOfThings<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>delete</span><span style=color:#eceff4>(</span>thing<span style=color:#eceff4>.</span>id<span style=color:#eceff4>);</span></span></span></code></pre></div><h3 id=성능-배경>성능 배경<a hidden class=anchor aria-hidden=true href=#성능-배경>#</a></h3><p>객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재
Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨
마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능</p><p><strong>참고 개념</strong></p><ul><li>객체 셰이프 변화는 모노모픽 → 폴리모픽 전이 유발 가능</li><li>Map은 내부적으로 동적 키 공간에 최적화된 경로 제공</li></ul><h3 id=내장-키-오염-문제>내장 키 오염 문제<a hidden class=anchor aria-hidden=true href=#내장-키-오염-문제>#</a></h3><p>객체는 프로토타입 체인에 의해 비어 있어도 여러 키가 이미 존재함</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> myMapLikeObj <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{};</span>
</span></span><span style=display:flex><span>myMapLikeObj<span style=color:#eceff4>.</span>valueOf<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span>myMapLikeObj<span style=color:#eceff4>.</span>toString<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span>myMapLikeObj<span style=color:#eceff4>.</span>hasOwnProperty<span style=color:#eceff4>;</span></span></span></code></pre></div><p>임의 키-값 저장에서 우연히 충돌하거나 방어 코드가 필요해짐</p><h3 id=반복의-일관성>반복의 일관성<a hidden class=anchor aria-hidden=true href=#반복의-일관성>#</a></h3><p>for..in은 상속된 키까지 순회 가능해 방어 코드 필요해짐</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>for</span> <span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>const</span> key <span style=color:#81a1c1;font-weight:700>in</span> obj<span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>prototype<span style=color:#eceff4>.</span>hasOwnProperty<span style=color:#eceff4>.</span>call<span style=color:#eceff4>(</span>obj<span style=color:#eceff4>,</span> key<span style=color:#eceff4>))</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>    <span style=color:#616e87;font-style:italic>// 안전하지만 장황함
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>  <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>keys<span style=color:#eceff4>(</span>obj<span style=color:#eceff4>).</span>forEach<span style=color:#eceff4>((</span>key<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#616e87;font-style:italic>// 키만 순회
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>});</span></span></span></code></pre></div><p>Map은 표준 이터레이터를 제공하며 키와 값을 구조 분해로 즉시 획득 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>for</span> <span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>const</span> <span style=color:#eceff4>[</span>key<span style=color:#eceff4>,</span> value<span style=color:#eceff4>]</span> <span style=color:#81a1c1;font-weight:700>of</span> myMap<span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#616e87;font-style:italic>// 깔끔한 순회
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#eceff4>}</span></span></span></code></pre></div><h3 id=키-순서-유지>키 순서 유지<a hidden class=anchor aria-hidden=true href=#키-순서-유지>#</a></h3><p>Map은 삽입 순서를 보존함
정확한 순서로 구조 분해 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> <span style=color:#eceff4>[[</span>firstKey<span style=color:#eceff4>,</span> firstValue<span style=color:#eceff4>]]</span> <span style=color:#81a1c1>=</span> myMap<span style=color:#eceff4>;</span></span></span></code></pre></div><p>LRU 캐시 같은 순서 기반 전략 구현에 유리함</p><h3 id=복사>복사<a hidden class=anchor aria-hidden=true href=#복사>#</a></h3><p>객체는 전개나 assign으로 얕은 복사 쉬움</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> copyObj <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> <span style=color:#eceff4>...</span>obj <span style=color:#eceff4>};</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> copyObj2 <span style=color:#81a1c1>=</span> <span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>assign<span style=color:#eceff4>({},</span> obj<span style=color:#eceff4>);</span></span></span></code></pre></div><p>Map도 생성자에 이터러블을 넘겨 간단히 복사 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> copyMap <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>(</span>myMap<span style=color:#eceff4>);</span></span></span></code></pre></div><p>깊은 복사는 structuredClone 사용 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> deepCopyMap <span style=color:#81a1c1>=</span> structuredClone<span style=color:#eceff4>(</span>myMap<span style=color:#eceff4>);</span></span></span></code></pre></div><h3 id=map--객체-상호-변환>Map ↔ 객체 상호 변환<a hidden class=anchor aria-hidden=true href=#map--객체-상호-변환>#</a></h3><p>Map → 객체</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> objFromMap <span style=color:#81a1c1>=</span> <span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>fromEntries<span style=color:#eceff4>(</span>myMap<span style=color:#eceff4>);</span></span></span></code></pre></div><p>객체 → Map</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> mapFromObj <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>(</span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>entries<span style=color:#eceff4>(</span>obj<span style=color:#eceff4>));</span></span></span></code></pre></div><p>선언 시 객체 리터럴을 이용해 가독성 개선 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> myMap <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>(</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>entries<span style=color:#eceff4>({</span>
</span></span><span style=display:flex><span>    key<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;value&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>    keyTwo<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;valueTwo&#34;</span><span style=color:#eceff4>,</span>
</span></span><span style=display:flex><span>  <span style=color:#eceff4>})</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 간단 헬퍼
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span><span style=color:#81a1c1;font-weight:700>const</span> makeMap <span style=color:#81a1c1>=</span> <span style=color:#eceff4>(</span>o<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>(</span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>entries<span style=color:#eceff4>(</span>o<span style=color:#eceff4>));</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> m <span style=color:#81a1c1>=</span> makeMap<span style=color:#eceff4>({</span> key<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;value&#34;</span> <span style=color:#eceff4>});</span></span></span></code></pre></div><p>TypeScript 제네릭 형태</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> makeMap <span style=color:#81a1c1>=</span> <span style=color:#eceff4>&lt;</span><span style=color:#81a1c1>V</span> <span style=color:#bf616a>=</span> <span style=color:#8fbcbb>unknown</span><span style=color:#eceff4>&gt;(</span>o: <span style=color:#81a1c1>Record</span><span style=color:#eceff4>&lt;</span><span style=color:#81a1c1>string</span><span style=color:#eceff4>,</span> <span style=color:#8fbcbb>V</span><span style=color:#eceff4>&gt;)</span> <span style=color:#81a1c1>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>&lt;</span><span style=color:#81a1c1>string</span><span style=color:#eceff4>,</span> <span style=color:#8fbcbb>V</span><span style=color:#eceff4>&gt;(</span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>entries<span style=color:#eceff4>(</span>o<span style=color:#eceff4>));</span></span></span></code></pre></div><h3 id=키-타입-유연성과-weakmap>키 타입 유연성과 WeakMap<a hidden class=anchor aria-hidden=true href=#키-타입-유연성과-weakmap>#</a></h3><p>객체 키는 문자열 또는 심볼로 제한됨
Map은 임의 객체를 키로 사용 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>myMap<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>({},</span> value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>myMap<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>([],</span> value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>myMap<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>document</span><span style=color:#eceff4>.</span>body<span style=color:#eceff4>,</span> value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>myMap<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(()</span> <span style=color:#81a1c1>=&gt;</span> <span style=color:#eceff4>{},</span> value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>myMap<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span>myObj<span style=color:#eceff4>,</span> value<span style=color:#eceff4>);</span></span></span></code></pre></div><p>메타데이터를 원본 객체에 오염 없이 부착하는 패턴에 유용함</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> metadata <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>();</span>
</span></span><span style=display:flex><span>metadata<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span>myDomNode<span style=color:#eceff4>,</span> <span style=color:#eceff4>{</span> internalId<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;...&#34;</span> <span style=color:#eceff4>});</span>
</span></span><span style=display:flex><span>metadata<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>get</span><span style=color:#eceff4>(</span>myDomNode<span style=color:#eceff4>);</span></span></span></code></pre></div><p>단점은 참조를 보유하면 가비지 컬렉션이 지연되어 메모리 누수 위험 존재
이 경우 WeakMap 사용</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> metadata <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> WeakMap<span style=color:#eceff4>();</span>
</span></span><span style=display:flex><span>metadata<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span>myTodo<span style=color:#eceff4>,</span> <span style=color:#eceff4>{</span> focused: <span style=color:#81a1c1>true</span> <span style=color:#eceff4>});</span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 다른 강한 참조가 사라지면 자동으로 수거됨
</span></span></span></code></pre></div><h3 id=map-유틸리티-메서드-요약>Map 유틸리티 메서드 요약<a hidden class=anchor aria-hidden=true href=#map-유틸리티-메서드-요약>#</a></h3><ul><li>map.clear() 전체 비우기</li><li>map.size 크기 조회</li><li>map.keys() 키 이터레이터</li><li>map.values() 값 이터레이터</li></ul><h3 id=set과-weakset>Set과 WeakSet<a hidden class=anchor aria-hidden=true href=#set과-weakset>#</a></h3><p>Set은 고유 요소 집합 표현에 적합하며 추가·삭제·조회가 단순하고 종종 배열 대비 성능상 유리</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> <span style=color:#81a1c1;font-weight:700>set</span> <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Set<span style=color:#eceff4>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>3</span><span style=color:#eceff4>]);</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>.</span>add<span style=color:#eceff4>(</span><span style=color:#b48ead>3</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>delete</span><span style=color:#eceff4>(</span><span style=color:#b48ead>4</span><span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>.</span>has<span style=color:#eceff4>(</span><span style=color:#b48ead>5</span><span style=color:#eceff4>);</span></span></span></code></pre></div><p>객체 참조 집합에 대해 GC 친화성을 원하면 WeakSet 사용</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> checked <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> WeakSet<span style=color:#eceff4>([</span>todo1<span style=color:#eceff4>,</span> todo2<span style=color:#eceff4>]);</span></span></span></code></pre></div><h3 id=직렬화-전략>직렬화 전략<a hidden class=anchor aria-hidden=true href=#직렬화-전략>#</a></h3><p>JSON은 Map/Set을 직접 직렬화하지 않음
replacer와 reviver를 이용해 직렬화 규칙을 커스터마이즈 가능</p><p>Map/Set을 직렬화를 위해 객체/배열로 변환</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> replacer<span style=color:#eceff4>(</span>key<span style=color:#eceff4>,</span> value<span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value <span style=color:#81a1c1;font-weight:700>instanceof</span> Map<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>fromEntries<span style=color:#eceff4>(</span>value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value <span style=color:#81a1c1;font-weight:700>instanceof</span> Set<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#81a1c1>Array</span><span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>from</span><span style=color:#eceff4>(</span>value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>return</span> value<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> payload <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> <span style=color:#81a1c1;font-weight:700>set</span><span style=color:#81a1c1>:</span> <span style=color:#81a1c1;font-weight:700>new</span> Set<span style=color:#eceff4>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>3</span><span style=color:#eceff4>]),</span> map: <span style=color:#81a1c1>new</span> Map<span style=color:#eceff4>([[</span><span style=color:#a3be8c>&#34;k&#34;</span><span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;v&#34;</span><span style=color:#eceff4>]])</span> <span style=color:#eceff4>};</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> json <span style=color:#81a1c1>=</span> JSON<span style=color:#eceff4>.</span>stringify<span style=color:#eceff4>(</span>payload<span style=color:#eceff4>,</span> replacer<span style=color:#eceff4>);</span></span></span></code></pre></div><p>역직렬화 시 객체와 배열을 무조건 Map/Set으로 바꾸면 구분 불가 이슈 발생
타입 태그를 추가해 손실 없이 왕복 가능</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> taggedReplacer<span style=color:#eceff4>(</span>key<span style=color:#eceff4>,</span> value<span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value <span style=color:#81a1c1;font-weight:700>instanceof</span> Map<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#eceff4>{</span> __type<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;Map&#34;</span><span style=color:#eceff4>,</span> value: <span style=color:#81a1c1>Object.fromEntries</span><span style=color:#eceff4>(</span>value<span style=color:#eceff4>)</span> <span style=color:#eceff4>};</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value <span style=color:#81a1c1;font-weight:700>instanceof</span> Set<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#eceff4>{</span> __type<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;Set&#34;</span><span style=color:#eceff4>,</span> value: <span style=color:#81a1c1>Array.from</span><span style=color:#eceff4>(</span>value<span style=color:#eceff4>)</span> <span style=color:#eceff4>};</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>return</span> value<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> taggedReviver<span style=color:#eceff4>(</span>key<span style=color:#eceff4>,</span> value<span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value<span style=color:#81a1c1>?</span><span style=color:#eceff4>.</span>__type <span style=color:#81a1c1>===</span> <span style=color:#a3be8c>&#34;Map&#34;</span><span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>(</span><span style=color:#81a1c1>Object</span><span style=color:#eceff4>.</span>entries<span style=color:#eceff4>(</span>value<span style=color:#eceff4>.</span>value<span style=color:#eceff4>));</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>value<span style=color:#81a1c1>?</span><span style=color:#eceff4>.</span>__type <span style=color:#81a1c1>===</span> <span style=color:#a3be8c>&#34;Set&#34;</span><span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> <span style=color:#81a1c1;font-weight:700>new</span> Set<span style=color:#eceff4>(</span>value<span style=color:#eceff4>.</span>value<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>return</span> value<span style=color:#eceff4>;</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> obj <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> <span style=color:#81a1c1;font-weight:700>set</span><span style=color:#81a1c1>:</span> <span style=color:#81a1c1;font-weight:700>new</span> Set<span style=color:#eceff4>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>]),</span> map: <span style=color:#81a1c1>new</span> Map<span style=color:#eceff4>([[</span><span style=color:#a3be8c>&#34;key&#34;</span><span style=color:#eceff4>,</span> <span style=color:#a3be8c>&#34;value&#34;</span><span style=color:#eceff4>]])</span> <span style=color:#eceff4>};</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> str <span style=color:#81a1c1>=</span> JSON<span style=color:#eceff4>.</span>stringify<span style=color:#eceff4>(</span>obj<span style=color:#eceff4>,</span> taggedReplacer<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> roundTripped <span style=color:#81a1c1>=</span> JSON<span style=color:#eceff4>.</span>parse<span style=color:#eceff4>(</span>str<span style=color:#eceff4>,</span> taggedReviver<span style=color:#eceff4>);</span></span></span></code></pre></div><h3 id=언제-무엇을-쓸까-요약>언제 무엇을 쓸까 요약<a hidden class=anchor aria-hidden=true href=#언제-무엇을-쓸까-요약>#</a></h3><ul><li>구조가 고정된 도메인 객체는 객체 사용, 예 title, date 같은 명확한 스키마</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> event <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> title<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#34;Conf&#34;</span><span style=color:#eceff4>,</span> date: <span style=color:#81a1c1>new</span> <span style=color:#81a1c1>Date</span><span style=color:#eceff4>()</span> <span style=color:#eceff4>};</span></span></span></code></pre></div><ul><li>동적 키-값 저장과 빈번한 추가·삭제는 Map 사용</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> events <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Map<span style=color:#eceff4>();</span>
</span></span><span style=display:flex><span>events<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>set</span><span style=color:#eceff4>(</span>event<span style=color:#eceff4>.</span>id<span style=color:#eceff4>,</span> event<span style=color:#eceff4>);</span>
</span></span><span style=display:flex><span>events<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>delete</span><span style=color:#eceff4>(</span>event<span style=color:#eceff4>.</span>id<span style=color:#eceff4>);</span></span></span></code></pre></div><ul><li>순서가 중요하고 중복 허용 목록은 배열</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> list <span style=color:#81a1c1>=</span> <span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>3</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>];</span></span></span></code></pre></div><ul><li>중복 없는 집합이고 순서 중요하지 않으면 Set</li></ul><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> uniq <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>new</span> Set<span style=color:#eceff4>([</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>3</span><span style=color:#eceff4>]);</span></span></span></code></pre></div><h3 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h3><p>객체는 구조화된 데이터 모델에, Map은 동적 해시맵 패턴에, Set은 고유 집합에 최적
성능은 실제 시나리오에서 검증하되, 키 추가·삭제와 반복·키타입 유연성 측면에서 Map이 갖는 일관된 장점이 큼
메모리 안전성이 필요한 참조 기반 메타데이터에는 WeakMap과 WeakSet 고려 권장</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://www.builder.io/blog/maps>https://www.builder.io/blog/maps</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/API/structuredClone>https://developer.mozilla.org/en-US/docs/Web/API/structuredClone</a></li><li><a href=https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html>https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html</a></li><li><a href=https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html>https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html</a></li><li><a href=https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza>https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/javascript/>Javascript</a></li><li><a href=https://blog.jsontapose.com/tags/map/>Map</a></li><li><a href=https://blog.jsontapose.com/tags/set/>Set</a></li><li><a href=https://blog.jsontapose.com/tags/weakmap/>Weakmap</a></li><li><a href=https://blog.jsontapose.com/tags/weakset/>Weakset</a></li><li><a href=https://blog.jsontapose.com/tags/performance/>Performance</a></li><li><a href=https://blog.jsontapose.com/tags/data-structures/>Data-Structures</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/><span class=title>« Prev</span><br><span>Kubernetes 아키텍처와 핵심 컴포넌트 정리</span>
</a><a class=next href=https://blog.jsontapose.com/posts/eip-712-signtypeddata-guide-29efde/><span class=title>Next »</span><br><span>EIP-712 기반 signTypedData 가이드와 지갑 연동 핵심</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on x" href="https://x.com/intent/tweet/?text=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f&amp;hashtags=javascript%2cmap%2cset%2cweakmap%2cweakset%2cperformance%2cdata-structures"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f&amp;title=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0&amp;summary=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f&title=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on whatsapp" href="https://api.whatsapp.com/send?text=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on telegram" href="https://telegram.me/share/url?text=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유 on ycombinator" href="https://news.ycombinator.com/submitlink?t=JavaScript%ec%97%90%ec%84%9c%20%ea%b0%9d%ec%b2%b4%20%eb%8c%80%ec%8b%a0%20Map%2fSet%ec%9d%84%20%ec%84%a0%ed%83%9d%ed%95%b4%ec%95%bc%20%ed%95%98%eb%8a%94%20%ea%b2%bd%ec%9a%b0%ec%99%80%20%ec%9d%b4%ec%9c%a0&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fuse-maps-and-sets-instead-of-objects-3cd24d%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>