<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 | HandsLog</title>
<meta name=keywords content="kubernetes,nodejs,liveness-probe,readiness-probe,health-check,devops"><meta name=description content="개요
Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행
Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침
핵심 차이

Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행
Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행
본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨

Node.js 맥락

Liveness Probe 대상 상황

이벤트 루프 블로킹으로 요청 처리 불가 상태
무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능
메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태


Readiness Probe 대상 상황

프로세스는 떠 있으나 초기화 작업 진행 중인 상태
DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태


유의점

Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험
Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함



구현 스니펫
Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드"><meta property="og:description" content="개요 Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행 Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침
핵심 차이 Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행 Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행 본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨 Node.js 맥락 Liveness Probe 대상 상황 이벤트 루프 블로킹으로 요청 처리 불가 상태 무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능 메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태 Readiness Probe 대상 상황 프로세스는 떠 있으나 초기화 작업 진행 중인 상태 DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태 유의점 Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험 Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함 구현 스니펫 Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-11T13:14:28+00:00"><meta property="article:modified_time" content="2025-12-11T13:14:28+00:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Liveness-Probe"><meta property="article:tag" content="Readiness-Probe"><meta property="article:tag" content="Health-Check"><meta property="article:tag" content="Devops"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드"><meta name=twitter:description content="개요
Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행
Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침
핵심 차이

Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행
Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행
본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨

Node.js 맥락

Liveness Probe 대상 상황

이벤트 루프 블로킹으로 요청 처리 불가 상태
무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능
메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태


Readiness Probe 대상 상황

프로세스는 떠 있으나 초기화 작업 진행 중인 상태
DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태


유의점

Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험
Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함



구현 스니펫
Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드","item":"https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드","name":"Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드","description":"개요 Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행 Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침\n핵심 차이 Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행 Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행 본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨 Node.js 맥락 Liveness Probe 대상 상황 이벤트 루프 블로킹으로 요청 처리 불가 상태 무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능 메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태 Readiness Probe 대상 상황 프로세스는 떠 있으나 초기화 작업 진행 중인 상태 DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태 유의점 Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험 Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함 구현 스니펫 Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장\n","keywords":["kubernetes","nodejs","liveness-probe","readiness-probe","health-check","devops"],"articleBody":"개요 Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행 Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침\n핵심 차이 Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행 Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행 본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨 Node.js 맥락 Liveness Probe 대상 상황 이벤트 루프 블로킹으로 요청 처리 불가 상태 무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능 메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태 Readiness Probe 대상 상황 프로세스는 떠 있으나 초기화 작업 진행 중인 상태 DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태 유의점 Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험 Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함 구현 스니펫 Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장\n간단한 Express 핸들러 예시\nlet isReady = false // Liveness app.get('/health/live', (_req, res) =\u003e res.status(200).send('OK')) // Readiness app.get('/health/ready', (_req, res) =\u003e { if (isReady) return res.status(200).send('OK') return res.status(503).send('Not Ready') })준비 플래그는 DB 연결 완료 시점 등에서 true로 전환하는 방식 권장\nKubernetes 프로브 최소 설정 예시\nlivenessProbe: httpGet: path: /health/live port: 3000 initialDelaySeconds: 5 periodSeconds: 10 readinessProbe: httpGet: path: /health/ready port: 3000 initialDelaySeconds: 5 periodSeconds: 10앱 기동 시간이 긴 경우 startupProbe 사용 고려\nstartupProbe: httpGet: path: /health/live port: 3000 periodSeconds: 5 failureThreshold: 12주의와 베스트 프랙티스 Liveness에 DB 체크 넣지 않기 DB 일시 지연으로 Liveness 실패 시 컨테이너 재시작 폭주 발생 가능 재접속 과부하로 DB 상태 악화, 전체 장애로 확산되는 연쇄 실패 위험 Readiness에는 실제 서비스 처리 가능 상태를 반영 DB 연결 불가, 핵심 캐시 미구축 시 503 반환으로 트래픽 유입 차단 초기 지연 대응 initialDelaySeconds를 앱 기동 시간보다 여유 있게 설정 또는 startupProbe로 초기 부트 구간 명시 과한 작업 금지 Liveness 핸들러에 무거운 로직, 외부 네트워크 호출, 파일 IO 등 포함 금지 Readiness도 불필요한 비용 최소화, 필요한 의존성 상태만 점검 프로브 타이밍 파라미터 조정 periodSeconds, timeoutSeconds, failureThreshold를 워크로드 특성에 맞춰 튜닝 일시적 네트워크 지연에 과민하지 않도록 실패 임계값 완충 적용 엔드포인트 분리 /health/live와 /health/ready는 별도 라우트로 유지, 공용 미들웨어에서 불필요한 비용 유입 방지 운영 시 고려사항 배포 중 Readiness가 OK가 될 때까지 로드밸런서가 신규 파드로 트래픽을 라우팅하지 않음 롤링 업데이트 시 502와 같은 전이적 오류 방지에 효과적 장애 상황 가시화 Liveness 재시작 이벤트와 Readiness 변화를 모니터링 지표로 수집하면 회귀나 성능 저하 조기 탐지에 유용 Node.js 특성 반영 이벤트 루프 블로킹은 Liveness로 조기 감지 가능 메모리 누수로 인한 GC 압박과 응답 지연은 Readiness 변동과 함께 관찰 시 원인 추적에 도움 요약 Liveness Probe는 죽었으면 살려내라, 실패 시 재시작 수행 Readiness Probe는 준비 안 됐으면 손님 받지 마라, 실패 시 트래픽 차단 수행 Node.js에서는 Liveness를 가볍게, Readiness로 의존성 준비 상태를 엄밀히 반영 초기 부트 지연 구간은 startupProbe로 구분해 재시작 루프 예방 권장 참고자료 https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/ https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ ","wordCount":"490","inLanguage":"en","datePublished":"2025-12-11T13:14:28.193Z","dateModified":"2025-12-11T13:14:28.193Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드</h1><div class=post-meta><span title='2025-12-11 13:14:28.193 +0000 UTC'>December 11, 2025</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행
Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침</p><h3 id=핵심-차이>핵심 차이<a hidden class=anchor aria-hidden=true href=#핵심-차이>#</a></h3><ul><li>Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행</li><li>Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행</li><li>본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨</li></ul><h3 id=nodejs-맥락>Node.js 맥락<a hidden class=anchor aria-hidden=true href=#nodejs-맥락>#</a></h3><ul><li>Liveness Probe 대상 상황<ul><li>이벤트 루프 블로킹으로 요청 처리 불가 상태</li><li>무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능</li><li>메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태</li></ul></li><li>Readiness Probe 대상 상황<ul><li>프로세스는 떠 있으나 초기화 작업 진행 중인 상태</li><li>DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태</li></ul></li><li>유의점<ul><li>Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험</li><li>Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함</li></ul></li></ul><h3 id=구현-스니펫>구현 스니펫<a hidden class=anchor aria-hidden=true href=#구현-스니펫>#</a></h3><p>Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장</p><p>간단한 Express 핸들러 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>let</span> isReady <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// Liveness
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>app<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>get</span><span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;/health/live&#39;</span><span style=color:#eceff4>,</span> <span style=color:#eceff4>(</span>_req<span style=color:#eceff4>,</span> res<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> res<span style=color:#eceff4>.</span>status<span style=color:#eceff4>(</span><span style=color:#b48ead>200</span><span style=color:#eceff4>).</span>send<span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;OK&#39;</span><span style=color:#eceff4>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// Readiness
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>app<span style=color:#eceff4>.</span><span style=color:#81a1c1;font-weight:700>get</span><span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;/health/ready&#39;</span><span style=color:#eceff4>,</span> <span style=color:#eceff4>(</span>_req<span style=color:#eceff4>,</span> res<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>if</span> <span style=color:#eceff4>(</span>isReady<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>return</span> res<span style=color:#eceff4>.</span>status<span style=color:#eceff4>(</span><span style=color:#b48ead>200</span><span style=color:#eceff4>).</span>send<span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;OK&#39;</span><span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>return</span> res<span style=color:#eceff4>.</span>status<span style=color:#eceff4>(</span><span style=color:#b48ead>503</span><span style=color:#eceff4>).</span>send<span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;Not Ready&#39;</span><span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>})</span></span></span></code></pre></div><p>준비 플래그는 DB 연결 완료 시점 등에서 true로 전환하는 방식 권장</p><p>Kubernetes 프로브 최소 설정 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#81a1c1>livenessProbe</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>httpGet</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>path</span><span style=color:#eceff4>:</span> /health/live
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>port</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>3000</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>initialDelaySeconds</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>5</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>periodSeconds</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#81a1c1>readinessProbe</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>httpGet</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>path</span><span style=color:#eceff4>:</span> /health/ready
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>port</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>3000</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>initialDelaySeconds</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>5</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>periodSeconds</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>10</span></span></span></code></pre></div><p>앱 기동 시간이 긴 경우 startupProbe 사용 고려</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#81a1c1>startupProbe</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>httpGet</span><span style=color:#eceff4>:</span>
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>path</span><span style=color:#eceff4>:</span> /health/live
</span></span><span style=display:flex><span>    <span style=color:#81a1c1>port</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>3000</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>periodSeconds</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>5</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1>failureThreshold</span><span style=color:#eceff4>:</span> <span style=color:#b48ead>12</span></span></span></code></pre></div><h3 id=주의와-베스트-프랙티스>주의와 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#주의와-베스트-프랙티스>#</a></h3><ul><li>Liveness에 DB 체크 넣지 않기<ul><li>DB 일시 지연으로 Liveness 실패 시 컨테이너 재시작 폭주 발생 가능</li><li>재접속 과부하로 DB 상태 악화, 전체 장애로 확산되는 연쇄 실패 위험</li></ul></li><li>Readiness에는 실제 서비스 처리 가능 상태를 반영<ul><li>DB 연결 불가, 핵심 캐시 미구축 시 503 반환으로 트래픽 유입 차단</li></ul></li><li>초기 지연 대응<ul><li>initialDelaySeconds를 앱 기동 시간보다 여유 있게 설정 또는 startupProbe로 초기 부트 구간 명시</li></ul></li><li>과한 작업 금지<ul><li>Liveness 핸들러에 무거운 로직, 외부 네트워크 호출, 파일 IO 등 포함 금지</li><li>Readiness도 불필요한 비용 최소화, 필요한 의존성 상태만 점검</li></ul></li><li>프로브 타이밍 파라미터 조정<ul><li>periodSeconds, timeoutSeconds, failureThreshold를 워크로드 특성에 맞춰 튜닝</li><li>일시적 네트워크 지연에 과민하지 않도록 실패 임계값 완충 적용</li></ul></li><li>엔드포인트 분리<ul><li>/health/live와 /health/ready는 별도 라우트로 유지, 공용 미들웨어에서 불필요한 비용 유입 방지</li></ul></li></ul><h3 id=운영-시-고려사항>운영 시 고려사항<a hidden class=anchor aria-hidden=true href=#운영-시-고려사항>#</a></h3><ul><li>배포 중 Readiness가 OK가 될 때까지 로드밸런서가 신규 파드로 트래픽을 라우팅하지 않음<ul><li>롤링 업데이트 시 502와 같은 전이적 오류 방지에 효과적</li></ul></li><li>장애 상황 가시화<ul><li>Liveness 재시작 이벤트와 Readiness 변화를 모니터링 지표로 수집하면 회귀나 성능 저하 조기 탐지에 유용</li></ul></li><li>Node.js 특성 반영<ul><li>이벤트 루프 블로킹은 Liveness로 조기 감지 가능</li><li>메모리 누수로 인한 GC 압박과 응답 지연은 Readiness 변동과 함께 관찰 시 원인 추적에 도움</li></ul></li></ul><h3 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h3><ul><li>Liveness Probe는 죽었으면 살려내라, 실패 시 재시작 수행</li><li>Readiness Probe는 준비 안 됐으면 손님 받지 마라, 실패 시 트래픽 차단 수행</li><li>Node.js에서는 Liveness를 가볍게, Readiness로 의존성 준비 상태를 엄밀히 반영</li><li>초기 부트 지연 구간은 startupProbe로 구분해 재시작 루프 예방 권장</li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></li><li><a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes</a></li><li><a href=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/>https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/kubernetes/>Kubernetes</a></li><li><a href=https://blog.jsontapose.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jsontapose.com/tags/liveness-probe/>Liveness-Probe</a></li><li><a href=https://blog.jsontapose.com/tags/readiness-probe/>Readiness-Probe</a></li><li><a href=https://blog.jsontapose.com/tags/health-check/>Health-Check</a></li><li><a href=https://blog.jsontapose.com/tags/devops/>Devops</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/><span class=title>« Prev</span><br><span>Node.js 글로벌 에러 핸들러 가이드</span>
</a><a class=next href=https://blog.jsontapose.com/posts/javascript-array-flatmap-22e1f3/><span class=title>Next »</span><br><span>JavaScript Array.prototype.flatMap 개념과 사용 예시</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on x" href="https://x.com/intent/tweet/?text=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f&amp;hashtags=kubernetes%2cnodejs%2cliveness-probe%2creadiness-probe%2chealth-check%2cdevops"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f&amp;title=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;summary=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f&title=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on whatsapp" href="https://api.whatsapp.com/send?text=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on telegram" href="https://telegram.me/share/url?text=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kubernetes%ec%97%90%ec%84%9c%20Node.js%20Liveness%ec%99%80%20Readiness%20Probe%20%ec%84%a4%ea%b3%84%20%ea%b0%80%ec%9d%b4%eb%93%9c&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fkubernetes-nodejs-liveness-readiness-probe-guide-4853ec%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>