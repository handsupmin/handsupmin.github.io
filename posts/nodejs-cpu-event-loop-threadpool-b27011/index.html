<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 | HandsLog</title>
<meta name=keywords content="nodejs,event-loop,libuv,linux-kernel,cpu,performance,io,worker-threads,scalability,profiling"><meta name=description content="개요
목표  이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기
Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음
CPU 코어와 OS 스레드의 물리적 의미
하드웨어와 OS 레벨 정의를 먼저 정리

CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개
스레드  OS 스케줄러가 CPU를 할당하는 최소 단위
동시성 vs 병렬성

코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성
코어 여러 개일 때만 실제 병렬 실행 가능



CPU 관점의 핵심 비용"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용"><meta property="og:description" content="개요 목표 이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기 Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음
CPU 코어와 OS 스레드의 물리적 의미 하드웨어와 OS 레벨 정의를 먼저 정리
CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개 스레드 OS 스케줄러가 CPU를 할당하는 최소 단위 동시성 vs 병렬성 코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성 코어 여러 개일 때만 실제 병렬 실행 가능 CPU 관점의 핵심 비용"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-22T13:16:57+00:00"><meta property="article:modified_time" content="2026-01-22T13:16:57+00:00"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Event-Loop"><meta property="article:tag" content="Libuv"><meta property="article:tag" content="Linux-Kernel"><meta property="article:tag" content="Cpu"><meta property="article:tag" content="Performance"><meta name=twitter:card content="summary"><meta name=twitter:title content="CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용"><meta name=twitter:description content="개요
목표  이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기
Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음
CPU 코어와 OS 스레드의 물리적 의미
하드웨어와 OS 레벨 정의를 먼저 정리

CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개
스레드  OS 스케줄러가 CPU를 할당하는 최소 단위
동시성 vs 병렬성

코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성
코어 여러 개일 때만 실제 병렬 실행 가능



CPU 관점의 핵심 비용"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용","item":"https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용","name":"CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용","description":"개요 목표 이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기 Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음\nCPU 코어와 OS 스레드의 물리적 의미 하드웨어와 OS 레벨 정의를 먼저 정리\nCPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개 스레드 OS 스케줄러가 CPU를 할당하는 최소 단위 동시성 vs 병렬성 코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성 코어 여러 개일 때만 실제 병렬 실행 가능 CPU 관점의 핵심 비용\n","keywords":["nodejs","event-loop","libuv","linux-kernel","cpu","performance","io","worker-threads","scalability","profiling"],"articleBody":"개요 목표 이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기 Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음\nCPU 코어와 OS 스레드의 물리적 의미 하드웨어와 OS 레벨 정의를 먼저 정리\nCPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개 스레드 OS 스케줄러가 CPU를 할당하는 최소 단위 동시성 vs 병렬성 코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성 코어 여러 개일 때만 실제 병렬 실행 가능 CPU 관점의 핵심 비용\n실행 유저 코드나 커널 코드가 실제로 CPU 사이클 소모 대기 I O 응답 등으로 CPU 미사용 상태 Blocked 문맥 교환 OS가 실행 중인 스레드를 바꾸는 과정 레지스터 저장 복원, 캐시 오염 등 오버헤드 발생 Node.js의 실행 모델 Actors Node.js 프로세스가 CPU 자원을 소비하는 주체 세 가지로 단순화 가능\n메인 스레드 Event Loop 정체 Node.js 시작 시 생성되는 단 하나의 OS 스레드 역할 V8 엔진 위 JS 실행, 콜백 처리, 비동기 요청 등록 CPU 특징 대부분 사용자 모드에서 CPU 사용 이 스레드가 막히면 애플리케이션 전체가 멈춘 것으로 체감됨 커널 Linux Kernel 정체 OS의 핵심 컴포넌트, 하드웨어 제어 역할 TCP IP 스택, 파일 시스템, epoll 기반 이벤트 통지 처리 CPU 특징 시스템 콜 수행 시 유저 모드와 커널 모드 전환이 일어나며 CPU 사용 libuv 스레드풀 Thread Pool 정체 Node.js 프로세스 내부의 별도 OS 스레드 그룹 기본 4개 역할 OS가 비동기를 직접 제공하지 않거나 CPU 연산이 큰 작업을 오프로딩 파일 I O 완전 비동기 파일 접근은 OS마다 제약 존재 일부 암호화 crypto, 압축 zlib, TLS 연산 일부 dns.lookup 시스템 리졸버 호출 CPU 특징 메인 스레드와 별개로 스케줄링되어 멀티 코어 환경에서 병렬 처리 가능 시나리오별 CPU 자원 흐름 A) 순수 CPU 연산 CPU bound 예 거대한 루프, 복잡한 정규식, 대용량 JSON.parse, 암호화 해싱\n흐름 메인 스레드가 V8 위에서 코드를 연속 실행 CPU 상태 메인 스레드 CPU 점유율 100% 근접 문제점 메인 스레드 점유로 완료된 I O 이벤트나 타이머 콜백 처리가 지연되어 기아 Starvation 발생 사용자는 Node가 멈춘 것으로 인지 해결 worker_threads로 오프로딩하거나 외부 프로세스로 분리 B) 네트워크 I O Network bound 예 HTTP 요청 응답, DB 쿼리 대기\n흐름 요청 메인 스레드가 write 시스템 콜 호출 짧은 CPU 사용 대기 커널이 NIC로 패킷 전송 후 응답 대기 메인 스레드는 Non blocking으로 다른 일 처리 수신 패킷 도착 시 커널 인터럽트 처리 후 epoll로 이벤트 준비 처리 메인 스레드가 깨어나 콜백 실행 CPU 상태 네트워크 대기 시간 동안 CPU 사용량 거의 0 수천 연결도 실제 패킷 처리 시점에만 CPU 사용 집중 특징 스레드풀 불사용 Node.js가 가장 효율적인 영역 C) 파일 I O Disk bound 예 fs.readFile, fs.writeFile Async\n파일 시스템 작업은 libuv 스레드풀로 이관되는 경우가 일반적임 Linux AIO 제약 및 이식성 이슈\n흐름 위임 메인 스레드는 작업을 스레드풀 큐에 넣고 즉시 리턴 작업 스레드풀 스레드가 read write 시스템 콜 수행 후 디스크 응답을 블로킹 대기 완료 작업 완료 시 스레드풀이 메인 스레드에 이벤트 통지 CPU 상태 메인 스레드는 자유롭게 다른 이벤트 처리 스레드풀 스레드는 I O 대기와 메모리 복사 구간에서만 CPU 사용 상태 전환 주의 스레드풀 크기 기본 4개를 초과하는 동시 파일 요청 시 큐 대기 증가로 지연 확대 UV_THREADPOOL_SIZE 튜닝 필요 예시 최소 스니펫 환경변수 기반 스레드풀 크기 조정\nUV_THREADPOOL_SIZE=32 node app.js D) DNS 조회 함정 주의 dns.lookup 도메인 OS의 getaddrinfo 호출을 사용 호출 자체는 블로킹 모델이므로 libuv 스레드풀에서 실행 JS는 블로킹되지 않지만 스레드풀 슬롯을 점유 dns.resolve 도메인 c-ares 기반 비동기 리졸버 사용 네트워크 I O처럼 동작하며 스레드풀 미사용 커널 비동기 메커니즘과 이벤트 루프로 처리 CPU 관점에서 자주 헷갈리는 개념 Node.js는 싱글 스레드다 정확히는 JS 코드 실행 컨텍스트가 메인 스레드 하나라는 의미 실제 프로세스는 libuv 스레드풀 기본 4개와 V8 내부 스레드 GC, 최적화 등 포함 다수 OS 스레드 사용\nAsync 작업은 모두 스레드풀에서 돈다 아님 네트워크 I O HTTP, TCP는 스레드풀을 거치지 않고 epoll kqueue 등 커널 비동기를 사용 CPU 효율 우수 파일 I O, 암호화, 압축, DNS lookup 등은 스레드풀 사용\nCPU 코어가 많으면 Node.js 하나로 충분한가 아님 메인 스레드는 한 번에 코어 1개만 사용 가능 코어 8개면 프로세스 다중화 cluster 또는 worker_threads로 병렬성 확보 필요\n실무 진단 CPU 패턴으로 병목 찾기 모니터링의 CPU 그래프와 지연 시간으로 병목 추론\n증상 CPU 패턴 예상 원인 조치 응답 매우 느림 CPU 100% Core 1개 CPU bound 무한루프, 큰 연산 프로파일링으로 핫스팟 식별, 워커 분리 응답 느림 CPU 낮음 Idle I O bound 외부 API, DB 지연 외부 서비스 상태 점검, 쿼리 튜닝 간헐적 멈춤 톱니바퀴 모양 스파이크 GC 가비지 컬렉션 또는 Burst 작업 메모리 누수 점검, 힙 사이즈 조정 파일 처리 지연 CPU 보통, Latency 증가 스레드풀 고갈 UV_THREADPOOL_SIZE 증가 고려 보강 팁\nTLS 핸드셰이크의 암 복호화는 crypto 연산으로 스레드풀 사용 가능 네트워크 I O 자체와 분리해 관찰 권장 GC 스파이크는 이벤트 루프 지연으로 직결 샘플링 프로파일링과 힙 스냅샷으로 원인 추적 권장 파일 I O가 지배적이면 스토리지 대역폭과 IOPS 지표를 함께 확인 필요 요약 메인 스레드 보호가 최우선 JS 실행이 막히면 서버 전체가 멈춘 것과 다름없음 I O는 대기 시간을 커널이 책임 Node.js는 이 기다림을 비동기로 효율 처리 스레드풀은 만능 아님 파일 시스템과 무거운 연산을 위한 보조 수단 네트워크 처리는 스레드풀과 무관하게 더 효율적으로 동작 마무리 CPU 코어와 OS 스레드의 물리적 제약, 커널 비동기 모델, libuv 스레드풀의 역할을 분리해 보면 병목 지점이 선명해짐 워커 스레드 도입, 프로세스 다중화, 스레드풀 튜닝, 외부 I O 지연 제거 순으로 단계적 최적화 권장\n참고자료 https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick https://nodejs.org/api/cli.html#uv_threadpool_size-size https://nodejs.org/api/worker_threads.html https://nodejs.org/api/dns.html https://nodejs.org/api/fs.html https://libuv.org/ https://man7.org/linux/man-pages/man7/epoll.7.html https://c-ares.org/ ","wordCount":"854","inLanguage":"en","datePublished":"2026-01-22T13:16:57.22Z","dateModified":"2026-01-22T13:16:57.22Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용</h1><div class=post-meta><span title='2026-01-22 13:16:57.22 +0000 UTC'>January 22, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>목표 이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기
Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음</p><h3 id=cpu-코어와-os-스레드의-물리적-의미>CPU 코어와 OS 스레드의 물리적 의미<a hidden class=anchor aria-hidden=true href=#cpu-코어와-os-스레드의-물리적-의미>#</a></h3><p>하드웨어와 OS 레벨 정의를 먼저 정리</p><ul><li>CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개</li><li>스레드 OS 스케줄러가 CPU를 할당하는 최소 단위</li><li>동시성 vs 병렬성<ul><li>코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성</li><li>코어 여러 개일 때만 실제 병렬 실행 가능</li></ul></li></ul><p>CPU 관점의 핵심 비용</p><ol><li>실행 유저 코드나 커널 코드가 실제로 CPU 사이클 소모</li><li>대기 I O 응답 등으로 CPU 미사용 상태 Blocked</li><li>문맥 교환 OS가 실행 중인 스레드를 바꾸는 과정 레지스터 저장 복원, 캐시 오염 등 오버헤드 발생</li></ol><h3 id=nodejs의-실행-모델--actors>Node.js의 실행 모델 Actors<a hidden class=anchor aria-hidden=true href=#nodejs의-실행-모델--actors>#</a></h3><p>Node.js 프로세스가 CPU 자원을 소비하는 주체 세 가지로 단순화 가능</p><h4 id=메인-스레드--event-loop>메인 스레드 Event Loop<a hidden class=anchor aria-hidden=true href=#메인-스레드--event-loop>#</a></h4><ul><li>정체 Node.js 시작 시 생성되는 단 하나의 OS 스레드</li><li>역할 V8 엔진 위 JS 실행, 콜백 처리, 비동기 요청 등록</li><li>CPU 특징 대부분 사용자 모드에서 CPU 사용 이 스레드가 막히면 애플리케이션 전체가 멈춘 것으로 체감됨</li></ul><h4 id=커널--linux-kernel>커널 Linux Kernel<a hidden class=anchor aria-hidden=true href=#커널--linux-kernel>#</a></h4><ul><li>정체 OS의 핵심 컴포넌트, 하드웨어 제어</li><li>역할 TCP IP 스택, 파일 시스템, epoll 기반 이벤트 통지 처리</li><li>CPU 특징 시스템 콜 수행 시 유저 모드와 커널 모드 전환이 일어나며 CPU 사용</li></ul><h4 id=libuv-스레드풀--thread-pool>libuv 스레드풀 Thread Pool<a hidden class=anchor aria-hidden=true href=#libuv-스레드풀--thread-pool>#</a></h4><ul><li>정체 Node.js 프로세스 내부의 별도 OS 스레드 그룹 기본 4개</li><li>역할 OS가 비동기를 직접 제공하지 않거나 CPU 연산이 큰 작업을 오프로딩<ul><li>파일 I O 완전 비동기 파일 접근은 OS마다 제약 존재</li><li>일부 암호화 crypto, 압축 zlib, TLS 연산 일부</li><li>dns.lookup 시스템 리졸버 호출</li></ul></li><li>CPU 특징 메인 스레드와 별개로 스케줄링되어 멀티 코어 환경에서 병렬 처리 가능</li></ul><h3 id=시나리오별-cpu-자원-흐름>시나리오별 CPU 자원 흐름<a hidden class=anchor aria-hidden=true href=#시나리오별-cpu-자원-흐름>#</a></h3><h4 id=a-순수-cpu-연산--cpu-bound>A) 순수 CPU 연산 CPU bound<a hidden class=anchor aria-hidden=true href=#a-순수-cpu-연산--cpu-bound>#</a></h4><p>예 거대한 루프, 복잡한 정규식, 대용량 JSON.parse, 암호화 해싱</p><ol><li>흐름 메인 스레드가 V8 위에서 코드를 연속 실행</li><li>CPU 상태 메인 스레드 CPU 점유율 100% 근접</li><li>문제점 메인 스레드 점유로 완료된 I O 이벤트나 타이머 콜백 처리가 지연되어 기아 Starvation 발생 사용자는 Node가 멈춘 것으로 인지</li><li>해결 worker_threads로 오프로딩하거나 외부 프로세스로 분리</li></ol><h4 id=b-네트워크-i-o--network-bound>B) 네트워크 I O Network bound<a hidden class=anchor aria-hidden=true href=#b-네트워크-i-o--network-bound>#</a></h4><p>예 HTTP 요청 응답, DB 쿼리 대기</p><ol><li>흐름</li></ol><ul><li>요청 메인 스레드가 write 시스템 콜 호출 짧은 CPU 사용</li><li>대기 커널이 NIC로 패킷 전송 후 응답 대기 메인 스레드는 Non blocking으로 다른 일 처리</li><li>수신 패킷 도착 시 커널 인터럽트 처리 후 epoll로 이벤트 준비</li><li>처리 메인 스레드가 깨어나 콜백 실행</li></ul><ol start=2><li>CPU 상태</li></ol><ul><li>네트워크 대기 시간 동안 CPU 사용량 거의 0</li><li>수천 연결도 실제 패킷 처리 시점에만 CPU 사용 집중</li></ul><ol start=3><li>특징 스레드풀 불사용 Node.js가 가장 효율적인 영역</li></ol><h4 id=c-파일-i-o--disk-bound>C) 파일 I O Disk bound<a hidden class=anchor aria-hidden=true href=#c-파일-i-o--disk-bound>#</a></h4><p>예 fs.readFile, fs.writeFile Async</p><p>파일 시스템 작업은 libuv 스레드풀로 이관되는 경우가 일반적임 Linux AIO 제약 및 이식성 이슈</p><ol><li>흐름</li></ol><ul><li>위임 메인 스레드는 작업을 스레드풀 큐에 넣고 즉시 리턴</li><li>작업 스레드풀 스레드가 read write 시스템 콜 수행 후 디스크 응답을 블로킹 대기</li><li>완료 작업 완료 시 스레드풀이 메인 스레드에 이벤트 통지</li></ul><ol start=2><li>CPU 상태</li></ol><ul><li>메인 스레드는 자유롭게 다른 이벤트 처리</li><li>스레드풀 스레드는 I O 대기와 메모리 복사 구간에서만 CPU 사용 상태 전환</li></ul><ol start=3><li>주의 스레드풀 크기 기본 4개를 초과하는 동시 파일 요청 시 큐 대기 증가로 지연 확대 UV_THREADPOOL_SIZE 튜닝 필요</li></ol><p>예시 최소 스니펫 환경변수 기반 스레드풀 크기 조정</p><ul><li>UV_THREADPOOL_SIZE=32 node app.js</li></ul><h4 id=d-dns-조회--함정-주의>D) DNS 조회 함정 주의<a hidden class=anchor aria-hidden=true href=#d-dns-조회--함정-주의>#</a></h4><ul><li>dns.lookup 도메인 OS의 getaddrinfo 호출을 사용 호출 자체는 블로킹 모델이므로 libuv 스레드풀에서 실행 JS는 블로킹되지 않지만 스레드풀 슬롯을 점유</li><li>dns.resolve 도메인 c-ares 기반 비동기 리졸버 사용 네트워크 I O처럼 동작하며 스레드풀 미사용 커널 비동기 메커니즘과 이벤트 루프로 처리</li></ul><h3 id=cpu-관점에서-자주-헷갈리는-개념>CPU 관점에서 자주 헷갈리는 개념<a hidden class=anchor aria-hidden=true href=#cpu-관점에서-자주-헷갈리는-개념>#</a></h3><h4 id=nodejs는-싱글-스레드다>Node.js는 싱글 스레드다<a hidden class=anchor aria-hidden=true href=#nodejs는-싱글-스레드다>#</a></h4><p>정확히는 JS 코드 실행 컨텍스트가 메인 스레드 하나라는 의미
실제 프로세스는 libuv 스레드풀 기본 4개와 V8 내부 스레드 GC, 최적화 등 포함 다수 OS 스레드 사용</p><h4 id=async-작업은-모두-스레드풀에서-돈다>Async 작업은 모두 스레드풀에서 돈다<a hidden class=anchor aria-hidden=true href=#async-작업은-모두-스레드풀에서-돈다>#</a></h4><p>아님
네트워크 I O HTTP, TCP는 스레드풀을 거치지 않고 epoll kqueue 등 커널 비동기를 사용 CPU 효율 우수
파일 I O, 암호화, 압축, DNS lookup 등은 스레드풀 사용</p><h4 id=cpu-코어가-많으면-nodejs-하나로-충분한가>CPU 코어가 많으면 Node.js 하나로 충분한가<a hidden class=anchor aria-hidden=true href=#cpu-코어가-많으면-nodejs-하나로-충분한가>#</a></h4><p>아님 메인 스레드는 한 번에 코어 1개만 사용 가능
코어 8개면 프로세스 다중화 cluster 또는 worker_threads로 병렬성 확보 필요</p><h3 id=실무-진단--cpu-패턴으로-병목-찾기>실무 진단 CPU 패턴으로 병목 찾기<a hidden class=anchor aria-hidden=true href=#실무-진단--cpu-패턴으로-병목-찾기>#</a></h3><p>모니터링의 CPU 그래프와 지연 시간으로 병목 추론</p><table><thead><tr><th>증상</th><th>CPU 패턴</th><th>예상 원인</th><th>조치</th></tr></thead><tbody><tr><td>응답 매우 느림</td><td>CPU 100% Core 1개</td><td>CPU bound 무한루프, 큰 연산</td><td>프로파일링으로 핫스팟 식별, 워커 분리</td></tr><tr><td>응답 느림</td><td>CPU 낮음 Idle</td><td>I O bound 외부 API, DB 지연</td><td>외부 서비스 상태 점검, 쿼리 튜닝</td></tr><tr><td>간헐적 멈춤</td><td>톱니바퀴 모양 스파이크</td><td>GC 가비지 컬렉션 또는 Burst 작업</td><td>메모리 누수 점검, 힙 사이즈 조정</td></tr><tr><td>파일 처리 지연</td><td>CPU 보통, Latency 증가</td><td>스레드풀 고갈</td><td>UV_THREADPOOL_SIZE 증가 고려</td></tr></tbody></table><p>보강 팁</p><ul><li>TLS 핸드셰이크의 암 복호화는 crypto 연산으로 스레드풀 사용 가능 네트워크 I O 자체와 분리해 관찰 권장</li><li>GC 스파이크는 이벤트 루프 지연으로 직결 샘플링 프로파일링과 힙 스냅샷으로 원인 추적 권장</li><li>파일 I O가 지배적이면 스토리지 대역폭과 IOPS 지표를 함께 확인 필요</li></ul><h3 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h3><ol><li>메인 스레드 보호가 최우선 JS 실행이 막히면 서버 전체가 멈춘 것과 다름없음</li><li>I O는 대기 시간을 커널이 책임 Node.js는 이 기다림을 비동기로 효율 처리</li><li>스레드풀은 만능 아님 파일 시스템과 무거운 연산을 위한 보조 수단 네트워크 처리는 스레드풀과 무관하게 더 효율적으로 동작</li></ol><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>CPU 코어와 OS 스레드의 물리적 제약, 커널 비동기 모델, libuv 스레드풀의 역할을 분리해 보면 병목 지점이 선명해짐
워커 스레드 도입, 프로세스 다중화, 스레드풀 튜닝, 외부 I O 지연 제거 순으로 단계적 최적화 권장</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick>https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick</a></li><li><a href=https://nodejs.org/api/cli.html#uv_threadpool_size-size>https://nodejs.org/api/cli.html#uv_threadpool_size-size</a></li><li><a href=https://nodejs.org/api/worker_threads.html>https://nodejs.org/api/worker_threads.html</a></li><li><a href=https://nodejs.org/api/dns.html>https://nodejs.org/api/dns.html</a></li><li><a href=https://nodejs.org/api/fs.html>https://nodejs.org/api/fs.html</a></li><li><a href=https://libuv.org/>https://libuv.org/</a></li><li><a href=https://man7.org/linux/man-pages/man7/epoll.7.html>https://man7.org/linux/man-pages/man7/epoll.7.html</a></li><li><a href=https://c-ares.org/>https://c-ares.org/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jsontapose.com/tags/event-loop/>Event-Loop</a></li><li><a href=https://blog.jsontapose.com/tags/libuv/>Libuv</a></li><li><a href=https://blog.jsontapose.com/tags/linux-kernel/>Linux-Kernel</a></li><li><a href=https://blog.jsontapose.com/tags/cpu/>Cpu</a></li><li><a href=https://blog.jsontapose.com/tags/performance/>Performance</a></li><li><a href=https://blog.jsontapose.com/tags/io/>Io</a></li><li><a href=https://blog.jsontapose.com/tags/worker-threads/>Worker-Threads</a></li><li><a href=https://blog.jsontapose.com/tags/scalability/>Scalability</a></li><li><a href=https://blog.jsontapose.com/tags/profiling/>Profiling</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/><span class=title>« Prev</span><br><span>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</span>
</a><a class=next href=https://blog.jsontapose.com/posts/ethereum-transaction-nonce-states-7cf0f0/><span class=title>Next »</span><br><span>nonce가 꼬인다? 트랜잭션 상태별 nonce의 변화</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on x" href="https://x.com/intent/tweet/?text=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f&amp;hashtags=nodejs%2cevent-loop%2clibuv%2clinux-kernel%2ccpu%2cperformance%2cio%2cworker-threads%2cscalability%2cprofiling"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f&amp;title=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9&amp;summary=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f&title=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on whatsapp" href="https://api.whatsapp.com/send?text=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on telegram" href="https://telegram.me/share/url?text=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용 on ycombinator" href="https://news.ycombinator.com/submitlink?t=CPU%20%ec%9e%90%ec%9b%90%20%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%20%eb%b3%b4%eb%8a%94%20Node.js%20%ec%9d%b4%eb%b2%a4%ed%8a%b8%20%eb%a3%a8%ed%94%84%ec%99%80%20%ec%8a%a4%eb%a0%88%eb%93%9c%ed%92%80%20%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fnodejs-cpu-event-loop-threadpool-b27011%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>