<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 | HandsLog</title>
<meta name=keywords content="ramda,functional-programming,javascript,typescript,immutability,currying,composition"><meta name=description content="개요
Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임
순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦
이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함

R.prop 개념과 문법
목적과 동작 원리

객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구
속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환
커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함

시그니처"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항"><meta property="og:description" content="개요 Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임 순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦 이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함
R.prop 개념과 문법 목적과 동작 원리
객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구 속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환 커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함 시그니처"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-04T13:25:03+00:00"><meta property="article:modified_time" content="2026-02-04T13:25:03+00:00"><meta property="article:tag" content="Ramda"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Immutability"><meta property="article:tag" content="Currying"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항"><meta name=twitter:description content="개요
Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임
순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦
이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함

R.prop 개념과 문법
목적과 동작 원리

객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구
속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환
커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함

시그니처"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항","item":"https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항","name":"Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항","description":"개요 Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임 순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦 이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함\nR.prop 개념과 문법 목적과 동작 원리\n객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구 속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환 커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함 시그니처\n","keywords":["ramda","functional-programming","javascript","typescript","immutability","currying","composition"],"articleBody":"개요 Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임 순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦 이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함\nR.prop 개념과 문법 목적과 동작 원리\n객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구 속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환 커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함 시그니처\nR.prop(propName, obj) → any 커링 지원, 부분 적용 가능 간단 예시\nconst getName = R.prop(’name') getName({ name: ‘Alice’, age: 25 }) ⇒ ‘Alice’ getName({ age: 25 }) ⇒ undefined 조합에서의 쓰임새\n컬렉션 변환에서 map과 조합해 특정 필드 집계에 활용 파이프라인의 초입에서 안전한 데이터 선택자로 사용 주의\n중첩 경로는 R.path 사용 권장 null 또는 undefined 대상에 대한 접근 시에도 오류 없이 undefined 반환 설치와 로드 npm install ramda 또는 pnpm add ramda CommonJS 환경에서는 const R = require(‘ramda’) ESM/TS에서는 import * as R from ‘ramda’ TypeScript 타입 정의 포함되어 별도 @types 설치 불요 Ramda의 설계 철학과 장점 핵심 개념\n순수 함수 중심 설계, 입력이 같으면 출력도 같음, 부작용 최소화 불변성 지향, 원본 데이터 변경 대신 사본 반환 모든 주요 함수 커링 지원, 부분 적용을 통해 의도와 맥락을 코드에 드러냄 함수 → 데이터 인자 순서 통일, compose와 pipe로 읽기 좋은 데이터 흐름 구성 효과\n선언적 코드 스타일 유도, 제어 흐름 대신 데이터 흐름 표현 테스트 용이성 증가, 예측 가능한 동작 조합 가능한 작은 함수 단위로 유지보수성 향상 컬렉션 변환의 기본기 맵과 리듀스의 Ramda 버전 특징\nR.map(f, list) 형태의 인자 순서, 커링 친화적 설계 R.reduce(reducer, init, list)로 누적 계산 표현 간결화 합계는 R.sum, 평균은 R.mean 등 단축 함수 사용 권장 짧은 스니펫\nconst names = R.map(R.prop('name'))(users) const total = R.reduce((acc, x) =\u003e acc + x, 0)(nums)가변 인자 함수 적용\n배열을 펼쳐 인자로 적용해야 하는 경우 R.apply 사용 예시 용도는 Math.max, Math.min 같은 내장 함수 호출 커링과 자리 표시자 R.curry로 부분 적용을 일상화\n다인자 함수를 맥락마다 일부 인자 고정해 재사용 단위로 분해 앞쪽 인자부터 고정되는 점 고려해 인자 순서를 의도적으로 설계 자리 표시자 R.__\n특정 인자를 비워두고 뒤 인자부터 고정하고 싶을 때 사용 짧은 스니펫\nconst volume = R.curry((d, w, h) =\u003e d * w * h) const area = volume(1) area(3, 4) // 12 함수 조합과 파이프라인 R.pipe와 R.compose\npipe는 왼쪽에서 오른쪽으로 데이터 흐름 표현에 적합 compose는 수학적 표기와 같이 오른쪽에서 왼쪽으로 평가 조합 결과는 다시 1급 함수로 재사용 가능 짧은 스니펫\nconst normalize = R.pipe(Math.sqrt, Math.round, String) normalize(10) // '3' 원소와 속성 접근 유틸리티 R.nth(n, list) 안전한 n번째 원소 접근, 없으면 undefined R.prop(k, obj) 안전한 단일 속성 접근, 없으면 undefined R.path([k1, k2, …], obj) 중첩 경로 안전 접근 이들 함수는 예외 대신 undefined를 반환하므로 파이프라인 중간에 안전하게 삽입 가능함\n컬렉션 생성과 가공 생성\nR.range(from, to) 반열린 구간 수열 생성, 끝값 제외 R.repeat(item, n) 동일 원소 반복 리스트 생성 필터와 정렬\nR.filter(pred, list) 조건을 만족하는 원소만 유지 R.sort(compare, list) 비교 함수를 이용한 정렬, 불변성 유지 R.reverse(listOrString) 역순 변환 연결과 분할\nR.concat(a, b) 리스트 또는 문자열 연결 R.append(x, list) 뒤에 원소 추가한 새 리스트 반환 R.prepend(x, list) 앞에 원소 추가한 새 리스트 반환 R.head(list) 첫 원소 안전 참조, 없으면 undefined R.take(n, list), R.takeLast(n, list) 앞뒤에서 n개 취함 R.drop(n, list), R.dropLast(n, list) 앞뒤에서 n개 제거 R.slice(from, to, list) 구간 슬라이스, Infinity로 끝까지 표현 가능 객체 불변 업데이트\nR.assoc(k, v, obj) 키를 v로 갱신한 새 객체 반환 R.dissoc(k, obj) 키 제거한 새 객체 반환 깊은 경로는 R.assocPath, R.dissocPath 사용 고려 집합 연산 중복 제거와 멱등 연산을 기반으로 한 집합 다루기\nR.union(a, b) 합집합, 좌측 우선 보존 규칙으로 순서 결정 R.intersection(a, b) 교집합, a의 순서를 보존하며 b에 존재하는 원소만 유지 R.difference(a, b) 차집합, a에서 b에 포함된 원소 제거 주의\nRamda의 집합 연산은 참조 동등성 또는 지정된 동등 비교 규칙에 의존함 객체 요소의 동등성 비교가 필요한 경우 R.unionWith, R.intersectionWith 등 커스텀 비교자 사용 고려 논리와 조건 유틸리티 타입 검사\nR.is(Ctor, val) 생성자 기반 인스턴스 여부 검사 커링으로 특정 타입 가드 유틸 생성에 용이 논리 부정\nR.complement(pred) 논리 결과 반전 함수 생성 양·음의 범위\nR.all(pred, list) 모두 참인지 검사 R.any(pred, list) 하나라도 참인지 검사 상수 함숫값\nR.T 항진 함수, 항상 true 반환 R.F 항진 함수, 항상 false 반환 R.always(x) 항상 x를 반환하는 함수 생성 분기 구성\nR.cond([[pred1, f1], [pred2, f2], …]) 다중 분기를 표현하는 조합기 TypeScript에서의 Ramda 타입 정의\nRamda는 자체 타입 정의를 포함, 일반적인 사용에서 추가 설치 없이 타입 안전성 확보 가능 복잡한 조합이나 가변 길이 파이프라인에서 추론 경계 존재, 필요 시 함수 경계에 명시적 타입 주석 권장 실전 팁\n컬렉션 연산에서는 제네릭 타입 변수의 구체화를 돕기 위해 람다식 인자에 타입 주석 추가 R.path, R.assocPath 사용 시 경로와 결과 타입을 명시해 추론 실패에 대비 짧은 스니펫\ntype User = { name: string; age: number } const users: User[] = [ { name: 'A', age: 25 }, { name: 'B', age: 30 } ] const names: string[] = R.map((u: User) =\u003e u.name)(users) R.prop 심화 활용 패턴 배열에서 특정 필드 수집\nR.map(R.prop(‘field’), list)로 간결하게 필드 리스트 생성 기본값과의 결합\nR.pipe(R.prop(‘field’), R.defaultTo(defaultValue))로 안전한 디폴트 적용 안전한 중첩 접근\nR.pipe(R.path([‘a’, ‘b’, ‘c’]), R.defaultTo(fallback)) 사용 옵셔널 체이닝과 비교\n언어 레벨 옵셔널 체이닝 a?.b?.c는 문법 설탕, Ramda는 함수 조합으로 동일 흐름을 데이터 파이프라인으로 유지 일관된 형식의 함수형 파이프라인을 선호한다면 R.path 기반 접근 유지 권장 흔한 함정과 우회 전략 R.and와 R.or의 오해\nR.and와 R.or는 이항 불 연산을 커링한 함수로, 전달된 피연산자 자체의 진리성만 평가함 R.and(fn1, fn2)(x)처럼 술어 함수를 인자로 넘기면 fn1과 fn2 함수 객체가 모두 truthy이므로 결과가 항상 truthy가 되는 문제가 발생함 동일 인자 x에 대해 두 술어를 모두 평가하는 목적이라면 R.both(pred1, pred2) 또는 R.allPass([pred1, pred2]) 사용 동일하게 OR 조합이 필요하면 R.either 또는 R.anyPass 사용 짧은 스니펫\nconst isNotNil = R.complement(R.isNil) const isNotEmpty = (v: any) =\u003e !(Array.isArray(v) \u0026\u0026 v.length === 0) \u0026\u0026 v !== '' const valid = R.both(isNotNil, isNotEmpty) valid(undefined) // false valid('0x1234') // true 인자 순서와 커링\nJS 내장 Array.map은 수신자 메서드 형태로 데이터 → 함수 순서, Ramda는 함수 → 데이터 순서 조합과 부분 적용을 적극 사용하려면 Ramda의 순서가 유리 지나친 조합과 타입 추론 붕괴\n단계가 많은 pipe에서 중간 단계 타입이 모호하면 추론 실패 가능성 존재 경계마다 반환 타입 주석 추가 또는 조합 단위를 의미 있게 쪼개기 권장 성능과 가독성 균형\n소규모 유틸을 과도하게 조합하면 호출 오버헤드와 디버깅 난도가 증가할 수 있음 파이프라인 단계 수를 의미 중심으로 제한, 필요한 곳에서만 미세 최적화 실전 조합 레시피 데이터 정규화 파이프라인\n공백 트리밍 → 소문자화 → 빈 문자열을 null로 치환하는 흐름을 pipe로 명시 예 R.pipe(R.trim, R.toLower, v =\u003e v === ’’ ? null : v) 불변 업데이트로 조건적 갱신\n특정 필드가 존재할 때만 새 값 적용 예 R.when(R.has(‘flag’), R.assoc(‘updated’, true)) 컬렉션에서 안전한 선택 후 변환\n예 R.pipe(R.map(R.prop(‘id’)), R.filter(Boolean), R.uniq) 조건 분기 단순화\n다중 if-else를 R.cond로 옮겨 비즈니스 규칙을 데이터로 표현 요약 R.prop은 안전한 속성 접근의 기본 단위, 커링과 조합에서 재사용성 높음 Ramda는 함수 → 데이터 인자 순서로 조합 친화적인 API를 제공, 불변성과 순수 함수 원칙을 일관되게 지원 파이프라인은 pipe와 compose로 구성, 컬렉션 변환은 map·filter·reduce 계열로 단순화 술어 조합에는 R.both·R.either·R.allPass·R.anyPass 사용, R.and·R.or는 값 조합용이라는 점 주의 TypeScript에서는 복잡한 조합 경계에 타입 주석을 더해 추론을 보조 참고 링크 공식 문서와 REPL에서 함수 동작을 빠르게 실험 가능\n함수형 패러다임에 익숙하지 않다면 작은 단위의 파이프라인부터 도입 권장\nRamda Docs https://ramdajs.com/docs/\nTry Ramda REPL https://ramdajs.com/repl/\nFunctional Programming with Ramda.js https://www.sitepoint.com/functional-programming-with-ramda/\n자바스크립트로 함수형 프로그래밍하기 개요 글 https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html\n참고자료 https://ramdajs.com/docs/ https://ramdajs.com/repl/ https://www.sitepoint.com/functional-programming-with-ramda/ https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html https://www.npmjs.com/package/ramda ","wordCount":"1187","inLanguage":"en","datePublished":"2026-02-04T13:25:03.536Z","dateModified":"2026-02-04T13:25:03.536Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항</h1><div class=post-meta><span title='2026-02-04 13:25:03.536 +0000 UTC'>February 4, 2026</span></div></header><div class=post-content><h3 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h3><p>Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임
순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦
이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함</p><hr><h3 id=rprop-개념과-문법>R.prop 개념과 문법<a hidden class=anchor aria-hidden=true href=#rprop-개념과-문법>#</a></h3><p>목적과 동작 원리</p><ul><li>객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구</li><li>속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환</li><li>커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함</li></ul><p>시그니처</p><ul><li>R.prop(propName, obj) → any</li><li>커링 지원, 부분 적용 가능</li></ul><p>간단 예시</p><ul><li>const getName = R.prop(&rsquo;name')</li><li>getName({ name: &lsquo;Alice&rsquo;, age: 25 }) ⇒ &lsquo;Alice&rsquo;</li><li>getName({ age: 25 }) ⇒ undefined</li></ul><p>조합에서의 쓰임새</p><ul><li>컬렉션 변환에서 map과 조합해 특정 필드 집계에 활용</li><li>파이프라인의 초입에서 안전한 데이터 선택자로 사용</li></ul><p>주의</p><ul><li>중첩 경로는 R.path 사용 권장</li><li>null 또는 undefined 대상에 대한 접근 시에도 오류 없이 undefined 반환</li></ul><hr><h3 id=설치와-로드>설치와 로드<a hidden class=anchor aria-hidden=true href=#설치와-로드>#</a></h3><ul><li>npm install ramda 또는 pnpm add ramda</li><li>CommonJS 환경에서는 const R = require(&lsquo;ramda&rsquo;)</li><li>ESM/TS에서는 import * as R from &lsquo;ramda&rsquo;</li><li>TypeScript 타입 정의 포함되어 별도 @types 설치 불요</li></ul><hr><h3 id=ramda의-설계-철학과-장점>Ramda의 설계 철학과 장점<a hidden class=anchor aria-hidden=true href=#ramda의-설계-철학과-장점>#</a></h3><p>핵심 개념</p><ul><li>순수 함수 중심 설계, 입력이 같으면 출력도 같음, 부작용 최소화</li><li>불변성 지향, 원본 데이터 변경 대신 사본 반환</li><li>모든 주요 함수 커링 지원, 부분 적용을 통해 의도와 맥락을 코드에 드러냄</li><li>함수 → 데이터 인자 순서 통일, compose와 pipe로 읽기 좋은 데이터 흐름 구성</li></ul><p>효과</p><ul><li>선언적 코드 스타일 유도, 제어 흐름 대신 데이터 흐름 표현</li><li>테스트 용이성 증가, 예측 가능한 동작</li><li>조합 가능한 작은 함수 단위로 유지보수성 향상</li></ul><hr><h3 id=컬렉션-변환의-기본기>컬렉션 변환의 기본기<a hidden class=anchor aria-hidden=true href=#컬렉션-변환의-기본기>#</a></h3><p>맵과 리듀스의 Ramda 버전 특징</p><ul><li>R.map(f, list) 형태의 인자 순서, 커링 친화적 설계</li><li>R.reduce(reducer, init, list)로 누적 계산 표현 간결화</li><li>합계는 R.sum, 평균은 R.mean 등 단축 함수 사용 권장</li></ul><p>짧은 스니펫</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> names <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>map<span style=color:#eceff4>(</span>R<span style=color:#eceff4>.</span>prop<span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;name&#39;</span><span style=color:#eceff4>))(</span>users<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> total <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>reduce<span style=color:#eceff4>((</span>acc<span style=color:#eceff4>,</span> x<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> acc <span style=color:#81a1c1>+</span> x<span style=color:#eceff4>,</span> <span style=color:#b48ead>0</span><span style=color:#eceff4>)(</span>nums<span style=color:#eceff4>)</span></span></span></code></pre></div><p>가변 인자 함수 적용</p><ul><li>배열을 펼쳐 인자로 적용해야 하는 경우 R.apply 사용</li><li>예시 용도는 Math.max, Math.min 같은 내장 함수 호출</li></ul><hr><h3 id=커링과-자리-표시자>커링과 자리 표시자<a hidden class=anchor aria-hidden=true href=#커링과-자리-표시자>#</a></h3><p>R.curry로 부분 적용을 일상화</p><ul><li>다인자 함수를 맥락마다 일부 인자 고정해 재사용 단위로 분해</li><li>앞쪽 인자부터 고정되는 점 고려해 인자 순서를 의도적으로 설계</li></ul><p>자리 표시자 R.__</p><ul><li>특정 인자를 비워두고 뒤 인자부터 고정하고 싶을 때 사용</li></ul><p>짧은 스니펫</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> volume <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>curry<span style=color:#eceff4>((</span>d<span style=color:#eceff4>,</span> w<span style=color:#eceff4>,</span> h<span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> d <span style=color:#81a1c1>*</span> w <span style=color:#81a1c1>*</span> h<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> area <span style=color:#81a1c1>=</span> volume<span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>area<span style=color:#eceff4>(</span><span style=color:#b48ead>3</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>4</span><span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// 12
</span></span></span></code></pre></div><hr><h3 id=함수-조합과-파이프라인>함수 조합과 파이프라인<a hidden class=anchor aria-hidden=true href=#함수-조합과-파이프라인>#</a></h3><p>R.pipe와 R.compose</p><ul><li>pipe는 왼쪽에서 오른쪽으로 데이터 흐름 표현에 적합</li><li>compose는 수학적 표기와 같이 오른쪽에서 왼쪽으로 평가</li><li>조합 결과는 다시 1급 함수로 재사용 가능</li></ul><p>짧은 스니펫</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> normalize <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>pipe<span style=color:#eceff4>(</span><span style=color:#81a1c1>Math</span><span style=color:#eceff4>.</span>sqrt<span style=color:#eceff4>,</span> <span style=color:#81a1c1>Math</span><span style=color:#eceff4>.</span>round<span style=color:#eceff4>,</span> <span style=color:#81a1c1>String</span><span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>normalize<span style=color:#eceff4>(</span><span style=color:#b48ead>10</span><span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// &#39;3&#39;
</span></span></span></code></pre></div><hr><h3 id=원소와-속성-접근-유틸리티>원소와 속성 접근 유틸리티<a hidden class=anchor aria-hidden=true href=#원소와-속성-접근-유틸리티>#</a></h3><ul><li>R.nth(n, list) 안전한 n번째 원소 접근, 없으면 undefined</li><li>R.prop(k, obj) 안전한 단일 속성 접근, 없으면 undefined</li><li>R.path([k1, k2, &mldr;], obj) 중첩 경로 안전 접근</li></ul><p>이들 함수는 예외 대신 undefined를 반환하므로 파이프라인 중간에 안전하게 삽입 가능함</p><hr><h3 id=컬렉션-생성과-가공>컬렉션 생성과 가공<a hidden class=anchor aria-hidden=true href=#컬렉션-생성과-가공>#</a></h3><p>생성</p><ul><li>R.range(from, to) 반열린 구간 수열 생성, 끝값 제외</li><li>R.repeat(item, n) 동일 원소 반복 리스트 생성</li></ul><p>필터와 정렬</p><ul><li>R.filter(pred, list) 조건을 만족하는 원소만 유지</li><li>R.sort(compare, list) 비교 함수를 이용한 정렬, 불변성 유지</li><li>R.reverse(listOrString) 역순 변환</li></ul><p>연결과 분할</p><ul><li>R.concat(a, b) 리스트 또는 문자열 연결</li><li>R.append(x, list) 뒤에 원소 추가한 새 리스트 반환</li><li>R.prepend(x, list) 앞에 원소 추가한 새 리스트 반환</li><li>R.head(list) 첫 원소 안전 참조, 없으면 undefined</li><li>R.take(n, list), R.takeLast(n, list) 앞뒤에서 n개 취함</li><li>R.drop(n, list), R.dropLast(n, list) 앞뒤에서 n개 제거</li><li>R.slice(from, to, list) 구간 슬라이스, Infinity로 끝까지 표현 가능</li></ul><p>객체 불변 업데이트</p><ul><li>R.assoc(k, v, obj) 키를 v로 갱신한 새 객체 반환</li><li>R.dissoc(k, obj) 키 제거한 새 객체 반환</li><li>깊은 경로는 R.assocPath, R.dissocPath 사용 고려</li></ul><hr><h3 id=집합-연산>집합 연산<a hidden class=anchor aria-hidden=true href=#집합-연산>#</a></h3><p>중복 제거와 멱등 연산을 기반으로 한 집합 다루기</p><ul><li>R.union(a, b) 합집합, 좌측 우선 보존 규칙으로 순서 결정</li><li>R.intersection(a, b) 교집합, a의 순서를 보존하며 b에 존재하는 원소만 유지</li><li>R.difference(a, b) 차집합, a에서 b에 포함된 원소 제거</li></ul><p>주의</p><ul><li>Ramda의 집합 연산은 참조 동등성 또는 지정된 동등 비교 규칙에 의존함</li><li>객체 요소의 동등성 비교가 필요한 경우 R.unionWith, R.intersectionWith 등 커스텀 비교자 사용 고려</li></ul><hr><h3 id=논리와-조건-유틸리티>논리와 조건 유틸리티<a hidden class=anchor aria-hidden=true href=#논리와-조건-유틸리티>#</a></h3><p>타입 검사</p><ul><li>R.is(Ctor, val) 생성자 기반 인스턴스 여부 검사</li><li>커링으로 특정 타입 가드 유틸 생성에 용이</li></ul><p>논리 부정</p><ul><li>R.complement(pred) 논리 결과 반전 함수 생성</li></ul><p>양·음의 범위</p><ul><li>R.all(pred, list) 모두 참인지 검사</li><li>R.any(pred, list) 하나라도 참인지 검사</li></ul><p>상수 함숫값</p><ul><li>R.T 항진 함수, 항상 true 반환</li><li>R.F 항진 함수, 항상 false 반환</li><li>R.always(x) 항상 x를 반환하는 함수 생성</li></ul><p>분기 구성</p><ul><li>R.cond([[pred1, f1], [pred2, f2], &mldr;]) 다중 분기를 표현하는 조합기</li></ul><hr><h3 id=typescript에서의-ramda>TypeScript에서의 Ramda<a hidden class=anchor aria-hidden=true href=#typescript에서의-ramda>#</a></h3><p>타입 정의</p><ul><li>Ramda는 자체 타입 정의를 포함, 일반적인 사용에서 추가 설치 없이 타입 안전성 확보 가능</li><li>복잡한 조합이나 가변 길이 파이프라인에서 추론 경계 존재, 필요 시 함수 경계에 명시적 타입 주석 권장</li></ul><p>실전 팁</p><ul><li>컬렉션 연산에서는 제네릭 타입 변수의 구체화를 돕기 위해 람다식 인자에 타입 주석 추가</li><li>R.path, R.assocPath 사용 시 경로와 결과 타입을 명시해 추론 실패에 대비</li></ul><p>짧은 스니펫</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>type</span> User <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span><span style=color:#eceff4>;</span> age: <span style=color:#81a1c1>number</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> users: <span style=color:#81a1c1>User</span><span style=color:#eceff4>[]</span> <span style=color:#81a1c1>=</span> <span style=color:#eceff4>[</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;A&#39;</span><span style=color:#eceff4>,</span> age: <span style=color:#81a1c1>25</span> <span style=color:#eceff4>},</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;B&#39;</span><span style=color:#eceff4>,</span> age: <span style=color:#81a1c1>30</span> <span style=color:#eceff4>}</span> <span style=color:#eceff4>]</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> names: <span style=color:#81a1c1>string</span><span style=color:#eceff4>[]</span> <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>map<span style=color:#eceff4>((</span>u: <span style=color:#81a1c1>User</span><span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> u<span style=color:#eceff4>.</span>name<span style=color:#eceff4>)(</span>users<span style=color:#eceff4>)</span></span></span></code></pre></div><hr><h3 id=rprop-심화-활용-패턴>R.prop 심화 활용 패턴<a hidden class=anchor aria-hidden=true href=#rprop-심화-활용-패턴>#</a></h3><p>배열에서 특정 필드 수집</p><ul><li>R.map(R.prop(&lsquo;field&rsquo;), list)로 간결하게 필드 리스트 생성</li></ul><p>기본값과의 결합</p><ul><li>R.pipe(R.prop(&lsquo;field&rsquo;), R.defaultTo(defaultValue))로 안전한 디폴트 적용</li></ul><p>안전한 중첩 접근</p><ul><li>R.pipe(R.path([&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;]), R.defaultTo(fallback)) 사용</li></ul><p>옵셔널 체이닝과 비교</p><ul><li>언어 레벨 옵셔널 체이닝 a?.b?.c는 문법 설탕, Ramda는 함수 조합으로 동일 흐름을 데이터 파이프라인으로 유지</li><li>일관된 형식의 함수형 파이프라인을 선호한다면 R.path 기반 접근 유지 권장</li></ul><hr><h3 id=흔한-함정과-우회-전략>흔한 함정과 우회 전략<a hidden class=anchor aria-hidden=true href=#흔한-함정과-우회-전략>#</a></h3><p>R.and와 R.or의 오해</p><ul><li>R.and와 R.or는 이항 불 연산을 커링한 함수로, 전달된 피연산자 자체의 진리성만 평가함</li><li>R.and(fn1, fn2)(x)처럼 술어 함수를 인자로 넘기면 fn1과 fn2 함수 객체가 모두 truthy이므로 결과가 항상 truthy가 되는 문제가 발생함</li><li>동일 인자 x에 대해 두 술어를 모두 평가하는 목적이라면 R.both(pred1, pred2) 또는 R.allPass([pred1, pred2]) 사용</li><li>동일하게 OR 조합이 필요하면 R.either 또는 R.anyPass 사용</li></ul><p>짧은 스니펫</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> isNotNil <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>complement<span style=color:#eceff4>(</span>R<span style=color:#eceff4>.</span>isNil<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> isNotEmpty <span style=color:#81a1c1>=</span> <span style=color:#eceff4>(</span>v: <span style=color:#81a1c1>any</span><span style=color:#eceff4>)</span> <span style=color:#81a1c1>=&gt;</span> <span style=color:#81a1c1>!</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>Array</span><span style=color:#eceff4>.</span>isArray<span style=color:#eceff4>(</span>v<span style=color:#eceff4>)</span> <span style=color:#81a1c1>&amp;&amp;</span> v<span style=color:#eceff4>.</span>length <span style=color:#81a1c1>===</span> <span style=color:#b48ead>0</span><span style=color:#eceff4>)</span> <span style=color:#81a1c1>&amp;&amp;</span> v <span style=color:#81a1c1>!==</span> <span style=color:#a3be8c>&#39;&#39;</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> valid <span style=color:#81a1c1>=</span> R<span style=color:#eceff4>.</span>both<span style=color:#eceff4>(</span>isNotNil<span style=color:#eceff4>,</span> isNotEmpty<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>valid<span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>undefined</span><span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// false
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>valid<span style=color:#eceff4>(</span><span style=color:#a3be8c>&#39;0x1234&#39;</span><span style=color:#eceff4>)</span>  <span style=color:#616e87;font-style:italic>// true
</span></span></span></code></pre></div><p>인자 순서와 커링</p><ul><li>JS 내장 Array.map은 수신자 메서드 형태로 데이터 → 함수 순서, Ramda는 함수 → 데이터 순서</li><li>조합과 부분 적용을 적극 사용하려면 Ramda의 순서가 유리</li></ul><p>지나친 조합과 타입 추론 붕괴</p><ul><li>단계가 많은 pipe에서 중간 단계 타입이 모호하면 추론 실패 가능성 존재</li><li>경계마다 반환 타입 주석 추가 또는 조합 단위를 의미 있게 쪼개기 권장</li></ul><p>성능과 가독성 균형</p><ul><li>소규모 유틸을 과도하게 조합하면 호출 오버헤드와 디버깅 난도가 증가할 수 있음</li><li>파이프라인 단계 수를 의미 중심으로 제한, 필요한 곳에서만 미세 최적화</li></ul><hr><h3 id=실전-조합-레시피>실전 조합 레시피<a hidden class=anchor aria-hidden=true href=#실전-조합-레시피>#</a></h3><p>데이터 정규화 파이프라인</p><ul><li>공백 트리밍 → 소문자화 → 빈 문자열을 null로 치환하는 흐름을 pipe로 명시</li><li>예 R.pipe(R.trim, R.toLower, v => v === &rsquo;&rsquo; ? null : v)</li></ul><p>불변 업데이트로 조건적 갱신</p><ul><li>특정 필드가 존재할 때만 새 값 적용</li><li>예 R.when(R.has(&lsquo;flag&rsquo;), R.assoc(&lsquo;updated&rsquo;, true))</li></ul><p>컬렉션에서 안전한 선택 후 변환</p><ul><li>예 R.pipe(R.map(R.prop(&lsquo;id&rsquo;)), R.filter(Boolean), R.uniq)</li></ul><p>조건 분기 단순화</p><ul><li>다중 if-else를 R.cond로 옮겨 비즈니스 규칙을 데이터로 표현</li></ul><hr><h3 id=요약>요약<a hidden class=anchor aria-hidden=true href=#요약>#</a></h3><ul><li>R.prop은 안전한 속성 접근의 기본 단위, 커링과 조합에서 재사용성 높음</li><li>Ramda는 함수 → 데이터 인자 순서로 조합 친화적인 API를 제공, 불변성과 순수 함수 원칙을 일관되게 지원</li><li>파이프라인은 pipe와 compose로 구성, 컬렉션 변환은 map·filter·reduce 계열로 단순화</li><li>술어 조합에는 R.both·R.either·R.allPass·R.anyPass 사용, R.and·R.or는 값 조합용이라는 점 주의</li><li>TypeScript에서는 복잡한 조합 경계에 타입 주석을 더해 추론을 보조</li></ul><hr><h3 id=참고-링크>참고 링크<a hidden class=anchor aria-hidden=true href=#참고-링크>#</a></h3><ul><li><p>공식 문서와 REPL에서 함수 동작을 빠르게 실험 가능</p></li><li><p>함수형 패러다임에 익숙하지 않다면 작은 단위의 파이프라인부터 도입 권장</p></li><li><p>Ramda Docs <a href=https://ramdajs.com/docs/>https://ramdajs.com/docs/</a></p></li><li><p>Try Ramda REPL <a href=https://ramdajs.com/repl/>https://ramdajs.com/repl/</a></p></li><li><p>Functional Programming with Ramda.js <a href=https://www.sitepoint.com/functional-programming-with-ramda/>https://www.sitepoint.com/functional-programming-with-ramda/</a></p></li><li><p>자바스크립트로 함수형 프로그래밍하기 개요 글 <a href=https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html>https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html</a></p></li></ul><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://ramdajs.com/docs/>https://ramdajs.com/docs/</a></li><li><a href=https://ramdajs.com/repl/>https://ramdajs.com/repl/</a></li><li><a href=https://www.sitepoint.com/functional-programming-with-ramda/>https://www.sitepoint.com/functional-programming-with-ramda/</a></li><li><a href=https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html>https://bakyeono.net/post/2017-07-11-javascript-fp-with-ramda.html</a></li><li><a href=https://www.npmjs.com/package/ramda>https://www.npmjs.com/package/ramda</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/ramda/>Ramda</a></li><li><a href=https://blog.jsontapose.com/tags/functional-programming/>Functional-Programming</a></li><li><a href=https://blog.jsontapose.com/tags/javascript/>Javascript</a></li><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/immutability/>Immutability</a></li><li><a href=https://blog.jsontapose.com/tags/currying/>Currying</a></li><li><a href=https://blog.jsontapose.com/tags/composition/>Composition</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/javascript-structuredclone-deep-copy-shallow-copy-7cdc3a/><span class=title>« Prev</span><br><span>JavaScript 깊은 복사 vs 얕은 복사, structuredClone 사용 가이드</span>
</a><a class=next href=https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/><span class=title>Next »</span><br><span>SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on x" href="https://x.com/intent/tweet/?text=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f&amp;hashtags=ramda%2cfunctional-programming%2cjavascript%2ctypescript%2cimmutability%2ccurrying%2ccomposition"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f&amp;title=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&amp;summary=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f&title=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on whatsapp" href="https://api.whatsapp.com/send?text=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on telegram" href="https://telegram.me/share/url?text=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Ramda%20%ed%95%b5%ec%8b%ac%20%ea%b0%9c%eb%85%90%20%ec%a0%95%eb%a6%ac%ec%99%80%20R.prop%20%ec%95%88%ec%a0%84%ed%95%9c%20%ec%86%8d%ec%84%b1%20%ec%a0%91%ea%b7%bc%2c%20%ec%bb%a4%eb%a7%81%c2%b7%ec%a1%b0%ed%95%a9%c2%b7%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2framda-core-and-r-prop-currying-composition-caveats-f3fa82%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>