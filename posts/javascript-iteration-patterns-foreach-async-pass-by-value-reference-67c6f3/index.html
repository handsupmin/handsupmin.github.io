<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 | HandsLog</title>
<meta name=keywords content="javascript,typescript,iteration,for-each,for-of,promises,async-await,pass-by-value,references"><meta name=description content="배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for&mldr;of, 그리고 객체 속성에 적합한 for&mldr;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함
개념/배경
자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임

for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용
forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가
for&mldr;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능
for&mldr;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재

이터러블과 이터레이터 프로토콜을 따르는 객체에 for&mldr;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/json href=https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/index.json><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리"><meta property="og:description" content="배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for…of, 그리고 객체 속성에 적합한 for…in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함
개념/배경 자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임
for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용 forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가 for…of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능 for…in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재 이터러블과 이터레이터 프로토콜을 따르는 객체에 for…of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-27T13:17:16+00:00"><meta property="article:modified_time" content="2026-01-27T13:17:16+00:00"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Iteration"><meta property="article:tag" content="For-Each"><meta property="article:tag" content="For-Of"><meta property="article:tag" content="Promises"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리"><meta name=twitter:description content="배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for&mldr;of, 그리고 객체 속성에 적합한 for&mldr;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함
개념/배경
자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임

for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용
forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가
for&mldr;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능
for&mldr;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재

이터러블과 이터레이터 프로토콜을 따르는 객체에 for&mldr;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"},{"@type":"ListItem","position":2,"name":"JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리","item":"https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리","name":"JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리","description":"배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for\u0026hellip;of, 그리고 객체 속성에 적합한 for\u0026hellip;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함\n개념/배경 자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임\nfor 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용 forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가 for\u0026hellip;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능 for\u0026hellip;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재 이터러블과 이터레이터 프로토콜을 따르는 객체에 for\u0026hellip;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임\n","keywords":["javascript","typescript","iteration","for-each","for-of","promises","async-await","pass-by-value","references"],"articleBody":"배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for…of, 그리고 객체 속성에 적합한 for…in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함\n개념/배경 자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임\nfor 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용 forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가 for…of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능 for…in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재 이터러블과 이터레이터 프로토콜을 따르는 객체에 for…of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임\nforEach의 비동기 한계 forEach는 콜백을 동기적으로 순회함. 콜백 내부에서 비동기 작업을 호출해도 forEach 자체는 해당 작업의 완료를 기다리지 않음. 반환값은 항상 undefined이며 프로미스 체이닝에 직접 쓸 수 없음. break, continue, return으로 흐름 제어 불가\n아래 코드는 바깥 스코프에서 모든 비동기 처리가 끝났는지 보장하지 않음\nitems.forEach(async item =\u003e { await doSomethingAsync(item) }) // 이 시점에 모든 작업이 끝났다고 보장 못함 핵심 포인트\n순회는 동기적으로 완료되고 비동기 작업은 백그라운드로 진행됨 await를 콜백 내부에 써도 forEach 전체의 완료 시점은 추적되지 않음 콜백 결과를 수집해 단일 프로미스로 합치기 어려움 비동기 제어 대안 순차 처리 필요 시 for…of + await 선택\nfor (const item of items) await doSomethingAsync(item) // 여기 도달 시 순차 처리 완료 병렬 처리 필요 시 map + Promise.all 사용\nawait Promise.all(items.map(item =\u003e doSomethingAsync(item))) // 병렬 실행 후 전부 완료된 시점 순차 누적 계산이 필요하면 reduce + async/await 패턴 고려\nconst result = await items.reduce(async (accP, item) =\u003e { const acc = await accP const next = await stepAsync(acc, item) return next }, Promise.resolve(init))트레이드오프 요약\nfor…of + await 순차적 안정성, 외부 리소스 제한 정책과 궁합 좋음, 총 소요시간 증가 가능 Promise.all 병렬 성능, 실패 시 전체 거부, 동시성 제한 없으므로 과부하 주의 reduce 기반 순차 누적 로직 표현력 좋음, 가독성 비용 존재 반복문 선택 가이드 인덱스 필요, 조기 종료 필요, 성능 미세 튜닝 필요 for 사용 값만 필요, 동기적 작업, 간결한 선언형 스타일 선호 forEach 사용 이터러블을 값 중심으로 순회, await로 흐름 제어 필요 for…of 사용 객체 속성 키 순회 for…in 사용. 배열에는 비권장 참고 이슈\nforEach는 break/continue 불가. 일부 조건에서 return으로 콜백만 종료 가능하나 전체 순회는 계속됨 for…of는 break/continue/yield/await 등 제어 흐름 조합 용이 배열을 객체처럼 취급해 for…in을 쓰면 예상치 못한 키 순서, 상속 프로퍼티 순회 등으로 버그 유발 가능 TypeScript/JavaScript의 값과 참조 전달 이해 TypeScript는 JavaScript와 동일한 호출 의미론을 가짐. 자바스크립트는 엄밀히 값에 의한 전달 모델이며 객체의 참조도 값으로 복사됨. 흔히 참조에 의한 전달로 오해하지만 실제로는 참조 값이 복사되어 공유되는 pass-by-sharing 특성에 가깝다고 이해하는 편이 안전함\n원시 타입 number, string, boolean, null, undefined, symbol, bigint는 값이 복사되어 전달됨. 함수 내부 변경이 외부에 영향 없음 객체, 배열, 함수는 참조 값이 복사되어 전달됨. 함수 내부에서 프로퍼티를 변경하면 같은 객체를 가리키므로 외부에서도 변경이 보임. 단, 매개변수 변수에 새 객체를 재할당해도 외부 바인딩은 그대로 유지됨 원시 타입 예시\nlet n = 50 function changeValue(x: number) { x = 100 } changeValue(n) // n은 50 유지 객체 프로퍼티 변경 예시\nconst user = { name: 'Original' } function changeObject(o: { name: string }) { o.name = 'Changed' } changeObject(user) // user.name은 'Changed' 객체 자체 재할당 예시\nconst user = { name: 'Original' } function replaceObject(o: { name: string }) { o = { name: 'New' } } replaceObject(user) // 외부 user는 그대로 유지 배열도 동일한 참조 값 복사 특성 적용\nconst arr = [1, 2, 3] function pushItem(a: number[]) { a.push(4) } pushItem(arr) // arr는 [1,2,3,4] 프로퍼티 읽기 시 값 복사 예시. 문자열은 원시 타입이므로 별도 복사본을 가짐\nconst user = { name: 'John' } let userName = user.name // 'John' 값 복사 userName = 'Jane' // user.name에는 영향 없음 실무 체크리스트\n원시와 참조 타입의 전달 차이를 명확히 구분할 것 함수에서 외부 객체를 변경하려는 의도가 없다면 얕은 복사나 깊은 복사로 불변성 유지 고려 비동기 루프에서 완료 시점이 중요하면 for…of + await 또는 Promise.all을 명시적으로 사용할 것 병렬 처리 시 동시성 제한이 필요하면 p-limit 류의 제한 기법 적용 검토 마무리 forEach는 설계상 비동기 완료를 기다리지 않는 동기 순회 도구임. 비동기 흐름 제어가 필요하면 for…of + await 또는 Promise.all 같은 명시적 조합 선택이 안전함. 또한 JS/TS는 값에 의한 전달이며 참조 값 복사라는 특성 때문에 객체 내용 변경은 공유되지만 재할당은 외부에 파급되지 않음을 전제하고 코드를 작성할 것\n참고자료 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures https://developer.mozilla.org/en-US/docs/Glossary/Primitive ","wordCount":"699","inLanguage":"en","datePublished":"2026-01-27T13:17:16.498Z","dateModified":"2026-01-27T13:17:16.498Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/"},"publisher":{"@type":"Organization","name":"HandsLog","logo":{"@type":"ImageObject","url":"https://blog.jsontapose.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.jsontapose.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리</h1><div class=post-meta><span title='2026-01-27 13:17:16.498 +0000 UTC'>January 27, 2026</span></div></header><div class=post-content><p>배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for&mldr;of, 그리고 객체 속성에 적합한 for&mldr;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함</p><h3 id=개념배경>개념/배경<a hidden class=anchor aria-hidden=true href=#개념배경>#</a></h3><p>자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임</p><ul><li>for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용</li><li>forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가</li><li>for&mldr;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능</li><li>for&mldr;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재</li></ul><p>이터러블과 이터레이터 프로토콜을 따르는 객체에 for&mldr;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임</p><h3 id=foreach의-비동기-한계>forEach의 비동기 한계<a hidden class=anchor aria-hidden=true href=#foreach의-비동기-한계>#</a></h3><p>forEach는 콜백을 동기적으로 순회함. 콜백 내부에서 비동기 작업을 호출해도 forEach 자체는 해당 작업의 완료를 기다리지 않음. 반환값은 항상 undefined이며 프로미스 체이닝에 직접 쓸 수 없음. break, continue, return으로 흐름 제어 불가</p><p>아래 코드는 바깥 스코프에서 모든 비동기 처리가 끝났는지 보장하지 않음</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>items<span style=color:#eceff4>.</span>forEach<span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>async</span> item <span style=color:#eceff4>=&gt;</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>await</span> doSomethingAsync<span style=color:#eceff4>(</span>item<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#eceff4>})</span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 이 시점에 모든 작업이 끝났다고 보장 못함
</span></span></span></code></pre></div><p>핵심 포인트</p><ul><li>순회는 동기적으로 완료되고 비동기 작업은 백그라운드로 진행됨</li><li>await를 콜백 내부에 써도 forEach 전체의 완료 시점은 추적되지 않음</li><li>콜백 결과를 수집해 단일 프로미스로 합치기 어려움</li></ul><h3 id=비동기-제어-대안>비동기 제어 대안<a hidden class=anchor aria-hidden=true href=#비동기-제어-대안>#</a></h3><p>순차 처리 필요 시 for&mldr;of + await 선택</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>for</span> <span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>const</span> item <span style=color:#81a1c1;font-weight:700>of</span> items<span style=color:#eceff4>)</span> <span style=color:#81a1c1;font-weight:700>await</span> doSomethingAsync<span style=color:#eceff4>(</span>item<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 여기 도달 시 순차 처리 완료
</span></span></span></code></pre></div><p>병렬 처리 필요 시 map + Promise.all 사용</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>await</span> <span style=color:#81a1c1>Promise</span><span style=color:#eceff4>.</span>all<span style=color:#eceff4>(</span>items<span style=color:#eceff4>.</span>map<span style=color:#eceff4>(</span>item <span style=color:#eceff4>=&gt;</span> doSomethingAsync<span style=color:#eceff4>(</span>item<span style=color:#eceff4>)))</span>
</span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic>// 병렬 실행 후 전부 완료된 시점
</span></span></span></code></pre></div><p>순차 누적 계산이 필요하면 reduce + async/await 패턴 고려</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> result <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>await</span> items<span style=color:#eceff4>.</span>reduce<span style=color:#eceff4>(</span><span style=color:#81a1c1;font-weight:700>async</span> <span style=color:#eceff4>(</span>accP<span style=color:#eceff4>,</span> item<span style=color:#eceff4>)</span> <span style=color:#eceff4>=&gt;</span> <span style=color:#eceff4>{</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>const</span> acc <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>await</span> accP
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>const</span> next <span style=color:#81a1c1>=</span> <span style=color:#81a1c1;font-weight:700>await</span> stepAsync<span style=color:#eceff4>(</span>acc<span style=color:#eceff4>,</span> item<span style=color:#eceff4>)</span>
</span></span><span style=display:flex><span>  <span style=color:#81a1c1;font-weight:700>return</span> next
</span></span><span style=display:flex><span><span style=color:#eceff4>},</span> <span style=color:#81a1c1>Promise</span><span style=color:#eceff4>.</span>resolve<span style=color:#eceff4>(</span>init<span style=color:#eceff4>))</span></span></span></code></pre></div><p>트레이드오프 요약</p><ul><li>for&mldr;of + await 순차적 안정성, 외부 리소스 제한 정책과 궁합 좋음, 총 소요시간 증가 가능</li><li>Promise.all 병렬 성능, 실패 시 전체 거부, 동시성 제한 없으므로 과부하 주의</li><li>reduce 기반 순차 누적 로직 표현력 좋음, 가독성 비용 존재</li></ul><h3 id=반복문-선택-가이드>반복문 선택 가이드<a hidden class=anchor aria-hidden=true href=#반복문-선택-가이드>#</a></h3><ul><li>인덱스 필요, 조기 종료 필요, 성능 미세 튜닝 필요 for 사용</li><li>값만 필요, 동기적 작업, 간결한 선언형 스타일 선호 forEach 사용</li><li>이터러블을 값 중심으로 순회, await로 흐름 제어 필요 for&mldr;of 사용</li><li>객체 속성 키 순회 for&mldr;in 사용. 배열에는 비권장</li></ul><p>참고 이슈</p><ul><li>forEach는 break/continue 불가. 일부 조건에서 return으로 콜백만 종료 가능하나 전체 순회는 계속됨</li><li>for&mldr;of는 break/continue/yield/await 등 제어 흐름 조합 용이</li><li>배열을 객체처럼 취급해 for&mldr;in을 쓰면 예상치 못한 키 순서, 상속 프로퍼티 순회 등으로 버그 유발 가능</li></ul><h3 id=typescriptjavascript의-값과-참조-전달-이해>TypeScript/JavaScript의 값과 참조 전달 이해<a hidden class=anchor aria-hidden=true href=#typescriptjavascript의-값과-참조-전달-이해>#</a></h3><p>TypeScript는 JavaScript와 동일한 호출 의미론을 가짐. 자바스크립트는 엄밀히 값에 의한 전달 모델이며 객체의 참조도 값으로 복사됨. 흔히 참조에 의한 전달로 오해하지만 실제로는 참조 값이 복사되어 공유되는 pass-by-sharing 특성에 가깝다고 이해하는 편이 안전함</p><ul><li>원시 타입 number, string, boolean, null, undefined, symbol, bigint는 값이 복사되어 전달됨. 함수 내부 변경이 외부에 영향 없음</li><li>객체, 배열, 함수는 참조 값이 복사되어 전달됨. 함수 내부에서 프로퍼티를 변경하면 같은 객체를 가리키므로 외부에서도 변경이 보임. 단, 매개변수 변수에 새 객체를 재할당해도 외부 바인딩은 그대로 유지됨</li></ul><p>원시 타입 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>let</span> n <span style=color:#81a1c1>=</span> <span style=color:#b48ead>50</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> changeValue<span style=color:#eceff4>(</span>x: <span style=color:#81a1c1>number</span><span style=color:#eceff4>)</span> <span style=color:#eceff4>{</span> x <span style=color:#81a1c1>=</span> <span style=color:#b48ead>100</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>changeValue<span style=color:#eceff4>(</span>n<span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// n은 50 유지
</span></span></span></code></pre></div><p>객체 프로퍼티 변경 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> user <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;Original&#39;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> changeObject<span style=color:#eceff4>(</span>o<span style=color:#81a1c1>:</span> <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span> <span style=color:#eceff4>})</span> <span style=color:#eceff4>{</span> o<span style=color:#eceff4>.</span>name <span style=color:#81a1c1>=</span> <span style=color:#a3be8c>&#39;Changed&#39;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>changeObject<span style=color:#eceff4>(</span>user<span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// user.name은 &#39;Changed&#39;
</span></span></span></code></pre></div><p>객체 자체 재할당 예시</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> user <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;Original&#39;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> replaceObject<span style=color:#eceff4>(</span>o<span style=color:#81a1c1>:</span> <span style=color:#eceff4>{</span> name: <span style=color:#81a1c1>string</span> <span style=color:#eceff4>})</span> <span style=color:#eceff4>{</span> o <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;New&#39;</span> <span style=color:#eceff4>}</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>replaceObject<span style=color:#eceff4>(</span>user<span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// 외부 user는 그대로 유지
</span></span></span></code></pre></div><p>배열도 동일한 참조 값 복사 특성 적용</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> arr <span style=color:#81a1c1>=</span> <span style=color:#eceff4>[</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>2</span><span style=color:#eceff4>,</span> <span style=color:#b48ead>3</span><span style=color:#eceff4>]</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>function</span> pushItem<span style=color:#eceff4>(</span>a: <span style=color:#81a1c1>number</span><span style=color:#eceff4>[])</span> <span style=color:#eceff4>{</span> a<span style=color:#eceff4>.</span>push<span style=color:#eceff4>(</span><span style=color:#b48ead>4</span><span style=color:#eceff4>)</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span>pushItem<span style=color:#eceff4>(</span>arr<span style=color:#eceff4>)</span> <span style=color:#616e87;font-style:italic>// arr는 [1,2,3,4]
</span></span></span></code></pre></div><p>프로퍼티 읽기 시 값 복사 예시. 문자열은 원시 타입이므로 별도 복사본을 가짐</p><div class=highlight><pre tabindex=0 style=color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>const</span> user <span style=color:#81a1c1>=</span> <span style=color:#eceff4>{</span> name<span style=color:#81a1c1>:</span> <span style=color:#a3be8c>&#39;John&#39;</span> <span style=color:#eceff4>}</span>
</span></span><span style=display:flex><span><span style=color:#81a1c1;font-weight:700>let</span> userName <span style=color:#81a1c1>=</span> user<span style=color:#eceff4>.</span>name <span style=color:#616e87;font-style:italic>// &#39;John&#39; 값 복사
</span></span></span><span style=display:flex><span><span style=color:#616e87;font-style:italic></span>userName <span style=color:#81a1c1>=</span> <span style=color:#a3be8c>&#39;Jane&#39;</span>        <span style=color:#616e87;font-style:italic>// user.name에는 영향 없음
</span></span></span></code></pre></div><p>실무 체크리스트</p><ul><li>원시와 참조 타입의 전달 차이를 명확히 구분할 것</li><li>함수에서 외부 객체를 변경하려는 의도가 없다면 얕은 복사나 깊은 복사로 불변성 유지 고려</li><li>비동기 루프에서 완료 시점이 중요하면 for&mldr;of + await 또는 Promise.all을 명시적으로 사용할 것</li><li>병렬 처리 시 동시성 제한이 필요하면 p-limit 류의 제한 기법 적용 검토</li></ul><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>forEach는 설계상 비동기 완료를 기다리지 않는 동기 순회 도구임. 비동기 흐름 제어가 필요하면 for&mldr;of + await 또는 Promise.all 같은 명시적 조합 선택이 안전함. 또한 JS/TS는 값에 의한 전달이며 참조 값 복사라는 특성 때문에 객체 내용 변경은 공유되지만 재할당은 외부에 파급되지 않음을 전제하고 코드를 작성할 것</p><h3 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h3><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Primitive>https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jsontapose.com/tags/javascript/>Javascript</a></li><li><a href=https://blog.jsontapose.com/tags/typescript/>Typescript</a></li><li><a href=https://blog.jsontapose.com/tags/iteration/>Iteration</a></li><li><a href=https://blog.jsontapose.com/tags/for-each/>For-Each</a></li><li><a href=https://blog.jsontapose.com/tags/for-of/>For-Of</a></li><li><a href=https://blog.jsontapose.com/tags/promises/>Promises</a></li><li><a href=https://blog.jsontapose.com/tags/async-await/>Async-Await</a></li><li><a href=https://blog.jsontapose.com/tags/pass-by-value/>Pass-by-Value</a></li><li><a href=https://blog.jsontapose.com/tags/references/>References</a></li></ul><nav class=paginav><a class=prev href=https://blog.jsontapose.com/posts/ethereum-pos-tx-to-finality-ef6889/><span class=title>« Prev</span><br><span>이더리움 PoS에서 트랜잭션이 블록에 포함되고 최종화되기까지</span>
</a><a class=next href=https://blog.jsontapose.com/posts/ethereum-pos-node-types-and-roles-e8a3b8/><span class=title>Next »</span><br><span>이더리움 PoS 노드의 종류와 역할 정리</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on x" href="https://x.com/intent/tweet/?text=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f&amp;hashtags=javascript%2ctypescript%2citeration%2cfor-each%2cfor-of%2cpromises%2casync-await%2cpass-by-value%2creferences"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f&amp;title=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac&amp;summary=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac&amp;source=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f&title=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on whatsapp" href="https://api.whatsapp.com/send?text=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac%20-%20https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on telegram" href="https://telegram.me/share/url?text=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac&amp;url=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리 on ycombinator" href="https://news.ycombinator.com/submitlink?t=JavaScript%20%eb%b0%b0%ec%97%b4%20%ec%88%9c%ed%9a%8c%20%ed%8c%a8%ed%84%b4%ea%b3%bc%20forEach%20%eb%b9%84%eb%8f%99%ea%b8%b0%20%ed%95%9c%ea%b3%84%2c%20%ea%b0%92%c2%b7%ec%b0%b8%ec%a1%b0%20%ec%a0%84%eb%8b%ac%20%ec%a0%95%eb%a6%ac&u=https%3a%2f%2fblog.jsontapose.com%2fposts%2fjavascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>