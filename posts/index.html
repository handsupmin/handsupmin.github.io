<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | HandsLog</title>
<meta name=keywords content><meta name=description content="Posts - HandsLog"><meta name=author content><link rel=canonical href=https://blog.jsontapose.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jsontapose.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jsontapose.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jsontapose.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jsontapose.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jsontapose.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.jsontapose.com/posts/index.xml><link rel=alternate hreflang=en href=https://blog.jsontapose.com/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=module>
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  const isDark = () =>
    document.body.classList.contains("dark") ||
    window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

  const getThemeOptions = () => {
    const dark = isDark();
    return {
      startOnLoad: false,
      securityLevel: "loose", 
      theme: dark ? "dark" : "default",
      themeVariables: dark
        ? {
            primaryColor: "#0f172a"  ,
            primaryTextColor: "#e5e7eb"  ,
            primaryBorderColor: "#94a3b8"  ,
            lineColor: "#94a3b8",
            textColor: "#e5e7eb",
            nodeTextColor: "#e5e7eb",
            edgeLabelBackground: "#0f172a",
          }
        : {
            primaryColor: "#f8fafc"  ,
            primaryTextColor: "#111827",
            primaryBorderColor: "#374151",
            lineColor: "#374151",
            textColor: "#111827",
            nodeTextColor: "#111827",
            edgeLabelBackground: "#ffffff",
          },
    };
  };

  const renderMermaid = () => {
    
    document.querySelectorAll(".mermaid[data-processed]").forEach((el) => {
      el.removeAttribute("data-processed");
    });
    mermaid.initialize(getThemeOptions());
    mermaid.run({ querySelector: ".mermaid" });
  };

  
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid, {
      once: true,
    });
  } else {
    renderMermaid();
  }

  
  const btn = document.getElementById("theme-toggle");
  if (btn) {
    btn.addEventListener("click", () => {
      
      setTimeout(renderMermaid, 0);
    });
  }

  
  const mql = window.matchMedia?.("(prefers-color-scheme: dark)");
  if (mql && mql.addEventListener) {
    mql.addEventListener("change", renderMermaid);
  }
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://blog.jsontapose.com/posts/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Posts"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.jsontapose.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jsontapose.com/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.jsontapose.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.jsontapose.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://jsontapose.com/ title="compare JSON"><span>compare JSON</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.jsontapose.com/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오프체인 서명 검증(Off-chain Signature Verification)이란?</h2></header><div class=entry-content><p>개요 블록체인 기술에서 모든 것을 온체인(On-chain)으로 처리하는 것은 비효율적이거나 불가능한 경우가 많음 이때 오프체인 서명 검증(Off-chain Signature Verification)은 오프체인(서버)의 유연성과 온체인(컨트랙트)의 신뢰성을 결합하는 강력한 해결책이 됨
쉽게 비유하자면, 클럽 매니저(서버)가 VIP 손님(사용자)에게만 특별한 싸인이 담긴 입장권(서명)을 발급하고, 입구의 가드(스마트 컨트랙트)는 그 싸인만 확인하고 들여보내는 것과 같음 가드는 매번 매니저에게 연락할 필요 없이, 위조되지 않은 싸인인지 확인만 하면 됨
이 글에서는 오프체인 서명 검증이 무엇인지, 어떤 용어들이 사용되는지, 그리고 가장 중요하게는 어떤 원리로 동작하는지 상세히 알아봄
...</p></div><footer class=entry-footer><span title='2025-09-21 03:11:23.351 +0000 UTC'>September 21, 2025</span></footer><a class=entry-link aria-label="post link to 오프체인 서명 검증(Off-chain Signature Verification)이란?" href=https://blog.jsontapose.com/posts/off-chain-signature-verification-542a33/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)</h2></header><div class=entry-content><p>개요 블록체인 서비스에서 사용자가 겪는 가장 큰 장벽 중 하나는 단연 가스비(Gas Fee)임 아무리 좋은 서비스를 만들어도, 사용자가 지갑에 가스비로 쓸 코인(ETH 등)을 보유하고 있어야 한다는 점은 대중화를 가로막는 결정적인 요인임 이 문제를 해결해 사용자가 가스비 걱정 없이 서비스 핵심 가치에만 집중하게 만드는 것, 즉 가스리스 트랜잭션(Gasless Transaction)을 구현하는 것이 이번 개발의 최종 목표였음
zkSync Era는 이를 위해 페이마스터(Paymaster)라는 강력한 시스템을 제공함. 페이마스터는 서비스 제공자 같은 제3자가 사용자를 대신해 트랜잭션 수수료를 지불할 수 있게 해주는 스마트 컨트랙트임
...</p></div><footer class=entry-footer><span title='2025-09-21 02:14:08.087 +0000 UTC'>September 21, 2025</span></footer><a class=entry-link aria-label="post link to 안전한 가스비 대납을 위한 오프체인 서명 검증 페이마스터 (in ZkSync Era)" href=https://blog.jsontapose.com/posts/zksync-era-paymaster-off-chain-signature-verification-274b74/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)</h2></header><div class=entry-content><p>SSE(Server-Sent Events)란 무엇인가 SSE는 Server-Sent Events의 약자로, 서버가 클라이언트로 실시간 데이터를 단방향으로 푸시(push)할 수 있게 해주는 웹 기술임 클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임
주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함
SSE vs 웹소켓, 그리고 한계 SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함
...</p></div><footer class=entry-footer><span title='2025-10-25 13:06:24.493 +0000 UTC'>October 25, 2025</span></footer><a class=entry-link aria-label="post link to SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)" href=https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할</h2></header><div class=entry-content><p>개요 머클트리는 블록체인에서 거래 집합을 안전하고 효율적으로 요약·검증하기 위해 쓰이는 핵심 자료구조임 블록 헤더에 머클루트가 포함되는 이유는 블록 안의 모든 거래를 고정 크기 해시 하나로 대표해 무결성 확인과 경량 검증을 가능하게 하기 때문임 이 글은 머클트리의 구조와 동작 원리, 블록체인에서의 실무적 의미와 구현 주의사항까지 초보자도 이해할 수 있도록 상세히 설명함
핵심 개념과 구조 머클트리는 보통 이진 트리 형태로 구현함 거래들을 리프(leaf) 로 두고 인접 두 리프의 해시를 이어 붙여 부모 해시를 만들며 이 과정을 반복해 루트 해시를 얻음 해시 함수는 체인별로 다르며 비트코인은 더블 SHA‑256, 이더리움은 트라이 구조에서 Keccak‑256 을 사용함 최상단 해시를 머클루트(Merkle root) 라 부르며 크기는 해시 함수에 따라 고정됨 리프 수가 홀수일 때는 마지막 리프를 복제해 짝을 맞추는 방식이 일반적이며 비트코인은 이 규칙을 사용함 트리 깊이는 리프 수 N에 대해 ⌈log₂ N⌉ 에 비례하므로 대량의 거래를 효율적으로 요약할 수 있음 동작 원리와 장점 인접 노드 해시 H_left || H_right 를 순서대로 연결해 해시를 계산하고 이를 위로 올려가며 루트 해시를 얻음 무결성 검증 단일 거래가 바뀌면 해당 리프에서 루트까지의 모든 경로 해시가 바뀌어 변조를 즉시 탐지할 수 있음 효율적 포함 증명 특정 거래가 블록에 포함되었음을 증명하려면 그 거래와 경로상의 형제 해시들만 있으면 됨 필요한 해시 개수는 O(log N) 으로 작아 대역폭과 검증 비용이 작음 확장성 보조 리프가 1,000,000개여도 증명에 필요한 형제 해시는 약 20개 수준으로 32바이트 해시 기준 약 640바이트에 불과함 블록 헤더와 경량 노드(SPV) 비트코인 블록 헤더는 이전 블록 해시, 머클루트, 난스 등 합의 관련 메타데이터를 포함함 경량 노드(SPV)는 블록 전체가 아니라 헤더 체인만 받아 신뢰성을 확보하고, 개별 거래에 대해서는 풀노드로부터 머클 증명 을 받아 포함 여부를 검증함 이 방식은 모바일·임베디드 환경에서도 실사용이 가능하게 하는 기반이 됨 이더리움은 전통적인 이진 머클트리 대신 머클‑패트리샤 트라이(MPT) 를 사용해 거래·영수증·상태 루트를 헤더에 담아 유사한 목적을 달성함 구현 세부와 체인별 차이 비트코인
...</p></div><footer class=entry-footer><span title='2025-09-20 17:15:26.218 +0000 UTC'>September 20, 2025</span></footer><a class=entry-link aria-label="post link to 머클트리(Merkle Tree)란? 머클트리의 개념과 블록체인에서의 역할" href=https://blog.jsontapose.com/posts/merkle-tree-blockchain-role-274b74/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>class-transformer와 class-validator로 DTO 변환·검증 패턴 정리</h2></header><div class=entry-content><p>개요 클라이언트에서 서버로 들어오는 요청 데이터를 DTO로 다루면 변환과 검증의 경계를 명확히 유지 가능함 class-transformer는 입력을 클래스 인스턴스로 변환하는 역할, class-validator는 변환된 인스턴스의 유효성 검증 역할 두 라이브러리를 함께 쓰면 DTO 레이어에서 데이터 정합성을 선제적으로 보장 가능함
핵심 개념 DTO 데이터 전송 객체, 외부 입력을 내부 도메인으로 들이기 전 구조와 제약을 고정하는 경계 class-transformer plain object ↔ 클래스 인스턴스 변환, 노출/제외 필드 제어 class-validator 데코레이터 기반 유효성 규칙 선언, 실행 시 검증 에러 수집 설치 npm install class-transformer class-validator사용 흐름과 최소 예시 입력 JSON 수신 → DTO 클래스로 변환 → DTO 인스턴스 검증 → 실패 시 에러 응답, 성공 시 비즈니스 로직으로 전달 import { Expose, Exclude, plainToInstance } from 'class-transformer' import { IsInt, IsString, validate } from 'class-validator' class UserDTO { @IsString() @Expose() name: string @IsInt() @Expose() age: number @Exclude() password?: string } const dto = plainToInstance(UserDTO, payload) const errors = await validate(dto) if (errors.length) { // 검증 실패 처리 }포인트
...</p></div><footer class=entry-footer><span title='2026-02-07 13:16:22.11 +0000 UTC'>February 7, 2026</span></footer><a class=entry-link aria-label="post link to class-transformer와 class-validator로 DTO 변환·검증 패턴 정리" href=https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TypeScript에서 declare function의 개념과 사용 시점</h2></header><div class=entry-content><p>개요 TypeScript의 declare 키워드는 외부에서 이미 구현된 값의 타입 정보를 컴파일러에 알려주는 용도임 실제 구현은 다른 런타임 환경이나 스크립트에 존재하고, TypeScript는 타입 검사만 수행함 선언은 자바스크립트 코드로 출력되지 않음
핵심 개념 declare function: 외부에 존재하는 함수의 시그니처만 제공하는 선언 사용 위치: 주로 .d.ts 선언 파일, 필요 시 .ts에서도 가능하지만 빌드 결과물에는 코드가 생성되지 않음 목적: 컴파일 타임에 타입을 인지시켜 오류를 줄이고, IDE 보조 기능을 활성화함 언제 사용하나 타입 정보가 없는 외부 자바스크립트 라이브러리 사용 시 글로벌로 노출된 함수나 변수를 TypeScript가 모를 때 JS와 TS 혼용 프로젝트에서 점진적 마이그레이션을 진행할 때 예시 글로벌 함수 선언 // 이미 어딘가에서 구현된 전역 함수가 있다고 가정 // my-globals.d.ts declare function myGlobalFunction(msg: string): void이렇게 선언하면 TypeScript가 함수 존재와 시그니처를 인식함
...</p></div><footer class=entry-footer><span title='2026-02-06 13:24:46.472 +0000 UTC'>February 6, 2026</span></footer><a class=entry-link aria-label="post link to TypeScript에서 declare function의 개념과 사용 시점" href=https://blog.jsontapose.com/posts/typescript-declare-function-53e697/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JavaScript 깊은 복사 vs 얕은 복사, structuredClone 사용 가이드</h2></header><div class=entry-content><p>개요 값 복사에서 가장 흔한 실수는 얕은 복사와 깊은 복사의 차이를 간과하는 것임 이 글은 JSON 해킹이나 라이브러리 대신 브라우저와 런타임이 제공하는 structuredClone으로 깊은 복사를 안정적으로 수행하는 방법과 주의점을 정리함
얕은 복사 JavaScript의 전개 연산자 …로 만드는 복사는 기본적으로 얕은 복사임 겉 모양과 1단계 속성은 복제되지만 중첩된 객체는 동일 참조를 공유함
const myOriginal = { someProp: "with a string value", anotherProp: { withAnotherProp: 1, andAnotherProp: true } } const myShallowCopy = { ...myOriginal } myShallowCopy.aNewProp = "a new value" console.log(myOriginal.aNewProp) // ^ logs `undefined` myShallowCopy.anotherProp.aNewProp = "a new value" console.log(myOriginal.anotherProp.aNewProp) // ^ logs `a new value` 기본형 값은 값 자체가 복사되지만 객체 같은 참조형은 레퍼런스가 복사됨 따라서 중첩된 구조를 안전하게 분리하려면 깊은 복사가 필요함
...</p></div><footer class=entry-footer><span title='2026-02-05 13:26:26.192 +0000 UTC'>February 5, 2026</span></footer><a class=entry-link aria-label="post link to JavaScript 깊은 복사 vs 얕은 복사, structuredClone 사용 가이드" href=https://blog.jsontapose.com/posts/javascript-structuredclone-deep-copy-shallow-copy-7cdc3a/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항</h2></header><div class=entry-content><p>개요 Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임 순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦 이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함
R.prop 개념과 문법 목적과 동작 원리
객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구 속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환 커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함 시그니처
...</p></div><footer class=entry-footer><span title='2026-02-04 13:25:03.536 +0000 UTC'>February 4, 2026</span></footer><a class=entry-link aria-label="post link to Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항" href=https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트</h2></header><div class=entry-content><p>개요 SWC는 Rust로 작성된 초고속 TypeScript/JavaScript 컴파일러 겸 트랜스파일러 동일한 작업을 수행하는 Babel이나 tsc 대비 10~20배 수준의 성능 향상이 보고됨 Rust로 구현되어 JS 런타임 기반 도구 대비 낮은 오버헤드와 높은 병렬 처리 효율 확보
핵심 개념 목적 TS/JS 소스 코드를 목표 런타임에서 실행 가능한 코드로 빠르게 변환 특징 타입 체크 미포함, 변환에 집중해 극단적 속도 추구 적용 범위 컴파일 단계와 테스트 실행, 개발 서버 부팅, CI 빌드 가속에 유효 채택 사례 Next.js에 기본 통합됨, 서버 프레임워크에서도 선택지로 확산 중
...</p></div><footer class=entry-footer><span title='2026-02-03 13:24:57.482 +0000 UTC'>February 3, 2026</span></footer><a class=entry-link aria-label="post link to SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트" href=https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드</h2></header><div class=entry-content><p>개요 차세대 프론트엔드 빌드 도구 Vite 요약 Vue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤 프랑스어로 vite는 빠름을 의미함
핵심 가치
개발 서버 즉시 기동에 가까운 체감 속도 HMR이 가볍고 빠르게 동작 의존성 프리번들을 esbuild로 처리해 개발 경험 가속 프로덕션 빌드는 Rollup으로 안정적 번들 생성 배경과 문제 기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조
프로젝트 규모가 커질수록 첫 기동이 지연 코드 변경 반영 또한 번들 재생성 비용으로 지연 발생 개발 체감 문제
...</p></div><footer class=entry-footer><span title='2026-02-02 13:24:37.004 +0000 UTC'>February 2, 2026</span></footer><a class=entry-link aria-label="post link to Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드" href=https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.jsontapose.com/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://blog.jsontapose.com/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>