<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | HandsLog</title>
<meta name=keywords content><meta name=description content="Posts - HandsLog"><meta name=author content><link rel=canonical href=https://handsupmin.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.08f7d74f0ada0f975d29ae436285b61ed7a719d05f350cb888d00341642995a2.css integrity="sha256-CPfXTwraD5ddKa5DYoW2HtenGdBfNQy4iNADQWQplaI=" rel="preload stylesheet" as=style><link rel=icon href=https://handsupmin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://handsupmin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://handsupmin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://handsupmin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://handsupmin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://handsupmin.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://handsupmin.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6NKJRT1NC1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6NKJRT1NC1")</script><meta name=google-adsense-account content="ca-pub-6022353980017733"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6022353980017733" crossorigin=anonymous></script><meta property="og:url" content="https://handsupmin.github.io/posts/"><meta property="og:site_name" content="HandsLog"><meta property="og:title" content="Posts"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://handsupmin.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://handsupmin.github.io/ accesskey=h title="HandsLog (Alt + H)">HandsLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://handsupmin.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://handsupmin.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://handsupmin.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSE 기반 실시간 알림 아키텍처 설계 NestJS + Redis Pub/Sub</h2></header><div class=entry-content><p>SSE 기반 실시간 알림 설계서 NestJS + Redis Pub/Sub 목적 QR 이벤트 보상 알림과 채팅 등 다양한 도메인의 서버→클라이언트 실시간 전달을 표준 HTTP 기반인 SSE로 단일 파이프라인에서 처리함 Kubernetes 다중 인스턴스 환경에서도 단순하고 견고하게 동작하도록 Redis Pub/Sub를 브로커로 채택함 대상 독자 초보 백엔드 대상 SSE와 Pub/Sub의 개념, 동작 방식, 최소 구현 흐름 정리 시니어 백엔드 대상 채널·이벤트 모델, 커넥션 레지스트리, 운영 지표와 신뢰성 포지션, 트레이드오프 명확화 1) 개념 요약 SSE Server‑Sent Events
...</p></div><footer class=entry-footer><span title='2025-10-25 13:06:24.493 +0000 UTC'>October 25, 2025</span></footer><a class=entry-link aria-label="post link to SSE 기반 실시간 알림 아키텍처 설계 NestJS + Redis Pub/Sub" href=https://handsupmin.github.io/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>함수형 프로그래밍 핵심 개념 요약</h2></header><div class=entry-content><p>개요 함수형 프로그래밍은 데이터 변이를 억제해 예측 가능성과 동시성 안전성 확보 목적
핵심 순수 함수, 불변성, 일급·고차 함수, 함수 합성
적용 상태 공유 최소화, map/filter/reduce 우선, I/O는 경계로 분리
주의 과도한 복사 비용 가능, 메모이제이션·지연 평가로 보완
참고자료 https://velog.io/@teo/functional-programming https://mangkyu.tistory.com/111</p></div><footer class=entry-footer><span title='2025-10-24 13:10:56.838 +0000 UTC'>October 24, 2025</span></footer><a class=entry-link aria-label="post link to 함수형 프로그래밍 핵심 개념 요약" href=https://handsupmin.github.io/posts/functional-programming-core-concepts-17a1eb/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Node.js 환경에서 디버깅하기</h2></header><div class=entry-content><p>개요 Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함
문제를 명확히 하기 작성한 코드의 기대 동작 정의 실제 관측된 동작과의 차이 정리 실패 조건과 재현 절차 고정 문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음
...</p></div><footer class=entry-footer><span title='2025-10-23 13:11:27.681 +0000 UTC'>October 23, 2025</span></footer><a class=entry-link aria-label="post link to Node.js 환경에서 디버깅하기" href=https://handsupmin.github.io/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL InnoDB 장단점과 운영 시 주의사항 정리</h2></header><div class=entry-content><p>개요 MySQL InnoDB는 ACID 트랜잭션을 기본으로 지원하는 스토리지 엔진으로 데이터 무결성과 동시성 보장을 목표로 설계됨 Row-level lock, MVCC, 클러스터형 인덱스, 외래 키, 크래시 리커버리 등 기능을 통해 OLTP 환경에서 안정적인 처리 성능 제공 아래는 InnoDB의 장단점과 운영 시 주의사항을 정리한 내용임
핵심 개념 클러스터형 인덱스 기반 저장 구조 기본 키(PK) 순서대로 데이터 페이지에 정렬 저장 보조 인덱스는 리프에 PK를 포함하여 PK 탐색으로 실제 레코드 접근 MVCC와 일관 읽기 Undo 로그 기반 버전 관리로 일관 읽기 제공 쓰기와 읽기 동시 처리 시 경합을 줄여 높은 동시성 달성 트랜잭션과 크래시 리커버리 Redo 로그로 커밋 데이터의 내구성 확보 Doublewrite 버퍼로 부분 쓰기 방지 비정상 종료 후 복구 경로 확보 장점 트랜잭션 ACID 보장 COMMIT, ROLLBACK, SAVEPOINT로 안전한 트랜잭션 경계 관리 가능 Row-level lock 기반 높은 동시성 필요한 행만 잠금으로 쓰기 경합을 최소화 테이블 락 기반 엔진 대비 OLTP에 유리 외래 키 제약으로 참조 무결성 유지 부모 자식 간 참조 일관성 DB 레벨에서 강제 애플리케이션 측 검증 부담 감소 크래시 리커버리 안정성 Redo/Undo 로그와 Doublewrite로 장애 상황에서도 데이터 무결성 유지 클러스터형 인덱스의 빠른 PK 접근과 범위 스캔 효율 PK 기반 조회 및 순차 범위 스캔에서 강점 MVCC로 읽기 일관성과 동시 처리 성능 확보 롱 리드와 빈번한 쓰기가 공존하는 시나리오에 적합 대규모 OLTP 워크로드에 적합 대량의 INSERT/UPDATE/DELETE 처리에서 일관된 성능과 안정성 제공 단점 메모리 사용량 큼 Buffer Pool 등 캐시 구조로 메모리 요구량 높음 메모리 부족 시 디스크 I/O 증가로 성능 저하 가능 클러스터형 인덱스 특성에 따른 PK 설계 민감도 높음 PK 업데이트는 물리 재배치와 페이지 분할 유발 가능 긴 문자열 PK 사용 시 저장 비효율 및 분할 증가 위험 디스크 공간 사용량 상대적으로 큼 Undo/Redo, Doublewrite, 각종 메타데이터로 파일 규모 증가 가능 대량 갱신 후 조각화 우려 파라미터가 많아 운영 난이도 존재 innodb_buffer_pool_size, innodb_log_file_size, innodb_flush_method 등 튜닝 필요 부적절한 설정 시 기대 성능 미달 위험 외래 키로 인한 잠금 경합과 데드락 리스크 증가 다중 FK 검증 경로가 얽히면 경합 심화 삽입·삭제 순서 제약으로 트랜잭션 복잡도 증가 Read-heavy 분석형 워크로드 적합성 한계 대규모 단순 조회 중심 OLAP 성격은 컬럼 지향 분석 시스템이 유리한 경우 존재 과거 일부 읽기 패턴에서 MyISAM이 빠른 사례가 있었으나 현재는 InnoDB가 기본 선택지로 자리함 운영 시 주의사항과 베스트 프랙티스 명시적 PK 또는 고유 인덱스 필수 명시적 PK 없으면 숨은 Row ID 사용으로 비효율 발생 가능 변경이 드문 짧은 정수형 PK 선호 예) INT AUTO_INCREMENT, BIGINT Buffer Pool 사이즈 적정화 innodb_buffer_pool_size는 핵심 파라미터 가능한 많은 데이터 페이지를 메모리에 유지할수록 I/O 절감 효과 큼 서버 메모리 대비 높은 비중 할당 권장하나 워크로드와 여유 메모리 고려하여 점진 조정 FK 사용 최소화 및 인덱스 정합성 확보 꼭 필요한 관계에만 FK 적용 FK 컬럼에 적절한 인덱스 부여로 잠금 경합과 테이블 스캔 방지 트랜잭션 내 잠금 순서 일관성 유지로 데드락 확률 낮추기 Row format과 페이지 전략 선택 ROW_FORMAT=DYNAMIC 등으로 긴 TEXT/BLOB를 오프페이지화하여 저장 효율 개선 크게 보이지 않는 설정이라도 대규모 테이블에서 성능과 공간 효율에 영향 큼 Auto-increment 충돌 방지 레플리케이션 또는 멀티 라이터 시나리오에서 키 충돌 방지 전략 필요 innodb_autoinc_lock_mode 값 검토 및 키 공간 분할 또는 시퀀스 전략 병행 통계 갱신과 조각화 대응 ANALYZE TABLE로 옵티마이저 통계 최신화 OPTIMIZE TABLE 또는 테이블 리빌드로 심한 조각화 해소와 공간 회수 검토 데드락 모니터링 루틴화 SHOW ENGINE INNODB STATUS와 information_schema의 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS로 원인 추적 쿼리 접근 순서 정렬, 트랜잭션 단위 축소, 적절한 인덱싱으로 예방 로그 크기와 플러시 정책의 트레이드오프 이해 innodb_log_file_size, innodb_flush_log_at_trx_commit, sync_binlog 설정이 지연 시간과 내구성에 직접 영향 허용 가능한 데이터 손실 범위와 지연 요구사항에 맞춰 설정 조정 마무리 장점 요약 ACID 트랜잭션, Row-level lock, MVCC, FK, 클러스터형 인덱스, 안정적 크래시 리커버리 단점 요약 메모리와 디스크 사용량 큼, 설정 복잡도 존재, PK 설계 민감, FK로 인한 경합과 데드락 리스크 운영 체크리스트 짧은 정수형 명시적 PK 설계 Buffer Pool 및 로그 정책 튜닝 FK 최소화와 인덱스 정합성 확보 정기 통계 갱신과 조각화 관리, 데드락 모니터링 적절한 설정과 스키마 설계를 병행하면 OLTP 환경에서 높은 안정성과 성능을 동시에 달성 가능 참고자료 https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html https://dev.mysql.com/doc/refman/8.0/en/innodb-file-system-architecture.html https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html https://dev.mysql.com/doc/refman/8.0/en/innodb-optimizing-innodb-operations.html</p></div><footer class=entry-footer><span title='2025-10-22 13:12:18.76 +0000 UTC'>October 22, 2025</span></footer><a class=entry-link aria-label="post link to MySQL InnoDB 장단점과 운영 시 주의사항 정리" href=https://handsupmin.github.io/posts/mysql-innodb-pros-cons-and-cautions-4b2d90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TypeScript enum, const enum, as const 차이와 선택 기준</h2></header><div class=entry-content><p>개요 TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임 각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음
enum 개념과 동작 열거형 타입을 선언하는 문법 숫자 기반과 문자열 기반 모두 지원 컴파일 결과로 양방향 매핑을 담은 JS 객체 생성 키로 값 조회, 값으로 키 역조회 가능 예시
enum BooleanType { False = 0, True = 1, } 컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨
...</p></div><footer class=entry-footer><span title='2025-10-21 13:12:21.632 +0000 UTC'>October 21, 2025</span></footer><a class=entry-link aria-label="post link to TypeScript enum, const enum, as const 차이와 선택 기준" href=https://handsupmin.github.io/posts/typescript-enum-const-enum-as-const-3817af/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징</h2></header><div class=entry-content><p>기본 문법 LIMIT는 SELECT 결과에서 반환할 행 수를 제한하는 구문 WHERE와 ORDER BY 뒤, 즉 SELECT 문 끝에 위치
두 가지 형태 사용
SELECT 컬럼명 FROM 테이블명 LIMIT 개수 SELECT 컬럼명 FROM 테이블명 LIMIT 개수 OFFSET 시작_인덱스 일부 dialect에서는 아래 축약형도 존재
-- MySQL, SQLite SELECT 컬럼명 FROM 테이블명 LIMIT 시작_인덱스, 개수 1. LIMIT 개수 LIMIT 뒤 숫자는 인덱스가 아닌 개수
SELECT * FROM Book LIMIT 1 현재 정렬 기준에서 맨 위 행 1개만 반환 ORDER BY가 없으면 반환되는 행은 비결정적일 수 있음
...</p></div><footer class=entry-footer><span title='2025-10-20 13:10:30.355 +0000 UTC'>October 20, 2025</span></footer><a class=entry-link aria-label="post link to SQL LIMIT와 OFFSET 사용법 정리: 행 개수 제한과 페이징" href=https://handsupmin.github.io/posts/sql-limit-offset-basics-4a9880/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법</h2></header><div class=entry-content><p>개요 Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음 Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 –debug는 폐기, –inspect로 통일됨 CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함
이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함
핵심 개념 v8-inspector 프로토콜 V8이 노출하는 디버깅 프로토콜 Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조 –inspect vs –inspect-brk –inspect는 바로 실행하면서 디버거 접속 대기 –inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용 포트 기본 포트 9229 사용 –inspect=PORT, –inspect-brk=PORT 형태로 변경 가능 프론트엔드 Chromium 기반 개발자도구로 연결 가능 chrome://inspect 에서 Node 대상 탐색 및 연결 node-inspect Node 내장 CLI 디버거 동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행 크롬 개발자도구로 디버깅 Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정
...</p></div><footer class=entry-footer><span title='2025-10-19 13:06:18.179 +0000 UTC'>October 19, 2025</span></footer><a class=entry-link aria-label="post link to Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법" href=https://handsupmin.github.io/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교</h2></header><div class=entry-content><p>컨트롤 플레인은 쿠버네티스 클러스터의 두뇌이자 의사결정 계층으로, 워커 노드가 실제 워크로드를 돌리는 동안 전체 상태를 정의하고 조율하는 역할을 맡음 조직 비유로 보면 컨트롤 플레인은 본사와 경영진, 워커 노드는 지점과 현장 직원에 해당함
개념과 정의 컨트롤 플레인은 Desired State를 선언적으로 저장하고, Observed State와 비교해 일치하도록 끊임없이 조정하는 계층 사용자는 API를 통해 상태를 선언하고, 컨트롤 플레인은 스케줄링과 컨트롤 루프로 이를 만족하도록 시스템을 수렴시킴
핵심 구성요소 API 서버 kube-apiserver — 모든 요청의 진입점, 인증·인가·어드미션 수행 후 상태 변경을 etcd에 반영
...</p></div><footer class=entry-footer><span title='2025-10-18 13:06:16.817 +0000 UTC'>October 18, 2025</span></footer><a class=entry-link aria-label="post link to 쿠버네티스 컨트롤 플레인 핵심 개념과 EKS 비교" href=https://handsupmin.github.io/posts/kubernetes-control-plane-eks-2af164/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</h2></header><div class=entry-content><p>개요 가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리 컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명
가드란 NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소 미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점 요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨 canActivate가 true 또는 Promise을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생
...</p></div><footer class=entry-footer><span title='2025-10-17 13:09:19.602 +0000 UTC'>October 17, 2025</span></footer><a class=entry-link aria-label="post link to NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시" href=https://handsupmin.github.io/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes 핵심 구성요소와 동작 흐름</h2></header><div class=entry-content><p>개요 쿠버네티스는 제어 평면과 워커 노드, 그리고 그 사이를 매개하는 런타임과 커널 메커니즘이 맞물려 동작하는 분산 시스템 핵심은 단일 진실 소스에 원하는 상태를 기록하고, 이를 지속적으로 감시하고 조정해 실제 상태를 일치시키는 루프 각 컴포넌트의 역할과 상호작용을 이해하면 장애 대응, 스케일링, 성능 튜닝의 기준점 확보 가능
구성요소 관계 한눈에 kubectl / CI │ ▼ kube-apiserver ──> etcd │ ▲ │ └(상태 영속) │ ├─ kube-scheduler(어디 배치할지 결정) └─ kube-controller-manager(원하는 상태로 맞춤: ReplicaSet 등) [각 워커 노드] kubelet ──(CRI gRPC)──> container runtime ──(OCI)──> runc/crun ──> cgroup 설정 + 컨테이너 시작 │ │ ├─(CNI 호출) 네트워크/IP 할당 └─ 네임스페이스/마운트 등 격리 └─ kube-proxy(서비스 라우팅: iptables/ipvs) 모든 컴포넌트의 권위자이자 입구는 apiserver etcd와 직접 통신하는 주체는 apiserver만 존재 kubelet은 apiserver를 watch하여 자신에게 배정된 파드 감지 container runtime은 OCI 런타임을 통해 cgroup과 네임스페이스를 세팅하고 컨테이너 프로세스 실행 Pod 생성에서 Running까지 사용자가 kubectl apply 등으로 Desired State를 제출하면 apiserver가 인증과 유효성, 어드미션을 거쳐 etcd에 영속화 controller-manager가 오브젝트를 관찰하고 필요한 부수 리소스를 생성, 예 ReplicaSet과 Pod 등 scheduler가 Pending 파드에 대해 노드 배치를 결정, 리소스 요청, 어피니티, 토폴로지, taint와 tolerance 등을 고려해 Pod에 NodeName 바인딩 대상 노드의 kubelet이 apiserver watch로 자신에게 할당된 파드 탐지 kubelet이 이미지 풀, 볼륨 마운트, 네트워크 준비를 순차 수행, CNI 플러그인을 호출해 인터페이스와 IP 할당 kubelet이 CRI를 통해 container runtime에 파드와 컨테이너 생성 요청 전달 runtime이 OCI 런타임 runc 또는 crun을 호출하여 cgroup 생성과 리눅스 네임스페이스 PID NET MNT UTS IPC 설정 후 엔트리포인트 실행 kubelet이 liveness readiness 스타트업 프로브로 상태를 확인하고 apiserver로 주기 보고 kube-proxy가 Service와 Endpoints 변경을 반영해 iptables 혹은 ipvs 규칙 갱신, 서비스 트래픽 라우팅 경로 성립 클러스터 DNS와 Service IP를 통해 파드로 트래픽 전달 완료 cgroup과 리소스 제한 연결 PodSpec의 resources.requests와 limits가 kubelet을 거쳐 runtime에 전달되고, runtime과 OCI가 cgroup v1 또는 v2에 실제 quota와 limit 설정 CPU는 shares와 quota를 통해 스케줄러 가중치와 시간 쿼터 부여 메모리는 hard limit과 OOM killer 점수 조정으로 커널 레벨 강제 쿠버네티스 리소스 제한의 실체는 cgroup 설정이라는 점이 핵심 장애·스케일·자체 복구 흐름 컨테이너 크래시 발생 시 kubelet이 상태를 보고하고 컨트롤러가 Desired 수를 보장하기 위해 재시작 또는 재스케줄 수행 노드가 NotReady로 전환되면 스케줄러와 컨트롤러가 파드를 다른 노드로 이동시키는 복구 경로 선택 HPA VPA 클러스터 오토스케일러 등으로 Desired State를 조정하면 동일한 조율 루프로 반영되어 자원과 파드 수가 확장 또는 축소 용어 핵심 정리 control plane apiserver 권위와 입구, scheduler 배치, controller-manager 조율, etcd 단일 진실 저장소 worker node 파드를 실제로 실행하는 머신 풀 kubelet 각 노드의 현장 에이전트, 파드 라이프사이클 관리와 apiserver 동기화 담당 container runtime kubelet 지시로 컨테이너 생성과 삭제를 수행하는 실행기, CRI 인터페이스 준수 cgroup 컨테이너 자원 격리와 제한의 커널 메커니즘, OCI 런타임이 설정 마무리 apiserver는 진실의 관문, etcd는 진실의 저장소, 스케줄러와 컨트롤러는 계획과 조율, kubelet은 현장 실행, runtime과 OCI는 컨테이너 생성, cgroup은 자원 격리 담당
...</p></div><footer class=entry-footer><span title='2025-10-16 13:10:58.23 +0000 UTC'>October 16, 2025</span></footer><a class=entry-link aria-label="post link to Kubernetes 핵심 구성요소와 동작 흐름" href=https://handsupmin.github.io/posts/kubernetes-core-components-and-flow-915d3a/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://handsupmin.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://handsupmin.github.io/>HandsLog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>