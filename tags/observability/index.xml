<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Observability on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/observability/</link>
    <description>Recent content in Observability on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 31 Dec 2025 13:12:12 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/observability/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>API 에러 응답 설계 가이드 — HTTP Status는 대분류, 비즈니스 의미는 바디</title>
      <link>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</link>
      <pubDate>Wed, 31 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;HTTP Status Code만으로는 서비스 로직의 원인을 전달하기 부족함
400대와 500대는 네트워크 관점의 대분류 신호에 가깝고 실제로 필요한 것은 비즈니스 맥락의 구체적 사유임
결론은 단순함
HTTP Status는 대분류 신호로 두고 실제 의미와 추가 컨텍스트는 Response Body에 싣는 구조가 현실적 해법임&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Status는 큰 범주 신호등 역할
&lt;ul&gt;
&lt;li&gt;2xx 성공&lt;/li&gt;
&lt;li&gt;4xx 클라이언트 오류&lt;/li&gt;
&lt;li&gt;5xx 서버 오류&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비즈니스 의미는 Response Body의 커스텀 에러 구조로 표현&lt;/li&gt;
&lt;li&gt;클라이언트가 코드 기반으로 분기하고 UI를 결정할 수 있어야 함&lt;/li&gt;
&lt;li&gt;운영 관측을 위해 traceId 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;업계에서-검증된-기본-구조&#34;&gt;업계에서 검증된 기본 구조&lt;/h3&gt;
&lt;p&gt;아래 형태가 가장 보편적으로 쓰이는 패턴임&lt;/p&gt;</description>
    </item>
    <item>
      <title>트래픽을 일정 비율로 안전하게 나누는 방법: 해시 코호트와 구성 기반 롤아웃</title>
      <link>https://blog.jsontapose.com/posts/safe-traffic-splitting-with-hash-cohorts-and-config-rollout-f5b03f/</link>
      <pubDate>Mon, 29 Dec 2025 13:13:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/safe-traffic-splitting-with-hash-cohorts-and-config-rollout-f5b03f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;운영 중인 서비스에서 전체 트래픽을 한 번에 신규 기능이나 신규 인프라로 전환하지 않고, 일정 비율만 점진적으로 이동하는 전략이 필요함&lt;/p&gt;
&lt;p&gt;주요 활용 맥락&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A/B 테스트로 실험군과 통제군 분리&lt;/li&gt;
&lt;li&gt;카나리 배포로 신규 버전을 소수 사용자에게만 적용&lt;/li&gt;
&lt;li&gt;신규 데이터베이스, 캐시, 인덱스 전환 검증&lt;/li&gt;
&lt;li&gt;신규 알고리즘, 추천 엔진, 정책 점진 적용&lt;/li&gt;
&lt;li&gt;서버 비용 최적화를 위한 점진적 트래픽 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 대부분의 시나리오에 적용 가능한 일반화된 트래픽 분배 기법 정리&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;요구-조건&#34;&gt;요구 조건&lt;/h3&gt;
&lt;h4 id=&#34;deterministic--같은-사용자나-리소스는-항상-같은-그룹에-속해야-함&#34;&gt;Deterministic — 같은 사용자나 리소스는 항상 같은 그룹에 속해야 함&lt;/h4&gt;
&lt;p&gt;요청마다 그룹이 바뀌면 실험 신뢰성이 떨어지고 디버깅이 어려움
안정적 해시 기반 결정 방식 필요&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes 아키텍처와 핵심 컴포넌트 정리</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/</link>
      <pubDate>Mon, 22 Dec 2025 13:12:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-architecture-core-components-ebe5f4/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;쿠버네티스는 명령을 조율하는 Control Plane과 실제 워크로드가 실행되는 Data Plane으로 구성됨
각 컴포넌트의 역할과 흐름을 이해하면 트러블슈팅, 성능 최적화, 보안 구성에 필요한 기준이 생김
클라우드 매니지드 쿠버네티스의 경우 Control Plane은 보통 제공자가 관리하지만 동작 원리 이해는 필수&lt;/p&gt;
&lt;h3 id=&#34;control-plane&#34;&gt;Control Plane&lt;/h3&gt;
&lt;p&gt;API Server&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클러스터 유일 진입점&lt;/li&gt;
&lt;li&gt;모든 컴포넌트와 사용자는 API Server를 통해 통신&lt;/li&gt;
&lt;li&gt;인증과 권한 확인 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;etcd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클러스터 상태와 스펙을 보관하는 분산 키밸류 저장소&lt;/li&gt;
&lt;li&gt;API Server만 직접 접근 가능&lt;/li&gt;
&lt;li&gt;상태 복구의 근간이 되는 데이터 원장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scheduler&lt;/p&gt;</description>
    </item>
    <item>
      <title>사이드카 패턴 이해와 도입 판단 가이드: 마이크로서비스·쿠버네티스에서의 활용</title>
      <link>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</link>
      <pubDate>Sat, 13 Dec 2025 13:09:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스로 분산이 심화되면 로깅, 모니터링, 보안, 네트워킹 같은 공통 기능을 어디에 둘지 결정이 어려워짐
애플리케이션 코드에 공통 기능을 계속 끼워 넣으면 침투와 중복 증가, 배포와 버전 관리 복잡도 상승
사이드카 패턴은 공통 기능을 별도 컨테이너로 분리해 메인 서비스는 비즈니스 로직에 집중하게 하는 접근법
컨테이너 오케스트레이션 환경에서 일관된 운영 모델을 제공한다는 점이 실무적 장점&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;사이드카 패턴의 구성 요소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메인 컨테이너: 비즈니스 로직 담당, 웹 서비스나 API 서버 등&lt;/li&gt;
&lt;li&gt;사이드카 컨테이너: 횡단 관심사 처리, 로그 수집, 모니터링 에이전트, 프록시, 보안 검사 등
같은 파드 내 배치로 네트워크 네임스페이스와 볼륨 공유 가능, 표준 출력/공유 볼륨 등을 통해 데이터 연계
업데이트와 배포를 컨테이너 단위로 분리해 독립적 버전 관리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;p&gt;하나의 파드에 메인 컨테이너와 사이드카 컨테이너를 함께 배치&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
