<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Typescript on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/typescript/</link>
    <description>Recent content in Typescript on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 07 Feb 2026 13:16:22 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/typescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>class-transformer와 class-validator로 DTO 변환·검증 패턴 정리</title>
      <link>https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/</link>
      <pubDate>Sat, 07 Feb 2026 13:16:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/class-transformer-class-validator-dto-7d4133/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;클라이언트에서 서버로 들어오는 요청 데이터를 DTO로 다루면 변환과 검증의 경계를 명확히 유지 가능함
class-transformer는 입력을 클래스 인스턴스로 변환하는 역할, class-validator는 변환된 인스턴스의 유효성 검증 역할
두 라이브러리를 함께 쓰면 DTO 레이어에서 데이터 정합성을 선제적으로 보장 가능함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DTO 데이터 전송 객체, 외부 입력을 내부 도메인으로 들이기 전 구조와 제약을 고정하는 경계&lt;/li&gt;
&lt;li&gt;class-transformer plain object ↔ 클래스 인스턴스 변환, 노출/제외 필드 제어&lt;/li&gt;
&lt;li&gt;class-validator 데코레이터 기반 유효성 규칙 선언, 실행 시 검증 에러 수집&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;설치&#34;&gt;설치&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm install class-transformer class-validator&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;사용-흐름과-최소-예시&#34;&gt;사용 흐름과 최소 예시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;입력 JSON 수신 → DTO 클래스로 변환 → DTO 인스턴스 검증 → 실패 시 에러 응답, 성공 시 비즈니스 로직으로 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; Expose&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; Exclude&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; plainToInstance &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;class-transformer&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; IsInt&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; IsString&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; validate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;class-validator&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; UserDTO &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@IsString&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Expose&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@IsInt&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Expose&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Exclude&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  password?: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; dto &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; plainToInstance&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;UserDTO&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; payload&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; errors &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; validate&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;dto&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;errors&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;length&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 검증 실패 처리
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;포인트&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript에서 declare function의 개념과 사용 시점</title>
      <link>https://blog.jsontapose.com/posts/typescript-declare-function-53e697/</link>
      <pubDate>Fri, 06 Feb 2026 13:24:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-declare-function-53e697/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript의 declare 키워드는 외부에서 이미 구현된 값의 타입 정보를 컴파일러에 알려주는 용도임
실제 구현은 다른 런타임 환경이나 스크립트에 존재하고, TypeScript는 타입 검사만 수행함
선언은 자바스크립트 코드로 출력되지 않음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;declare function: 외부에 존재하는 함수의 시그니처만 제공하는 선언&lt;/li&gt;
&lt;li&gt;사용 위치: 주로 .d.ts 선언 파일, 필요 시 .ts에서도 가능하지만 빌드 결과물에는 코드가 생성되지 않음&lt;/li&gt;
&lt;li&gt;목적: 컴파일 타임에 타입을 인지시켜 오류를 줄이고, IDE 보조 기능을 활성화함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;언제-사용하나&#34;&gt;언제 사용하나&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타입 정보가 없는 외부 자바스크립트 라이브러리 사용 시&lt;/li&gt;
&lt;li&gt;글로벌로 노출된 함수나 변수를 TypeScript가 모를 때&lt;/li&gt;
&lt;li&gt;JS와 TS 혼용 프로젝트에서 점진적 마이그레이션을 진행할 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;글로벌 함수 선언&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 이미 어딘가에서 구현된 전역 함수가 있다고 가정
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// my-globals.d.ts
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;declare&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; myGlobalFunction&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;msg: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 선언하면 TypeScript가 함수 존재와 시그니처를 인식함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ramda 핵심 개념 정리와 R.prop 안전한 속성 접근, 커링·조합·주의사항</title>
      <link>https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/</link>
      <pubDate>Wed, 04 Feb 2026 13:25:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/ramda-core-and-r-prop-currying-composition-caveats-f3fa82/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Ramda는 JavaScript와 TypeScript에서 함수형 프로그래밍을 실용적으로 적용하기 위한 유틸리티 모음집임
순수 함수, 불변성, 커링, 함수 조합을 일관된 인터페이스로 제공하며, 매개변수 순서를 함수 → 데이터로 통일해 조합과 부분 적용을 자연스럽게 만듦
이 글은 R.prop을 중심으로 Ramda 핵심 함수의 개념과 사용법, 타입 고려사항, 흔한 함정과 우회 전략을 정리함&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;rprop-개념과-문법&#34;&gt;R.prop 개념과 문법&lt;/h3&gt;
&lt;p&gt;목적과 동작 원리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 특정 속성 값을 안전하게 조회하는 읽기 전용 도구&lt;/li&gt;
&lt;li&gt;속성이 없거나 undefined일 수 있는 상황에서 런타임 예외 없이 undefined 반환&lt;/li&gt;
&lt;li&gt;커링 지원으로 속성 이름을 고정해 재사용 가능한 픽커 함수 구성에 유리함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시그니처&lt;/p&gt;</description>
    </item>
    <item>
      <title>SWC로 TypeScript/JavaScript 빌드 가속하기 — Babel·tsc 대비 장점과 NestJS 적용 포인트</title>
      <link>https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/</link>
      <pubDate>Tue, 03 Feb 2026 13:24:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/swc-typescript-javascript-build-acceleration-babel-tsc-nestjs-c942ce/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;SWC는 Rust로 작성된 초고속 TypeScript/JavaScript 컴파일러 겸 트랜스파일러
동일한 작업을 수행하는 Babel이나 tsc 대비 10~20배 수준의 성능 향상이 보고됨
Rust로 구현되어 JS 런타임 기반 도구 대비 낮은 오버헤드와 높은 병렬 처리 효율 확보&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;목적  TS/JS 소스 코드를 목표 런타임에서 실행 가능한 코드로 빠르게 변환
특징  타입 체크 미포함, 변환에 집중해 극단적 속도 추구
적용 범위  컴파일 단계와 테스트 실행, 개발 서버 부팅, CI 빌드 가속에 유효
채택 사례  Next.js에 기본 통합됨, 서버 프레임워크에서도 선택지로 확산 중&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vitest 완벽 가이드</title>
      <link>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</link>
      <pubDate>Sun, 01 Feb 2026 13:16:32 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Vite 기반의 테스트 프레임워크 Vitest 소개 및 실무 사용 패턴 정리
Jest와 거의 동일한 API를 제공하고, Vite의 ESM/HMR을 활용해 빠른 재실행을 제공함
Vite 프로젝트에서는 최소 설정으로 바로 사용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;빠른 실행과 재실행, watch 효율 높음&lt;/li&gt;
&lt;li&gt;Jest API 호환성 높아 러닝 커브 낮음&lt;/li&gt;
&lt;li&gt;TypeScript 네이티브 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-기본-구조&#34;&gt;1. 기본 구조&lt;/h2&gt;
&lt;h3 id=&#34;테스트-파일-명명-규칙&#34;&gt;테스트 파일 명명 규칙&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*.spec.ts     또는     *.test.ts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;describename-fn&#34;&gt;describe(name, fn)&lt;/h3&gt;
&lt;p&gt;관련 테스트를 그룹화하는 컨테이너&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; describe&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; it&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; expect &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;vitest&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;describe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;계산기&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 더한다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 뺀다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;첫 번째 인자: 그룹 이름&lt;/li&gt;
&lt;li&gt;두 번째 인자: 테스트 콜백&lt;/li&gt;
&lt;li&gt;중첩 describe 구성 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;itname-fn--testname-fn&#34;&gt;it(name, fn) / test(name, fn)&lt;/h3&gt;
&lt;p&gt;개별 테스트 케이스 정의, 두 API는 동일 동작&lt;/p&gt;</description>
    </item>
    <item>
      <title>class-transformer의 @Expose/@Exclude, @Type, plainToInstance, excludeExtraneousValues 정확히 이해하고 쓰기</title>
      <link>https://blog.jsontapose.com/posts/class-transformer-expose-exclude-type-plain-to-instance-exclude-extraneous-values-8baf8a/</link>
      <pubDate>Sat, 31 Jan 2026 13:16:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/class-transformer-expose-exclude-type-plain-to-instance-exclude-extraneous-values-8baf8a/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API DTO를 다룰 때 class-transformer의 @Expose, @Exclude, @Type와 plainToInstance, excludeExtraneousValues 옵션을 정확히 이해해야 데이터 노출 제어와 변환 일관성을 확보할 수 있음
아래는 개념 정의와 동작 방향, 자주 생기는 오해 정리 및 최소 예시&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;expose와-exclude&#34;&gt;@Expose와 @Exclude&lt;/h3&gt;
&lt;p&gt;핵심 개념&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Expose: 변환 대상으로 명시적 노출 표시&lt;/li&gt;
&lt;li&gt;@Exclude: 변환에서 제외 표시&lt;/li&gt;
&lt;li&gt;기본 전략은 include-all에 가까움. 즉 아무 옵션 없이 변환하면 대부분의 필드가 그대로 따라옴. 진짜 필드 필터링을 원하면 @Exclude 사용 또는 excludeExtraneousValues 옵션과 함께 @Expose 사용 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;동작 원리&lt;/p&gt;</description>
    </item>
    <item>
      <title>tsconfig.json 핵심 옵션 가이드: module과 moduleResolution</title>
      <link>https://blog.jsontapose.com/posts/tsconfig-json-module-module-resolution-guide-05bc37/</link>
      <pubDate>Thu, 29 Jan 2026 13:23:24 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/tsconfig-json-module-module-resolution-guide-05bc37/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;tsconfig.json은 TypeScript 컴파일러 tsc의 설정 파일이며 프로젝트를 어떻게 컴파일할지 정의함&lt;/p&gt;
&lt;p&gt;TypeScript 코드가 JavaScript로 변환되는 경로에 대한 스위치 보드 역할 수행&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TypeScript (.ts)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ tsc ]  ← tsconfig.json이 규칙 제공
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↓
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;JavaScript (.js)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;module-옵션&#34;&gt;module 옵션&lt;/h3&gt;
&lt;p&gt;출력되는 JavaScript의 모듈 시스템 선택&lt;/p&gt;
&lt;p&gt;모듈 시스템의 변화 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;없음, 전역 스코프 공유&lt;/li&gt;
&lt;li&gt;CommonJS, require/module.exports 중심&lt;/li&gt;
&lt;li&gt;AMD, 브라우저 환경 define/require&lt;/li&gt;
&lt;li&gt;ES Modules, 표준 import/export&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;주요 값과 용도&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commonjs  Node.js 구버전 호환&lt;/li&gt;
&lt;li&gt;es2015/es6  표준 ESM, 브라우저·번들러 환경&lt;/li&gt;
&lt;li&gt;es2020  ESM + dynamic import 사용 환경&lt;/li&gt;
&lt;li&gt;es2022  ESM + top-level await 사용 환경&lt;/li&gt;
&lt;li&gt;esnext  최신 ESM 기능 추적&lt;/li&gt;
&lt;li&gt;nodenext  Node.js 16+의 ESM 출력·해석 규칙 반영&lt;/li&gt;
&lt;li&gt;node16  Node.js 16의 ESM과 CJS 혼합 환경 대응&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;같은 코드의 다른 출력 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript 배열 순회 패턴과 forEach 비동기 한계, 값·참조 전달 정리</title>
      <link>https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/</link>
      <pubDate>Tue, 27 Jan 2026 13:17:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-iteration-patterns-foreach-async-pass-by-value-reference-67c6f3/</guid>
      <description>&lt;p&gt;배열을 순회하는 방법은 여러 가지가 있음. 전통적인 for, Array.prototype.forEach, ES6 for&amp;hellip;of, 그리고 객체 속성에 적합한 for&amp;hellip;in. 여기에 forEach의 비동기 제어 한계와 값/참조 전달 의미 차이를 함께 정리함&lt;/p&gt;
&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;자바스크립트에서 순회는 목적과 제약에 맞춰 선택하는 문제임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 인덱스 제어, 경계 조건, 성능 미세 조정, 조기 종료 필요 시 유용&lt;/li&gt;
&lt;li&gt;forEach 선언적 스타일, 반환값 없음, 조기 종료 불가, 비동기 완료 제어 불가&lt;/li&gt;
&lt;li&gt;for&amp;hellip;of 이터러블 값 순회에 적합, 인덱스 필요 없을 때 간결, await와 결합 가능&lt;/li&gt;
&lt;li&gt;for&amp;hellip;in 객체의 열거 가능 속성 순회용. 배열에는 권장하지 않음. 키 순서와 상속 프로퍼티 이슈 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이터러블과 이터레이터 프로토콜을 따르는 객체에 for&amp;hellip;of를 적용 가능. 배열, 문자열, Map, Set 등이 대표적임&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript 고급 타입 패턴 정리 — 제네릭, 유니온·인터섹션, 매핑, 조건부, 유틸리티</title>
      <link>https://blog.jsontapose.com/posts/typescript-advanced-type-patterns-d8ee0f/</link>
      <pubDate>Sun, 25 Jan 2026 13:12:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-advanced-type-patterns-d8ee0f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript의 고급 타입은 단순 오류 방지 수준을 넘어 재사용성과 유지보수성을 끌어올리는 핵심 도구임
제네릭, 유니온·인터섹션, 매핑 타입, 조건부 타입, 그리고 실무에서 자주 쓰는 유틸리티 타입을 간단 예시와 함께 정리함&lt;/p&gt;
&lt;h3 id=&#34;제네릭&#34;&gt;제네릭&lt;/h3&gt;
&lt;p&gt;타입을 값처럼 받아서 사용하는 패턴으로, 선언 시점이 아니라 사용 시점에 타입을 결정함
any 대비 타입 정보를 잃지 않으면서 다양한 타입을 수용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기본 형태 &lt;!-- raw HTML omitted --&gt; 사용&lt;/li&gt;
&lt;li&gt;입력과 출력 타입의 관계를 보존하는 데 초점&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; wrap&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;value: &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;gt;(&lt;/span&gt;value: &lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; value &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; stringBox &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; numberBox &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; wrapBox&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;T는 관습적 이름이며 의미가 드러나는 이름 사용 권장&lt;/li&gt;
&lt;li&gt;제네릭 제한이 필요한 경우 extends를 사용해 제약 가능 ex) &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;유니온과-인터섹션&#34;&gt;유니온과 인터섹션&lt;/h3&gt;
&lt;p&gt;여러 타입을 조합해 표현력을 높이는 방법&lt;/p&gt;</description>
    </item>
    <item>
      <title>RxJS 핵심 가이드와 내부 동작 이해 Observable Subject Teardown Scheduler Operator</title>
      <link>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</link>
      <pubDate>Sat, 24 Jan 2026 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;RxJS는 Reactive Extensions for JavaScript의 약자이며 비동기 데이터 흐름을 스트림 Observable로 다루는 라이브러리임
이벤트, API 응답, 클릭, WebSocket처럼 시간에 따라 변하는 값을 하나의 연속 흐름으로 모델링 가능&lt;/p&gt;
&lt;p&gt;핵심 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise는 값 1개 처리&lt;/li&gt;
&lt;li&gt;Observable은 값 0개부터 무한대까지 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;observable-핵심&#34;&gt;Observable 핵심&lt;/h3&gt;
&lt;p&gt;정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간에 따라 변경되는 데이터를 push 기반 스트림으로 표현한 객체&lt;/li&gt;
&lt;li&gt;구독 subscribe 시점에만 실행되는 lazy 특성&lt;/li&gt;
&lt;li&gt;구독 해제 unsubscribe 시 리소스 정리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lazy 실행으로 불필요한 작업 방지&lt;/li&gt;
&lt;li&gt;cancel 가능으로 누수 방지&lt;/li&gt;
&lt;li&gt;0~무한개의 값 연속 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript/ESM import 경로 정리: &#39;@&#39;, &#39;#&#39;, 상대 경로의 의미와 설정</title>
      <link>https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/</link>
      <pubDate>Fri, 23 Jan 2026 13:15:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-esm-import-path-atsign-hash-relative-a9f97e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript와 ESM에서 자주 보이는 세 가지 import 패턴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;@&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;li&gt;import &amp;hellip; from &amp;lsquo;#&amp;hellip;&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;표기만 비슷할 뿐, 해석 주체와 동작 범위가 다름&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;@&amp;lsquo;는 경로 별칭 또는 npm 스코프 패키지 의미 가능&lt;/li&gt;
&lt;li&gt;&amp;lsquo;&amp;hellip;&amp;lsquo;는 상대·절대 경로로 파일 시스템 기준 해석&lt;/li&gt;
&lt;li&gt;&amp;lsquo;#&amp;lsquo;는 Node.js 패키지 imports 또는 브라우저 import maps에서의 별칭으로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래에서 각 패턴의 의미, 설정 지점, 주의사항을 정리함&lt;/p&gt;
&lt;h3 id=&#34;-경로의-두-가지-의미&#34;&gt;&amp;lsquo;@&amp;hellip;&amp;rsquo; 경로의 두 가지 의미&lt;/h3&gt;
&lt;h4 id=&#34;1-경로-별칭-path-alias&#34;&gt;1) 경로 별칭 path alias&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;의도: 길고 복잡한 상대 경로를 짧게 추상화&lt;/li&gt;
&lt;li&gt;설정 지점: tsconfig.json 의 compilerOptions.paths와 baseUrl&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;compilerOptions&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;baseUrl&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;./&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;paths&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;@models/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;src/models/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;#34;@utils/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;src/utils/*&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;@models/User&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; calculate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;@utils/math&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;상대 경로를 단순화, 가독성 및 리팩터링 내성 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주의
&lt;ul&gt;
&lt;li&gt;tsconfig paths는 타입 체크러와 에디터가 이해하는 별칭일 뿐, 런타임 해석자는 아님&lt;/li&gt;
&lt;li&gt;Node.js 런타임은 tsconfig paths를 모름. 번들러 설정별 alias 또는 전용 로더를 함께 구성 필요&lt;/li&gt;
&lt;li&gt;예: Vite, Webpack, ts-node, tsconfig-paths 등 도구별 설정 일치 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-스코프된-패키지-scoped-package&#34;&gt;2) 스코프된 패키지 scoped package&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;의미: npm 조직·팀·프로젝트 네임스페이스로 묶인 패키지 집합&lt;/li&gt;
&lt;li&gt;표기: @scope/package-name 형태
&lt;ul&gt;
&lt;li&gt;@nestjs/swagger, @angular/core 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사용 이유
&lt;ul&gt;
&lt;li&gt;네임스페이스로 이름 충돌 회피&lt;/li&gt;
&lt;li&gt;관련 패키지의 그룹화와 공개·비공개 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;설치&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;npm install @nestjs/swagger&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;해석
&lt;ul&gt;
&lt;li&gt;이 경우 &amp;lsquo;@&amp;lsquo;는 경로 별칭이 아닌 패키지 이름의 일부로 동작&lt;/li&gt;
&lt;li&gt;tsconfig paths와 무관. Node/npm가 패키지 이름으로 직접 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-상대절대-경로-import&#34;&gt;&amp;lsquo;&amp;hellip;&amp;rsquo; 상대·절대 경로 import&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상대 경로 &amp;lsquo;./&amp;rsquo;, &amp;lsquo;../&amp;rsquo; 기준으로 현재 파일 위치에서 탐색&lt;/li&gt;
&lt;li&gt;절대 경로 &amp;lsquo;/path&amp;rsquo;는 실행 환경마다 기준이 다름
&lt;ul&gt;
&lt;li&gt;브라우저 ESM에서는 오리진 기준 절대 URL 경로 해석&lt;/li&gt;
&lt;li&gt;Node.js에서는 파일 시스템 루트 절대 경로로 해석되어 이식성 낮음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;./models/User&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; calculate &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;../utils/math&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;추가 설정 없이 즉시 동작, 모든 환경 공통 동작 모델&lt;/li&gt;
&lt;li&gt;모듈 간 물리적 의존 관계가 드러남&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;디렉터리 깊어질수록 ../../../ 형태로 복잡도 상승&lt;/li&gt;
&lt;li&gt;구조 변경 시 경로 대량 수정 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-경로의-의미&#34;&gt;&amp;lsquo;#&amp;hellip;&amp;rsquo; 경로의 의미&lt;/h3&gt;
&lt;p&gt;&amp;lsquo;#{name}&amp;rsquo; 표기는 두 가지 서로 다른 맥락에서 등장함. 혼동 주의&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript readonly 이해와 사용법, 배열·객체 읽기 전용 타입 지정</title>
      <link>https://blog.jsontapose.com/posts/typescript-readonly-usage-immutable-arrays-objects-d79456/</link>
      <pubDate>Sun, 18 Jan 2026 13:10:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-readonly-usage-immutable-arrays-objects-d79456/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;readonly는 TypeScript 전용 타입 수정자이며 JavaScript 런타임에는 존재하지 않음
컴파일 타임에만 효력이 있으며, 읽기 전용으로 선언된 배열·객체 속성을 수정하려는 코드에 대해 타입 오류를 발생시킴&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;배열 또는 객체 속성의 변경 금지 의도를 타입 수준에서 명시
예를 들어 onChainResult: readonly bigint[]는 블록체인에서 읽어온 결과 배열이 이후 코드 흐름에서 변형되지 않음을 보장하려는 의도 표현
읽기 전용 제약은 타입 체크 시점에만 적용되며, 트랜스파일된 JavaScript에는 제약이 남지 않음&lt;/p&gt;
&lt;h3 id=&#34;동작과-제한&#34;&gt;동작과 제한&lt;/h3&gt;
&lt;p&gt;읽기 전용 배열은 변경 메서드가 제거된 ReadonlyArray 형태로 다뤄짐
객체의 readonly 속성은 재할당 금지, 단 객체 참조 자체는 다른 값으로 교체 가능할 수 있으므로 설계 시 구분 필요
타입 수준 readonly는 얕은 불변성에 해당하는 경우가 많음. 중첩된 구조까지 불변으로 보장하려면 계층별로 readonly를 적용하거나 별도 불변 모델을 설계해야 함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS 전역 예외 필터와 표준 오류 응답 설계 가이드</title>
      <link>https://blog.jsontapose.com/posts/nestjs-global-exception-filter-standard-error-response-81191e/</link>
      <pubDate>Fri, 16 Jan 2026 13:13:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-global-exception-filter-standard-error-response-81191e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API 에러 응답을 일관된 JSON 포맷으로 통일하고, 비즈니스 예외와 프레임워크 예외를 한 경로로 수집하는 전역 예외 필터 설계와 구현 정리
핵심은 표준 에러 코드 정의, AppError 기반의 명시적 예외 던지기, GlobalExceptionFilter에서의 단일 포맷 출력, ValidationPipe 결과의 구조화, traceId 기반 상관관계 추적&lt;/p&gt;
&lt;p&gt;요청 흐름 개요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청 진입 → ValidationPipe 검증&lt;/li&gt;
&lt;li&gt;검증 실패 → 전역 필터에서 표준 응답 변환&lt;/li&gt;
&lt;li&gt;검증 통과 → Controller/Service 실행&lt;/li&gt;
&lt;li&gt;비즈니스 로직 예외 → AppError 서브클래스 throw → 전역 필터 처리&lt;/li&gt;
&lt;li&gt;알 수 없는 예외 → 500으로 표준 응답 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;최종 응답 포맷은 단일 구조 유지&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS @Module 핵심 정리: imports, providers, exports, forRoot, Symbol 토큰, useFactory</title>
      <link>https://blog.jsontapose.com/posts/nestjs-module-imports-providers-exports-forroot-symbol-usefactory-025aae/</link>
      <pubDate>Sun, 11 Jan 2026 13:10:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-module-imports-providers-exports-forroot-symbol-usefactory-025aae/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS에서 @Module은 기능 단위 의존성을 묶는 단위이자 DI 경계를 정의하는 컨테이너 개념임
핵심은 imports로 외부 의존성 수입, providers로 내부 의존성 등록, exports로 외부 공개 대상을 결정하는 흐름 이해가 전부임&lt;/p&gt;
&lt;h3 id=&#34;module의-imports-providers-exports&#34;&gt;Module의 imports, providers, exports&lt;/h3&gt;
&lt;p&gt;@Module 선언의 기본 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@Module&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; imports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...],&lt;/span&gt; providers&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...],&lt;/span&gt; exports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[...]&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; SomeModule &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;providers
&lt;ul&gt;
&lt;li&gt;이 모듈에서 새로 생성해 DI 컨테이너에 등록할 대상 목록&lt;/li&gt;
&lt;li&gt;@Injectable 클래스들 중심 Service, Repository, Adapter 등&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;providers&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;BatchService&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; PortFetcher&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; StoreService&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; MergeService&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;imports
&lt;ul&gt;
&lt;li&gt;다른 모듈이 exports로 공개한 provider를 이 모듈에서 사용하겠다는 선언&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;imports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;RepositoryModule&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; HttpModule&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; LoggerModule&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;exports
&lt;ul&gt;
&lt;li&gt;이 모듈 바깥에서도 사용 가능하도록 내보낼 provider 목록&lt;/li&gt;
&lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;JSON_REPOSITORY&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; LogRepository&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;정리하면 providers는 내부 생성, imports는 외부 수입, exports는 외부 공개 대상 지정임&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript에서 type과 interface 차이와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/</link>
      <pubDate>Fri, 09 Jan 2026 13:14:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-type-vs-interface-b3670b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript에서 type과 interface는 겹치는 부분이 많지만 용도와 확장 방식이 다름
객체 구조 설계와 복잡한 타입 표현 중 무엇을 우선하느냐에 따라 선택 달라짐
핵심 차이 포인트 중심으로 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입 별칭 정의 수단&lt;/li&gt;
&lt;li&gt;기본 타입, 유니언, 튜플, 교차 타입 등 복합 표현에 유리&lt;/li&gt;
&lt;li&gt;선언 병합 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체의 구조 정의 수단&lt;/li&gt;
&lt;li&gt;확장과 선언 병합 지원&lt;/li&gt;
&lt;li&gt;주로 객체와 클래스와의 계약 정의에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// type 별칭 최소 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; ID &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Point &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Person &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// interface 최소 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;interface&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt; age: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;interface&lt;/span&gt; Employee &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;extends&lt;/span&gt; User &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; employeeId: &lt;span style=&#34;color:#81a1c1&#34;&gt;number&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;차이점과-동작&#34;&gt;차이점과 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;표현 범위&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Source of Truth(SSOT)의 의미와 적용 예시</title>
      <link>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</link>
      <pubDate>Fri, 02 Jan 2026 13:11:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함
핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함
원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 불일치 발생 위험 증가
&lt;ul&gt;
&lt;li&gt;위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유지보수 비용 급증
&lt;ul&gt;
&lt;li&gt;수정 시 흩어진 모든 복제본을 찾아 변경해야 함&lt;/li&gt;
&lt;li&gt;일부 누락 시 버그와 장애로 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 전파가 느림
&lt;ul&gt;
&lt;li&gt;캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실생활-비유&#34;&gt;실생활 비유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재
은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음&lt;/li&gt;
&lt;li&gt;스마트폰 연락처가 전화번호의 원본 역할을 수행
연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발-적용-예시&#34;&gt;개발 적용 예시&lt;/h3&gt;
&lt;h4 id=&#34;프론트엔드-상태-관리&#34;&gt;프론트엔드 상태 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리&lt;/li&gt;
&lt;li&gt;부모 변경이 자식에 반영되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;상위 컴포넌트 또는 중앙 스토어에만 userData 보관&lt;/li&gt;
&lt;li&gt;자식은 props나 selector로 읽기 전용 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터베이스-모델링&#34;&gt;데이터베이스 모델링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;회원 테이블에만 주소 저장&lt;/li&gt;
&lt;li&gt;주문 테이블은 회원 ID를 참조해 조인으로 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;타입-정의-공유typescript&#34;&gt;타입 정의 공유(TypeScript)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스와-주의&#34;&gt;베스트 프랙티스와 주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 경로 단일화
&lt;ul&gt;
&lt;li&gt;원본에 대한 쓰기는 반드시 한 경로로만 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 복제본과 캐시 관리
&lt;ul&gt;
&lt;li&gt;캐시는 파생물로 취급&lt;/li&gt;
&lt;li&gt;만료 정책, 동기화 주기, 재검증 전략을 명시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;식별자 기반 참조 우선
&lt;ul&gt;
&lt;li&gt;파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양방향 복제와 수동 동기화 지양
&lt;ul&gt;
&lt;li&gt;충돌 해결 복잡도와 데이터 드리프트 위험 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마이그레이션 단계 관리
&lt;ul&gt;
&lt;li&gt;이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;p&gt;원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부
이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음
프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript 객체 구조 분해 할당으로 프로퍼티 이름 변경하기</title>
      <link>https://blog.jsontapose.com/posts/typescript-object-destructuring-rename-property-ba20ff/</link>
      <pubDate>Tue, 30 Dec 2025 13:13:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-object-destructuring-rename-property-ba20ff/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;객체 구조 분해 할당에서 프로퍼티 이름을 바꾸는 기본형은 { 기존프로퍼티명: 새변수명 } 형태임&lt;/p&gt;
&lt;h3 id=&#34;사용법예시&#34;&gt;사용법/예시&lt;/h3&gt;
&lt;p&gt;아래는 request 프로퍼티를 revealRequest라는 이름으로 받는 예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; request: &lt;span style=&#34;color:#81a1c1&#34;&gt;revealRequest&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; client&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;doSomething&lt;span style=&#34;color:#eceff4&#34;&gt;({...})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;의미는 다음과 같음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;doSomething이 반환하는 객체에서 request 프로퍼티 추출&lt;/li&gt;
&lt;li&gt;추출한 값을 revealRequest 변수에 바인딩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래 전개 코드와 동일함&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; result &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; client&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;doSomething&lt;span style=&#34;color:#eceff4&#34;&gt;({...})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; revealRequest &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; result&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;왜-쓰는가&#34;&gt;왜 쓰는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드 간결화&lt;/li&gt;
&lt;li&gt;필요한 프로퍼티만 선택 추출&lt;/li&gt;
&lt;li&gt;문맥에 맞게 변수명 명확화, 의도 드러남&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Observer 패턴 제대로 이해하기 — 동작 원리와 RxJS 확장</title>
      <link>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</link>
      <pubDate>Sun, 28 Dec 2025 13:10:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름
발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름
핵심은 느슨한 결합과 자동 알림 흐름 유지&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-구성요소&#34;&gt;핵심 개념과 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Subject 또는 Observable
&lt;ul&gt;
&lt;li&gt;이벤트를 발생시키는 주체&lt;/li&gt;
&lt;li&gt;Observer 목록을 관리&lt;/li&gt;
&lt;li&gt;상태가 변하면 observers에 알림 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer
&lt;ul&gt;
&lt;li&gt;상태 변화를 알고 싶은 소비자&lt;/li&gt;
&lt;li&gt;update 같은 콜백 보유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;notify
&lt;ul&gt;
&lt;li&gt;Subject가 모든 Observer에게 브로드캐스트하는 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Observer가 Subject에 구독 등록&lt;/li&gt;
&lt;li&gt;Subject 상태 변화 발생&lt;/li&gt;
&lt;li&gt;Subject가 notify 실행, 등록된 Observer의 콜백 호출&lt;/li&gt;
&lt;li&gt;Observer는 전달된 값에 따라 자체 로직 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필수 인터페이스의 최소 형태는 아래와 같음&lt;/p&gt;</description>
    </item>
    <item>
      <title>Object.entries 사용법과 주의사항</title>
      <link>https://blog.jsontapose.com/posts/object-entries-usage-and-notes-329c74/</link>
      <pubDate>Sat, 27 Dec 2025 13:09:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/object-entries-usage-and-notes-329c74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Object.entries는 객체의 키-값 쌍을 [key, value] 형태의 배열 리스트로 반환하는 표준 메서드임. 객체를 배열로 바꿔 순회, 변환, 자료구조 간 변환 같은 작업을 단순화하는 데 유용함&lt;/p&gt;
&lt;h3 id=&#34;문법&#34;&gt;문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;entries&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;obj&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;매개변수 obj: 키-값 쌍을 가진 객체 값&lt;/li&gt;
&lt;li&gt;반환값: [key, value] 쌍의 2차원 배열&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;기본-예시&#34;&gt;기본 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; user &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; name&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; age&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;25&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;entries&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// [[&amp;#39;name&amp;#39;, &amp;#39;Alice&amp;#39;], [&amp;#39;age&amp;#39;, 25]]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;배열로 변환되므로 for&amp;hellip;of, map 같은 배열 API에 바로 연결 가능&lt;/p&gt;
&lt;h3 id=&#34;순회와-변환&#34;&gt;순회와 변환&lt;/h3&gt;
&lt;p&gt;for&amp;hellip;of로 키와 값을 동시에 순회 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>API ErrorCode Enum 설계 베스트 프랙티스</title>
      <link>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</link>
      <pubDate>Thu, 25 Dec 2025 13:11:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API 에러 규격의 핵심은 에러를 안정적으로 식별할 수 있는 Code 체계 확보임
HTTP Status만으로는 부족하고 메시지는 언어·맥락에 따라 바뀔 수 있음
실제로 계약으로서 신뢰할 수 있는 값은 error.code 임
아래는 다수의 글로벌 서비스에서 공통적으로 쓰는 Error Code 설계 원칙 정리&lt;/p&gt;
&lt;h3 id=&#34;설계-원칙&#34;&gt;설계 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;error.code 는 서비스 전반의 안정적인 식별자여야 함&lt;/li&gt;
&lt;li&gt;메시지나 HTTP Status는 변경 가능하지만 error.code 는 변경 불가&lt;/li&gt;
&lt;li&gt;구버전 클라이언트도 동일 코드를 신뢰해야 하므로 호환성 보장 필수&lt;/li&gt;
&lt;li&gt;숫자형 대신 의미가 드러나는 문자열 기반 Enum 권장
&lt;ul&gt;
&lt;li&gt;숫자형은 의미 파악 어려움, 매뉴얼 의존, 협업 비용 증가&lt;/li&gt;
&lt;li&gt;문자열 Enum은 가독성, 검색성, 커뮤니케이션 효율 우수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS 핵심 개념과 11.x 변화 정리 — 구조, DI, 데코레이터, 성능 업데이트</title>
      <link>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</link>
      <pubDate>Fri, 19 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS는 대규모 서버 애플리케이션을 위한 구조화된 Node.js 프레임워크임
핵심은 Angular 스타일의 아키텍처, 강력한 의존성 주입 컨테이너, 데코레이터 기반 메타프로그래밍 조합
팀 규모가 커질수록 일관성과 유지보수성이 살아나는 타입스크립트 퍼스트 선택지임&lt;/p&gt;
&lt;h3 id=&#34;구조적-강제의-이점&#34;&gt;구조적 강제의 이점&lt;/h3&gt;
&lt;p&gt;Nest는 모듈 Module, 컨트롤러 Controller, 서비스 Service 구조를 강제함
계층 분리 패턴 BLL, DAL, 도메인 레이어 등 적용 용이
아키텍처가 일관되게 유지되어 4~10명 규모 팀에서 코드 스타일과 책임 경계가 흐트러지지 않음&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fastify, Express 같은 미니멀 프레임워크 대비 생산성과 일관성 측면에서 팀 단위 효율 우위&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 모듈 시스템 정리: CommonJS와 ESM의 차이, 선택 기준, 상호 운용</title>
      <link>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</link>
      <pubDate>Tue, 16 Dec 2025 13:14:04 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 CommonJS(CJS)와 ESM(ES Modules)은 공존 상태이며, 신규 프로젝트는 ESM으로 전환되는 추세임. 두 시스템의 차이를 이해하면 번들 크기, 로딩 성능, 정적 분석, 생태계 호환에서 불필요한 시행착오 감소 가능&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2009년 Node.js는 표준 모듈 시스템이 없던 시기라 CommonJS 채택&lt;/li&gt;
&lt;li&gt;2015년 ES6에서 ESM이 언어 차원의 공식 표준으로 확정&lt;/li&gt;
&lt;li&gt;2020년대 들어 Node.js가 ESM을 정식 지원, 브라우저와 규약 수렴 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commonjs-요약&#34;&gt;CommonJS 요약&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// export
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;module&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;exports &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exports&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;bar &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// import
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; bar &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; require&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;./utils&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;특성&lt;/p&gt;</description>
    </item>
    <item>
      <title>전략 패턴 (Strategy Pattern) - 유연한 코드 만들기</title>
      <link>https://blog.jsontapose.com/posts/strategy-pattern-with-typescript-mermaid-6618f4/</link>
      <pubDate>Sat, 06 Dec 2025 13:08:38 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/strategy-pattern-with-typescript-mermaid-6618f4/</guid>
      <description>&lt;h3 id=&#34;전략-패턴이란&#34;&gt;전략 패턴이란?&lt;/h3&gt;
&lt;p&gt;객체의 특정 행동(알고리즘)을 직접 구현하지 않고, &lt;strong&gt;외부에서 &amp;lsquo;전략&amp;rsquo;을 주입받아 갈아 끼우는 방식&lt;/strong&gt;임&lt;/p&gt;
&lt;p&gt;쉽게 말해 &amp;ldquo;본체는 그대로 두고, 부품만 바꿔서 기능을 바꾸는 것&amp;quot;이라 보면 됨&lt;/p&gt;
&lt;h3 id=&#34;전략-패턴이-적용되지-않은-코드&#34;&gt;전략 패턴이 적용되지 않은 코드&lt;/h3&gt;
&lt;p&gt;전략 패턴을 쓰지 않으면 보통 이렇게 구현하게 됨&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; Vehicle &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;constructor&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;road&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;rail&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  move() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;road&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;부릉부릉 도로로 감 🚌&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;rail&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;칙칙폭폭 선로로 감 🚂&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 방식이 가지는 문제는 다음과 같음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;조건문이 계속 늘어남
새로운 이동 방식이 생길 때마다 move()를 수정해야 함
→ OCP(Open-Closed Principle) 위반&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript Record 제대로 이해하기 — 인덱스 시그니처와 맵드 타입 비교, 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-record-mapped-type-index-signature-d67f80/</link>
      <pubDate>Tue, 02 Dec 2025 13:13:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-record-mapped-type-index-signature-d67f80/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Record&amp;lt;Key, Value&amp;gt;는 키와 값 타입을 고정해 객체 형태를 만드는 타입스크립트 유틸리티 타입임
인덱스 시그니처와 유사하지만 문자열 리터럴 유니온을 키로 직접 사용할 수 있고, 맵드 타입으로도 같은 효과를 낼 수 있음&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Record&amp;lt;Key, Value&amp;gt;
&lt;ul&gt;
&lt;li&gt;키 타입 Key, 값 타입 Value를 갖는 객체 타입 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;인덱스 시그니처와의 차이
&lt;ul&gt;
&lt;li&gt;[key: string]: T 형태는 키 집합을 특정 리터럴 유니온으로 제한 불가&lt;/li&gt;
&lt;li&gt;Record는 &amp;lsquo;A&amp;rsquo; | &amp;lsquo;B&amp;rsquo; 같은 리터럴 유니온을 키로 직접 지정 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;맵드 타입과의 관계
&lt;ul&gt;
&lt;li&gt;{ [K in Keys]: V }와 Record&amp;lt;Keys, V&amp;gt;는 구조적으로 동일한 결과를 만들 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 스니펫&lt;/p&gt;</description>
    </item>
    <item>
      <title>스프레드 연산자로 배열 요소와 객체 속성 조건부 추가</title>
      <link>https://blog.jsontapose.com/posts/conditional-add-with-spread-array-object-940699/</link>
      <pubDate>Mon, 01 Dec 2025 13:13:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/conditional-add-with-spread-array-object-940699/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;리터럴 선언 시 조건에 따라 요소나 속성을 넣었다 뺄 수 있는 패턴 정리
분기문 없이 스프레드 연산자만으로 가독성 유지&lt;/p&gt;
&lt;h3 id=&#34;사용법예시&#34;&gt;사용법/예시&lt;/h3&gt;
&lt;p&gt;배열은 피연산자가 이터러블이어야 하므로 삼항 연산자 사용&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; arr &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...(&lt;/span&gt;cond &lt;span style=&#34;color:#81a1c1&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === true =&amp;gt; [1, 2, 3, 4, 5, 6]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === false =&amp;gt; [4, 5, 6]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체는 원시값을 스프레드해도 자체 속성이 없어 무시됨
불리언화로 안전성 확보&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; obj &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;!!&lt;/span&gt;cond &lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; a&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; b&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  d&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === true =&amp;gt; { a: 1, b: 2, c: 3, d: 4 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// cond === false =&amp;gt; { c: 3, d: 4 }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주의-사항&#34;&gt;주의 사항&lt;/h3&gt;
&lt;p&gt;배열에서 &amp;hellip;(cond &amp;amp;&amp;amp; [1,2,3]) 사용 금지, cond가 false면 이터러블 아님 오류 발생
객체에서 null이나 undefined를 그대로 스프레드하면 오류 가능, !!cond로 불리언화하거나 cond ? {..} : {} 형태 권장
타입스크립트에서는 &amp;amp;&amp;amp; 패턴이 타입 좁히기 미흡할 수 있음, 삼항으로 빈 객체 반환 또는 적절한 타입 주석 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Promise.all과 Map 정리 – 동시 비동기 처리와 키-값 컬렉션 기본</title>
      <link>https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/</link>
      <pubDate>Fri, 21 Nov 2025 13:09:50 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-promise-all-and-map-d2295e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;여러 비동기 작업을 한 번에 묶어 처리하거나 결과를 모아야 하는 경우가 잦음
키-값 기반으로 데이터를 구조화해 저장하고 순회해야 하는 요구도 흔함
이 글은 Promise.all의 동작과 주의점, Map의 핵심 사용법을 개발자 관점에서 요약 정리함&lt;/p&gt;
&lt;h3 id=&#34;promiseall-개념과-정의&#34;&gt;Promise.all 개념과 정의&lt;/h3&gt;
&lt;p&gt;여러 Promise를 단일 Promise로 집계하는 유틸리티
모든 입력이 이행되면 결과를 같은 순서의 배열로 반환
하나라도 거부되면 즉시 거부로 끝나는 fail fast 특성 보유
입력은 Promise와 값 혼합 가능하며 값은 내부적으로 Promise.resolve로 이행 처리됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma where 관계 필터 some vs every 동작 차이와 주의점</title>
      <link>https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/</link>
      <pubDate>Mon, 17 Nov 2025 13:11:31 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-some-vs-every-relationship-filter-dcd175/</guid>
      <description>&lt;p&gt;관계형 데이터에서 Prisma의 where 절은 자식 레코드 기준으로 부모를 거르는 필터를 제공함. 특히 some과 every는 겉보기엔 비슷하지만 결과 집합을 크게 바꾸는 핵심 차이가 있음. 단일 필드만으로 필터링해도 동일하지 않을 수 있어 주의 필요&lt;/p&gt;
&lt;h3 id=&#34;개념&#34;&gt;개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;some
&lt;ul&gt;
&lt;li&gt;관계된 레코드 중 적어도 하나가 조건을 만족하면 부모 포함&lt;/li&gt;
&lt;li&gt;존재성 검사에 해당, 하나라도 매칭되면 true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;every
&lt;ul&gt;
&lt;li&gt;모든 관계된 레코드가 조건을 만족해야 부모 포함&lt;/li&gt;
&lt;li&gt;단 하나라도 위배되면 제외됨&lt;/li&gt;
&lt;li&gt;관계된 레코드가 하나도 없으면 vacuously true로 간주되어 조건 만족으로 처리됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;some은 존재량화, every는 전칭량화에 해당함&lt;/li&gt;
&lt;li&gt;차이는 자식 레코드가 0개이거나 2개 이상일 때 두드러짐. 1개일 때는 조건이 동일하다면 결과가 같아질 수 있음&lt;/li&gt;
&lt;li&gt;특히 자식이 없는 경우 every는 기본적으로 참으로 평가되어 부모가 포함됨. 빈 결과를 제외하려면 추가 조건 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;model Post {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  id       Int       @id @default(autoincrement())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  title    String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  comments Comment[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;model Comment {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  id     Int    @id @default(autoincrement())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  text   String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  postId Int
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  post   Post   @relation(fields: [postId], references: [id])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;댓글 text가 &amp;lsquo;interesting&amp;rsquo;인 항목을 기준으로 게시글을 거르는 케이스를 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>커링과 부분 적용 이해하기: 함수형 자바스크립트 핵심 패턴</title>
      <link>https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/</link>
      <pubDate>Thu, 13 Nov 2025 13:11:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/currying-and-partial-application-e5bae4/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;커링 Currying은 여러 개의 인자를 받는 함수를 단일 인자 함수들의 연속으로 변환하는 기법
n개의 인자를 받는 함수 → n번에 걸쳐 한 개 인자씩 받는 함수 체인으로 분해
함수형 프로그래밍 맥락에서 재사용성과 조합성 향상 목적&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;커링 currying: f(a, b, c) 형태를 f(a)(b)(c)로 바꾸는 변환&lt;/li&gt;
&lt;li&gt;부분 적용 partial application: 전체 인자 중 일부를 고정해 새로운 함수를 만드는 기법&lt;/li&gt;
&lt;li&gt;관계: 커링된 함수는 부분 적용을 자연스럽게 지원함&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;동작-원리와-간단-예시&#34;&gt;동작 원리와 간단 예시&lt;/h3&gt;
&lt;p&gt;일반 함수&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findUnique에서 where와 include 제대로 쓰기</title>
      <link>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</link>
      <pubDate>Wed, 12 Nov 2025 13:12:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;findUnique&lt;/code&gt;로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 &lt;code&gt;where&lt;/code&gt;와 &lt;code&gt;include&lt;/code&gt;를 어떻게 조합해야 하는지 정리함
관계 필터링을 &lt;code&gt;where&lt;/code&gt;에 넣을 수 있는지, &lt;code&gt;include&lt;/code&gt;에서 필터가 가능한지 헷갈리기 쉬운 지점 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;는 유니크 키로 정확히 &lt;strong&gt;하나&lt;/strong&gt;의 레코드를 찾는 용도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;의 &lt;code&gt;where&lt;/code&gt;는 &lt;strong&gt;유니크 필드만&lt;/strong&gt; 허용됨, 관계 필터나 일반 조건 결합 불가&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;to-many 관계&lt;/strong&gt;에 한해 &lt;code&gt;include&lt;/code&gt; 내부에서 &lt;code&gt;where&lt;/code&gt; 사용 가능, to-one 관계는 &lt;code&gt;where&lt;/code&gt; 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where-사용-패턴&#34;&gt;where 사용 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;잘못된 예시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// findUnique에 관계 필터 결합 시도 → 타입 에러
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// (User(1) → Post(N) → Metadata(1) 관계)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;posts&amp;#39;는 유니크 필드가 아니므로 &amp;#39;where&amp;#39;에서 관계 필터링 불가
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;올바른 최소 조건&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;id&amp;#39;는 유니크 필드
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;관계 조건이 필요하면 findFirst 또는 findMany 사용&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;findUnique&amp;#39;가 아닌 &amp;#39;findFirst&amp;#39;를 사용하면
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;where&amp;#39;에 관계 필터를 포함할 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findFirst&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;요약하면 &lt;code&gt;findUnique&lt;/code&gt;에는 유니크 조건만, 관계 기반 필터는 &lt;code&gt;findFirst&lt;/code&gt; 또는 &lt;code&gt;findMany&lt;/code&gt;로 처리함&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript Parameters 유틸리티 타입 개념과 안전한 활용</title>
      <link>https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/</link>
      <pubDate>Sat, 01 Nov 2025 13:06:40 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-parameters-utility-type-913b5f/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Parameters는 TypeScript가 제공하는 제네릭 유틸리티 타입으로, 특정 함수 타입의 매개변수 타입들을 튜플로 추출하는 데 사용됨
함수 래핑, 고차 함수, 어댑터 계층에서 기존 함수 시그니처를 재사용해 타입 안정성을 유지하고 중복 선언을 줄이는 목적에 적합함&lt;/p&gt;
&lt;h3 id=&#34;문법&#34;&gt;문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;type&lt;/span&gt; Parameters&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#8fbcbb&#34;&gt;...args&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#8fbcbb&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#bf616a&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#bf616a&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; T &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;...&lt;/span&gt;args: &lt;span style=&#34;color:#81a1c1&#34;&gt;infer&lt;/span&gt; P
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;any&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1&#34;&gt;?&lt;/span&gt; P
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  : &lt;span style=&#34;color:#81a1c1&#34;&gt;never&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;T가 함수 타입이면 매개변수 목록을 튜플 타입 P로 추출&lt;/li&gt;
&lt;li&gt;T가 함수 타입이 아니면 never 반환&lt;/li&gt;
&lt;li&gt;추출 결과는 튜플이므로 인덱스 접근, 스프레드, 부분 적용 등 튜플 연산과 조합 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;기본 추출&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법</title>
      <link>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</link>
      <pubDate>Thu, 30 Oct 2025 13:11:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임
DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함
핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임&lt;/p&gt;
&lt;h3 id=&#34;apiproperty-개념과-사용&#34;&gt;ApiProperty 개념과 사용&lt;/h3&gt;
&lt;p&gt;@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임
타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공
코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함&lt;/p&gt;
&lt;p&gt;간단 사용 예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; CreateUserDto &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@ApiProperty&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; description&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;사용자 이름&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; example&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미</title>
      <link>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</link>
      <pubDate>Wed, 29 Oct 2025 13:11:51 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함
skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함&lt;/p&gt;
&lt;h3 id=&#34;핵심-동작&#34;&gt;핵심 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cursor는 그 지점부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 100부터 시작해 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;skip: 1은 cursor에 해당하는 레코드를 건너뜀&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  skip: &lt;span style=&#34;color:#81a1c1&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 101부터 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;예시로-보는-차이&#34;&gt;예시로 보는 차이&lt;/h3&gt;
&lt;p&gt;데이터가 아래와 같다고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자</title>
      <link>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</link>
      <pubDate>Tue, 28 Oct 2025 13:10:28 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma의 findMany는 다중 레코드 조회용 메서드
기본값은 대상 모델의 모든 레코드 반환
where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원
옵션 조합으로 조건 기반 조회를 간결하게 구성 가능&lt;/p&gt;
&lt;h3 id=&#34;기본-사용법&#34;&gt;기본 사용법&lt;/h3&gt;
&lt;p&gt;가장 단순한 호출 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; users &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주요-옵션&#34;&gt;주요 옵션&lt;/h3&gt;
&lt;p&gt;옵션은 필요한 것만 선택적으로 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where: 조건 필터링&lt;/li&gt;
&lt;li&gt;select: 필드 서브셋 선택&lt;/li&gt;
&lt;li&gt;include: 관계 데이터 로드&lt;/li&gt;
&lt;li&gt;orderBy: 정렬 기준 지정&lt;/li&gt;
&lt;li&gt;skip, take: 오프셋 기반 페이징&lt;/li&gt;
&lt;li&gt;distinct: 특정 필드 기준 중복 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where로-조건-필터링&#34;&gt;where로 조건 필터링&lt;/h3&gt;
&lt;p&gt;단일 조건부터 복합 조건까지 표현 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>TypeScript enum, const enum, as const 차이와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/</link>
      <pubDate>Tue, 21 Oct 2025 13:12:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/typescript-enum-const-enum-as-const-3817af/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;TypeScript에서 enum, const enum, as const는 값 집합을 선언하고 타입으로 활용하기 위한 서로 다른 도구임
각 특성의 차이와 트레이드오프를 이해하면 가독성과 안정성을 챙기면서 번들 크기와 도구 호환성 문제도 피할 수 있음&lt;/p&gt;
&lt;h3 id=&#34;enum-개념과-동작&#34;&gt;enum 개념과 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;열거형 타입을 선언하는 문법&lt;/li&gt;
&lt;li&gt;숫자 기반과 문자열 기반 모두 지원&lt;/li&gt;
&lt;li&gt;컴파일 결과로 양방향 매핑을 담은 JS 객체 생성
&lt;ul&gt;
&lt;li&gt;키로 값 조회, 값으로 키 역조회 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;enum&lt;/span&gt; BooleanType &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  False &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  True &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;컴파일 결과는 즉시실행함수 형태로 양방향 맵 객체 생성됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
    <item>
      <title>Viem으로 이더리움 읽기·쓰기 시작하기 가이드</title>
      <link>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</link>
      <pubDate>Thu, 02 Oct 2025 13:07:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임
ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음
프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Public Client&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트&lt;/li&gt;
&lt;li&gt;블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wallet Client&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
