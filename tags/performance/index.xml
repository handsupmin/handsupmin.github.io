<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Performance on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/performance/</link>
    <description>Recent content in Performance on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 26 Dec 2025 13:12:06 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴</title>
      <link>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</link>
      <pubDate>Fri, 26 Dec 2025 13:12:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함
직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함&lt;/p&gt;
&lt;h3 id=&#34;왜-중요한가&#34;&gt;왜 중요한가&lt;/h3&gt;
&lt;p&gt;처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자 1000 req/s, 소비자 100 req/s 가정&lt;/li&gt;
&lt;li&gt;매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험&lt;/li&gt;
&lt;li&gt;큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능
백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Producer: 데이터를 생성·전송하는 주체&lt;/li&gt;
&lt;li&gt;Consumer: 데이터를 수신·처리하는 주체&lt;/li&gt;
&lt;li&gt;Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위&lt;/li&gt;
&lt;li&gt;전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리전략&#34;&gt;동작 원리/전략&lt;/h3&gt;
&lt;p&gt;A. 조절 Control/Throttling&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript에서 객체 대신 Map/Set을 선택해야 하는 경우와 이유</title>
      <link>https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/</link>
      <pubDate>Sun, 21 Dec 2025 13:09:33 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/use-maps-and-sets-instead-of-objects-3cd24d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;객체는 만능처럼 보이지만 모든 키-값 저장에 적합한 도구는 아님
키를 자주 추가·삭제하고 임의 키로 조회하는 해시맵 유사 패턴에서는 Map이 더 안전하고 일관된 성능을 제공함
중복 없는 집합 연산에는 Set이 자연스러운 선택지&lt;/p&gt;
&lt;h3 id=&#34;언제-객체-대신-map을-고려할까&#34;&gt;언제 객체 대신 Map을 고려할까&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;키를 자주 추가·삭제하는 동적 해시맵 패턴&lt;/li&gt;
&lt;li&gt;안전한 반복과 구조 분해가 필요한 경우&lt;/li&gt;
&lt;li&gt;키의 삽입 순서 유지가 중요한 경우&lt;/li&gt;
&lt;li&gt;비문자열 키가 필요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 객체 기반 임의 키-값 해시맵 패턴은 delete에서 성능 불리할 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; mapOfThingsObj &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThingsObj&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; thing&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt; mapOfThingsObj&lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// Map은 동적 추가·삭제에 최적화
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; mapOfThings &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; Map&lt;span style=&#34;color:#eceff4&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThings&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; thing&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mapOfThings&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;delete&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;thing&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;id&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;성능-배경&#34;&gt;성능 배경&lt;/h3&gt;
&lt;p&gt;객체는 VM이 숨은 클래스/셰이프를 가정해 최적화하는 경향이 있어 구조가 변동하면 디옵티마이즈 유발 가능성 존재
Map은 해시맵 사용에 맞춰 키 추가·삭제가 빈번한 경우를 목표로 설계됨
마이크로벤치마크는 한계가 있으므로 실제 워크로드에서 측정 권장, 다만 Map이 해당 패턴에 맞춰 설계된 점은 문서로 확인 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</link>
      <pubDate>Fri, 31 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 &lt;strong&gt;메모리에 캐싱&lt;/strong&gt;하는 영역임
디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임
InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 &lt;strong&gt;심장부&lt;/strong&gt;라 할 수 있음&lt;/p&gt;
&lt;p&gt;쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;버퍼-풀-구성-요소&#34;&gt;버퍼 풀 구성 요소&lt;/h2&gt;
&lt;p&gt;버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터 페이지&lt;/strong&gt;: 실제 테이블 로우(Row)가 저장된 페이지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인덱스 페이지&lt;/strong&gt;: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기타 관리 페이지&lt;/strong&gt;: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;페이지-캐싱&#34;&gt;페이지 캐싱&lt;/h3&gt;
&lt;p&gt;InnoDB는 디스크 데이터를 페이지 단위로 다룸
클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 &lt;strong&gt;페이지 전체&lt;/strong&gt;를 버퍼 풀로 가져옴
이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
