<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ZKP on HandsLog</title><link>https://handsupmin.github.io/tags/zkp/</link><description>Recent content in ZKP on HandsLog</description><generator>Hugo -- 0.146.0</generator><language>ko-kr</language><lastBuildDate>Sun, 21 Sep 2025 02:33:25 +0000</lastBuildDate><atom:link href="https://handsupmin.github.io/tags/zkp/index.xml" rel="self" type="application/rss+xml"/><item><title>재귀적 영지식 증명이란?(Recursion ZKP)</title><link>https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/</link><pubDate>Sun, 21 Sep 2025 02:33:25 +0000</pubDate><guid>https://handsupmin.github.io/posts/recursion-zkp-basics-274b74/</guid><description>&lt;h2 id="개요">개요&lt;/h2>
&lt;ul>
&lt;li>재귀적 영지식 증명(Recursion ZKP) = 여러 개의 ZK 증명을 &lt;strong>계층적으로 합성&lt;/strong>해 &lt;strong>단일 증명&lt;/strong>으로 만드는 기법임.&lt;/li>
&lt;li>목적: 온체인(예: L1)에서 &lt;strong>검증 횟수/비용을 줄임&lt;/strong>. L2에서 생성한 다수의 증명을 하나로 압축해 검증 가스 절감 효과 얻음.&lt;/li>
&lt;/ul>
&lt;h2 id="왜-필요한가">왜 필요한가&lt;/h2>
&lt;ul>
&lt;li>단일 트랜잭션마다 증명 검증하면 &lt;strong>검증 비용이 선형 증가&lt;/strong>함.&lt;/li>
&lt;li>재귀를 쓰면 n개의 증명을 &lt;strong>로그/계층 구조&lt;/strong>로 합쳐 &lt;strong>한 번만 검증&lt;/strong>하면 됨.&lt;/li>
&lt;li>롤업/배치 처리/프라이버시 워크로드에서 &lt;strong>확장성&lt;/strong> 확보에 유리함.&lt;/li>
&lt;/ul>
&lt;h2 id="핵심-개념">핵심 개념&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>내부 증명(Inner proofs)&lt;/strong>: 원래 명제(트랜잭션, 상태 전이 등)에 대한 개별 ZK 증명들.&lt;/li>
&lt;li>&lt;strong>합성 회로/Aggregator&lt;/strong>: 이전 단계의 증명들을 &lt;strong>검증하는 로직을 포함&lt;/strong>한 회로. 이 회로 자체의 “검증이 성공했다”는 사실을 또 다른 증명으로 만듦.&lt;/li>
&lt;li>&lt;strong>최종 증명(Outer proof)&lt;/strong>: 여러 단계를 거쳐 &lt;strong>하나&lt;/strong>로 압축된 증명. 온체인은 이 증명만 확인하면 전체 유효성 보장됨.&lt;/li>
&lt;li>&lt;strong>공개 입력 바인딩(Public input binding)&lt;/strong>: 어떤 증명들을 합쳤는지(루트 커밋, 상태 요약 등)를 공개 입력에 포함해 &lt;strong>무결성&lt;/strong> 보장함.&lt;/li>
&lt;/ul>
&lt;h2 id="동작-흐름">동작 흐름&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>개별 증명 생성&lt;/strong>: L2에서 트랜잭션/배치 단위로 증명들 생성함.&lt;/li>
&lt;li>&lt;strong>1차 합성&lt;/strong>: 합성 회로가 증명 A·B를 &lt;strong>내부에서 검증&lt;/strong> → “A와 B 모두 올바름”을 나타내는 &lt;strong>새 증명&lt;/strong> 생성.&lt;/li>
&lt;li>&lt;strong>반복 합성&lt;/strong>: 위 출력을 쌍으로 다시 합성(트리 구조) → 증명 수를 절반씩 줄임.&lt;/li>
&lt;li>&lt;strong>최종 합성&lt;/strong>: 최종 1개 증명 도출.&lt;/li>
&lt;li>&lt;strong>온체인 검증&lt;/strong>: L1은 &lt;strong>최종 증명 1개만&lt;/strong> 검증 → 전체 집합이 유효하다는 결론에 도달.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>직관: “증명을 검증하는 회로”에 대해 다시 증명을 만든다고 생각하면 됨. 그래서 ‘재귀’라 부름.&lt;/p></description></item></channel></rss>