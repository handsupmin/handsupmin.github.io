<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Reduce on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/reduce/</link>
    <description>Recent content in Reduce on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 08 Feb 2026 13:16:54 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/reduce/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript Array.prototype.reduce 개념과 안전한 활용 가이드</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-reduce-guide-677e4e/</link>
      <pubDate>Sun, 08 Feb 2026 13:16:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-reduce-guide-677e4e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Array.prototype.reduce는 배열을 하나의 값으로 축약하는 표준 API
배열의 각 요소에 대해 리듀서 함수를 순차 실행하고 누산기 값을 반환
집계, 변환, 그룹핑, 파이프라인 구성 등 다양한 패턴에 사용&lt;/p&gt;
&lt;h3 id=&#34;구문&#34;&gt;구문&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;arr.reduce(callback[, initialValue])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;callback에 누산 로직 정의&lt;/li&gt;
&lt;li&gt;initialValue가 있으면 누산기의 시작값으로 사용, 없으면 배열의 첫 요소가 시작값&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;매개변수&#34;&gt;매개변수&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;callback(accumulator, currentValue, currentIndex, array)
&lt;ul&gt;
&lt;li&gt;accumulator: 누산된 값&lt;/li&gt;
&lt;li&gt;currentValue: 현재 요소 값&lt;/li&gt;
&lt;li&gt;currentIndex: 현재 인덱스&lt;/li&gt;
&lt;li&gt;array: 원본 배열&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;initialValue (옵션)
&lt;ul&gt;
&lt;li&gt;누산기의 초기값&lt;/li&gt;
&lt;li&gt;제공하지 않으면 배열 첫 요소가 초기값이 되어 콜백은 두 번째 요소부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;반환값&#34;&gt;반환값&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;축약 결과로 얻은 최종 누산값&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽에서 오른쪽으로 순회하며 callback을 한 번씩 호출&lt;/li&gt;
&lt;li&gt;initialValue 미제공
&lt;ul&gt;
&lt;li&gt;빈 배열이면 TypeError 발생&lt;/li&gt;
&lt;li&gt;요소가 하나뿐이면 그 요소를 그대로 반환하며 callback은 호출되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;initialValue 제공
&lt;ul&gt;
&lt;li&gt;배열이 비어 있어도 initialValue를 그대로 반환하며 callback은 호출되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;희소 배열의 빈 슬롯은 건너뜀&lt;/li&gt;
&lt;li&gt;누산기는 어떤 타입도 가능하며 객체, 맵, 프라미스 등으로 확장 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의-사항과-베스트-프랙티스&#34;&gt;주의 사항과 베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가능한 항상 initialValue 지정 권장
&lt;ul&gt;
&lt;li&gt;빈 배열 입력 시 예외 방지, 타입 안정성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;누산기 불변성 유지 권장
&lt;ul&gt;
&lt;li&gt;객체 누산 시 얕은 복사 또는 구조 분해 사용 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;콜백은 순수 함수 지향
&lt;ul&gt;
&lt;li&gt;외부 상태 변경 최소화, 테스트 용이성 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 어려운 과도한 축약 로직은 map, filter, for&amp;hellip;of 등으로 분리 고려&lt;/li&gt;
&lt;li&gt;희소 배열에서 빈 슬롯은 콜백이 호출되지 않음에 유의&lt;/li&gt;
&lt;li&gt;오른쪽에서 왼쪽으로 처리해야 하면 reduceRight 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;합계 계산&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
