<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Query-Optimization on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/query-optimization/</link>
    <description>Recent content in Query-Optimization on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 14 Dec 2025 13:09:03 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/query-optimization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</link>
      <pubDate>Sun, 14 Dec 2025 13:09:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Primary Key 지정 시 클러스터드 인덱스 생성&lt;/li&gt;
&lt;li&gt;Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념-정리&#34;&gt;핵심 개념 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;클러스터드 인덱스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 데이터가 인덱스 키 순서로 정리되는 구조&lt;/li&gt;
&lt;li&gt;테이블당 하나만 존재&lt;/li&gt;
&lt;li&gt;리프 노드가 실제 레코드(전체 컬럼)를 보유&lt;/li&gt;
&lt;li&gt;InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨&lt;/li&gt;
&lt;li&gt;PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;논클러스터드 인덱스(보조 인덱스, Secondary Index)&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 복합 인덱스와 Left-most Prefix 원칙 정리</title>
      <link>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</link>
      <pubDate>Sun, 30 Nov 2025 13:07:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</guid>
      <description>&lt;p&gt;InnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 &lt;code&gt;(colA, colB, colC)&lt;/code&gt; 인덱스면 &lt;code&gt;colA&lt;/code&gt; 기준으로 정렬되고 같은 &lt;code&gt;colA&lt;/code&gt; 그룹 내에서 &lt;code&gt;colB&lt;/code&gt;, 이어서 &lt;code&gt;colC&lt;/code&gt; 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐&lt;/p&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장&lt;/li&gt;
&lt;li&gt;InnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향&lt;/li&gt;
&lt;li&gt;left-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식-예시-cola-colb&#34;&gt;동작 방식 예시 &lt;code&gt;(colA, colB)&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;인덱스 구조&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정렬 키 순서: &lt;code&gt;colA&lt;/code&gt; → &lt;code&gt;colB&lt;/code&gt; → 내부적으로 PK 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;왼쪽 컬럼 우선 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE colA = ?&lt;/code&gt; 또는 &lt;code&gt;WHERE colA = ? AND colB = ?&lt;/code&gt; 형태는 인덱스를 온전히 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE colB = ?&lt;/code&gt;처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;왼쪽 접두사 부분 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(colA, colB)&lt;/code&gt;에서 &lt;code&gt;colA&lt;/code&gt;만 조건으로 사용해도 인덱스 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colA&lt;/code&gt;와 &lt;code&gt;colB&lt;/code&gt;를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colB&lt;/code&gt;만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;정렬과 결합 사용의 기본&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 키 순서와 같은 &lt;code&gt;ORDER BY colA, colB&lt;/code&gt;는 추가 정렬 비용 감소에 도움&lt;/li&gt;
&lt;li&gt;WHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;여러-컬럼을-묶는-이유&#34;&gt;여러 컬럼을 묶는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다중 조건 검색 성능 향상. 예: &lt;code&gt;WHERE colA = ? AND colB BETWEEN ? AND ?&lt;/code&gt;는 &lt;code&gt;(colA, colB)&lt;/code&gt;로 빠른 범위 스캔 가능&lt;/li&gt;
&lt;li&gt;커버링 인덱스 활용. 예: &lt;code&gt;SELECT colA, colB FROM T WHERE colA = ? AND colB = ?&lt;/code&gt;에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능&lt;/li&gt;
&lt;li&gt;쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장&lt;/li&gt;
&lt;li&gt;너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A, B, C)&lt;/code&gt;일 때 &lt;code&gt;WHERE B = ?&lt;/code&gt;처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 &lt;code&gt;(B, A)&lt;/code&gt; 같은 보완 인덱스 검토&lt;/li&gt;
&lt;li&gt;InnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리&lt;/li&gt;
&lt;li&gt;ORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락&lt;/li&gt;
&lt;li&gt;범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 &lt;code&gt;colA BETWEEN ...&lt;/code&gt;가 선두에 오면 그 뒤 &lt;code&gt;colB&lt;/code&gt;는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨&lt;/li&gt;
&lt;li&gt;다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음&lt;/li&gt;
&lt;li&gt;불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
