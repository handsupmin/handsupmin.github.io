<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Indexing on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/indexing/</link>
    <description>Recent content in Indexing on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 14 Dec 2025 13:09:03 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/indexing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</link>
      <pubDate>Sun, 14 Dec 2025 13:09:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Primary Key 지정 시 클러스터드 인덱스 생성&lt;/li&gt;
&lt;li&gt;Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념-정리&#34;&gt;핵심 개념 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;클러스터드 인덱스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 데이터가 인덱스 키 순서로 정리되는 구조&lt;/li&gt;
&lt;li&gt;테이블당 하나만 존재&lt;/li&gt;
&lt;li&gt;리프 노드가 실제 레코드(전체 컬럼)를 보유&lt;/li&gt;
&lt;li&gt;InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨&lt;/li&gt;
&lt;li&gt;PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;논클러스터드 인덱스(보조 인덱스, Secondary Index)&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 복합 인덱스와 Left-most Prefix 원칙 정리</title>
      <link>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</link>
      <pubDate>Sun, 30 Nov 2025 13:07:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</guid>
      <description>&lt;p&gt;InnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 &lt;code&gt;(colA, colB, colC)&lt;/code&gt; 인덱스면 &lt;code&gt;colA&lt;/code&gt; 기준으로 정렬되고 같은 &lt;code&gt;colA&lt;/code&gt; 그룹 내에서 &lt;code&gt;colB&lt;/code&gt;, 이어서 &lt;code&gt;colC&lt;/code&gt; 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐&lt;/p&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장&lt;/li&gt;
&lt;li&gt;InnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향&lt;/li&gt;
&lt;li&gt;left-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식-예시-cola-colb&#34;&gt;동작 방식 예시 &lt;code&gt;(colA, colB)&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;인덱스 구조&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정렬 키 순서: &lt;code&gt;colA&lt;/code&gt; → &lt;code&gt;colB&lt;/code&gt; → 내부적으로 PK 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;왼쪽 컬럼 우선 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE colA = ?&lt;/code&gt; 또는 &lt;code&gt;WHERE colA = ? AND colB = ?&lt;/code&gt; 형태는 인덱스를 온전히 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE colB = ?&lt;/code&gt;처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;왼쪽 접두사 부분 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(colA, colB)&lt;/code&gt;에서 &lt;code&gt;colA&lt;/code&gt;만 조건으로 사용해도 인덱스 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colA&lt;/code&gt;와 &lt;code&gt;colB&lt;/code&gt;를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colB&lt;/code&gt;만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;정렬과 결합 사용의 기본&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 키 순서와 같은 &lt;code&gt;ORDER BY colA, colB&lt;/code&gt;는 추가 정렬 비용 감소에 도움&lt;/li&gt;
&lt;li&gt;WHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;여러-컬럼을-묶는-이유&#34;&gt;여러 컬럼을 묶는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다중 조건 검색 성능 향상. 예: &lt;code&gt;WHERE colA = ? AND colB BETWEEN ? AND ?&lt;/code&gt;는 &lt;code&gt;(colA, colB)&lt;/code&gt;로 빠른 범위 스캔 가능&lt;/li&gt;
&lt;li&gt;커버링 인덱스 활용. 예: &lt;code&gt;SELECT colA, colB FROM T WHERE colA = ? AND colB = ?&lt;/code&gt;에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능&lt;/li&gt;
&lt;li&gt;쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장&lt;/li&gt;
&lt;li&gt;너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A, B, C)&lt;/code&gt;일 때 &lt;code&gt;WHERE B = ?&lt;/code&gt;처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 &lt;code&gt;(B, A)&lt;/code&gt; 같은 보완 인덱스 검토&lt;/li&gt;
&lt;li&gt;InnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리&lt;/li&gt;
&lt;li&gt;ORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락&lt;/li&gt;
&lt;li&gt;범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 &lt;code&gt;colA BETWEEN ...&lt;/code&gt;가 선두에 오면 그 뒤 &lt;code&gt;colB&lt;/code&gt;는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨&lt;/li&gt;
&lt;li&gt;다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음&lt;/li&gt;
&lt;li&gt;불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>MySQL EXPLAIN 실행 계획 해석 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</link>
      <pubDate>Wed, 15 Oct 2025 13:10:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구
병목 파악과 인덱스 전략 점검에 사용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select_type
&lt;ul&gt;
&lt;li&gt;SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음&lt;/li&gt;
&lt;li&gt;PRIMARY 가장 바깥쪽 SELECT&lt;/li&gt;
&lt;li&gt;SUBQUERY 서브쿼리&lt;/li&gt;
&lt;li&gt;DERIVED FROM 절의 서브쿼리&lt;/li&gt;
&lt;li&gt;UNION UNION의 두 번째 이후 SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 실행 품질 지표, 위에서 아래로 유리
&lt;ul&gt;
&lt;li&gt;system 테이블에 단 하나의 행&lt;/li&gt;
&lt;li&gt;const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회&lt;/li&gt;
&lt;li&gt;eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭&lt;/li&gt;
&lt;li&gt;ref 인덱스를 사용한 동등 조건 검색&lt;/li&gt;
&lt;li&gt;range 인덱스를 사용한 범위 검색&lt;/li&gt;
&lt;li&gt;index 인덱스 전체 스캔&lt;/li&gt;
&lt;li&gt;ALL 테이블 전체 스캔, 최악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음&lt;/li&gt;
&lt;li&gt;key 실제 사용된 인덱스, NULL이면 인덱스 미사용&lt;/li&gt;
&lt;li&gt;rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리&lt;/li&gt;
&lt;li&gt;filtered 조건 후 남는 행 비율 추정치, 높을수록 유리&lt;/li&gt;
&lt;li&gt;Extra 추가 단서
&lt;ul&gt;
&lt;li&gt;Using index 커버링 인덱스 사용, 유리&lt;/li&gt;
&lt;li&gt;Using where WHERE 조건으로 필터링 수행&lt;/li&gt;
&lt;li&gt;Using filesort 추가 정렬 필요, 비용 큼&lt;/li&gt;
&lt;li&gt;Using temporary 임시 테이블 사용, 비용 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해석-기준&#34;&gt;해석 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type이 const, ref, range 범주에 위치&lt;/li&gt;
&lt;li&gt;key가 NULL이 아니고 적절한 인덱스 선택&lt;/li&gt;
&lt;li&gt;rows 추정치가 작고 filtered 비율이 높음&lt;/li&gt;
&lt;li&gt;Extra에 Using filesort, Using temporary 부재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시와-해석&#34;&gt;예시와 해석&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;type: ALL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;possible_keys: NULL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rows: 3527425
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Extra: Using where; Using filesort&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;테이블 전체 스캔으로 많은 행을 읽게 됨&lt;/li&gt;
&lt;li&gt;인덱스 후보와 실제 사용 인덱스가 없음&lt;/li&gt;
&lt;li&gt;WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승&lt;/li&gt;
&lt;li&gt;현재 계획은 인덱스 설계와 조건식 재검토 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rows와 filtered는 통계 기반 추정치라 실제와 오차 가능&lt;/li&gt;
&lt;li&gt;filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용&lt;/li&gt;
&lt;li&gt;Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려&lt;/li&gt;
&lt;li&gt;커버링 인덱스 구성 시 Extra의 Using index로 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기
위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
