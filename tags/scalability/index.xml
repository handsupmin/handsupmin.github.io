<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Scalability on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/scalability/</link>
    <description>Recent content in Scalability on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 27 Feb 2026 13:23:46 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/scalability/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>유지보수와 확장성을 고려한 HTML/CSS 구조 전략</title>
      <link>https://blog.jsontapose.com/posts/maintainable-scalable-html-css-structure-strategy-6905d0/</link>
      <pubDate>Fri, 27 Feb 2026 13:23:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/maintainable-scalable-html-css-structure-strategy-6905d0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;작은 규칙의 일관성이 유지보수성과 확장성을 만든다고 봄. 아래 세 가지 원칙은 팀 합의만 되면 즉시 적용 가능하며, 코드 리뷰와 리팩터링 부담을 낮추는 효과가 큼&lt;/p&gt;
&lt;h3 id=&#34;classname-네이밍은-하이픈-사용-권장&#34;&gt;className 네이밍은 하이픈 사용 권장&lt;/h3&gt;
&lt;p&gt;camelCase, under_score보다 하이픈(-) 기준 분절이 명확해 가독성과 편집성이 좋음. 대소문자 전환 없이 입력 가능해 타이핑 피로도도 낮음&lt;/p&gt;
&lt;p&gt;에디터 단어 단위 이동/선택이 직관적. camelCase나 under_score는 하나의 토큰으로 취급되는 경우가 많아 커서 이동이 번거로움. 하이픈은 공백처럼 인식되어 단어 경계 이동이 쉬움. 예시로 &lt;code&gt;sweetPotato&lt;/code&gt;, &lt;code&gt;sweet_potato&lt;/code&gt;, &lt;code&gt;sweet-potato&lt;/code&gt; 비교 추천&lt;/p&gt;</description>
    </item>
    <item>
      <title>CPU 자원 관점에서 보는 Node.js 이벤트 루프와 스레드풀 상호작용</title>
      <link>https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/</link>
      <pubDate>Thu, 22 Jan 2026 13:16:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-cpu-event-loop-threadpool-b27011/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;목표  이벤트 루프, 스레드풀, 커널이 실제 CPU 코어와 어떻게 상호작용하는지 CPU 관점에서 명확히 이해하기
Node.js가 어디서 CPU를 쓰고 어디서 기다리는지 구분해야 병목을 제대로 잡을 수 있음&lt;/p&gt;
&lt;h3 id=&#34;cpu-코어와-os-스레드의-물리적-의미&#34;&gt;CPU 코어와 OS 스레드의 물리적 의미&lt;/h3&gt;
&lt;p&gt;하드웨어와 OS 레벨 정의를 먼저 정리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 코어 1개 ≈ 특정 시점에 물리적으로 실행 가능한 OS 스레드 1개&lt;/li&gt;
&lt;li&gt;스레드  OS 스케줄러가 CPU를 할당하는 최소 단위&lt;/li&gt;
&lt;li&gt;동시성 vs 병렬성
&lt;ul&gt;
&lt;li&gt;코어 1개면 수백 스레드도 시분할로 번갈아 실행되는 동시성&lt;/li&gt;
&lt;li&gt;코어 여러 개일 때만 실제 병렬 실행 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 관점의 핵심 비용&lt;/p&gt;</description>
    </item>
    <item>
      <title>좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙</title>
      <link>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</link>
      <pubDate>Thu, 01 Jan 2026 13:12:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장&lt;/p&gt;
&lt;h3 id=&#34;시스템-설계의-정의와-접근&#34;&gt;시스템 설계의 정의와 접근&lt;/h3&gt;
&lt;p&gt;소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앱 서버&lt;/li&gt;
&lt;li&gt;데이터베이스&lt;/li&gt;
&lt;li&gt;캐시&lt;/li&gt;
&lt;li&gt;큐와 잡 러너&lt;/li&gt;
&lt;li&gt;이벤트 버스&lt;/li&gt;
&lt;li&gt;프록시와 게이트웨이&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;좋은 설계의 징후&lt;/p&gt;</description>
    </item>
    <item>
      <title>백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴</title>
      <link>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</link>
      <pubDate>Fri, 26 Dec 2025 13:12:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함
직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함&lt;/p&gt;
&lt;h3 id=&#34;왜-중요한가&#34;&gt;왜 중요한가&lt;/h3&gt;
&lt;p&gt;처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자 1000 req/s, 소비자 100 req/s 가정&lt;/li&gt;
&lt;li&gt;매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험&lt;/li&gt;
&lt;li&gt;큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능
백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Producer: 데이터를 생성·전송하는 주체&lt;/li&gt;
&lt;li&gt;Consumer: 데이터를 수신·처리하는 주체&lt;/li&gt;
&lt;li&gt;Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위&lt;/li&gt;
&lt;li&gt;전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리전략&#34;&gt;동작 원리/전략&lt;/h3&gt;
&lt;p&gt;A. 조절 Control/Throttling&lt;/p&gt;</description>
    </item>
    <item>
      <title>블록체인 합의 알고리즘 가이드 — PoW, PoS와 영지식증명 활용</title>
      <link>https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</link>
      <pubDate>Sat, 11 Oct 2025 13:05:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/blockchain-consensus-algorithms-pow-pos-and-zero-knowledge-proofs-2946e5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;퍼블릭 블록체인은 중앙 관리자 없이 다수 참여자가 같은 상태를 공유해야 함
이때 모두가 믿을 수 있는 하나의 기록을 선택하는 규칙이 필요하며 이를 합의 알고리즘이라 부름
합의는 성능과 보안, 탈중앙화 사이의 균형 문제이기도 함
PoW와 PoS는 대표적 합의 방식이며 최근에는 영지식증명 같은 암호 기법이 개인정보 보호와 검증 간소화에 결합되는 추세임
실무 관점에서 각 방식의 원리와 트레이드오프, 영지식증명과의 접점을 정리함&lt;/p&gt;
&lt;h3 id=&#34;합의가-필요한-이유와-기준&#34;&gt;합의가 필요한 이유와 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;안전성 안전하게 하나의 정본을 고수하고 이중 지불 등 불변성 파괴가 발생하지 않음&lt;/li&gt;
&lt;li&gt;활성 상태 네트워크 지연이나 일부 장애가 있어도 새 블록 생성이 지속됨&lt;/li&gt;
&lt;li&gt;최종성 일단 확정된 거래가 되돌려지지 않음 확률적 또는 결정적 최종성으로 구분됨&lt;/li&gt;
&lt;li&gt;시빌 내성 가짜 참여자 대량 생성 공격에 저항함 경제적 비용 또는 신원 검증 기반 메커니즘 필요&lt;/li&gt;
&lt;li&gt;성능 처리량과 지연 시간 목표를 명확히 해야 함 블록 간격, 블록 크기, 검증 비용이 관건&lt;/li&gt;
&lt;li&gt;탈중앙화 검증 참여 문턱을 낮춰 누구나 검증 가능하도록 설계 권장 풀 집중이나 소수 지배를 억제할 유인 설계 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pow-작업증명-핵심&#34;&gt;PoW 작업증명 핵심&lt;/h3&gt;
&lt;p&gt;정의 특정 난이도의 해시 퍼즐을 풀어 블록 제안권을 얻는 방식 채굴자가 해시 연산을 반복해 목표값 미만의 해시를 찾는 구조
구성 요소 블록 헤더 난이도 목표값 논스 해시 함수 작업 증명 검증은 O(1)에 가까움 제안은 대량 계산 필요
난이도 조정 네트워크 전체 해시 파워 변화를 따라 목표 블록 간격을 유지하도록 주기적 재조정 수행
보안 모델 정직한 해시 파워가 과반을 차지하면 긴 사슬이 정본이 됨 51% 공격은 다수 해시력으로 과거 일부 구간을 재작성하는 위협을 의미
장점&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
