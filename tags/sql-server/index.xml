<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sql-Server on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/sql-server/</link>
    <description>Recent content in Sql-Server on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 25 Feb 2026 13:28:01 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/sql-server/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQL Server MERGE로 소스·타깃 동기화하기 패턴과 주의점</title>
      <link>https://blog.jsontapose.com/posts/sql-server-merge-source-target-sync-patterns-cautions-da99e5/</link>
      <pubDate>Wed, 25 Feb 2026 13:28:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sql-server-merge-source-target-sync-patterns-cautions-da99e5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;MERGE는 소스 테이블과 타깃 테이블을 조인한 결과를 기준으로 삽입·갱신·삭제를 한 번에 처리하는 집합 기반 연산
여러 개의 개별 DML을 하나로 합쳐 실행 횟수와 스캔 비용을 줄이는 것이 목적
테이블 간 차이를 기준으로 동기화가 필요한 배치나 증분 적재 시 유용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타깃 대상과 소스 입력의 조인 조건 정의&lt;/li&gt;
&lt;li&gt;WHEN MATCHED 조건에서 UPDATE 또는 DELETE 수행&lt;/li&gt;
&lt;li&gt;WHEN NOT MATCHED BY TARGET 조건에서 타깃에 INSERT 수행&lt;/li&gt;
&lt;li&gt;WHEN NOT MATCHED BY SOURCE 조건에서 소스에 없는 타깃 행을 DELETE 등으로 정리하는 패턴 지원&lt;/li&gt;
&lt;li&gt;하나의 문장으로 트랜잭션 일관성 유지가 쉬움&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;p&gt;필수 요소만 요약&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL Server nvarchar와 nchar 길이 단위 오해 바로잡기</title>
      <link>https://blog.jsontapose.com/posts/sql-server-nvarchar-nchar-length-misconception-c1f1aa/</link>
      <pubDate>Mon, 09 Feb 2026 13:28:52 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sql-server-nvarchar-nchar-length-misconception-c1f1aa/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;nvarchar와 nchar를 사용할 때 n이 곧 문자 개수라고 가정하는 경우가 많음
하지만 SQL Server에서 nchar(n), nvarchar(n)의 n은 문자 개수가 아니라 2바이트 단위의 길이, 즉 바이트 페어(byte-pair) 개수로 정의됨
문자 집합 범위에 따라 한 문자가 1개 혹은 2개의 바이트 페어를 사용할 수 있어 저장 가능한 문자의 실제 개수는 달라짐&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;nchar(n), nvarchar(n)의 n은 0~4000 바이트 페어 범위의 길이 의미&lt;/li&gt;
&lt;li&gt;하나의 바이트 페어는 2바이트로, 내부적으로 UTF-16 코드 유닛 단위로 이해 가능&lt;/li&gt;
&lt;li&gt;유니코드 BMP 범위(0~65,535) 문자는 보통 1 바이트 페어 사용&lt;/li&gt;
&lt;li&gt;보조 평면 범위(65,536~1,114,111) 문자는 서러게이트 페어로 2 바이트 페어 사용&lt;/li&gt;
&lt;li&gt;따라서 n이 문자의 최대 개수를 보장하지 않음&lt;/li&gt;
&lt;li&gt;char(n), varchar(n)은 n이 바이트 수 의미라는 점에서 유사한 맥락이나, nvarchar/nchar는 바이트 페어 기준이라는 차이 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추가 기본값 규칙&lt;/p&gt;</description>
    </item>
    <item>
      <title>VARCHAR(n) 길이 기준 정리 — 글자 수인가 바이트 수인가</title>
      <link>https://blog.jsontapose.com/posts/varchar-n-length-characters-vs-bytes-99b017/</link>
      <pubDate>Fri, 05 Dec 2025 13:11:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/varchar-n-length-characters-vs-bytes-99b017/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;VARCHAR(n)에서 n을 글자 수로 볼지 바이트 수로 볼지 혼동 많음
표준 SQL의 character varying(n)은 최대 글자 수 의미이나, 실제 구현은 DBMS와 문자셋 설정에 따라 달라짐
멀티바이트 문자셋에서는 저장 바이트 수와 글자 수가 다름. 길이 제한은 글자 수 기준일 수 있으나 내부 저장은 바이트 단위로 이뤄짐&lt;/p&gt;
&lt;h3 id=&#34;dbms별-동작&#34;&gt;DBMS별 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL
&lt;ul&gt;
&lt;li&gt;VARCHAR(n)에서 n은 글자 수 의미&lt;/li&gt;
&lt;li&gt;utf8mb4 사용 시 글자 하나가 최대 4바이트까지 소요. 행 크기 제한 등으로 인해 저장 가능 여부는 바이트 한계에도 영향 받음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PostgreSQL
&lt;ul&gt;
&lt;li&gt;character varying(n)에서 n은 글자 수 의미&lt;/li&gt;
&lt;li&gt;저장은 바이트 단위이나 제약은 글자 수 기준으로 평가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SQL Server
&lt;ul&gt;
&lt;li&gt;varchar(n)은 n이 바이트 수. 멀티바이트 문자 사용 시 같은 n이라도 담을 수 있는 글자 수 감소&lt;/li&gt;
&lt;li&gt;nvarchar(n)은 n이 글자 수. 유니코드 2바이트 단위 저장. 글자 수 기준 제약 필요 시 nvarchar 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Oracle
&lt;ul&gt;
&lt;li&gt;VARCHAR2(n)은 기본이 바이트 기준. 세션/시스템에서 CHAR semantics 또는 컬럼 정의 시 VARCHAR2(n CHAR)로 명시하면 글자 수 기준&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실무-팁&#34;&gt;실무 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한글 100자, 영어 100자 모두 허용 기대라면 글자 수 기준 타입 필요
&lt;ul&gt;
&lt;li&gt;MySQL VARCHAR(100), PostgreSQL varchar(100), SQL Server에서는 nvarchar(100), Oracle에서는 VARCHAR2(100 CHAR) 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;저장 바이트 한계 고려 필요. MySQL은 행 크기 한계, Oracle/SQL Server도 페이지 크기 등 제약 존재&lt;/li&gt;
&lt;li&gt;길이 함수 차이 주의. 바이트 길이와 글자 길이 함수가 다른 경우 존재. 예를 들어 글자 길이 검증은 문자 길이 함수 사용 권장&lt;/li&gt;
&lt;li&gt;이모지, 결합 문자 등 특수 유니코드 조합은 사용자 체감 글자 수와 코드 포인트 수가 다를 수 있음. 제품 요구사항에 맞는 길이 기준 정의 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VARCHAR(n)이 항상 바이트 무관이라는 주장은 오해&lt;/li&gt;
&lt;li&gt;많은 DBMS에서 n은 글자 수지만, SQL Server의 varchar처럼 바이트 기준인 구현 존재&lt;/li&gt;
&lt;li&gt;문자셋과 저장 한계를 함께 고려해야 안정적인 길이 설계 가능&lt;/li&gt;
&lt;li&gt;한글도 100글자, 영어도 100글자라는 기대를 보장하려면 글자 수 기준 타입과 설정을 명시적으로 선택할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/char.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/char.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/datatype-character.html&#34;&gt;https://www.postgresql.org/docs/current/datatype-character.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql&#34;&gt;https://learn.microsoft.com/sql/t-sql/data-types/char-and-varchar-transact-sql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673&#34;&gt;https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-3B0B0A24-FA05-4A1F-902E-2E6D0BF85673&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
