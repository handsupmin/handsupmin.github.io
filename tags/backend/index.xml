<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Backend on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/backend/</link>
    <description>Recent content in Backend on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 31 Dec 2025 13:12:12 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/backend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>API 에러 응답 설계 가이드 — HTTP Status는 대분류, 비즈니스 의미는 바디</title>
      <link>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</link>
      <pubDate>Wed, 31 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-response-design-guide-738261/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;HTTP Status Code만으로는 서비스 로직의 원인을 전달하기 부족함
400대와 500대는 네트워크 관점의 대분류 신호에 가깝고 실제로 필요한 것은 비즈니스 맥락의 구체적 사유임
결론은 단순함
HTTP Status는 대분류 신호로 두고 실제 의미와 추가 컨텍스트는 Response Body에 싣는 구조가 현실적 해법임&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Status는 큰 범주 신호등 역할
&lt;ul&gt;
&lt;li&gt;2xx 성공&lt;/li&gt;
&lt;li&gt;4xx 클라이언트 오류&lt;/li&gt;
&lt;li&gt;5xx 서버 오류&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비즈니스 의미는 Response Body의 커스텀 에러 구조로 표현&lt;/li&gt;
&lt;li&gt;클라이언트가 코드 기반으로 분기하고 UI를 결정할 수 있어야 함&lt;/li&gt;
&lt;li&gt;운영 관측을 위해 traceId 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;업계에서-검증된-기본-구조&#34;&gt;업계에서 검증된 기본 구조&lt;/h3&gt;
&lt;p&gt;아래 형태가 가장 보편적으로 쓰이는 패턴임&lt;/p&gt;</description>
    </item>
    <item>
      <title>API ErrorCode Enum 설계 베스트 프랙티스</title>
      <link>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</link>
      <pubDate>Thu, 25 Dec 2025 13:11:57 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-error-code-enum-best-practices-3f75b7/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;API 에러 규격의 핵심은 에러를 안정적으로 식별할 수 있는 Code 체계 확보임
HTTP Status만으로는 부족하고 메시지는 언어·맥락에 따라 바뀔 수 있음
실제로 계약으로서 신뢰할 수 있는 값은 error.code 임
아래는 다수의 글로벌 서비스에서 공통적으로 쓰는 Error Code 설계 원칙 정리&lt;/p&gt;
&lt;h3 id=&#34;설계-원칙&#34;&gt;설계 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;error.code 는 서비스 전반의 안정적인 식별자여야 함&lt;/li&gt;
&lt;li&gt;메시지나 HTTP Status는 변경 가능하지만 error.code 는 변경 불가&lt;/li&gt;
&lt;li&gt;구버전 클라이언트도 동일 코드를 신뢰해야 하므로 호환성 보장 필수&lt;/li&gt;
&lt;li&gt;숫자형 대신 의미가 드러나는 문자열 기반 Enum 권장
&lt;ul&gt;
&lt;li&gt;숫자형은 의미 파악 어려움, 매뉴얼 의존, 협업 비용 증가&lt;/li&gt;
&lt;li&gt;문자열 Enum은 가독성, 검색성, 커뮤니케이션 효율 우수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS forRoot()의 동작 원리와 싱글톤에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</link>
      <pubDate>Sun, 07 Dec 2025 13:07:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS을 다루다 보면 &lt;code&gt;ConfigModule.forRoot()&lt;/code&gt;, &lt;code&gt;TypeOrmModule.forRoot()&lt;/code&gt; 같은 코드를 보게 됨
보통 &amp;ldquo;이건 전역 설정이니까 한 번만 하면 끝이고 알아서 싱글톤 유지되겠지?&amp;ldquo;라고 생각하기 쉬움&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;forRoot()&lt;/code&gt;를 호출한다고 프레임워크가 알아서 물리적인 싱글톤 인스턴스를 강제하는 건 아님
특히 &lt;code&gt;ScheduleModule&lt;/code&gt;처럼 사이드 이펙트(이벤트 리스너, 타이머 등)를 유발하는 모듈을 잘못 다루면, 기능이 중복 실행되는 심각한 버그가 터질 수 있음&lt;/p&gt;
&lt;p&gt;이 글에서는 &lt;code&gt;forRoot()&lt;/code&gt;의 진짜 의미와 내부 동작, 그리고 &lt;code&gt;ScheduleModule&lt;/code&gt; 중복 실행 문제가 왜 생기는지 코드로 뜯어보겠음&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;forroot란-무엇인가&#34;&gt;forRoot()란 무엇인가&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;forRoot()&lt;/code&gt;는 NestJS의 &lt;strong&gt;동적 모듈&lt;/strong&gt;(Dynamic Module)을 생성하기 위해 관례적으로 쓰는 메서드 이름임&lt;/p&gt;</description>
    </item>
    <item>
      <title>백오프 Backoff 재시도 전략 정리 고정·선형·지수·지터</title>
      <link>https://blog.jsontapose.com/posts/backoff-retry-strategy-fixed-linear-exponential-jitter-6d23a5/</link>
      <pubDate>Fri, 28 Nov 2025 13:10:38 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backoff-retry-strategy-fixed-linear-exponential-jitter-6d23a5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;백오프는 실패한 작업을 즉시 재시도하지 않고 일정 시간 대기 후 다시 시도하는 전략을 말함
연속 실패 시 대기 시간을 점진적으로 늘려 서비스와 네트워크에 가해지는 부하를 낮추는 목적
RPC, 데이터베이스, 외부 API 호출, 트랜잭션 재시도 등에서 일반적으로 사용&lt;/p&gt;
&lt;h3 id=&#34;왜-쓰는가&#34;&gt;왜 쓰는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;과부하 방지
실패 직후 동시 재시도를 막아 서버와 네트워크 폭주를 예방&lt;/li&gt;
&lt;li&gt;일시적 장애 흡수
순간적인 지연이나 혼잡이 해소될 시간을 벌어 성공 확률을 높임&lt;/li&gt;
&lt;li&gt;비용 절감
불필요한 재시도 횟수와 리소스 낭비 감소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;대표-백오프-패턴&#34;&gt;대표 백오프 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;고정 백오프 Fixed
매번 동일 대기 시간 사용
예) 1초 → 1초 → 1초&lt;/li&gt;
&lt;li&gt;선형 백오프 Linear
시도할 때마다 일정 간격으로 증가
예) 1초 → 2초 → 3초 → 4초&lt;/li&gt;
&lt;li&gt;지수 백오프 Exponential
보통 2배로 증가하는 지수 증가 사용, 실무에서 기본값으로 가장 흔함
예) 1초 → 2초 → 4초 → 8초 → 16초&lt;/li&gt;
&lt;li&gt;지수 백오프 + 지터 Jitter
지수 증가에 무작위성을 섞어 동시 재시도 동기화를 깨뜨림
예) 1초 → 2.3초 → 4.1초 → 8.6초&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실전-포인트&#34;&gt;실전 포인트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;동시성 환경에서는 지터 필수
동일한 주기 백오프만으로는 다수 클라이언트가 같은 타이밍에 몰려 서버를 다시 두들김&lt;/li&gt;
&lt;li&gt;상한 설정
최대 대기 시간과 최대 재시도 횟수 캡을 두어 꼬리 길어짐 방지&lt;/li&gt;
&lt;li&gt;실패 예산과 타임아웃 연계
전체 호출 타임아웃 내에서 재시도 예산을 배분, 1회 호출과 재시도들이 전체 SLA를 초과하지 않도록 관리&lt;/li&gt;
&lt;li&gt;멱등성 보장
재시도 가능한 작업은 멱등성을 만족해야 안전, 아니면 보상 로직 필요&lt;/li&gt;
&lt;li&gt;서버 힌트 활용
Retry-After 등 서버가 제시하는 대기 힌트가 있으면 우선 적용&lt;/li&gt;
&lt;li&gt;지터 방식 선택
전체 구간 무작위 분포 Full jitter가 단순하고 효과적이라는 보고가 많음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;p&gt;아래는 지수 백오프의 최소 구현 예시이며, 지터와 최대 대기 시간 제한은 상황에 맞게 추가 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미</title>
      <link>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</link>
      <pubDate>Wed, 29 Oct 2025 13:11:51 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함
skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함&lt;/p&gt;
&lt;h3 id=&#34;핵심-동작&#34;&gt;핵심 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cursor는 그 지점부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 100부터 시작해 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;skip: 1은 cursor에 해당하는 레코드를 건너뜀&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  skip: &lt;span style=&#34;color:#81a1c1&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 101부터 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;예시로-보는-차이&#34;&gt;예시로 보는 차이&lt;/h3&gt;
&lt;p&gt;데이터가 아래와 같다고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 환경에서 디버깅하기</title>
      <link>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</link>
      <pubDate>Thu, 23 Oct 2025 13:11:27 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함&lt;/p&gt;
&lt;h3 id=&#34;문제를-명확히-하기&#34;&gt;문제를 명확히 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작성한 코드의 기대 동작 정의&lt;/li&gt;
&lt;li&gt;실제 관측된 동작과의 차이 정리&lt;/li&gt;
&lt;li&gt;실패 조건과 재현 절차 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
