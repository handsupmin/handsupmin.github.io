<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Database-Design on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/database-design/</link>
    <description>Recent content in Database-Design on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 28 Feb 2026 13:13:46 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/database-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>EAV(Entity-Attribute-Value) 모델 개념과 구조, 장단점 정리</title>
      <link>https://blog.jsontapose.com/posts/eav-entity-attribute-value-model-43c338/</link>
      <pubDate>Sat, 28 Feb 2026 13:13:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/eav-entity-attribute-value-model-43c338/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EAV는 Entity-Attribute-Value의 약자이며, 기존 정규화 스키마에서 컬럼으로 고정하던 속성을 행 단위로 분리해 저장하는 데이터 모델
속성 집합이 사용자마다 다르거나 런타임에 추가되는 등 스키마를 선제 정의하기 어려운 경우 사용
속성이 희소할 때 저장 공간 절약과 스키마 변경 부담 감소에 유리&lt;/p&gt;
&lt;h3 id=&#34;구조&#34;&gt;구조&lt;/h3&gt;
&lt;p&gt;일반적으로 세 컬럼 기반 테이블로 구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entity  데이터의 주체 예 사용자, 제품&lt;/li&gt;
&lt;li&gt;attribute  엔터티의 속성 예 이름, 색상&lt;/li&gt;
&lt;li&gt;value  속성의 실제 값 예 김철수, 빨간색&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시&#34;&gt;예시&lt;/h3&gt;
&lt;p&gt;엔터티가 사용자이고 속성이 이름, 나이, 이메일이라고 가정
일반 테이블 예  Users(UserId, Name, Age, Email)
EAV 표현 예&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Source of Truth(SSOT)의 의미와 적용 예시</title>
      <link>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</link>
      <pubDate>Fri, 02 Jan 2026 13:11:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함
핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함
원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 불일치 발생 위험 증가
&lt;ul&gt;
&lt;li&gt;위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유지보수 비용 급증
&lt;ul&gt;
&lt;li&gt;수정 시 흩어진 모든 복제본을 찾아 변경해야 함&lt;/li&gt;
&lt;li&gt;일부 누락 시 버그와 장애로 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 전파가 느림
&lt;ul&gt;
&lt;li&gt;캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실생활-비유&#34;&gt;실생활 비유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재
은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음&lt;/li&gt;
&lt;li&gt;스마트폰 연락처가 전화번호의 원본 역할을 수행
연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발-적용-예시&#34;&gt;개발 적용 예시&lt;/h3&gt;
&lt;h4 id=&#34;프론트엔드-상태-관리&#34;&gt;프론트엔드 상태 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리&lt;/li&gt;
&lt;li&gt;부모 변경이 자식에 반영되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;상위 컴포넌트 또는 중앙 스토어에만 userData 보관&lt;/li&gt;
&lt;li&gt;자식은 props나 selector로 읽기 전용 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터베이스-모델링&#34;&gt;데이터베이스 모델링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;회원 테이블에만 주소 저장&lt;/li&gt;
&lt;li&gt;주문 테이블은 회원 ID를 참조해 조인으로 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;타입-정의-공유typescript&#34;&gt;타입 정의 공유(TypeScript)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스와-주의&#34;&gt;베스트 프랙티스와 주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 경로 단일화
&lt;ul&gt;
&lt;li&gt;원본에 대한 쓰기는 반드시 한 경로로만 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 복제본과 캐시 관리
&lt;ul&gt;
&lt;li&gt;캐시는 파생물로 취급&lt;/li&gt;
&lt;li&gt;만료 정책, 동기화 주기, 재검증 전략을 명시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;식별자 기반 참조 우선
&lt;ul&gt;
&lt;li&gt;파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양방향 복제와 수동 동기화 지양
&lt;ul&gt;
&lt;li&gt;충돌 해결 복잡도와 데이터 드리프트 위험 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마이그레이션 단계 관리
&lt;ul&gt;
&lt;li&gt;이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;p&gt;원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부
이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음
프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</title>
      <link>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</link>
      <pubDate>Sun, 26 Oct 2025 13:07:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임
대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함
사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함
이때 결정 규칙이 존재함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용&lt;/li&gt;
&lt;li&gt;그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함
따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
