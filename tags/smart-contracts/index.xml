<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Smart-Contracts on HandsLog</title><link>https://handsupmin.github.io/tags/smart-contracts/</link><description>Recent content in Smart-Contracts on HandsLog</description><generator>Hugo -- 0.146.0</generator><language>ko-kr</language><lastBuildDate>Wed, 01 Oct 2025 13:10:22 +0000</lastBuildDate><atom:link href="https://handsupmin.github.io/tags/smart-contracts/index.xml" rel="self" type="application/rss+xml"/><item><title>WETH 이해와 활용 가이드 – ETH를 ERC-20로 포장하는 이유와 동작 원리</title><link>https://handsupmin.github.io/posts/weth-eth-erc20-guide-683552/</link><pubDate>Wed, 01 Oct 2025 13:10:22 +0000</pubDate><guid>https://handsupmin.github.io/posts/weth-eth-erc20-guide-683552/</guid><description>&lt;h3 id="개념배경">개념/배경&lt;/h3>
&lt;p>WETH는 이더리움 네트워크의 기본 자산인 ETH를 ERC-20 표준과 호환되도록 포장한 토큰을 의미함
ETH 자체는 계정 잔고 모델을 따르며 ERC-20 인터페이스를 구현하지 않음
반면 대부분의 디파이 프로토콜과 토큰 간 상호작용은 ERC-20을 전제로 동작함
이 간극을 메우기 위해 1:1 가치로 교환 가능한 WETH가 사용됨&lt;/p>
&lt;p>핵심은 호환성과 일관성임
WETH를 사용하면 ETH를 일반적인 ERC-20 토큰처럼 전송, 승인, 보관, 스왑 등 동일한 방식으로 다룰 수 있음&lt;/p>
&lt;h3 id="핵심-개념과-정의">핵심 개념과 정의&lt;/h3>
&lt;ul>
&lt;li>정의: ETH를 스마트 컨트랙트에 예치하고 동일 수량의 ERC-20 토큰을 발행한 형태의 래핑 자산&lt;/li>
&lt;li>가치 페깅: 1 WETH = 1 ETH를 목표로 하며 언제든 역변환 가능&lt;/li>
&lt;li>표준 호환: ERC-20 인터페이스 준수로 승인, 전송, 수령 등 동작이 통일됨&lt;/li>
&lt;li>커스터디 모델: 컨트랙트가 ETH를 보관하고, 사용자는 WETH를 보유하여 권리를 표현함&lt;/li>
&lt;/ul>
&lt;h3 id="동작-원리">동작 원리&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>래핑 흐름&lt;/p></description></item><item><title>OpenZeppelin Contracts 5.0 마이그레이션 가이드 — ERC20·ERC721·ERC1155 _update 전환과 ERC777 제거</title><link>https://handsupmin.github.io/posts/openzeppelin-contracts-5-migration-erc20-erc721-erc1155-update-erc777-removal-73e149/</link><pubDate>Fri, 26 Sep 2025 13:08:50 +0000</pubDate><guid>https://handsupmin.github.io/posts/openzeppelin-contracts-5-migration-erc20-erc721-erc1155-update-erc777-removal-73e149/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>OpenZeppelin Contracts 5.0으로 올라가면서 토큰 표준 구현 방식이 크게 바뀜
핵심은 ERC20·ERC721·ERC1155에서 _beforeTokenTransfer와 _afterTokenTransfer 훅이 제거되고 내부 상태 갱신 진입점이 _update 하나로 통합된 것
또한 ERC777과 ERC1820Implementer가 제거됨
이 글은 4.6 계열에서 5.1까지 마이그레이션할 때 알아야 할 변경점과 안전한 이전 절차를 정리함&lt;/p>
&lt;h3 id="핵심-변경-사항">핵심 변경 사항&lt;/h3>
&lt;ul>
&lt;li>ERC20·ERC721·ERC1155의 전송 수명주기 훅 제거 및 _update 도입
&lt;ul>
&lt;li>기존 훅 기반 커스터마이징은 _update 오버라이드로 이전 필요&lt;/li>
&lt;li>민트와 번 포함 모든 잔액 변경 경로가 _update로 수렴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>_transfer, _mint, _burn 비가상 처리
&lt;ul>
&lt;li>더 이상 이 함수들을 직접 오버라이드 불가&lt;/li>
&lt;li>일관성 보장을 위해 상태 변경 경로를 고정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ERC777 및 ERC1820Implementer 제거
&lt;ul>
&lt;li>4.9에서 폐기 예고되었고 5.0에서 실제 삭제&lt;/li>
&lt;li>해당 표준 인터페이스는 별도 레포에서 유지되나 구현체 제공하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="동작-원리와-의도">동작 원리와 의도&lt;/h3>
&lt;ul>
&lt;li>단일 진입점 설계
&lt;ul>
&lt;li>모든 잔액 및 공급 변화가 _update에서 처리됨&lt;/li>
&lt;li>확장과 커스터마이징은 _update를 단일 오버라이드 포인트로 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불변식 강화
&lt;ul>
&lt;li>_transfer, _mint, _burn을 잠그고 내부 루팅으로만 호출되게 하여 상태 불일치 리스크 감소&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>확장 간 상호작용 일관화
&lt;ul>
&lt;li>투표, 스냅샷, 소각 수수료, 중지 등 다양한 확장을 _update 체인으로 연결&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="마이그레이션-가이드">마이그레이션 가이드&lt;/h3>
&lt;ol>
&lt;li>훅 사용 여부 점검&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>_beforeTokenTransfer, _afterTokenTransfer 오버라이드 코드 존재 여부 확인&lt;/li>
&lt;li>각 훅에서 하던 검증, 제한, 회계 처리 항목을 목록화&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>_update 오버라이드로 이전&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>훅에 있던 로직을 _update에 통합&lt;/li>
&lt;li>검증은 상태 갱신 전 수행 권장&lt;/li>
&lt;li>필수로 super._update 호출 필요&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>기존 _transfer, _mint, _burn 오버라이드 삭제&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>5.0에서는 오버라이드 자체가 불가&lt;/li>
&lt;li>커스터마이징은 _update 단일 경로로 정리&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>민트와 번 경계값 처리 확인&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>from 또는 to가 address(0)인 경우를 민트와 번으로 해석&lt;/li>
&lt;li>수수료, 제한, 공급 상한과 같은 정책에서 제로 주소 여부 분기 필요&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>테스트와 이벤트 검증 강화&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Transfer 이벤트는 여전히 발생하므로 기존 테스트 자산 가능&lt;/li>
&lt;li>단, 커스터마이징이 이벤트 순서나 재진입 가능성에 영향 주지 않게 확인&lt;/li>
&lt;/ul>
&lt;h3 id="최소-예시">최소 예시&lt;/h3>
&lt;p>아래는 기존 _beforeTokenTransfer에서 하던 검증을 _update로 옮기는 형태의 최소 패턴 예시&lt;/p></description></item><item><title>스마트 컨트랙트에서 O(n)을 피하고 O(1)을 지향해야 하는 이유와 실무 대처법</title><link>https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/</link><pubDate>Sun, 21 Sep 2025 13:05:50 +0000</pubDate><guid>https://handsupmin.github.io/posts/why-avoid-o-n-in-smart-contracts-aim-for-o1-274b74/</guid><description>&lt;h3 id="개요">개요&lt;/h3>
&lt;p>스마트 컨트랙트에서 무제한에 가까운 O(n) 반복문은 성능 저하를 넘어 &lt;strong>실행 불가&lt;/strong>로 이어질 수 있음
블록당 가스 한도와 트랜잭션 가스 모델 때문에 선형 탐색이나 전수 루프는 특정 규모에서 &lt;strong>가스 한도 초과&lt;/strong>를 일으켜 서비스 가용성을 떨어뜨림
이 문서는 원인과 개선 패턴, 실무 체크리스트를 정리함&lt;/p>
&lt;hr>
&lt;h3 id="문제-정의와-영향">문제 정의와 영향&lt;/h3>
&lt;ul>
&lt;li>배열 전수 탐색으로 중복 검사나 상태 검증을 수행하는 구현이 흔함
예 users 배열을 처음부터 끝까지 훑어 가입자 중복을 확인하는 방식&lt;/li>
&lt;li>가입자 수에 비례해 가스가 선형 증가하며 어느 시점부터 한 트랜잭션으로 처리 불가&lt;/li>
&lt;li>공격자가 &lt;strong>가스 그리핑&lt;/strong>을 유도하거나 외부 입력으로 루프 길이를 키우면 사실상 &lt;strong>DoS&lt;/strong>가 될 수 있음&lt;/li>
&lt;li>RPC 에러 메시지는 노드별로 다르지만 본질은 가스 예산 초과로 인한 &lt;strong>미포함·리버트&lt;/strong>임&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="핵심-개념과-대안">핵심 개념과 대안&lt;/h3>
&lt;p>&lt;strong>1) 매핑으로 존재 여부 O(1) 검사&lt;/strong>
저장 키 기반 조회가 상수 시간으로 동작해 선형 탐색을 제거함&lt;/p></description></item></channel></rss>