<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Orm on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/orm/</link>
    <description>Recent content in Orm on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 06 Nov 2025 13:11:04 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/orm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prisma OrderByWithAggregationInput로 집계 기반 정렬하기와 올바른 사용 맥락</title>
      <link>https://blog.jsontapose.com/posts/prisma-orderbywithaggregationinput-aggregation-sorting-7e02ce/</link>
      <pubDate>Thu, 06 Nov 2025 13:11:04 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-orderbywithaggregationinput-aggregation-sorting-7e02ce/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;OrderByWithAggregationInput은 일반 필드뿐 아니라 _count, _avg, _sum 같은 집계 결과를 기준으로 정렬을 정의하는 Prisma 입력 타입임
핵심은 이 타입이 findMany가 아니라 groupBy에서 사용하는 것이라는 점임
집계 결과를 섞어 정렬하려면 groupBy 컨텍스트에서만 가능하며, 일반 목록 조회(findMany)에서는 관계 수 기준(_count) 정도만 지원하고 이는 별도 타입 경로를 통해 처리됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대상 연산
&lt;ul&gt;
&lt;li&gt;groupBy에서만 OrderByWithAggregationInput 사용 가능&lt;/li&gt;
&lt;li&gt;일반 목록 조회는 ModelOrderByWithRelationInput 또는 OrderByRelationAggregateInput 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;정렬 기준 구성
&lt;ul&gt;
&lt;li&gt;스칼라 필드 정렬 + 집계 결과 정렬을 함께 배열로 전달 가능&lt;/li&gt;
&lt;li&gt;orderBy는 하나 또는 배열, 우선순위는 배열 순서대로 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;타입 안전성
&lt;ul&gt;
&lt;li&gt;집계 키(_count, _avg, _sum, _min, _max)와 필드명이 스키마와 정합되도록 컴파일 타임 검증됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용법과-예시&#34;&gt;사용법과 예시&lt;/h3&gt;
&lt;p&gt;아래 예시는 Inventory 모델을 기준으로 설명함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findMany 가이드: where, select/include, 정렬·페이징, in/비교 연산자</title>
      <link>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</link>
      <pubDate>Tue, 28 Oct 2025 13:10:28 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findmany-guide-where-select-include-orderby-pagination-e52110/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma의 findMany는 다중 레코드 조회용 메서드
기본값은 대상 모델의 모든 레코드 반환
where 필터, select/include, 정렬, 페이징, 중복 제거 등 옵션 지원
옵션 조합으로 조건 기반 조회를 간결하게 구성 가능&lt;/p&gt;
&lt;h3 id=&#34;기본-사용법&#34;&gt;기본 사용법&lt;/h3&gt;
&lt;p&gt;가장 단순한 호출 형태&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;prisma&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;findMany&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주요-옵션&#34;&gt;주요 옵션&lt;/h3&gt;
&lt;p&gt;옵션은 필요한 것만 선택적으로 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;where: 조건 필터링&lt;/li&gt;
&lt;li&gt;select: 필드 서브셋 선택&lt;/li&gt;
&lt;li&gt;include: 관계 데이터 로드&lt;/li&gt;
&lt;li&gt;orderBy: 정렬 기준 지정&lt;/li&gt;
&lt;li&gt;skip, take: 오프셋 기반 페이징&lt;/li&gt;
&lt;li&gt;distinct: 특정 필드 기준 중복 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where로-조건-필터링&#34;&gt;where로 조건 필터링&lt;/h3&gt;
&lt;p&gt;단일 조건부터 복합 조건까지 표현 가능&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
