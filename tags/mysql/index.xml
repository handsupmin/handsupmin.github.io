<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mysql on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/mysql/</link>
    <description>Recent content in Mysql on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 30 Nov 2025 13:07:58 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>InnoDB 복합 인덱스와 Left-most Prefix 원칙 정리</title>
      <link>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</link>
      <pubDate>Sun, 30 Nov 2025 13:07:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-composite-index-left-most-prefix-cb4ef3/</guid>
      <description>&lt;p&gt;InnoDB에서 여러 컬럼을 묶어 복합 인덱스를 만들면 정의된 순서대로 값을 결합해 B-Tree에 저장됨. 예를 들어 &lt;code&gt;(colA, colB, colC)&lt;/code&gt; 인덱스면 &lt;code&gt;colA&lt;/code&gt; 기준으로 정렬되고 같은 &lt;code&gt;colA&lt;/code&gt; 그룹 내에서 &lt;code&gt;colB&lt;/code&gt;, 이어서 &lt;code&gt;colC&lt;/code&gt; 순으로 정렬됨. 이 구조 때문에 왼쪽 접두사(Left-most prefix) 원칙이 성립하며, 인덱스 정의의 선두 컬럼부터 조건이 주어질수록 효율이 높아짐&lt;/p&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 정의 순서대로 키를 묶어 B-Tree에 저장&lt;/li&gt;
&lt;li&gt;InnoDB의 보조 인덱스는 리프에 보조키와 함께 PK를 포함함. PK 길이가 길면 보조 인덱스 크기와 I/O에 직접 영향&lt;/li&gt;
&lt;li&gt;left-most prefix 원칙이 핵심. 인덱스의 선두 컬럼부터 연속해서 매칭될 때 탐색 범위가 급격히 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식-예시-cola-colb&#34;&gt;동작 방식 예시 &lt;code&gt;(colA, colB)&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;인덱스 구조&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;정렬 키 순서: &lt;code&gt;colA&lt;/code&gt; → &lt;code&gt;colB&lt;/code&gt; → 내부적으로 PK 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;왼쪽 컬럼 우선 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE colA = ?&lt;/code&gt; 또는 &lt;code&gt;WHERE colA = ? AND colB = ?&lt;/code&gt; 형태는 인덱스를 온전히 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE colB = ?&lt;/code&gt;처럼 선두 컬럼 없이 후행 컬럼만 조건일 때는 인덱스 이용이 제한되거나 범위가 매우 넓어짐. 최신 버전에서 옵티마이저가 제한적으로 우회 전략을 쓰는 경우가 있으나 일반적인 기대값으로 두기 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;왼쪽 접두사 부분 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(colA, colB)&lt;/code&gt;에서 &lt;code&gt;colA&lt;/code&gt;만 조건으로 사용해도 인덱스 사용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colA&lt;/code&gt;와 &lt;code&gt;colB&lt;/code&gt;를 모두 조건으로 사용하면 탐색 범위가 더 좁아짐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;colB&lt;/code&gt;만 조건이면 left-most prefix가 깨져 효과가 급감할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;정렬과 결합 사용의 기본&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 키 순서와 같은 &lt;code&gt;ORDER BY colA, colB&lt;/code&gt;는 추가 정렬 비용 감소에 도움&lt;/li&gt;
&lt;li&gt;WHERE 조건이 인덱스 선두를 건너뛰거나 정렬 순서가 키 정의와 다르면 이점이 줄어듦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;여러-컬럼을-묶는-이유&#34;&gt;여러 컬럼을 묶는 이유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다중 조건 검색 성능 향상. 예: &lt;code&gt;WHERE colA = ? AND colB BETWEEN ? AND ?&lt;/code&gt;는 &lt;code&gt;(colA, colB)&lt;/code&gt;로 빠른 범위 스캔 가능&lt;/li&gt;
&lt;li&gt;커버링 인덱스 활용. 예: &lt;code&gt;SELECT colA, colB FROM T WHERE colA = ? AND colB = ?&lt;/code&gt;에서 테이블 추가 접근 없이 인덱스만으로 결과 충족 가능&lt;/li&gt;
&lt;li&gt;쿼리 패턴 최적화. 실제 WHERE 절에서 자주 함께 쓰는 컬럼을 순서까지 고려해 묶는 설계가 유효. 드물게 쓰이거나 고카디널리티 이점이 없는 컬럼을 무리하게 포함하면 쓰기 비용만 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의할-점&#34;&gt;주의할 점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인덱스 정의 순서가 성능을 좌우. 자주 필터링되는 컬럼, 카디널리티가 높은 컬럼을 선두에 두는 것이 일반적 권장&lt;/li&gt;
&lt;li&gt;너무 많은 컬럼을 묶으면 인덱스 폭과 관리 비용 증가. 보통 2~3개, 많아도 4개 이하로 목적에 맞게 제한&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A, B, C)&lt;/code&gt;일 때 &lt;code&gt;WHERE B = ?&lt;/code&gt;처럼 선두가 빠지면 인덱스 사용이 제한. 패턴에 따라 &lt;code&gt;(B, A)&lt;/code&gt; 같은 보완 인덱스 검토&lt;/li&gt;
&lt;li&gt;InnoDB 보조 인덱스는 PK를 함께 가진다는 점을 고려. PK가 길면 복합 인덱스 크기와 캐시 효율, 쓰기 비용에 불리&lt;/li&gt;
&lt;li&gt;ORDER BY, GROUP BY와 결합 시 인덱스 정의 순서와 일치할 때 이점. 중간에 범위 조건이 끼거나 순서가 어긋나면 효과 하락&lt;/li&gt;
&lt;li&gt;범위 조건 이후 컬럼 활용 제한 가능. 예를 들어 &lt;code&gt;colA BETWEEN ...&lt;/code&gt;가 선두에 오면 그 뒤 &lt;code&gt;colB&lt;/code&gt;는 정렬이나 추가 필터에서 기대만큼 활용되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;복합 인덱스는 왼쪽부터 순차적으로 정렬되는 구조이며 left-most prefix 원칙이 적용됨&lt;/li&gt;
&lt;li&gt;다중 컬럼 조건, 범위 스캔, 정렬이나 그룹 연산에 유용하지만 인덱스 정의 순서가 쿼리 패턴과 맞지 않으면 이점을 잃음&lt;/li&gt;
&lt;li&gt;불필요하게 많은 컬럼을 포함하면 쓰기 부담과 스토리지 사용량만 증가. 실제 트래픽 패턴과 카디널리티를 근거로 최소한의 조합과 올바른 순서를 선택하는 것이 핵심&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참고자료&#34;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&#34;&gt;https://dev.mysql.com/doc/refman/8.0/en/covering-indexes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>MySQL 테이블 이름 변경 RENAME TABLE vs ALTER TABLE 정리</title>
      <link>https://blog.jsontapose.com/posts/mysql-rename-table-vs-alter-table-470e90/</link>
      <pubDate>Mon, 24 Nov 2025 13:12:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-rename-table-vs-alter-table-470e90/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 이름 변경은 ALTER TABLE로도 가능하지만, RENAME TABLE을 쓰면 다수 테이블을 한 번에 처리 가능하며 같은 서버 내 다른 데이터베이스로 이동까지 가능함&lt;/p&gt;
&lt;h3 id=&#34;핵심-차이&#34;&gt;핵심 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ALTER TABLE RENAME은 단일 테이블 대상&lt;/li&gt;
&lt;li&gt;RENAME TABLE은 여러 테이블을 한 문장으로 변경 가능&lt;/li&gt;
&lt;li&gt;스키마 간 이동 지원 current_db.table에서 other_db.table로 변경 가능&lt;/li&gt;
&lt;li&gt;동일 트랜잭션처럼 동작하는 원자성 제공, 다중 변경 중 하나라도 실패 시 전체 미적용&lt;/li&gt;
&lt;li&gt;권한 요구 사항 존재, 원본 테이블에 ALTER와 DROP, 대상 스키마에 CREATE 권한 필요&lt;/li&gt;
&lt;li&gt;트리거와 외래키 메타데이터는 함께 유지되나, 뷰나 저장 프로시저의 하드코딩된 참조는 자동 갱신되지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용법&#34;&gt;사용법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 테이블 이름 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;RENAME TABLE old_table TO new_table;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;단일 테이블 이름 변경 ALTER 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ALTER TABLE old_table RENAME new_table;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다수 테이블 이름 일괄 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;RENAME TABLE old_table1 TO new_table1,
             old_table2 TO new_table2,
             old_table3 TO new_table3;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;다른 데이터베이스로 이동 같은 서버 내&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;RENAME TABLE current_db.table_name TO other_db.table_name;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;주의-사항&#34;&gt;주의 사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대상 이름이 이미 존재하면 실패&lt;/li&gt;
&lt;li&gt;교차 서버 이동 불가, 같은 서버 인스턴스 내 스키마 간 이동만 가능&lt;/li&gt;
&lt;li&gt;실행 시 메타데이터 락 획득, 짧은 구간 동안 읽기나 쓰기 대기 가능&lt;/li&gt;
&lt;li&gt;배치 변경 전 사전 검증 권장, 이름 충돌 여부와 권한 확인&lt;/li&gt;
&lt;li&gt;뷰나 프로시저 참조는 수동 점검 필요, 린트나 간단한 탐색 쿼리로 영향 범위 확인 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정리&#34;&gt;정리&lt;/h3&gt;
&lt;p&gt;단일 변경만 필요하면 ALTER로 충분하나, 다수 변경이나 스키마 이동까지 고려하면 RENAME TABLE이 더 실용적 선택
원자적 일괄 변경과 스키마 간 이동을 활용하되, 권한과 의존성 영향 검증을 선행할 것&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</link>
      <pubDate>Fri, 31 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 &lt;strong&gt;메모리에 캐싱&lt;/strong&gt;하는 영역임
디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임
InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 &lt;strong&gt;심장부&lt;/strong&gt;라 할 수 있음&lt;/p&gt;
&lt;p&gt;쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;버퍼-풀-구성-요소&#34;&gt;버퍼 풀 구성 요소&lt;/h2&gt;
&lt;p&gt;버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터 페이지&lt;/strong&gt;: 실제 테이블 로우(Row)가 저장된 페이지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인덱스 페이지&lt;/strong&gt;: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기타 관리 페이지&lt;/strong&gt;: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;페이지-캐싱&#34;&gt;페이지 캐싱&lt;/h3&gt;
&lt;p&gt;InnoDB는 디스크 데이터를 페이지 단위로 다룸
클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 &lt;strong&gt;페이지 전체&lt;/strong&gt;를 버퍼 풀로 가져옴
이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</title>
      <link>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</link>
      <pubDate>Sun, 26 Oct 2025 13:07:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임
대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함
사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함
이때 결정 규칙이 존재함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용&lt;/li&gt;
&lt;li&gt;그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함
따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL EXPLAIN 실행 계획 해석 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</link>
      <pubDate>Wed, 15 Oct 2025 13:10:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구
병목 파악과 인덱스 전략 점검에 사용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select_type
&lt;ul&gt;
&lt;li&gt;SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음&lt;/li&gt;
&lt;li&gt;PRIMARY 가장 바깥쪽 SELECT&lt;/li&gt;
&lt;li&gt;SUBQUERY 서브쿼리&lt;/li&gt;
&lt;li&gt;DERIVED FROM 절의 서브쿼리&lt;/li&gt;
&lt;li&gt;UNION UNION의 두 번째 이후 SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 실행 품질 지표, 위에서 아래로 유리
&lt;ul&gt;
&lt;li&gt;system 테이블에 단 하나의 행&lt;/li&gt;
&lt;li&gt;const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회&lt;/li&gt;
&lt;li&gt;eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭&lt;/li&gt;
&lt;li&gt;ref 인덱스를 사용한 동등 조건 검색&lt;/li&gt;
&lt;li&gt;range 인덱스를 사용한 범위 검색&lt;/li&gt;
&lt;li&gt;index 인덱스 전체 스캔&lt;/li&gt;
&lt;li&gt;ALL 테이블 전체 스캔, 최악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음&lt;/li&gt;
&lt;li&gt;key 실제 사용된 인덱스, NULL이면 인덱스 미사용&lt;/li&gt;
&lt;li&gt;rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리&lt;/li&gt;
&lt;li&gt;filtered 조건 후 남는 행 비율 추정치, 높을수록 유리&lt;/li&gt;
&lt;li&gt;Extra 추가 단서
&lt;ul&gt;
&lt;li&gt;Using index 커버링 인덱스 사용, 유리&lt;/li&gt;
&lt;li&gt;Using where WHERE 조건으로 필터링 수행&lt;/li&gt;
&lt;li&gt;Using filesort 추가 정렬 필요, 비용 큼&lt;/li&gt;
&lt;li&gt;Using temporary 임시 테이블 사용, 비용 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해석-기준&#34;&gt;해석 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type이 const, ref, range 범주에 위치&lt;/li&gt;
&lt;li&gt;key가 NULL이 아니고 적절한 인덱스 선택&lt;/li&gt;
&lt;li&gt;rows 추정치가 작고 filtered 비율이 높음&lt;/li&gt;
&lt;li&gt;Extra에 Using filesort, Using temporary 부재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시와-해석&#34;&gt;예시와 해석&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;type: ALL
possible_keys: NULL
rows: 3527425
Extra: Using where; Using filesort&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;테이블 전체 스캔으로 많은 행을 읽게 됨&lt;/li&gt;
&lt;li&gt;인덱스 후보와 실제 사용 인덱스가 없음&lt;/li&gt;
&lt;li&gt;WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승&lt;/li&gt;
&lt;li&gt;현재 계획은 인덱스 설계와 조건식 재검토 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rows와 filtered는 통계 기반 추정치라 실제와 오차 가능&lt;/li&gt;
&lt;li&gt;filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용&lt;/li&gt;
&lt;li&gt;Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려&lt;/li&gt;
&lt;li&gt;커버링 인덱스 구성 시 Extra의 Using index로 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기
위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
