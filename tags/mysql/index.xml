<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Mysql on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/mysql/</link>
    <description>Recent content in Mysql on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 31 Oct 2025 13:10:20 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL InnoDB 버퍼 풀 개념과 동작 원리, 크기 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</link>
      <pubDate>Fri, 31 Oct 2025 13:10:20 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-innodb-buffer-pool-c63a29/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;InnoDB 버퍼 풀은 데이터와 인덱스 페이지를 &lt;strong&gt;메모리에 캐싱&lt;/strong&gt;하는 영역임
디스크 I/O를 획기적으로 줄여 지연 시간을 낮추는 게 목적임
InnoDB 스토리지 엔진(트랜잭션, MVCC, 행 단위 락 지원) 성능의 &lt;strong&gt;심장부&lt;/strong&gt;라 할 수 있음&lt;/p&gt;
&lt;p&gt;쉽게 말해, 자주 쓰는 데이터와 인덱스를 디스크 대신 메모리에 올려두고 처리하는 구조임&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;버퍼-풀-구성-요소&#34;&gt;버퍼 풀 구성 요소&lt;/h2&gt;
&lt;p&gt;버퍼 풀에는 주로 이런 페이지(기본 16KB)가 올라옴&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;데이터 페이지&lt;/strong&gt;: 실제 테이블 로우(Row)가 저장된 페이지&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인덱스 페이지&lt;/strong&gt;: B-Tree 인덱스 노드 페이지 (PK 및 세컨더리 인덱스 포함)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기타 관리 페이지&lt;/strong&gt;: UNDO 페이지, 트랜잭션/MVCC 관리에 필요한 메타데이터 등&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h2&gt;
&lt;h3 id=&#34;페이지-캐싱&#34;&gt;페이지 캐싱&lt;/h3&gt;
&lt;p&gt;InnoDB는 디스크 데이터를 페이지 단위로 다룸
클라이언트가 특정 로우를 읽고 싶어 하면, 그 로우가 속한 &lt;strong&gt;페이지 전체&lt;/strong&gt;를 버퍼 풀로 가져옴
이후 같은 페이지에 있는 다른 로우를 읽을 때는 디스크를 다시 보지 않고 버퍼 풀(메모리)에서 바로 조회함&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB에서 PK 없는 테이블의 동작과 트레이드오프</title>
      <link>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</link>
      <pubDate>Sun, 26 Oct 2025 13:07:10 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/innodb-pk-less-tables-trade-offs-2dc695/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;InnoDB는 데이터를 클러스터형 인덱스 기준으로 저장하는 스토리지 엔진임
대부분의 테이블에서 이 클러스터형 인덱스는 프라이머리 키가 담당함
사용자가 명시적으로 PK를 정의하지 않은 경우에도 InnoDB는 테이블에 클러스터 키를 반드시 갖도록 함
이때 결정 규칙이 존재함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;먼저 NOT NULL 제약을 가진 유니크 인덱스가 있으면 그것을 클러스터형 인덱스로 사용&lt;/li&gt;
&lt;li&gt;그런 인덱스가 없으면 내부 6바이트 row_id를 생성해 숨김 PK로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세컨더리 인덱스는 항상 클러스터 키를 포함하여 룩업을 수행함
따라서 명시적 PK가 없더라도 내부적으로는 클러스터 키가 존재하며 저장과 탐색 경로의 기준으로 동작함&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL EXPLAIN 실행 계획 해석 가이드</title>
      <link>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</link>
      <pubDate>Wed, 15 Oct 2025 13:10:54 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-explain-execution-plan-guide-b7fb65/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 SELECT가 어떤 경로로 데이터를 읽는지 드러내는 도구
병목 파악과 인덱스 전략 점검에 사용&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select_type
&lt;ul&gt;
&lt;li&gt;SIMPLE 단순 SELECT, 서브쿼리나 UNION 없음&lt;/li&gt;
&lt;li&gt;PRIMARY 가장 바깥쪽 SELECT&lt;/li&gt;
&lt;li&gt;SUBQUERY 서브쿼리&lt;/li&gt;
&lt;li&gt;DERIVED FROM 절의 서브쿼리&lt;/li&gt;
&lt;li&gt;UNION UNION의 두 번째 이후 SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;type 실행 품질 지표, 위에서 아래로 유리
&lt;ul&gt;
&lt;li&gt;system 테이블에 단 하나의 행&lt;/li&gt;
&lt;li&gt;const PRIMARY KEY 또는 UNIQUE 인덱스 단건 조회&lt;/li&gt;
&lt;li&gt;eq_ref 조인에서 PRIMARY KEY 또는 UNIQUE로 정확히 1행 매칭&lt;/li&gt;
&lt;li&gt;ref 인덱스를 사용한 동등 조건 검색&lt;/li&gt;
&lt;li&gt;range 인덱스를 사용한 범위 검색&lt;/li&gt;
&lt;li&gt;index 인덱스 전체 스캔&lt;/li&gt;
&lt;li&gt;ALL 테이블 전체 스캔, 최악&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;possible_keys 사용 가능한 인덱스 목록, NULL이면 후보 없음&lt;/li&gt;
&lt;li&gt;key 실제 사용된 인덱스, NULL이면 인덱스 미사용&lt;/li&gt;
&lt;li&gt;rows 옵티마이저가 읽을 것으로 추정한 행 수, 낮을수록 유리&lt;/li&gt;
&lt;li&gt;filtered 조건 후 남는 행 비율 추정치, 높을수록 유리&lt;/li&gt;
&lt;li&gt;Extra 추가 단서
&lt;ul&gt;
&lt;li&gt;Using index 커버링 인덱스 사용, 유리&lt;/li&gt;
&lt;li&gt;Using where WHERE 조건으로 필터링 수행&lt;/li&gt;
&lt;li&gt;Using filesort 추가 정렬 필요, 비용 큼&lt;/li&gt;
&lt;li&gt;Using temporary 임시 테이블 사용, 비용 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해석-기준&#34;&gt;해석 기준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type이 const, ref, range 범주에 위치&lt;/li&gt;
&lt;li&gt;key가 NULL이 아니고 적절한 인덱스 선택&lt;/li&gt;
&lt;li&gt;rows 추정치가 작고 filtered 비율이 높음&lt;/li&gt;
&lt;li&gt;Extra에 Using filesort, Using temporary 부재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시와-해석&#34;&gt;예시와 해석&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;type: ALL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;possible_keys: NULL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rows: 3527425
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Extra: Using where; Using filesort
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;테이블 전체 스캔으로 많은 행을 읽게 됨&lt;/li&gt;
&lt;li&gt;인덱스 후보와 실제 사용 인덱스가 없음&lt;/li&gt;
&lt;li&gt;WHERE로 필터링하고 추가 정렬까지 수행하여 비용 상승&lt;/li&gt;
&lt;li&gt;현재 계획은 인덱스 설계와 조건식 재검토 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-팁&#34;&gt;주의와 팁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rows와 filtered는 통계 기반 추정치라 실제와 오차 가능&lt;/li&gt;
&lt;li&gt;filtered는 대략 rows × filtered%로 남는 행 규모 가늠에 사용&lt;/li&gt;
&lt;li&gt;Using filesort가 항상 나쁜 것은 아님, 결과 집합이 매우 작으면 영향 미미할 수 있음&lt;/li&gt;
&lt;li&gt;인덱스 생성 시 조건 컬럼의 선택도와 정렬·조인 키 우선 고려&lt;/li&gt;
&lt;li&gt;커버링 인덱스 구성 시 Extra의 Using index로 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;EXPLAIN은 증상 관찰 도구, 원인은 스키마 설계와 조건식, 인덱스 전략에서 찾기
위 지표를 기준으로 스캔 범위를 줄이고 불필요한 정렬과 임시 테이블을 제거하는 방향으로 개선 시도 권장&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
