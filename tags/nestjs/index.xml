<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nestjs on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/nestjs/</link>
    <description>Recent content in Nestjs on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 07 Dec 2025 13:07:35 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/nestjs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SSE란? 실시간 이벤트 전달 프로토콜 (Server-Sent Events)</title>
      <link>https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</link>
      <pubDate>Sat, 25 Oct 2025 13:06:24 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sse-realtime-notification-architecture-nestjs-redis-pub-sub-f4346d/</guid>
      <description>&lt;h1 id=&#34;sseserver-sent-events란-무엇인가&#34;&gt;SSE(Server-Sent Events)란 무엇인가&lt;/h1&gt;
&lt;p&gt;SSE는 &lt;strong&gt;Server-Sent Events&lt;/strong&gt;의 약자로, 서버가 클라이언트로 &lt;strong&gt;실시간 데이터를 단방향으로 푸시&lt;/strong&gt;(push)할 수 있게 해주는 웹 기술임
클라이언트가 먼저 요청을 보내고 서버는 그 연결을 끊지 않은 채, 새로운 데이터가 생길 때마다 지속적으로 응답을 보내는 방식임&lt;/p&gt;
&lt;p&gt;주로 실시간 알림, 주식 시세 업데이트, 라이브 피드 등 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 경우에 매우 유용함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sse-vs-웹소켓-그리고-한계&#34;&gt;SSE vs 웹소켓, 그리고 한계&lt;/h2&gt;
&lt;p&gt;SSE는 실시간 이벤트 전송에 유용하지만 만능은 아님. 웹소켓과 비교했을 때 명확한 장단점이 존재함&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS forRoot()와 forFeature의 의미와 사용 패턴</title>
      <link>https://blog.jsontapose.com/posts/nestjs-forroot-forfeature-usage-patterns-922927/</link>
      <pubDate>Sun, 07 Dec 2025 13:07:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-forroot-forfeature-usage-patterns-922927/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;forRoot()는 모듈이 동작하기 위한 전역 설정을 애플리케이션에 한 번만 주입하기 위한 관례적 팩토리 메서드임. 루트 모듈에서 호출해 싱글톤 리소스와 전역 프로바이더를 구성하는 용도에 해당함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반 import: 기능 모듈을 여러 곳에서 자유롭게 가져오는 방식&lt;/li&gt;
&lt;li&gt;forRoot(): 설정과 함께 모듈을 초기화하는 진입점. 애플리케이션 전역 단 한 번 호출 전제&lt;/li&gt;
&lt;li&gt;위치: 루트 모듈 또는 엔트리 모듈에서만 사용 권장&lt;/li&gt;
&lt;li&gt;대표 예시: ConfigModule.forRoot, TypeOrmModule.forRoot, ScheduleModule.forRoot 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NestJS 동적 모듈 패턴 기반. forRoot()는 내부적으로 DynamicModule을 반환해 프로바이더와 설정 값을 주입&lt;/li&gt;
&lt;li&gt;전역 리소스 초기화 책임을 가짐. 예) 데이터베이스 커넥션 풀, 작업 스케줄러, 구성 설정 캐시 등 싱글톤 리소스&lt;/li&gt;
&lt;li&gt;isGlobal 옵션을 제공하는 경우 전역 범위로 프로바이더를 노출하도록 설계됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;일반-import-vs-forroot-비교&#34;&gt;일반 import vs forRoot 비교&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반 모듈: 재사용 기능 제공, 여러 모듈에서 중복 import 가능&lt;/li&gt;
&lt;li&gt;forRoot 모듈: 전역 설정 + 리소스 초기화, 한 번만 호출해야 함&lt;/li&gt;
&lt;li&gt;잘못된 사용 시 문제: 전역 리소스가 중복 생성되어 의도치 않은 다중 실행, 커넥션 중복, 메모리 증가 등 부작용 유발 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;schedulemoduleforroot-동작&#34;&gt;ScheduleModule.forRoot 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Cron 기반 스케줄러 싱글톤 생성&lt;/li&gt;
&lt;li&gt;@Cron 등 데코레이터로 선언된 작업 탐색 및 등록 수행&lt;/li&gt;
&lt;li&gt;타이머 시작으로 실제 스케줄 실행 트리거&lt;/li&gt;
&lt;li&gt;두 번 호출 시 스케줄러와 작업 등록이 중복되어 동일 작업이 두 번 이상 실행되는 현상 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;forroot--forfeature-구분&#34;&gt;forRoot / forFeature 구분&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;forRoot: 앱 전역 설정과 초기화 담당. 호출 1회 원칙&lt;/li&gt;
&lt;li&gt;forFeature: 특정 기능 단위 등록용. 예) ORM 엔티티, 리포지토리, 서브기능. 필요 모듈에서 여러 번 호출 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스&#34;&gt;베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;전역 리소스 초기화가 필요한 모듈만 forRoot 사용&lt;/li&gt;
&lt;li&gt;forRoot는 루트 모듈 또는 해당 기능을 대표하는 엔트리 모듈 한 곳에서만 호출&lt;/li&gt;
&lt;li&gt;기능 단위 확장은 forFeature로 분리하여 의존성 범위를 최소화&lt;/li&gt;
&lt;li&gt;전역 설정이 필요하면 isGlobal 옵션 고려. 불필요한 재노출 방지를 위해 범위 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;간단-예시&#34;&gt;간단 예시&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 루트 모듈에서만 전역 초기화 수행
@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    TypeOrmModule.forRoot({ host: &amp;#39;localhost&amp;#39; }),
    ScheduleModule.forRoot(),
  ],
})
class AppModule {}&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// 기능 모듈에서는 필요한 리소스만 forFeature로 등록
@Module({ imports: [TypeOrmModule.forFeature([UserEntity, PostEntity])] })
class FeatureModule {}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;forRoot()는 전역 초기화와 설정 전달을 한 번에 묶는 패턴. 위치와 호출 횟수를 통제하지 않으면 전역 리소스 중복 문제로 이어짐. 전역은 forRoot, 기능 단위는 forFeature로 역할을 분리하고, 루트에서 한 번만 초기화하는 규칙을 지키는 것이 핵심임&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법</title>
      <link>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</link>
      <pubDate>Thu, 30 Oct 2025 13:11:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임
DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함
핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임&lt;/p&gt;
&lt;h3 id=&#34;apiproperty-개념과-사용&#34;&gt;ApiProperty 개념과 사용&lt;/h3&gt;
&lt;p&gt;@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임
타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공
코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함&lt;/p&gt;
&lt;p&gt;간단 사용 예시&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;class CreateUserDto {
  @ApiProperty({ description: &amp;#34;사용자 이름&amp;#34;, example: &amp;#34;John Doe&amp;#34; })
  name: string;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
