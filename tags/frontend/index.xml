<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Frontend on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/frontend/</link>
    <description>Recent content in Frontend on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 21 Feb 2026 13:16:03 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/frontend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSS 상대 단위 em과 rem: 기준, 계산, 선택 가이드</title>
      <link>https://blog.jsontapose.com/posts/css-em-rem-guide-e17481/</link>
      <pubDate>Sat, 21 Feb 2026 13:16:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/css-em-rem-guide-e17481/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;반응형 레이아웃과 접근성 요구가 커지면서 px 고정값 대신 em, rem 같은 상대 단위 사용 빈도 증가
두 단위 모두 글꼴 크기(font-size)를 기준으로 동작하지만 기준점이 다름
핵심은 기준이 어디인지 명확히 이해하고 일관된 스케일로 적용하는 것&lt;/p&gt;
&lt;p&gt;콘텐츠가 없어도 블록 요소 높이를 유지해야 하는 경우 같은 실무 이슈에서 min-height를 em이나 rem로 정의해 타이포 스케일에 연동하는 방식 유용함&lt;/p&gt;
&lt;h3 id=&#34;상대-단위-개념&#34;&gt;상대 단위 개념&lt;/h3&gt;
&lt;p&gt;상대(relative) 단위는 주어진 기준에 따라 유동적으로 값이 변하는 길이 단위
em, rem, %, vw, vh 등이 대표
절대(absolute) 단위는 상황과 무관하게 고정된 길이로 취급하는 단위군으로 px, pt, cm, in 등이 포함됨
참고 기준으로 CSS에서 1px는 1/96in에 해당하는 길이로 정의됨. 실제 디바이스의 물리 픽셀과는 분리된 개념&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unobtrusive JavaScript와 HTML·JS 분리 원칙</title>
      <link>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</link>
      <pubDate>Sun, 15 Feb 2026 13:17:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Unobtrusive JavaScript는 HTML 구조와 JS 동작을 분리하는 접근 철학
HTML은 의미와 콘텐츠, CSS는 표현, JS는 상호작용과 상태 제어 담당
인라인 스크립트와 이벤트 속성 제거, 외부 스크립트에서 안전하게 바인딩하는 방식 지향&lt;/p&gt;
&lt;p&gt;핵심 목표는 접근성 보장, 점진적 향상, 유지보수성과 테스트 용이성 개선, 캐시 효율 상승, 보안 취약점 노출 감소&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTML은 의미 중심 마크업 유지&lt;/li&gt;
&lt;li&gt;CSS는 표현만 담당&lt;/li&gt;
&lt;li&gt;JS는 DOMContentLoaded 이후 동작 주입&lt;/li&gt;
&lt;li&gt;인라인 onclick 등 이벤트 속성 사용 금지&lt;/li&gt;
&lt;li&gt;기능 감지 우선, UA 스니핑 지양&lt;/li&gt;
&lt;li&gt;데이터 훅은 data-* 속성 사용, 스타일 훅과 분리&lt;/li&gt;
&lt;li&gt;JS 미동작 상황에서도 기본 기능 유지, 점진적 향상 고려&lt;/li&gt;
&lt;li&gt;모듈 분리와 의존성 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;p&gt;마크업은 링크와 폼이 기본 동작을 스스로 제공하도록 설계
JS는 존재하면 기본 동작을 확장하거나 향상
이벤트 바인딩은 외부 스크립트에서 선택자 기반으로 수행, 인라인 스크립트 제거&lt;/p&gt;</description>
    </item>
    <item>
      <title>a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer</title>
      <link>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</link>
      <pubDate>Fri, 13 Feb 2026 13:25:25 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;링크를 새 탭에서 열 때 a 태그에 target=&amp;quot;_blank&amp;quot;를 많이 사용함
이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음
rel=&amp;ldquo;noopener noreferrer&amp;quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;target: 링크 대상 브라우징 컨텍스트 지정&lt;/li&gt;
&lt;li&gt;window.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체&lt;/li&gt;
&lt;li&gt;rel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지&lt;/li&gt;
&lt;li&gt;rel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target-값-정리&#34;&gt;target 값 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;_self: 현재 탭에서 열기, 기본값이라 명시 생략 가능&lt;/li&gt;
&lt;li&gt;_blank: 새 탭에서 열기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target_blank만-사용할-때의-문제&#34;&gt;target=&amp;quot;_blank&amp;quot;만 사용할 때의 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;보안 취약점 발생 가능
악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재
원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음&lt;/li&gt;
&lt;li&gt;성능 간섭 가능성
새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음
무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rel=&amp;ldquo;noopener&amp;rdquo;
새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단
탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화&lt;/li&gt;
&lt;li&gt;rel=&amp;ldquo;noreferrer&amp;rdquo;
이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지
분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;필수 최소 속성만 명시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드</title>
      <link>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</link>
      <pubDate>Mon, 02 Feb 2026 13:24:37 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;차세대 프론트엔드 빌드 도구 Vite 요약
Vue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤
프랑스어로 vite는 빠름을 의미함&lt;/p&gt;
&lt;p&gt;핵심 가치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발 서버 즉시 기동에 가까운 체감 속도&lt;/li&gt;
&lt;li&gt;HMR이 가볍고 빠르게 동작&lt;/li&gt;
&lt;li&gt;의존성 프리번들을 esbuild로 처리해 개발 경험 가속&lt;/li&gt;
&lt;li&gt;프로덕션 빌드는 Rollup으로 안정적 번들 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;배경과-문제&#34;&gt;배경과 문제&lt;/h3&gt;
&lt;p&gt;기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 규모가 커질수록 첫 기동이 지연&lt;/li&gt;
&lt;li&gt;코드 변경 반영 또한 번들 재생성 비용으로 지연 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발 체감 문제&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.map 개념과 사용법 정리</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</link>
      <pubDate>Sat, 15 Nov 2025 13:07:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Array.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임
원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임&lt;/p&gt;
&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; newArray &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; index&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;element 현재 요소&lt;/li&gt;
&lt;li&gt;index 현재 인덱스&lt;/li&gt;
&lt;li&gt;array 원본 배열 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨&lt;/p&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;숫자 배열 변환&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; numbers &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; doubled &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;n&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; n &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// [2, 4, 6, 8, 10]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체 배열에서 특정 속성 추출&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
