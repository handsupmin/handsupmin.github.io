<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Frontend on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/frontend/</link>
    <description>Recent content in Frontend on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 13 Feb 2026 13:25:25 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/frontend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer</title>
      <link>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</link>
      <pubDate>Fri, 13 Feb 2026 13:25:25 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;링크를 새 탭에서 열 때 a 태그에 target=&amp;quot;_blank&amp;quot;를 많이 사용함
이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음
rel=&amp;ldquo;noopener noreferrer&amp;quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;target: 링크 대상 브라우징 컨텍스트 지정&lt;/li&gt;
&lt;li&gt;window.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체&lt;/li&gt;
&lt;li&gt;rel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지&lt;/li&gt;
&lt;li&gt;rel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target-값-정리&#34;&gt;target 값 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;_self: 현재 탭에서 열기, 기본값이라 명시 생략 가능&lt;/li&gt;
&lt;li&gt;_blank: 새 탭에서 열기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target_blank만-사용할-때의-문제&#34;&gt;target=&amp;quot;_blank&amp;quot;만 사용할 때의 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;보안 취약점 발생 가능
악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재
원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음&lt;/li&gt;
&lt;li&gt;성능 간섭 가능성
새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음
무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rel=&amp;ldquo;noopener&amp;rdquo;
새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단
탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화&lt;/li&gt;
&lt;li&gt;rel=&amp;ldquo;noreferrer&amp;rdquo;
이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지
분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;필수 최소 속성만 명시&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vite 개요와 작동 원리 — ESM 기반 개발 서버, esbuild 프리번들, Rollup 빌드</title>
      <link>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</link>
      <pubDate>Mon, 02 Feb 2026 13:24:37 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vite-esm-esbuild-rollup-overview-dc5ca1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;차세대 프론트엔드 빌드 도구 Vite 요약
Vue.js 창시자 Evan You가 만들었고, 개발 중 대기 시간을 줄이는 데 초점 맞춤
프랑스어로 vite는 빠름을 의미함&lt;/p&gt;
&lt;p&gt;핵심 가치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발 서버 즉시 기동에 가까운 체감 속도&lt;/li&gt;
&lt;li&gt;HMR이 가볍고 빠르게 동작&lt;/li&gt;
&lt;li&gt;의존성 프리번들을 esbuild로 처리해 개발 경험 가속&lt;/li&gt;
&lt;li&gt;프로덕션 빌드는 Rollup으로 안정적 번들 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;배경과-문제&#34;&gt;배경과 문제&lt;/h3&gt;
&lt;p&gt;기존 번들러(Webpack) 방식은 시작 시 전체 그래프를 사전 번들링하는 구조&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 규모가 커질수록 첫 기동이 지연&lt;/li&gt;
&lt;li&gt;코드 변경 반영 또한 번들 재생성 비용으로 지연 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개발 체감 문제&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaScript Array.prototype.map 개념과 사용법 정리</title>
      <link>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</link>
      <pubDate>Sat, 15 Nov 2025 13:07:01 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-array-prototype-map-01352e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Array.prototype.map은 배열의 각 요소에 대해 콜백을 호출해 변환된 결과로 새 배열을 만드는 메서드임
원본 배열 불변 유지, 동일 길이의 새 배열 생성이 핵심 특징임&lt;/p&gt;
&lt;h3 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; newArray &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;element&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; index&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; array&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; element&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;element 현재 요소&lt;/li&gt;
&lt;li&gt;index 현재 인덱스&lt;/li&gt;
&lt;li&gt;array 원본 배열 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;콜백은 요소 수만큼 호출되고, 콜백의 반환값이 새 배열의 같은 위치에 배치됨&lt;/p&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;숫자 배열 변환&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; numbers &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; doubled &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;map&lt;span style=&#34;color:#eceff4&#34;&gt;((&lt;/span&gt;n&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; n &lt;span style=&#34;color:#81a1c1&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// [2, 4, 6, 8, 10]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;객체 배열에서 특정 속성 추출&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
