<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Testing on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/testing/</link>
    <description>Recent content in Testing on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 17 Feb 2026 13:27:05 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Selenium WebDriver pageLoadStrategy 동작 원리와 설정 가이드</title>
      <link>https://blog.jsontapose.com/posts/selenium-webdriver-pageloadstrategy-guide-8cac26/</link>
      <pubDate>Tue, 17 Feb 2026 13:27:05 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/selenium-webdriver-pageloadstrategy-guide-8cac26/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;pageLoadStrategy는 WebDriver가 페이지 이동 명령을 언제 완료로 판단할지 결정하는 세션 단위 설정값임. 핵심은 document.readyState 조회 시점을 어떻게 보느냐이며 전략별 대기 조건이 다름. 기본값은 normal이며, 네트워크 리소스가 많아 느린 페이지에서 eager 또는 none으로 바꿔 세션 체감 속도를 높일 수 있음&lt;/p&gt;
&lt;p&gt;SPA처럼 자바스크립트가 동적으로 화면을 채우는 사이트에서는 readyState가 complete여도 실제 사용자 관점의 완료와 다를 수 있음. 전략 변경 시 명시적 대기 조합 설계가 필수임&lt;/p&gt;
&lt;p&gt;주의할 점은 get 등 URL 기반 내비게이션과 달리, 클릭이나 폼 제출로 발생한 내비게이션에는 동일한 대기 규칙이 그대로 적용되지 않을 수 있음. 이 경우에도 별도의 대기 전략으로 안정성을 확보해야 함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vitest 완벽 가이드</title>
      <link>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</link>
      <pubDate>Sun, 01 Feb 2026 13:16:32 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/vitest-complete-guide-3d3f4f/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Vite 기반의 테스트 프레임워크 Vitest 소개 및 실무 사용 패턴 정리
Jest와 거의 동일한 API를 제공하고, Vite의 ESM/HMR을 활용해 빠른 재실행을 제공함
Vite 프로젝트에서는 최소 설정으로 바로 사용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;빠른 실행과 재실행, watch 효율 높음&lt;/li&gt;
&lt;li&gt;Jest API 호환성 높아 러닝 커브 낮음&lt;/li&gt;
&lt;li&gt;TypeScript 네이티브 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;1-기본-구조&#34;&gt;1. 기본 구조&lt;/h2&gt;
&lt;h3 id=&#34;테스트-파일-명명-규칙&#34;&gt;테스트 파일 명명 규칙&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;*.spec.ts     또는     *.test.ts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;describename-fn&#34;&gt;describe(name, fn)&lt;/h3&gt;
&lt;p&gt;관련 테스트를 그룹화하는 컨테이너&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; describe&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; it&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; expect &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;vitest&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;describe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;계산기&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 더한다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  it&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;두 수를 뺀다&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expect&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;).&lt;/span&gt;toBe&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;첫 번째 인자: 그룹 이름&lt;/li&gt;
&lt;li&gt;두 번째 인자: 테스트 콜백&lt;/li&gt;
&lt;li&gt;중첩 describe 구성 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;itname-fn--testname-fn&#34;&gt;it(name, fn) / test(name, fn)&lt;/h3&gt;
&lt;p&gt;개별 테스트 케이스 정의, 두 API는 동일 동작&lt;/p&gt;</description>
    </item>
    <item>
      <title>유한 상태 머신(FSM) 기본 개념과 적용 포인트</title>
      <link>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</link>
      <pubDate>Sun, 04 Jan 2026 13:10:43 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</guid>
      <description>&lt;p&gt;유한 상태 머신(FSM, Finite State Machine)은 시스템이 가질 수 있는 상태와 그 사이 전이를 명확히 정의하는 모델
복잡한 비즈니스 로직을 단순화하고 예측 가능하게 만들어 결제나 주문처럼 순서와 무결성이 중요한 도메인에 적합&lt;/p&gt;
&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;상태와 규칙을 명시적으로 모델링해 허용되지 않은 동작을 구조적으로 차단하는 접근
요구사항이 늘어도 상태 전이 규칙을 중심으로 변경 범위를 제한해 안정성 확보에 유리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 State
시스템이 존재할 수 있는 유한한 조건 집합
예 로그인 전, 로그인 후, 결제 대기, 결제 완료&lt;/li&gt;
&lt;li&gt;이벤트 또는 입력 Event/Input
상태 변화를 유발하는 외부 행위나 신호
예 버튼 클릭, 네트워크 끊김, 시간 초과&lt;/li&gt;
&lt;li&gt;전이 또는 규칙 Transition/Rule
어떤 상태에서 어떤 이벤트가 발생하면 다음 상태로 이동한다는 정의
규칙에 없는 전이는 거부 또는 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 상태와 입력을 받아 다음 상태를 결정하는 전이 함수 관점으로 해석 가능 f(state, event) -&amp;gt; nextState 형태&lt;/li&gt;
&lt;li&gt;전이에는 가드 조건과 부수효과가 수반될 수 있음
가드는 전이 허용 여부 판단, 부수효과는 알림 전송이나 로그 기록 등 외부 행동을 명시적으로 수행&lt;/li&gt;
&lt;li&gt;정의되지 않은 전이를 막아 비정상 흐름 차단
재진입이나 중복 이벤트 처리 시에도 일관된 행동을 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시-자판기-모델&#34;&gt;예시 자판기 모델&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 대기 중, 이벤트 동전 투입 -&amp;gt; 다음 상태 금액 충족
돈이 들어와야만 다음 상태로 이동&lt;/li&gt;
&lt;li&gt;상태 금액 충족, 이벤트 상품 버튼 누름 -&amp;gt; 다음 상태 상품 배출 중
상품 선택 가능&lt;/li&gt;
&lt;li&gt;상태 상품 배출 중, 이벤트 배출 완료 -&amp;gt; 다음 상태 대기 중
초기 상태로 복귀&lt;/li&gt;
&lt;li&gt;상태 대기 중, 이벤트 상품 버튼 누름 -&amp;gt; 상태 변화 없음
금액 미충족 시 입력 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점과-효과&#34;&gt;장점과 효과&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정합성 보장
정의된 전이 외 동작 불가하므로 데이터 꼬임 예방
결제가 완료 상태에서 결제 요청 이벤트가 다시 들어오면 규칙에 없는 전이로 처리되어 거부 또는 무시되어 중복 결제 차단에 기여 멱등 처리 전략과 결합 시 효과적&lt;/li&gt;
&lt;li&gt;예측 가능성 향상
몇 개의 상태와 전이 규칙으로 복잡도를 축소해 로직 이해와 디버깅 용이&lt;/li&gt;
&lt;li&gt;테스트 용이성
상태 x 이벤트 조합별로 기대 결과가 명확해 단위 테스트 케이스 설계가 단순&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-베스트-프랙티스&#34;&gt;주의와 베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 폭발 주의
의미 있는 상태만 유지하고 파생 속성은 별도 데이터로 관리&lt;/li&gt;
&lt;li&gt;전이 정의의 단일 소스 유지
가드와 부수효과를 전이 정의 근처에 모아 산재된 분기 로직을 제거&lt;/li&gt;
&lt;li&gt;잘못된 전이 로깅과 모니터링 활성화
무시된 입력을 계측해 모델 누락이나 외부 시스템 이상 조기 탐지&lt;/li&gt;
&lt;li&gt;멱등성 고려
중복 이벤트 재수신 가능 환경에서는 전이와 부수효과를 멱등하게 설계&lt;/li&gt;
&lt;li&gt;분산 환경에서는 상태 영속화와 재시도 정책을 명시
크래시 후 재기동 시 일관성 있는 상태 복원 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;FSM은 상태와 전이를 중심으로 시스템 동작을 제한하고 드러내며, 규칙 밖 동작을 원천 차단해 안정성을 끌어올림
결제나 주문 같은 순서 기반 도메인에 특히 유용하며, 상태 정의와 전이 규칙만 명확히 유지하면 변경에도 견고하게 대응 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>DI가 결합도를 낮추는 원리와 최소 예시</title>
      <link>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</link>
      <pubDate>Sun, 09 Nov 2025 13:06:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</guid>
      <description>&lt;h2 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h2&gt;
&lt;p&gt;DI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함
&lt;strong&gt;객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용&lt;/strong&gt;하는 것임
이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;문제-상황-강한-결합-tight-coupling&#34;&gt;문제 상황: 강한 결합 (Tight Coupling)&lt;/h2&gt;
&lt;p&gt;전형적인 문제 패턴은 클래스 내부에서 다른 &lt;strong&gt;구체적인 클래스&lt;/strong&gt;(Concrete Class)를 &lt;code&gt;new&lt;/code&gt; 키워드로 직접 생성하여 사용하는 것임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 &lt;strong&gt;반드시 함께 수정&lt;/strong&gt;해야 함&lt;/li&gt;
&lt;li&gt;단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 &lt;code&gt;Gamer&lt;/code&gt;가 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;를 직접 생성해 사용한다면, &lt;code&gt;Gamer&lt;/code&gt;는 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;라는 구체적인 구현에 영구적으로 고정됨
만약 키보드 종류를 &lt;code&gt;RedSwitchSilentKeyboard&lt;/code&gt;로 바꾸려면 &lt;code&gt;Gamer&lt;/code&gt; 클래스의 내부 코드를 직접 수정해야 함
이 상태를 &lt;strong&gt;결합도가 높다&lt;/strong&gt;고 부름&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
