<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Software-Architecture on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/software-architecture/</link>
    <description>Recent content in Software-Architecture on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 04 Jan 2026 13:10:43 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/software-architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>유한 상태 머신(FSM) 기본 개념과 적용 포인트</title>
      <link>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</link>
      <pubDate>Sun, 04 Jan 2026 13:10:43 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/finite-state-machine-fsm-basics-and-usage-points-ed7623/</guid>
      <description>&lt;p&gt;유한 상태 머신(FSM, Finite State Machine)은 시스템이 가질 수 있는 상태와 그 사이 전이를 명확히 정의하는 모델
복잡한 비즈니스 로직을 단순화하고 예측 가능하게 만들어 결제나 주문처럼 순서와 무결성이 중요한 도메인에 적합&lt;/p&gt;
&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;상태와 규칙을 명시적으로 모델링해 허용되지 않은 동작을 구조적으로 차단하는 접근
요구사항이 늘어도 상태 전이 규칙을 중심으로 변경 범위를 제한해 안정성 확보에 유리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 State
시스템이 존재할 수 있는 유한한 조건 집합
예 로그인 전, 로그인 후, 결제 대기, 결제 완료&lt;/li&gt;
&lt;li&gt;이벤트 또는 입력 Event/Input
상태 변화를 유발하는 외부 행위나 신호
예 버튼 클릭, 네트워크 끊김, 시간 초과&lt;/li&gt;
&lt;li&gt;전이 또는 규칙 Transition/Rule
어떤 상태에서 어떤 이벤트가 발생하면 다음 상태로 이동한다는 정의
규칙에 없는 전이는 거부 또는 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현재 상태와 입력을 받아 다음 상태를 결정하는 전이 함수 관점으로 해석 가능 f(state, event) -&amp;gt; nextState 형태&lt;/li&gt;
&lt;li&gt;전이에는 가드 조건과 부수효과가 수반될 수 있음
가드는 전이 허용 여부 판단, 부수효과는 알림 전송이나 로그 기록 등 외부 행동을 명시적으로 수행&lt;/li&gt;
&lt;li&gt;정의되지 않은 전이를 막아 비정상 흐름 차단
재진입이나 중복 이벤트 처리 시에도 일관된 행동을 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;예시-자판기-모델&#34;&gt;예시 자판기 모델&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 대기 중, 이벤트 동전 투입 -&amp;gt; 다음 상태 금액 충족
돈이 들어와야만 다음 상태로 이동&lt;/li&gt;
&lt;li&gt;상태 금액 충족, 이벤트 상품 버튼 누름 -&amp;gt; 다음 상태 상품 배출 중
상품 선택 가능&lt;/li&gt;
&lt;li&gt;상태 상품 배출 중, 이벤트 배출 완료 -&amp;gt; 다음 상태 대기 중
초기 상태로 복귀&lt;/li&gt;
&lt;li&gt;상태 대기 중, 이벤트 상품 버튼 누름 -&amp;gt; 상태 변화 없음
금액 미충족 시 입력 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;장점과-효과&#34;&gt;장점과 효과&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;정합성 보장
정의된 전이 외 동작 불가하므로 데이터 꼬임 예방
결제가 완료 상태에서 결제 요청 이벤트가 다시 들어오면 규칙에 없는 전이로 처리되어 거부 또는 무시되어 중복 결제 차단에 기여 멱등 처리 전략과 결합 시 효과적&lt;/li&gt;
&lt;li&gt;예측 가능성 향상
몇 개의 상태와 전이 규칙으로 복잡도를 축소해 로직 이해와 디버깅 용이&lt;/li&gt;
&lt;li&gt;테스트 용이성
상태 x 이벤트 조합별로 기대 결과가 명확해 단위 테스트 케이스 설계가 단순&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의와-베스트-프랙티스&#34;&gt;주의와 베스트 프랙티스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상태 폭발 주의
의미 있는 상태만 유지하고 파생 속성은 별도 데이터로 관리&lt;/li&gt;
&lt;li&gt;전이 정의의 단일 소스 유지
가드와 부수효과를 전이 정의 근처에 모아 산재된 분기 로직을 제거&lt;/li&gt;
&lt;li&gt;잘못된 전이 로깅과 모니터링 활성화
무시된 입력을 계측해 모델 누락이나 외부 시스템 이상 조기 탐지&lt;/li&gt;
&lt;li&gt;멱등성 고려
중복 이벤트 재수신 가능 환경에서는 전이와 부수효과를 멱등하게 설계&lt;/li&gt;
&lt;li&gt;분산 환경에서는 상태 영속화와 재시도 정책을 명시
크래시 후 재기동 시 일관성 있는 상태 복원 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;마무리&#34;&gt;마무리&lt;/h3&gt;
&lt;p&gt;FSM은 상태와 전이를 중심으로 시스템 동작을 제한하고 드러내며, 규칙 밖 동작을 원천 차단해 안정성을 끌어올림
결제나 주문 같은 순서 기반 도메인에 특히 유용하며, 상태 정의와 전이 규칙만 명확히 유지하면 변경에도 견고하게 대응 가능&lt;/p&gt;</description>
    </item>
    <item>
      <title>Single Source of Truth(SSOT)의 의미와 적용 예시</title>
      <link>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</link>
      <pubDate>Fri, 02 Jan 2026 13:11:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함
핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함
원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 불일치 발생 위험 증가
&lt;ul&gt;
&lt;li&gt;위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유지보수 비용 급증
&lt;ul&gt;
&lt;li&gt;수정 시 흩어진 모든 복제본을 찾아 변경해야 함&lt;/li&gt;
&lt;li&gt;일부 누락 시 버그와 장애로 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 전파가 느림
&lt;ul&gt;
&lt;li&gt;캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실생활-비유&#34;&gt;실생활 비유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재
은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음&lt;/li&gt;
&lt;li&gt;스마트폰 연락처가 전화번호의 원본 역할을 수행
연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발-적용-예시&#34;&gt;개발 적용 예시&lt;/h3&gt;
&lt;h4 id=&#34;프론트엔드-상태-관리&#34;&gt;프론트엔드 상태 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리&lt;/li&gt;
&lt;li&gt;부모 변경이 자식에 반영되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;상위 컴포넌트 또는 중앙 스토어에만 userData 보관&lt;/li&gt;
&lt;li&gt;자식은 props나 selector로 읽기 전용 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터베이스-모델링&#34;&gt;데이터베이스 모델링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;회원 테이블에만 주소 저장&lt;/li&gt;
&lt;li&gt;주문 테이블은 회원 ID를 참조해 조인으로 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;타입-정의-공유typescript&#34;&gt;타입 정의 공유(TypeScript)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스와-주의&#34;&gt;베스트 프랙티스와 주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 경로 단일화
&lt;ul&gt;
&lt;li&gt;원본에 대한 쓰기는 반드시 한 경로로만 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 복제본과 캐시 관리
&lt;ul&gt;
&lt;li&gt;캐시는 파생물로 취급&lt;/li&gt;
&lt;li&gt;만료 정책, 동기화 주기, 재검증 전략을 명시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;식별자 기반 참조 우선
&lt;ul&gt;
&lt;li&gt;파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양방향 복제와 수동 동기화 지양
&lt;ul&gt;
&lt;li&gt;충돌 해결 복잡도와 데이터 드리프트 위험 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마이그레이션 단계 관리
&lt;ul&gt;
&lt;li&gt;이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;p&gt;원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부
이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음
프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observer 패턴 제대로 이해하기 — 동작 원리와 RxJS 확장</title>
      <link>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</link>
      <pubDate>Sun, 28 Dec 2025 13:10:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름
발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름
핵심은 느슨한 결합과 자동 알림 흐름 유지&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-구성요소&#34;&gt;핵심 개념과 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Subject 또는 Observable
&lt;ul&gt;
&lt;li&gt;이벤트를 발생시키는 주체&lt;/li&gt;
&lt;li&gt;Observer 목록을 관리&lt;/li&gt;
&lt;li&gt;상태가 변하면 observers에 알림 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer
&lt;ul&gt;
&lt;li&gt;상태 변화를 알고 싶은 소비자&lt;/li&gt;
&lt;li&gt;update 같은 콜백 보유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;notify
&lt;ul&gt;
&lt;li&gt;Subject가 모든 Observer에게 브로드캐스트하는 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Observer가 Subject에 구독 등록&lt;/li&gt;
&lt;li&gt;Subject 상태 변화 발생&lt;/li&gt;
&lt;li&gt;Subject가 notify 실행, 등록된 Observer의 콜백 호출&lt;/li&gt;
&lt;li&gt;Observer는 전달된 값에 따라 자체 로직 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필수 인터페이스의 최소 형태는 아래와 같음&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
