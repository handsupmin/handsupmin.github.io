<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Single-Source-of-Truth on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/single-source-of-truth/</link>
    <description>Recent content in Single-Source-of-Truth on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 02 Jan 2026 13:11:49 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/single-source-of-truth/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Single Source of Truth(SSOT)의 의미와 적용 예시</title>
      <link>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</link>
      <pubDate>Fri, 02 Jan 2026 13:11:49 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/single-source-of-truth-ssot-meaning-and-examples-1eabe5/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Single Source of Truth(SSOT)는 소프트웨어와 데이터 관리에서 중요한 데이터는 권위 있는 하나의 출처만을 가진다는 원칙을 뜻함
핵심은 원본은 한 곳에만 두고 나머지는 그 원본을 참조하거나 파생해 사용함
원본이 분산되면 동기화 비용과 불일치 위험이 기하급수적으로 증가함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 불일치 발생 위험 증가
&lt;ul&gt;
&lt;li&gt;위치 A의 유저 나이가 20인데 위치 B에서는 21로 표시되는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유지보수 비용 급증
&lt;ul&gt;
&lt;li&gt;수정 시 흩어진 모든 복제본을 찾아 변경해야 함&lt;/li&gt;
&lt;li&gt;일부 누락 시 버그와 장애로 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 전파가 느림
&lt;ul&gt;
&lt;li&gt;캐시나 로컬 복제본 만료 정책이 미흡할 때 최신성이 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실생활-비유&#34;&gt;실생활 비유&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;주민등록과 같은 신원 시스템의 원본 데이터는 정부의 공식 저장소에 존재
은행이나 병원은 이를 조회해 사용할 뿐 별도의 원본을 만들지 않음&lt;/li&gt;
&lt;li&gt;스마트폰 연락처가 전화번호의 원본 역할을 수행
연락처에서 번호를 바꾸면 메신저나 문자 앱도 최신 번호를 참조해 표시함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;개발-적용-예시&#34;&gt;개발 적용 예시&lt;/h3&gt;
&lt;h4 id=&#34;프론트엔드-상태-관리&#34;&gt;프론트엔드 상태 관리&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;부모 컴포넌트에 userData 보유, 자식 컴포넌트가 이를 복사해 별도 상태로 관리&lt;/li&gt;
&lt;li&gt;부모 변경이 자식에 반영되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;상위 컴포넌트 또는 중앙 스토어에만 userData 보관&lt;/li&gt;
&lt;li&gt;자식은 props나 selector로 읽기 전용 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;데이터베이스-모델링&#34;&gt;데이터베이스 모델링&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;주문 테이블에 고객 주소를 중복 저장하고 회원 테이블에도 주소 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;회원 테이블에만 주소 저장&lt;/li&gt;
&lt;li&gt;주문 테이블은 회원 ID를 참조해 조인으로 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;타입-정의-공유typescript&#34;&gt;타입 정의 공유(TypeScript)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bad
&lt;ul&gt;
&lt;li&gt;동일한 API 응답 타입을 페이지 A와 B 각각에서 중복 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSOT
&lt;ul&gt;
&lt;li&gt;types/user.ts에 단일 타입 정의 위치 확보 후 모든 모듈에서 import하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;베스트-프랙티스와-주의&#34;&gt;베스트 프랙티스와 주의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 경로 단일화
&lt;ul&gt;
&lt;li&gt;원본에 대한 쓰기는 반드시 한 경로로만 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 복제본과 캐시 관리
&lt;ul&gt;
&lt;li&gt;캐시는 파생물로 취급&lt;/li&gt;
&lt;li&gt;만료 정책, 동기화 주기, 재검증 전략을 명시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;식별자 기반 참조 우선
&lt;ul&gt;
&lt;li&gt;파생 데이터에는 식별자만 저장하고 필요 시 조인 또는 조회로 해석&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;양방향 복제와 수동 동기화 지양
&lt;ul&gt;
&lt;li&gt;충돌 해결 복잡도와 데이터 드리프트 위험 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마이그레이션 단계 관리
&lt;ul&gt;
&lt;li&gt;이중 쓰기 기간 최소화, 피처 플래그와 데이터 백필 계획 수립, 점진적 전환 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;
&lt;p&gt;원본은 하나만 관리하고 나머지는 참조한다는 단순한 원칙이 SSOT의 전부
이를 지키면 데이터 신뢰성 확보와 변경 비용 축소에 직접적인 효과가 있음
프론트엔드 상태, DB 스키마, 타입 정의까지 동일한 기준으로 일관 적용 권장&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
