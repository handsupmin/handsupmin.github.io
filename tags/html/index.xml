<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Html on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/html/</link>
    <description>Recent content in Html on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Fri, 27 Feb 2026 13:23:46 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/html/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>유지보수와 확장성을 고려한 HTML/CSS 구조 전략</title>
      <link>https://blog.jsontapose.com/posts/maintainable-scalable-html-css-structure-strategy-6905d0/</link>
      <pubDate>Fri, 27 Feb 2026 13:23:46 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/maintainable-scalable-html-css-structure-strategy-6905d0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;작은 규칙의 일관성이 유지보수성과 확장성을 만든다고 봄. 아래 세 가지 원칙은 팀 합의만 되면 즉시 적용 가능하며, 코드 리뷰와 리팩터링 부담을 낮추는 효과가 큼&lt;/p&gt;
&lt;h3 id=&#34;classname-네이밍은-하이픈-사용-권장&#34;&gt;className 네이밍은 하이픈 사용 권장&lt;/h3&gt;
&lt;p&gt;camelCase, under_score보다 하이픈(-) 기준 분절이 명확해 가독성과 편집성이 좋음. 대소문자 전환 없이 입력 가능해 타이핑 피로도도 낮음&lt;/p&gt;
&lt;p&gt;에디터 단어 단위 이동/선택이 직관적. camelCase나 under_score는 하나의 토큰으로 취급되는 경우가 많아 커서 이동이 번거로움. 하이픈은 공백처럼 인식되어 단어 경계 이동이 쉬움. 예시로 &lt;code&gt;sweetPotato&lt;/code&gt;, &lt;code&gt;sweet_potato&lt;/code&gt;, &lt;code&gt;sweet-potato&lt;/code&gt; 비교 추천&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTML data-* 속성 사용 패턴과 예시</title>
      <link>https://blog.jsontapose.com/posts/html-data-attributes-usage-4ad1f0/</link>
      <pubDate>Mon, 23 Feb 2026 13:27:43 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/html-data-attributes-usage-4ad1f0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;HTML5의 data-* 속성은 마크업에 보이지 않는 커스텀 데이터를 담기 위한 전역 속성
UI와 스크립트 사이 값 전달, 기능 감지 플래그, 간단한 지역화 메타데이터 등에 유용
DOM에서는 element.dataset으로 접근해 읽기/쓰기 가능&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;속성명 규칙: data- 접두사 + 소문자 케밥케이스 사용
접근 규칙: data-foo-bar → dataset.fooBar 로 매핑
값 타입: 문자열 저장, 필요 시 직접 직렬화/파싱 처리 필요
보안 유의: 민감정보나 토큰 저장 금지, 노출 전제 데이터만 저장
표준 속성과 역할 혼동 금지, 의미적 데이터는 적절한 속성이나 요소 사용 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unobtrusive JavaScript와 HTML·JS 분리 원칙</title>
      <link>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</link>
      <pubDate>Sun, 15 Feb 2026 13:17:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/unobtrusive-javascript-html-js-separation-eec1ed/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Unobtrusive JavaScript는 HTML 구조와 JS 동작을 분리하는 접근 철학
HTML은 의미와 콘텐츠, CSS는 표현, JS는 상호작용과 상태 제어 담당
인라인 스크립트와 이벤트 속성 제거, 외부 스크립트에서 안전하게 바인딩하는 방식 지향&lt;/p&gt;
&lt;p&gt;핵심 목표는 접근성 보장, 점진적 향상, 유지보수성과 테스트 용이성 개선, 캐시 효율 상승, 보안 취약점 노출 감소&lt;/p&gt;
&lt;h3 id=&#34;핵심-원칙&#34;&gt;핵심 원칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTML은 의미 중심 마크업 유지&lt;/li&gt;
&lt;li&gt;CSS는 표현만 담당&lt;/li&gt;
&lt;li&gt;JS는 DOMContentLoaded 이후 동작 주입&lt;/li&gt;
&lt;li&gt;인라인 onclick 등 이벤트 속성 사용 금지&lt;/li&gt;
&lt;li&gt;기능 감지 우선, UA 스니핑 지양&lt;/li&gt;
&lt;li&gt;데이터 훅은 data-* 속성 사용, 스타일 훅과 분리&lt;/li&gt;
&lt;li&gt;JS 미동작 상황에서도 기본 기능 유지, 점진적 향상 고려&lt;/li&gt;
&lt;li&gt;모듈 분리와 의존성 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-방식&#34;&gt;동작 방식&lt;/h3&gt;
&lt;p&gt;마크업은 링크와 폼이 기본 동작을 스스로 제공하도록 설계
JS는 존재하면 기본 동작을 확장하거나 향상
이벤트 바인딩은 외부 스크립트에서 선택자 기반으로 수행, 인라인 스크립트 제거&lt;/p&gt;</description>
    </item>
    <item>
      <title>a 태그 새 탭 열기와 보안 가이드 target=_blank rel=noopener noreferrer</title>
      <link>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</link>
      <pubDate>Fri, 13 Feb 2026 13:25:25 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/a-tag-open-in-new-tab-noopener-noreferrer-9d1fb5/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;링크를 새 탭에서 열 때 a 태그에 target=&amp;quot;_blank&amp;quot;를 많이 사용함
이 경우 window.opener로 원본 페이지에 접근 가능한 취약점과 리소스 간섭 이슈가 발생할 수 있음
rel=&amp;ldquo;noopener noreferrer&amp;quot;를 함께 지정해 리버스 태브내빙(reverse tabnabbing) 방지와 리퍼러 차단을 적용하는 것이 권장됨&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;target: 링크 대상 브라우징 컨텍스트 지정&lt;/li&gt;
&lt;li&gt;window.opener: 새 탭에서 원본 창을 참조하는 브라우저 객체&lt;/li&gt;
&lt;li&gt;rel=noopener: 새 탭에서 window.opener를 끊어 원본 페이지 접근 불가로 만듦, 리버스 태브내빙 방지&lt;/li&gt;
&lt;li&gt;rel=noreferrer: 새 탭으로 이동 시 Referer 헤더 전송 차단, 원본 페이지 URL 비공개&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target-값-정리&#34;&gt;target 값 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;_self: 현재 탭에서 열기, 기본값이라 명시 생략 가능&lt;/li&gt;
&lt;li&gt;_blank: 새 탭에서 열기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;target_blank만-사용할-때의-문제&#34;&gt;target=&amp;quot;_blank&amp;quot;만 사용할 때의 문제&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;보안 취약점 발생 가능
악성 페이지가 window.opener를 통해 부모 창의 location을 임의 변경하여 피싱 페이지로 리디렉션하는 리버스 태브내빙 위험 존재
원본 페이지의 데이터 접근 시도 등 추가 피해 가능성 있음&lt;/li&gt;
&lt;li&gt;성능 간섭 가능성
새 탭이 원본과 같은 브라우징 컨텍스트 그룹에서 실행될 수 있어 이벤트 루프나 리소스 경쟁으로 지연이 커질 수 있음
무거운 스크립트가 열린 탭 간에 체감 성능 저하를 유발할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rel=&amp;ldquo;noopener&amp;rdquo;
새 탭의 window.opener를 null로 만들어 원본 페이지 참조 차단
탭 간 연결이 끊겨 보안 위험과 리소스 간섭 완화&lt;/li&gt;
&lt;li&gt;rel=&amp;ldquo;noreferrer&amp;rdquo;
이동 시 Referer 헤더를 제거해 원본 URL과 경로 노출 방지
분석이나 리퍼러 기반 측정이 필요한 경우에는 생략을 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용-예시&#34;&gt;사용 예시&lt;/h3&gt;
&lt;p&gt;필수 최소 속성만 명시&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
