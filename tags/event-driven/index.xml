<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Event-Driven on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/event-driven/</link>
    <description>Recent content in Event-Driven on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 01 Jan 2026 13:12:42 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/event-driven/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>좋은 시스템 설계 가이드: 상태 최소화와 검증된 컴포넌트 조합의 원칙</title>
      <link>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</link>
      <pubDate>Thu, 01 Jan 2026 13:12:42 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/good-system-design-guide-484b40/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;좋은 시스템 설계는 복잡해 보이지 않고 긴 시간 동안 별문제 없이 돌아가는 상태를 말함
핵심은 상태를 최소화하고, 검증된 단순한 컴포넌트를 필요할 때만 조합하는 방향
과설계나 과도한 신기술 도입은 문제를 감추거나 유지보수 비용을 키우는 경향
최소 기능의 단순 구조에서 시작 후 관측 기반으로 점진 개선 권장&lt;/p&gt;
&lt;h3 id=&#34;시스템-설계의-정의와-접근&#34;&gt;시스템 설계의 정의와 접근&lt;/h3&gt;
&lt;p&gt;소프트웨어 설계가 코드 조립이라면 시스템 설계는 서비스를 조합하는 일이라는 관점
주요 구성 요소 팔레트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앱 서버&lt;/li&gt;
&lt;li&gt;데이터베이스&lt;/li&gt;
&lt;li&gt;캐시&lt;/li&gt;
&lt;li&gt;큐와 잡 러너&lt;/li&gt;
&lt;li&gt;이벤트 버스&lt;/li&gt;
&lt;li&gt;프록시와 게이트웨이&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;좋은 설계의 징후&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observer 패턴 제대로 이해하기 — 동작 원리와 RxJS 확장</title>
      <link>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</link>
      <pubDate>Sun, 28 Dec 2025 13:10:48 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/observer-pattern-basics-and-rxjs-66e936/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;한 객체의 상태 변화나 이벤트를 여러 객체가 자동으로 감지하고 반응하게 만드는 구조를 Observer 패턴이라 부름
발행자와 구독자의 관계로도 설명됨. Publisher가 이벤트를 내보내고 Subscribers가 이를 받는 흐름
핵심은 느슨한 결합과 자동 알림 흐름 유지&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-구성요소&#34;&gt;핵심 개념과 구성요소&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Subject 또는 Observable
&lt;ul&gt;
&lt;li&gt;이벤트를 발생시키는 주체&lt;/li&gt;
&lt;li&gt;Observer 목록을 관리&lt;/li&gt;
&lt;li&gt;상태가 변하면 observers에 알림 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer
&lt;ul&gt;
&lt;li&gt;상태 변화를 알고 싶은 소비자&lt;/li&gt;
&lt;li&gt;update 같은 콜백 보유&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;notify
&lt;ul&gt;
&lt;li&gt;Subject가 모든 Observer에게 브로드캐스트하는 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Observer가 Subject에 구독 등록&lt;/li&gt;
&lt;li&gt;Subject 상태 변화 발생&lt;/li&gt;
&lt;li&gt;Subject가 notify 실행, 등록된 Observer의 콜백 호출&lt;/li&gt;
&lt;li&gt;Observer는 전달된 값에 따라 자체 로직 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필수 인터페이스의 최소 형태는 아래와 같음&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
