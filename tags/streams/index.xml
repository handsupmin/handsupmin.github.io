<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Streams on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/streams/</link>
    <description>Recent content in Streams on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 24 Jan 2026 13:11:22 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/streams/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RxJS 핵심 가이드와 내부 동작 이해 Observable Subject Teardown Scheduler Operator</title>
      <link>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</link>
      <pubDate>Sat, 24 Jan 2026 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/rxjs-core-guide-internal-observable-subject-teardown-scheduler-operators-18d2d1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;RxJS는 Reactive Extensions for JavaScript의 약자이며 비동기 데이터 흐름을 스트림 Observable로 다루는 라이브러리임
이벤트, API 응답, 클릭, WebSocket처럼 시간에 따라 변하는 값을 하나의 연속 흐름으로 모델링 가능&lt;/p&gt;
&lt;p&gt;핵심 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise는 값 1개 처리&lt;/li&gt;
&lt;li&gt;Observable은 값 0개부터 무한대까지 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;observable-핵심&#34;&gt;Observable 핵심&lt;/h3&gt;
&lt;p&gt;정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간에 따라 변경되는 데이터를 push 기반 스트림으로 표현한 객체&lt;/li&gt;
&lt;li&gt;구독 subscribe 시점에만 실행되는 lazy 특성&lt;/li&gt;
&lt;li&gt;구독 해제 unsubscribe 시 리소스 정리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lazy 실행으로 불필요한 작업 방지&lt;/li&gt;
&lt;li&gt;cancel 가능으로 누수 방지&lt;/li&gt;
&lt;li&gt;0~무한개의 값 연속 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>자바스크립트 비동기와 이터레이터 정리 — 기다림, 동시성, 백프레셔</title>
      <link>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</link>
      <pubDate>Sat, 10 Jan 2026 13:10:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;비동기는 강력한 도구임. 다만 배열과 스트림 같은 이터레이터와 결합되면 누가 무엇을 언제 기다리는지 불명확해지기 쉬움
핵심 포인트 세 가지 기억&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완료 보장 확보했는지&lt;/li&gt;
&lt;li&gt;동시성 제어를 명시했는지&lt;/li&gt;
&lt;li&gt;백프레셔로 생산 속도 ≤ 소비 속도 유지했는지&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비동기가-의도대로-동작하지-않는-케이스&#34;&gt;비동기가 의도대로 동작하지 않는 케이스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;forEach + async 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;콜백이 반환한 프로미스를 외부가 수집하지 않음 → 완료 보장 깨짐, 레이스와 누락 가능성 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;items&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;forEach&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; doAsync&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 외부에서 기다리지 않음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map + async 이후 기다리지 않음&lt;/p&gt;</description>
    </item>
    <item>
      <title>백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴</title>
      <link>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</link>
      <pubDate>Fri, 26 Dec 2025 13:12:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함
직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함&lt;/p&gt;
&lt;h3 id=&#34;왜-중요한가&#34;&gt;왜 중요한가&lt;/h3&gt;
&lt;p&gt;처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자 1000 req/s, 소비자 100 req/s 가정&lt;/li&gt;
&lt;li&gt;매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험&lt;/li&gt;
&lt;li&gt;큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능
백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Producer: 데이터를 생성·전송하는 주체&lt;/li&gt;
&lt;li&gt;Consumer: 데이터를 수신·처리하는 주체&lt;/li&gt;
&lt;li&gt;Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위&lt;/li&gt;
&lt;li&gt;전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리전략&#34;&gt;동작 원리/전략&lt;/h3&gt;
&lt;p&gt;A. 조절 Control/Throttling&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
