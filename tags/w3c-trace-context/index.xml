<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>W3c-Trace-Context on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/w3c-trace-context/</link>
    <description>Recent content in W3c-Trace-Context on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 06 Jan 2026 13:13:56 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/w3c-trace-context/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TID 전파 베스트 프랙티스: HTTP 헤더와 메시지 큐 Payload 기준</title>
      <link>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</link>
      <pubDate>Tue, 06 Jan 2026 13:13:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스와 비동기 작업이 섞인 환경에서 요청의 전 흐름을 좇기 위한 상관 식별자 필요
일반적으로 trace id를 tid로 표기해 서비스 경계를 넘나들며 전파함
HTTP 같은 동기 호출과 메시지 큐 같은 비동기 처리의 전파 매체가 다르므로 매체별 규칙을 명확히 두는 것이 핵심
산업 표준은 W3C Trace Context와 OpenTelemetry가 사실상 기본값
프로세스 내부 전파에는 비동기 컨텍스트 저장소 사용 권장&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TID(trace id)와 span id 구분, tid는 전체 요청 상관을 위한 루트 식별자 역할&lt;/li&gt;
&lt;li&gt;W3C Trace Context의 traceparent와 tracestate 헤더로 표준 전파&lt;/li&gt;
&lt;li&gt;OpenTelemetry는 위 표준을 구현하고 언어별 SDK 제공&lt;/li&gt;
&lt;li&gt;프로세스 내 컨텍스트 전파는 AsyncLocalStorage 등 런타임 컨텍스트로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-패턴&#34;&gt;표준 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 및 gRPC 같은 동기 네트워크 통신은 헤더 사용이 기본 원칙&lt;/li&gt;
&lt;li&gt;메시지 큐나 비동기 작업은 메시지 Body 또는 시스템이 제공하는 메시지 속성 사용&lt;/li&gt;
&lt;li&gt;지원되는 경우 메시지 헤더를 우선 사용, 없으면 Payload에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요약&lt;/p&gt;</description>
    </item>
    <item>
      <title>분산 추적 표준 패턴 정리: HTTP 헤더와 메시지 페이로드, OpenTelemetry와 W3C Trace Context</title>
      <link>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</link>
      <pubDate>Sat, 03 Jan 2026 13:10:13 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;분산 추적 컨텍스트를 어디에 어떻게 실어 나를지에 대한 표준 패턴 정리. HTTP 같은 동기식 통신과 메시지 큐 같은 비동기식 통신은 전달 수단이 다름. 업계 표준은 W3C Trace Context와 이를 구현한 OpenTelemetry를 따르는 흐름임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;trace-id, span-id, sampling 플래그 등 추적 컨텍스트 전달 필요&lt;/li&gt;
&lt;li&gt;동기식 요청/응답 채널은 헤더 기반 메타데이터 전달이 자연스러움&lt;/li&gt;
&lt;li&gt;비동기 메시징은 메시지 자체가 전달 단위이므로 페이로드 또는 메시지 속성 이용&lt;/li&gt;
&lt;li&gt;채널이 헤더 개념을 지원하면 헤더 우선, 없으면 페이로드에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;통신별-패턴&#34;&gt;통신별 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/REST 통신: 요청/응답 헤더에 trace 컨텍스트 실어 전달&lt;/li&gt;
&lt;li&gt;gRPC: 메타데이터(헤더 개념)로 전달&lt;/li&gt;
&lt;li&gt;Kafka: 메시지 헤더 지원. 가능하면 헤더 사용 권장&lt;/li&gt;
&lt;li&gt;RabbitMQ: 메시지 프로퍼티의 headers 사용 가능&lt;/li&gt;
&lt;li&gt;AWS SQS: Message Attributes 사용 가능. 미지원 시 Body에 포함&lt;/li&gt;
&lt;li&gt;BullMQ/Redis 기반 잡 큐: 헤더 개념 없음. Job data에 포함&lt;/li&gt;
&lt;li&gt;WebSocket: 초기 핸드셰이크 단계에서 허용된 메타데이터 채널 또는 쿼리로 전달, 이후 각 메시지 페이로드에 포함. 환경 제약으로 커스텀 헤더 불가한 경우 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;산업-표준&#34;&gt;산업 표준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry는 W3C Trace Context를 구현하는 업계 표준 스택&lt;/li&gt;
&lt;li&gt;HTTP는 W3C traceparent, tracestate 헤더 사용&lt;/li&gt;
&lt;li&gt;비동기 메시징은 채널이 헤더를 지원하면 헤더 사용, 아니면 데이터에 포함하는 전략 일반화&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
