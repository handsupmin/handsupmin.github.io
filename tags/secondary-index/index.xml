<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Secondary-Index on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/secondary-index/</link>
    <description>Recent content in Secondary-Index on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 14 Dec 2025 13:09:03 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/secondary-index/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL 클러스터드 인덱스와 논클러스터드 인덱스 이해와 선택 기준</title>
      <link>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</link>
      <pubDate>Sun, 14 Dec 2025 13:09:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/mysql-clustered-vs-nonclustered-index-f925e0/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;테이블 검색 성능을 끌어올리는 1차 수단은 인덱스 구축임
인덱스는 단일 컬럼 또는 다중 컬럼 기준으로 생성 가능하며, 다음과 같은 기본 생성 규칙이 작동함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Primary Key 지정 시 클러스터드 인덱스 생성&lt;/li&gt;
&lt;li&gt;Unique 제약은 보조 인덱스(논클러스터드 인덱스, InnoDB에선 Secondary Index)로 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL의 InnoDB는 B+Tree 기반 인덱스를 사용하며, 데이터 저장 구조와 접근 패턴이 인덱스 유형별로 상이함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념-정리&#34;&gt;핵심 개념 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;클러스터드 인덱스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테이블 데이터가 인덱스 키 순서로 정리되는 구조&lt;/li&gt;
&lt;li&gt;테이블당 하나만 존재&lt;/li&gt;
&lt;li&gt;리프 노드가 실제 레코드(전체 컬럼)를 보유&lt;/li&gt;
&lt;li&gt;InnoDB에서 Primary Key가 곧 클러스터드 인덱스가 됨&lt;/li&gt;
&lt;li&gt;PK가 없으면 첫 번째 유니크 not null 인덱스를 사용, 그것도 없으면 내부적으로 보이지 않는 6바이트 Row ID를 생성해 클러스터링 키로 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;논클러스터드 인덱스(보조 인덱스, Secondary Index)&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
