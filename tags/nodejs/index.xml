<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nodejs on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/nodejs/</link>
    <description>Recent content in Nodejs on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 13 Jan 2026 13:15:30 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/nodejs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>API 성능 테스트와 모니터링 표준 가이드</title>
      <link>https://blog.jsontapose.com/posts/api-performance-testing-and-monitoring-guide-2b9e24/</link>
      <pubDate>Tue, 13 Jan 2026 13:15:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/api-performance-testing-and-monitoring-guide-2b9e24/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;신규 API 개발 또는 로직 변경 시 서비스의 안정성과 성능을 사전에 검증하기 위한 표준 테스트 프로세스 정의 목적
코드 수준의 비효율 제거와 인프라 병목 식별을 분리해 진행하며, 동일 스택으로 로컬과 서버 환경을 일관되게 관찰하는 것을 권장&lt;/p&gt;
&lt;h3 id=&#34;테스트-전략-개요&#34;&gt;테스트 전략 개요&lt;/h3&gt;
&lt;p&gt;성능 테스트는 환경과 목적에 따라 두 단계로 구분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Phase 1 Local
&lt;ul&gt;
&lt;li&gt;목표  코드 레벨 최적화와 비효율 제거&lt;/li&gt;
&lt;li&gt;관점  CPU 스파이크, 메모리 누수, 이벤트 루프 지연, 불필요한 I O 대기&lt;/li&gt;
&lt;li&gt;도구  k6 로컬, Clinic.js&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phase 2 Dev 서버
&lt;ul&gt;
&lt;li&gt;목표  시스템 레벨 검증과 병목 지점 확인&lt;/li&gt;
&lt;li&gt;관점  DB Redis MQ 한계, 연결 풀 고갈, 큐 적체, 에러율&lt;/li&gt;
&lt;li&gt;도구  k6 원격, Prometheus Grafana&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;도구-구성&#34;&gt;도구 구성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;부하 생성  k6
&lt;ul&gt;
&lt;li&gt;JS 기반 스크립팅으로 학습 비용 낮음&lt;/li&gt;
&lt;li&gt;CI CD 파이프라인 연동 용이&lt;/li&gt;
&lt;li&gt;로컬과 서버 환경 모두에서 실행 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;모니터링  Grafana Prometheus
&lt;ul&gt;
&lt;li&gt;인프라 통합 관제에 적합 Redis DB MQ WAS 지표를 일관된 대시보드로 관찰&lt;/li&gt;
&lt;li&gt;테스트 중 실시간 병목 구간 가시화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로파일링  Clinic.js
&lt;ul&gt;
&lt;li&gt;Node.js 내부 지표 심층 분석에 특화&lt;/li&gt;
&lt;li&gt;CPU 스파이크, 메모리 누수, 이벤트 루프 지연 원인 파악에 유용&lt;/li&gt;
&lt;li&gt;로컬 디버깅 우선 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단계별-진행&#34;&gt;단계별 진행&lt;/h3&gt;
&lt;h4 id=&#34;step-1-로컬-프로파일링-local-profiling&#34;&gt;Step 1 로컬 프로파일링 Local Profiling&lt;/h4&gt;
&lt;p&gt;질문  내 코드에 논리적 비효율이 없는가
배포 전 로컬에서 가벼운 부하를 주고 코드 결함을 조기에 식별&lt;/p&gt;</description>
    </item>
    <item>
      <title>자바스크립트 비동기와 이터레이터 정리 — 기다림, 동시성, 백프레셔</title>
      <link>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</link>
      <pubDate>Sat, 10 Jan 2026 13:10:30 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/javascript-async-iterators-waiting-concurrency-backpressure-e200bd/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;비동기는 강력한 도구임. 다만 배열과 스트림 같은 이터레이터와 결합되면 누가 무엇을 언제 기다리는지 불명확해지기 쉬움
핵심 포인트 세 가지 기억&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완료 보장 확보했는지&lt;/li&gt;
&lt;li&gt;동시성 제어를 명시했는지&lt;/li&gt;
&lt;li&gt;백프레셔로 생산 속도 ≤ 소비 속도 유지했는지&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;비동기가-의도대로-동작하지-않는-케이스&#34;&gt;비동기가 의도대로 동작하지 않는 케이스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;forEach + async 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;콜백이 반환한 프로미스를 외부가 수집하지 않음 → 완료 보장 깨짐, 레이스와 누락 가능성 증가&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;items&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;forEach&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; doAsync&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;x&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 외부에서 기다리지 않음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map + async 이후 기다리지 않음&lt;/p&gt;</description>
    </item>
    <item>
      <title>TID 전파 베스트 프랙티스: HTTP 헤더와 메시지 큐 Payload 기준</title>
      <link>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</link>
      <pubDate>Tue, 06 Jan 2026 13:13:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/tid-propagation-best-practices-http-header-vs-queue-payload-b25f8e/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스와 비동기 작업이 섞인 환경에서 요청의 전 흐름을 좇기 위한 상관 식별자 필요
일반적으로 trace id를 tid로 표기해 서비스 경계를 넘나들며 전파함
HTTP 같은 동기 호출과 메시지 큐 같은 비동기 처리의 전파 매체가 다르므로 매체별 규칙을 명확히 두는 것이 핵심
산업 표준은 W3C Trace Context와 OpenTelemetry가 사실상 기본값
프로세스 내부 전파에는 비동기 컨텍스트 저장소 사용 권장&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TID(trace id)와 span id 구분, tid는 전체 요청 상관을 위한 루트 식별자 역할&lt;/li&gt;
&lt;li&gt;W3C Trace Context의 traceparent와 tracestate 헤더로 표준 전파&lt;/li&gt;
&lt;li&gt;OpenTelemetry는 위 표준을 구현하고 언어별 SDK 제공&lt;/li&gt;
&lt;li&gt;프로세스 내 컨텍스트 전파는 AsyncLocalStorage 등 런타임 컨텍스트로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;표준-패턴&#34;&gt;표준 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 및 gRPC 같은 동기 네트워크 통신은 헤더 사용이 기본 원칙&lt;/li&gt;
&lt;li&gt;메시지 큐나 비동기 작업은 메시지 Body 또는 시스템이 제공하는 메시지 속성 사용&lt;/li&gt;
&lt;li&gt;지원되는 경우 메시지 헤더를 우선 사용, 없으면 Payload에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요약&lt;/p&gt;</description>
    </item>
    <item>
      <title>백프레셔 Backpressure 개념 정리와 스트림·큐·RxJS 적용 패턴</title>
      <link>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</link>
      <pubDate>Fri, 26 Dec 2025 13:12:06 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/backpressure-flow-control-stream-rxjs-351e4c/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;백프레셔 Backpressure는 소비자가 생산자의 처리 속도를 따라가지 못할 때, 소비자가 생산자의 속도를 조절하도록 피드백을 주는 흐름 제어 메커니즘을 의미함
직관적 비유로 좁은 깔때기 소비자에 높은 수압 생산자를 연결했을 때, 깔때기 내부에 물이 차며 더 유입되지 않도록 압력이 올라가거나 수도를 잠그라는 신호를 보내는 상황과 동일함&lt;/p&gt;
&lt;h3 id=&#34;왜-중요한가&#34;&gt;왜 중요한가&lt;/h3&gt;
&lt;p&gt;처리 속도 불균형이 누적되면 메모리 초과와 지연 폭증으로 이어짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자 1000 req/s, 소비자 100 req/s 가정&lt;/li&gt;
&lt;li&gt;매초 900개가 버퍼에 쌓여 메모리 증가, 결국 OOM 위험&lt;/li&gt;
&lt;li&gt;큐 대기열이 길어져 tail-latency 증가, 사실상 영구 대기 상태 발생 가능
백프레셔는 이런 누적을 초기에 억제해 시스템 안정성 확보와 자원 보호에 기여함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Producer: 데이터를 생성·전송하는 주체&lt;/li&gt;
&lt;li&gt;Consumer: 데이터를 수신·처리하는 주체&lt;/li&gt;
&lt;li&gt;Backpressure: 소비자가 처리 가능한 속도로 생산자에 역방향 피드백을 전달해 유량을 제어하는 행위&lt;/li&gt;
&lt;li&gt;전략 축: 조절 Control, 버퍼링 Buffering, 드롭 Dropping&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리전략&#34;&gt;동작 원리/전략&lt;/h3&gt;
&lt;p&gt;A. 조절 Control/Throttling&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS 핵심 개념과 11.x 변화 정리 — 구조, DI, 데코레이터, 성능 업데이트</title>
      <link>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</link>
      <pubDate>Fri, 19 Dec 2025 13:12:12 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-core-concepts-and-11x-updates-8dc68e/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS는 대규모 서버 애플리케이션을 위한 구조화된 Node.js 프레임워크임
핵심은 Angular 스타일의 아키텍처, 강력한 의존성 주입 컨테이너, 데코레이터 기반 메타프로그래밍 조합
팀 규모가 커질수록 일관성과 유지보수성이 살아나는 타입스크립트 퍼스트 선택지임&lt;/p&gt;
&lt;h3 id=&#34;구조적-강제의-이점&#34;&gt;구조적 강제의 이점&lt;/h3&gt;
&lt;p&gt;Nest는 모듈 Module, 컨트롤러 Controller, 서비스 Service 구조를 강제함
계층 분리 패턴 BLL, DAL, 도메인 레이어 등 적용 용이
아키텍처가 일관되게 유지되어 4~10명 규모 팀에서 코드 스타일과 책임 경계가 흐트러지지 않음&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fastify, Express 같은 미니멀 프레임워크 대비 생산성과 일관성 측면에서 팀 단위 효율 우위&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 모듈 시스템 정리: CommonJS와 ESM의 차이, 선택 기준, 상호 운용</title>
      <link>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</link>
      <pubDate>Tue, 16 Dec 2025 13:14:04 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-module-system-commonjs-vs-esm-0fed74/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 CommonJS(CJS)와 ESM(ES Modules)은 공존 상태이며, 신규 프로젝트는 ESM으로 전환되는 추세임. 두 시스템의 차이를 이해하면 번들 크기, 로딩 성능, 정적 분석, 생태계 호환에서 불필요한 시행착오 감소 가능&lt;/p&gt;
&lt;h3 id=&#34;배경&#34;&gt;배경&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2009년 Node.js는 표준 모듈 시스템이 없던 시기라 CommonJS 채택&lt;/li&gt;
&lt;li&gt;2015년 ES6에서 ESM이 언어 차원의 공식 표준으로 확정&lt;/li&gt;
&lt;li&gt;2020년대 들어 Node.js가 ESM을 정식 지원, 브라우저와 규약 수렴 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;commonjs-요약&#34;&gt;CommonJS 요약&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// export
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;module&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;exports &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exports&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;bar &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// import
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; foo&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; bar &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;=&lt;/span&gt; require&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;./utils&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;특성&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 글로벌 에러 핸들러 가이드</title>
      <link>https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/</link>
      <pubDate>Fri, 12 Dec 2025 13:13:05 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-global-error-handler-3ae1d7/</guid>
      <description>&lt;h3 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h3&gt;
&lt;p&gt;Node.js 프로세스 레벨에서 잡히지 않은 에러를 마지막으로 처리하는 안전망을 두는 목적 정리
애플리케이션 어디에서도 처리되지 못한 오류를 기록하고 종료 경로를 일관되게 관리하기 위함
프로덕션 환경에서 원인 파악과 사후 조치 자동화를 위한 최소 장치로 간주&lt;/p&gt;
&lt;h3 id=&#34;핵심-이벤트&#34;&gt;핵심 이벤트&lt;/h3&gt;
&lt;p&gt;두 가지 이벤트가 글로벌 핸들러의 대상&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uncaughtException
&lt;ul&gt;
&lt;li&gt;try-catch로 포착되지 않은 동기 오류가 호출 스택 끝까지 전파될 때 발생&lt;/li&gt;
&lt;li&gt;핸들러가 없으면 프로세스가 비정상 종료됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 동기 에러가 상위에서 잡히지 않은 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; boom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Error&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;폭발&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;boom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;unhandledRejection
&lt;ul&gt;
&lt;li&gt;Promise가 reject되었으나 await 혹은 .catch로 처리되지 않은 경우 발생&lt;/li&gt;
&lt;li&gt;Node.js 15+ 기본 동작은 핸들러가 없을 때 프로세스 종료&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// reject가 소비되지 않은 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;function&lt;/span&gt; asyncBoom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#81a1c1&#34;&gt;Error&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#39;비동기 폭발&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;asyncBoom&lt;span style=&#34;color:#eceff4&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;왜-글로벌-핸들러인가&#34;&gt;왜 글로벌 핸들러인가&lt;/h3&gt;
&lt;p&gt;코드 최상위에서 아무도 잡지 못한 에러에 대한 마지막 안전망 역할&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes에서 Node.js Liveness와 Readiness Probe 설계 가이드</title>
      <link>https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/</link>
      <pubDate>Thu, 11 Dec 2025 13:14:28 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/kubernetes-nodejs-liveness-readiness-probe-guide-4853ec/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Kubernetes 환경에서 Liveness Probe와 Readiness Probe는 애플리케이션 상태를 주기적으로 점검해 자동 복구와 트래픽 차단을 수행하는 안전 장치 역할 수행
Node.js는 싱글 스레드 기반으로 이벤트 루프 차단이나 메모리 누수 상황이 치명적이라 두 프로브의 설계가 안정성에 직접적인 영향 미침&lt;/p&gt;
&lt;h3 id=&#34;핵심-차이&#34;&gt;핵심 차이&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Liveness Probe의 질문은 너 살아있니, 실패 시 컨테이너 재시작 수행&lt;/li&gt;
&lt;li&gt;Readiness Probe의 질문은 일할 준비 됐니, 실패 시 서비스 엔드포인트에서 제외해 트래픽 차단 수행&lt;/li&gt;
&lt;li&gt;본질적 차이는 실패 시 K8s가 취하는 액션이며 재시작과 트래픽 제어로 구분됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nodejs-맥락&#34;&gt;Node.js 맥락&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Liveness Probe 대상 상황
&lt;ul&gt;
&lt;li&gt;이벤트 루프 블로킹으로 요청 처리 불가 상태&lt;/li&gt;
&lt;li&gt;무한 루프 또는 데드락과 유사한 좀비 상태로 PID는 있으나 응답 불능&lt;/li&gt;
&lt;li&gt;메모리 누수로 OOM 임박하여 응답 지연 또는 멈춤에 가까운 상태&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Readiness Probe 대상 상황
&lt;ul&gt;
&lt;li&gt;프로세스는 떠 있으나 초기화 작업 진행 중인 상태&lt;/li&gt;
&lt;li&gt;DB 연결 수립 중, 대용량 설정 로딩, 캐시 워밍업 등으로 실제 서비스 처리 불가 상태&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;유의점
&lt;ul&gt;
&lt;li&gt;Liveness는 가벼운 체크로 한정, 외부 의존성까지 포함 시 불필요한 재시작 유발 위험&lt;/li&gt;
&lt;li&gt;Readiness는 실제 트래픽 처리 가능 여부를 반영해야 하며 의존성 준비 상태를 포함하는 편이 안전함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;구현-스니펫&#34;&gt;구현 스니펫&lt;/h3&gt;
&lt;p&gt;Node.js에서 Liveness는 최소한의 핑 수준으로, Readiness는 의존성 준비 여부를 반영하는 형태 권장&lt;/p&gt;</description>
    </item>
    <item>
      <title>이벤트 루프와 비동기, await에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</link>
      <pubDate>Wed, 03 Dec 2025 13:13:33 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;nodejs-기본-구조&#34;&gt;Node.js 기본 구조&lt;/h2&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TB
    subgraph STACK[Call Stack]
        S1[현재 실행 중인 함수]
    end

    subgraph LOOP[Event Loop]
        EL[Call Stack 비었나?&amp;lt;br/&amp;gt;→ Queue에서 가져오기]
    end

    subgraph QUEUES[Queues]
        MQ[Microtask Queue&amp;lt;br/&amp;gt;Promise, await 완료]
        TQ[Task Queue&amp;lt;br/&amp;gt;setTimeout, I/O, Cron]
    end

    STACK --&amp;gt; |비어있을 때만| LOOP
    LOOP --&amp;gt; MQ
    MQ --&amp;gt; |비었으면| TQ
    TQ --&amp;gt; STACK

    style STACK fill:#ff6b6b
    style MQ fill:#4ecdc4
    style TQ fill:#45b7d1&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;핵심 규칙: Call Stack이 비어야만 다음 작업 실행&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;오해-1-settimeout0은-즉시-실행된다&#34;&gt;오해 1: &amp;ldquo;setTimeout(0)은 즉시 실행된다&amp;rdquo;&lt;/h2&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;setTimeout&lt;span style=&#34;color:#eceff4&#34;&gt;(()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;실행-흐름&#34;&gt;실행 흐름&lt;/h3&gt;
&lt;pre class=&#34;mermaid&#34;&gt;sequenceDiagram
    participant CS as Call Stack
    participant TQ as Task Queue
    participant OUT as 출력

    Note over CS: console.log(&amp;#39;1&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;1&amp;#34;

    Note over CS: setTimeout 등록
    CS-&amp;gt;&amp;gt;TQ: 콜백 등록 (0ms여도!)

    Note over CS: console.log(&amp;#39;3&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;3&amp;#34;

    Note over CS: Call Stack 비었음!
    TQ-&amp;gt;&amp;gt;CS: 콜백 가져오기

    Note over CS: 콜백 실행
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;2&amp;#34;&lt;/pre&gt;&lt;h3 id=&#34;출력-1--3--2&#34;&gt;출력: &lt;code&gt;1 → 3 → 2&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setTimeout(0)은 &amp;ldquo;다음 Event Loop에 실행&amp;quot;이라는 뜻!&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma에는 왜 JOIN이 없을까: ORM 패턴, 스키마, 내부 동작 정리</title>
      <link>https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/</link>
      <pubDate>Sun, 23 Nov 2025 13:06:21 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/why-prisma-has-no-join-ed7155/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma로 관계형 데이터베이스를 다루다 보면 자연스럽게 드는 질문이 있음
Prisma에서는 JOIN이 어디로 갔나 하는 질문임
개발자가 작성하는 Prisma Client API에는 JOIN이 없고, 서브쿼리도 보이지 않음
정말로 없는지, 없다면 왜 그런지, 어떤 트레이드오프가 있는지 정리함&lt;/p&gt;
&lt;h3 id=&#34;orm이란-무엇인가&#34;&gt;ORM이란 무엇인가&lt;/h3&gt;
&lt;p&gt;ORM은 객체와 관계형 데이터베이스 간의 매핑을 제공하는 아이디어이자 구현체 집합을 의미함
애플리케이션에서 모델을 통해 데이터베이스 테이블을 간접 제어하는 추상화 계층 제공
SQL을 직접 작성하지 않고 데이터 접근 로직을 일관된 API로 수행 가능
데이터베이스 의존성 완화 효과 기대&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma findUnique에서 where와 include 제대로 쓰기</title>
      <link>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</link>
      <pubDate>Wed, 12 Nov 2025 13:12:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-findunique-where-include-1ada6d/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;findUnique&lt;/code&gt;로 단일 레코드 조회하면서 관련된 데이터까지 한 번에 가져오고 싶을 때 &lt;code&gt;where&lt;/code&gt;와 &lt;code&gt;include&lt;/code&gt;를 어떻게 조합해야 하는지 정리함
관계 필터링을 &lt;code&gt;where&lt;/code&gt;에 넣을 수 있는지, &lt;code&gt;include&lt;/code&gt;에서 필터가 가능한지 헷갈리기 쉬운 지점 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;는 유니크 키로 정확히 &lt;strong&gt;하나&lt;/strong&gt;의 레코드를 찾는 용도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findUnique&lt;/code&gt;의 &lt;code&gt;where&lt;/code&gt;는 &lt;strong&gt;유니크 필드만&lt;/strong&gt; 허용됨, 관계 필터나 일반 조건 결합 불가&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;는 조회된 레코드에 대한 연관 레코드를 함께 가져오는 옵션&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;to-many 관계&lt;/strong&gt;에 한해 &lt;code&gt;include&lt;/code&gt; 내부에서 &lt;code&gt;where&lt;/code&gt; 사용 가능, to-one 관계는 &lt;code&gt;where&lt;/code&gt; 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;where-사용-패턴&#34;&gt;where 사용 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;잘못된 예시&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// findUnique에 관계 필터 결합 시도 → 타입 에러
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// (User(1) → Post(N) → Metadata(1) 관계)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;posts&amp;#39;는 유니크 필드가 아니므로 &amp;#39;where&amp;#39;에서 관계 필터링 불가
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;올바른 최소 조건&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findUnique&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;id&amp;#39;는 유니크 필드
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;관계 조건이 필요하면 findFirst 또는 findMany 사용&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;findUnique&amp;#39;가 아닌 &amp;#39;findFirst&amp;#39;를 사용하면
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// &amp;#39;where&amp;#39;에 관계 필터를 포함할 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; db&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findFirst&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  where&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#81a1c1&#34;&gt;userId&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    posts&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; some&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; metadata&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; editorEmail: &lt;span style=&#34;color:#81a1c1&#34;&gt;email&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;요약하면 &lt;code&gt;findUnique&lt;/code&gt;에는 유니크 조건만, 관계 기반 필터는 &lt;code&gt;findFirst&lt;/code&gt; 또는 &lt;code&gt;findMany&lt;/code&gt;로 처리함&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 실행 흐름과 이벤트 루프 단계 정리</title>
      <link>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</link>
      <pubDate>Tue, 11 Nov 2025 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리
바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V8 엔진, Ignition 바이트코드와 JIT 최적화&lt;/li&gt;
&lt;li&gt;libuv, 비동기 I O 백엔드와 이벤트 루프 단계&lt;/li&gt;
&lt;li&gt;모듈 시스템, CommonJS와 ES Module의 로딩 차이&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트와 런타임 내장 객체&lt;/li&gt;
&lt;li&gt;마이크로태스크 큐와 process.nextTick의 우선순위&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행-순서-요약&#34;&gt;실행 순서 요약&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Node 바이너리 시작&lt;/li&gt;
&lt;li&gt;런타임 초기화와 내부 바인딩 준비&lt;/li&gt;
&lt;li&gt;모듈 로더 기동 및 엔트리 파일 로드&lt;/li&gt;
&lt;li&gt;V8 파싱과 바이트코드 컴파일&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트 구성과 최상위 코드 실행&lt;/li&gt;
&lt;li&gt;비동기 작업 등록&lt;/li&gt;
&lt;li&gt;이벤트 루프 진입&lt;/li&gt;
&lt;li&gt;비동기 콜백 처리 반복&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TD
A[Node 시작] --&amp;gt; B[V8, libuv 초기화]
B --&amp;gt; C[모듈 로딩]
C --&amp;gt; D[파싱 및 컴파일]
D --&amp;gt; E[최상위 코드 실행]
E --&amp;gt; F[이벤트 루프]
F --&amp;gt; G[비동기 처리 반복]&lt;/pre&gt;&lt;h3 id=&#34;단계별-동작&#34;&gt;단계별 동작&lt;/h3&gt;
&lt;h4 id=&#34;1단계-node-바이너리-시작&#34;&gt;1단계 Node 바이너리 시작&lt;/h4&gt;
&lt;p&gt;node yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨
V8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>Prisma cursor 기반 페이지네이션 동작 원리와 skip: 1의 의미</title>
      <link>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</link>
      <pubDate>Wed, 29 Oct 2025 13:11:51 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/prisma-cursor-pagination-and-skip-1-a14080/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Prisma에서 cursor는 특정 레코드 지점부터 결과를 읽기 시작하는 기준점으로 동작함
skip: 1은 해당 cursor 레코드를 결과에서 제외하기 위한 옵션으로, 페이지 간 중복을 제거하는 데 사용함&lt;/p&gt;
&lt;h3 id=&#34;핵심-동작&#34;&gt;핵심 동작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cursor는 그 지점부터 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 100부터 시작해 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;skip: 1은 cursor에 해당하는 레코드를 건너뜀&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;await&lt;/span&gt; prisma&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;user&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;findMany&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cursor&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id: &lt;span style=&#34;color:#81a1c1&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  skip: &lt;span style=&#34;color:#81a1c1&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  take: &lt;span style=&#34;color:#81a1c1&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  orderBy&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt; id&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;asc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#616e87;font-style:italic&#34;&gt;// 결과: 101부터 5개 반환
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;예시로-보는-차이&#34;&gt;예시로 보는 차이&lt;/h3&gt;
&lt;p&gt;데이터가 아래와 같다고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 환경에서 디버깅하기</title>
      <link>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</link>
      <pubDate>Thu, 23 Oct 2025 13:11:27 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함&lt;/p&gt;
&lt;h3 id=&#34;문제를-명확히-하기&#34;&gt;문제를 명확히 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작성한 코드의 기대 동작 정의&lt;/li&gt;
&lt;li&gt;실제 관측된 동작과의 차이 정리&lt;/li&gt;
&lt;li&gt;실패 조건과 재현 절차 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법</title>
      <link>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</link>
      <pubDate>Sun, 19 Oct 2025 13:06:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음
Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 &amp;ndash;debug는 폐기, &amp;ndash;inspect로 통일됨
CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함&lt;/p&gt;
&lt;p&gt;이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v8-inspector 프로토콜
&lt;ul&gt;
&lt;li&gt;V8이 노출하는 디버깅 프로토콜&lt;/li&gt;
&lt;li&gt;Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect vs &amp;ndash;inspect-brk
&lt;ul&gt;
&lt;li&gt;&amp;ndash;inspect는 바로 실행하면서 디버거 접속 대기&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;포트
&lt;ul&gt;
&lt;li&gt;기본 포트 9229 사용&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect=PORT, &amp;ndash;inspect-brk=PORT 형태로 변경 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프론트엔드
&lt;ul&gt;
&lt;li&gt;Chromium 기반 개발자도구로 연결 가능&lt;/li&gt;
&lt;li&gt;chrome://inspect 에서 Node 대상 탐색 및 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;node-inspect
&lt;ul&gt;
&lt;li&gt;Node 내장 CLI 디버거&lt;/li&gt;
&lt;li&gt;동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;크롬-개발자도구로-디버깅&#34;&gt;크롬 개발자도구로 디버깅&lt;/h3&gt;
&lt;p&gt;Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
    <item>
      <title>Viem으로 이더리움 읽기·쓰기 시작하기 가이드</title>
      <link>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</link>
      <pubDate>Thu, 02 Oct 2025 13:07:56 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/viem-ethereum-read-write-guide-4a5336/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Viem은 이더리움 계열 체인과 상호작용하는 경량 Web3 클라이언트 라이브러리임
ethers나 web3.js와 같은 범용 라이브러리와 동일한 범주의 도구지만, 모듈 분리 구조와 타입 안전성, 빌드 사이즈, 성능에서 강점이 있음
프로덕션에서 자주 필요한 읽기와 쓰기 흐름을 중심으로, 설치부터 블록 조회, 컨트랙트 읽기, 컨트랙트 쓰기까지의 필수 개념과 실용 팁 정리&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Public Client&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;퍼블릭 RPC를 통해 체인 데이터 읽기 전용 호출 수행하는 클라이언트&lt;/li&gt;
&lt;li&gt;블록, 트랜잭션, 로그 조회, read-only 컨트랙트 호출 담당&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wallet Client&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
