<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Microservices on HandsLog</title>
    <link>https://blog.jsontapose.com/tags/microservices/</link>
    <description>Recent content in Microservices on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 03 Jan 2026 13:10:13 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/tags/microservices/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>분산 추적 표준 패턴 정리: HTTP 헤더와 메시지 페이로드, OpenTelemetry와 W3C Trace Context</title>
      <link>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</link>
      <pubDate>Sat, 03 Jan 2026 13:10:13 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/distributed-tracing-standard-patterns-333ccc/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;분산 추적 컨텍스트를 어디에 어떻게 실어 나를지에 대한 표준 패턴 정리. HTTP 같은 동기식 통신과 메시지 큐 같은 비동기식 통신은 전달 수단이 다름. 업계 표준은 W3C Trace Context와 이를 구현한 OpenTelemetry를 따르는 흐름임&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;trace-id, span-id, sampling 플래그 등 추적 컨텍스트 전달 필요&lt;/li&gt;
&lt;li&gt;동기식 요청/응답 채널은 헤더 기반 메타데이터 전달이 자연스러움&lt;/li&gt;
&lt;li&gt;비동기 메시징은 메시지 자체가 전달 단위이므로 페이로드 또는 메시지 속성 이용&lt;/li&gt;
&lt;li&gt;채널이 헤더 개념을 지원하면 헤더 우선, 없으면 페이로드에 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;통신별-패턴&#34;&gt;통신별 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/REST 통신: 요청/응답 헤더에 trace 컨텍스트 실어 전달&lt;/li&gt;
&lt;li&gt;gRPC: 메타데이터(헤더 개념)로 전달&lt;/li&gt;
&lt;li&gt;Kafka: 메시지 헤더 지원. 가능하면 헤더 사용 권장&lt;/li&gt;
&lt;li&gt;RabbitMQ: 메시지 프로퍼티의 headers 사용 가능&lt;/li&gt;
&lt;li&gt;AWS SQS: Message Attributes 사용 가능. 미지원 시 Body에 포함&lt;/li&gt;
&lt;li&gt;BullMQ/Redis 기반 잡 큐: 헤더 개념 없음. Job data에 포함&lt;/li&gt;
&lt;li&gt;WebSocket: 초기 핸드셰이크 단계에서 허용된 메타데이터 채널 또는 쿼리로 전달, 이후 각 메시지 페이로드에 포함. 환경 제약으로 커스텀 헤더 불가한 경우 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;산업-표준&#34;&gt;산업 표준&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OpenTelemetry는 W3C Trace Context를 구현하는 업계 표준 스택&lt;/li&gt;
&lt;li&gt;HTTP는 W3C traceparent, tracestate 헤더 사용&lt;/li&gt;
&lt;li&gt;비동기 메시징은 채널이 헤더를 지원하면 헤더 사용, 아니면 데이터에 포함하는 전략 일반화&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예시&lt;/p&gt;</description>
    </item>
    <item>
      <title>사이드카 패턴 이해와 도입 판단 가이드: 마이크로서비스·쿠버네티스에서의 활용</title>
      <link>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</link>
      <pubDate>Sat, 13 Dec 2025 13:09:08 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/sidecar-pattern-explained-for-kubernetes-and-microservices-d48084/</guid>
      <description>&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;마이크로서비스로 분산이 심화되면 로깅, 모니터링, 보안, 네트워킹 같은 공통 기능을 어디에 둘지 결정이 어려워짐
애플리케이션 코드에 공통 기능을 계속 끼워 넣으면 침투와 중복 증가, 배포와 버전 관리 복잡도 상승
사이드카 패턴은 공통 기능을 별도 컨테이너로 분리해 메인 서비스는 비즈니스 로직에 집중하게 하는 접근법
컨테이너 오케스트레이션 환경에서 일관된 운영 모델을 제공한다는 점이 실무적 장점&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;p&gt;사이드카 패턴의 구성 요소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메인 컨테이너: 비즈니스 로직 담당, 웹 서비스나 API 서버 등&lt;/li&gt;
&lt;li&gt;사이드카 컨테이너: 횡단 관심사 처리, 로그 수집, 모니터링 에이전트, 프록시, 보안 검사 등
같은 파드 내 배치로 네트워크 네임스페이스와 볼륨 공유 가능, 표준 출력/공유 볼륨 등을 통해 데이터 연계
업데이트와 배포를 컨테이너 단위로 분리해 독립적 버전 관리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;p&gt;하나의 파드에 메인 컨테이너와 사이드카 컨테이너를 함께 배치&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
