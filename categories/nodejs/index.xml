<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nodejs on HandsLog</title>
    <link>https://blog.jsontapose.com/categories/nodejs/</link>
    <description>Recent content in Nodejs on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 03 Dec 2025 13:13:33 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/categories/nodejs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>이벤트 루프와 비동기, await에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</link>
      <pubDate>Wed, 03 Dec 2025 13:13:33 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-event-loop-async-await-guide-4552e4/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;nodejs-기본-구조&#34;&gt;Node.js 기본 구조&lt;/h2&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TB
    subgraph STACK[Call Stack]
        S1[현재 실행 중인 함수]
    end

    subgraph LOOP[Event Loop]
        EL[Call Stack 비었나?&amp;lt;br/&amp;gt;→ Queue에서 가져오기]
    end

    subgraph QUEUES[Queues]
        MQ[Microtask Queue&amp;lt;br/&amp;gt;Promise, await 완료]
        TQ[Task Queue&amp;lt;br/&amp;gt;setTimeout, I/O, Cron]
    end

    STACK --&amp;gt; |비어있을 때만| LOOP
    LOOP --&amp;gt; MQ
    MQ --&amp;gt; |비었으면| TQ
    TQ --&amp;gt; STACK

    style STACK fill:#ff6b6b
    style MQ fill:#4ecdc4
    style TQ fill:#45b7d1&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;핵심 규칙: Call Stack이 비어야만 다음 작업 실행&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;오해-1-settimeout0은-즉시-실행된다&#34;&gt;오해 1: &amp;ldquo;setTimeout(0)은 즉시 실행된다&amp;rdquo;&lt;/h2&gt;
&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;setTimeout&lt;span style=&#34;color:#eceff4&#34;&gt;(()&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;=&amp;gt;&lt;/span&gt; console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;),&lt;/span&gt; &lt;span style=&#34;color:#b48ead&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;console&lt;span style=&#34;color:#eceff4&#34;&gt;.&lt;/span&gt;log&lt;span style=&#34;color:#eceff4&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;실행-흐름&#34;&gt;실행 흐름&lt;/h3&gt;
&lt;pre class=&#34;mermaid&#34;&gt;sequenceDiagram
    participant CS as Call Stack
    participant TQ as Task Queue
    participant OUT as 출력

    Note over CS: console.log(&amp;#39;1&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;1&amp;#34;

    Note over CS: setTimeout 등록
    CS-&amp;gt;&amp;gt;TQ: 콜백 등록 (0ms여도!)

    Note over CS: console.log(&amp;#39;3&amp;#39;)
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;3&amp;#34;

    Note over CS: Call Stack 비었음!
    TQ-&amp;gt;&amp;gt;CS: 콜백 가져오기

    Note over CS: 콜백 실행
    CS-&amp;gt;&amp;gt;OUT: &amp;#34;2&amp;#34;&lt;/pre&gt;&lt;h3 id=&#34;출력-1--3--2&#34;&gt;출력: &lt;code&gt;1 → 3 → 2&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;setTimeout(0)은 &amp;ldquo;다음 Event Loop에 실행&amp;quot;이라는 뜻!&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 실행 흐름과 이벤트 루프 단계 정리</title>
      <link>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</link>
      <pubDate>Tue, 11 Nov 2025 13:11:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-execution-flow-event-loop-b04459/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js가 스크립트를 실행할 때 어떤 구성요소가 어떤 순서로 초기화되고 동작하는지 정리
바이너리 기동부터 모듈 로딩, V8 파싱과 실행, 이벤트 루프와 비동기 작업 처리까지의 전체 흐름을 개발자 관점에서 간결하게 설명&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;V8 엔진, Ignition 바이트코드와 JIT 최적화&lt;/li&gt;
&lt;li&gt;libuv, 비동기 I O 백엔드와 이벤트 루프 단계&lt;/li&gt;
&lt;li&gt;모듈 시스템, CommonJS와 ES Module의 로딩 차이&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트와 런타임 내장 객체&lt;/li&gt;
&lt;li&gt;마이크로태스크 큐와 process.nextTick의 우선순위&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행-순서-요약&#34;&gt;실행 순서 요약&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Node 바이너리 시작&lt;/li&gt;
&lt;li&gt;런타임 초기화와 내부 바인딩 준비&lt;/li&gt;
&lt;li&gt;모듈 로더 기동 및 엔트리 파일 로드&lt;/li&gt;
&lt;li&gt;V8 파싱과 바이트코드 컴파일&lt;/li&gt;
&lt;li&gt;전역 실행 컨텍스트 구성과 최상위 코드 실행&lt;/li&gt;
&lt;li&gt;비동기 작업 등록&lt;/li&gt;
&lt;li&gt;이벤트 루프 진입&lt;/li&gt;
&lt;li&gt;비동기 콜백 처리 반복&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;mermaid&#34;&gt;graph TD
A[Node 시작] --&amp;gt; B[V8, libuv 초기화]
B --&amp;gt; C[모듈 로딩]
C --&amp;gt; D[파싱 및 컴파일]
D --&amp;gt; E[최상위 코드 실행]
E --&amp;gt; F[이벤트 루프]
F --&amp;gt; G[비동기 처리 반복]&lt;/pre&gt;&lt;h3 id=&#34;단계별-동작&#34;&gt;단계별 동작&lt;/h3&gt;
&lt;h4 id=&#34;1단계-node-바이너리-시작&#34;&gt;1단계 Node 바이너리 시작&lt;/h4&gt;
&lt;p&gt;node yourfile.js 실행으로 C++ 엔트리 포인트가 기동됨
V8, libuv, 내부 바인딩 계층이 초기화되고 런타임 전역 상태가 준비됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js 환경에서 디버깅하기</title>
      <link>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</link>
      <pubDate>Thu, 23 Oct 2025 13:11:27 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-debugging-inspect-node-inspect-vscode-27a058/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js에서 디버깅은 문제를 재현 가능한 최소 단위로 축소하고, 실행 흐름과 상태를 관찰해 원인을 단정하는 과정임. 이 글은 디버깅 기본 원리와 함께 Node.js 환경에서 자주 쓰는 세 가지 방법인 Chrome DevTools, node-inspect CLI, VS Code 디버거 사용법을 정리함&lt;/p&gt;
&lt;h3 id=&#34;문제를-명확히-하기&#34;&gt;문제를 명확히 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;작성한 코드의 기대 동작 정의&lt;/li&gt;
&lt;li&gt;실제 관측된 동작과의 차이 정리&lt;/li&gt;
&lt;li&gt;실패 조건과 재현 절차 고정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문제 정의가 모호하면 디버깅 범위가 불필요하게 커짐. 입력, 환경 변수, 의존성 버전, 네트워크 상태 등 외부 요인도 고정하는 편이 좋음&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node.js v8-inspector 디버깅 가이드 — --inspect와 node-inspect 사용법</title>
      <link>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</link>
      <pubDate>Sun, 19 Oct 2025 13:06:18 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nodejs-v8-inspector-debugging-guide-inspect-node-inspect-2e5ae9/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;Node.js 디버깅 환경은 V8 인스펙터 도입 이후 일관된 방식으로 수렴했음
Node.js v6부터 V8 네이티브 인스펙터가 들어왔고 v8.0.0에서 v8-inspector를 본격 지원하면서 기존 &amp;ndash;debug는 폐기, &amp;ndash;inspect로 통일됨
CLI 디버거 node-inspect가 코어에 통합되어 브라우저 개발자도구와 커맨드라인 중 선택 가능함&lt;/p&gt;
&lt;p&gt;이 글은 Node.js 8 이상에서 동작하는 v8-inspector 기반 디버깅 플로우를 요약함&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;v8-inspector 프로토콜
&lt;ul&gt;
&lt;li&gt;V8이 노출하는 디버깅 프로토콜&lt;/li&gt;
&lt;li&gt;Node 프로세스가 WebSocket 엔드포인트를 열고 디버거가 여기에 연결하는 구조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect vs &amp;ndash;inspect-brk
&lt;ul&gt;
&lt;li&gt;&amp;ndash;inspect는 바로 실행하면서 디버거 접속 대기&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect-brk는 첫 줄에서 일시정지 후 시작, 초기화 로직부터 추적할 때 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;포트
&lt;ul&gt;
&lt;li&gt;기본 포트 9229 사용&lt;/li&gt;
&lt;li&gt;&amp;ndash;inspect=PORT, &amp;ndash;inspect-brk=PORT 형태로 변경 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프론트엔드
&lt;ul&gt;
&lt;li&gt;Chromium 기반 개발자도구로 연결 가능&lt;/li&gt;
&lt;li&gt;chrome://inspect 에서 Node 대상 탐색 및 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;node-inspect
&lt;ul&gt;
&lt;li&gt;Node 내장 CLI 디버거&lt;/li&gt;
&lt;li&gt;동일한 인스펙터 포트로 접속하여 터미널에서 스텝 실행과 REPL 수행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;크롬-개발자도구로-디버깅&#34;&gt;크롬 개발자도구로 디버깅&lt;/h3&gt;
&lt;p&gt;Express 같은 서버 앱을 예시로 실행 파일이 bin/www라고 가정&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
