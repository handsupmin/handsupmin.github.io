<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Design-Patterns on HandsLog</title>
    <link>https://blog.jsontapose.com/categories/design-patterns/</link>
    <description>Recent content in Design-Patterns on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 06 Dec 2025 13:08:38 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/categories/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>전략 패턴으로 행위를 동적으로 교체하기 — OCP 관점과 Java 활용 포인트</title>
      <link>https://blog.jsontapose.com/posts/strategy-pattern-dynamic-behavior-swap-ocp-java-6618f4/</link>
      <pubDate>Sat, 06 Dec 2025 13:08:38 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/strategy-pattern-dynamic-behavior-swap-ocp-java-6618f4/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;전략 패턴은 객체의 행위를 직접 수정하지 않고, 행위를 캡슐화한 전략 객체를 갈아끼우는 방식으로 동작을 교체하는 설계 방식임
핵심은 상속보다 합성 위주 설계와 인터페이스 기반 위임이며, 런타임에 전략을 바꾸어도 클라이언트 코드는 안정적으로 유지 가능함&lt;/p&gt;
&lt;h3 id=&#34;왜-필요한가&#34;&gt;왜 필요한가&lt;/h3&gt;
&lt;p&gt;버스와 기차 같은 운송 수단이 있고 move라는 동일 행위를 제공한다고 가정
처음에는 버스는 도로, 기차는 선로를 따른다고 구현했다고 하자
이후 선로를 따라 움직이는 버스 요구가 생기면 기존 Bus의 move 구현을 직접 바꾸게 됨
이는 OCP(Open-Closed Principle) 위배 가능성 높음&lt;/p&gt;</description>
    </item>
    <item>
      <title>DI가 결합도를 낮추는 원리와 최소 예시</title>
      <link>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</link>
      <pubDate>Sun, 09 Nov 2025 13:06:58 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/why-di-reduces-coupling-b59160/</guid>
      <description>&lt;h2 id=&#34;개념배경&#34;&gt;개념/배경&lt;/h2&gt;
&lt;p&gt;DI(Dependency Injection, 의존성 주입)의 핵심 아이디어는 명확함
&lt;strong&gt;객체가 자신이 사용할 의존 객체를 스스로 생성하지 않고, 외부로부터 전달받아 사용&lt;/strong&gt;하는 것임
이 단순한 설계 변경만으로도 코드의 변경 용이성, 테스트 편의성, 그리고 전체 시스템의 확장성에서 거대한 차이가 발생함&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;문제-상황-강한-결합-tight-coupling&#34;&gt;문제 상황: 강한 결합 (Tight Coupling)&lt;/h2&gt;
&lt;p&gt;전형적인 문제 패턴은 클래스 내부에서 다른 &lt;strong&gt;구체적인 클래스&lt;/strong&gt;(Concrete Class)를 &lt;code&gt;new&lt;/code&gt; 키워드로 직접 생성하여 사용하는 것임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존 대상의 구현이 변경되면, 해당 객체를 사용하는 클래스 내부 코드도 &lt;strong&gt;반드시 함께 수정&lt;/strong&gt;해야 함&lt;/li&gt;
&lt;li&gt;단위 테스트(Unit Test)를 작성할 때, 테스트 대상 객체가 의존하는 실제 객체들까지 모두 함께 엮여 들어와 테스트가 복잡하고 무거워짐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 &lt;code&gt;Gamer&lt;/code&gt;가 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;를 직접 생성해 사용한다면, &lt;code&gt;Gamer&lt;/code&gt;는 &lt;code&gt;BlueSwitchKeyboard&lt;/code&gt;라는 구체적인 구현에 영구적으로 고정됨
만약 키보드 종류를 &lt;code&gt;RedSwitchSilentKeyboard&lt;/code&gt;로 바꾸려면 &lt;code&gt;Gamer&lt;/code&gt; 클래스의 내부 코드를 직접 수정해야 함
이 상태를 &lt;strong&gt;결합도가 높다&lt;/strong&gt;고 부름&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
