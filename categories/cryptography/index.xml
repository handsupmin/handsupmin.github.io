<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Cryptography on HandsLog</title>
    <link>https://blog.jsontapose.com/categories/cryptography/</link>
    <description>Recent content in Cryptography on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 26 Nov 2025 13:13:16 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/categories/cryptography/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RSA 암호의 원리와 키 생성, 암복호화 정리</title>
      <link>https://blog.jsontapose.com/posts/rsa-principles-key-generation-encryption-decryption-789bd1/</link>
      <pubDate>Wed, 26 Nov 2025 13:13:16 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/rsa-principles-key-generation-encryption-decryption-789bd1/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;비대칭 암호에서 말하는 어려운 문제와 그 활용을 RSA를 통해 개념 위주로 정리함
핵심은 소인수분해의 어려움과 모듈러 거듭제곱의 성질을 결합한 설계임&lt;/p&gt;
&lt;h3 id=&#34;rsa-암호&#34;&gt;RSA 암호&lt;/h3&gt;
&lt;p&gt;RSA는 IFP(Integer Factorization Problem), 즉 정수 소인수분해 문제에 기반함
n = p × q로 구성된 큰 합성수 n에 대해 p, q를 곱해 n을 만드는 일은 쉽지만 n만으로 p, q를 찾는 일은 어려움
이 비대칭성이 공개키로 암호화하고 개인키로 복호화하는 구조를 가능하게 함&lt;/p&gt;
&lt;h3 id=&#34;수론-기초&#34;&gt;수론 기초&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소수 정의
1보다 크고 ±1, ±p만을 약수로 가지는 정수 p를 소수라 함&lt;/li&gt;
&lt;li&gt;소인수분해의 유일성
1보다 큰 모든 정수 a는 소수의 거듭제곱 곱 a = p1^α1 · p2^α2 · … · pt^αt 로 단 한 가지 방식으로 표현 가능&lt;/li&gt;
&lt;li&gt;서로소와 최대공약수
gcd(a, b) = 1이면 a와 b는 서로소 관계&lt;/li&gt;
&lt;li&gt;모듈러 연산과 합동
임의의 정수 a와 양의 정수 n에 대해 a = qn + r, 0 ≤ r &amp;lt; n, a mod n = r
a ≡ b (mod n)은 a mod n과 b mod n이 같음을 의미함&lt;/li&gt;
&lt;li&gt;오일러 피 함수 ϕ(n)
1 ≤ k ≤ n 중 n과 서로소인 정수의 개수
p, q가 서로 다른 소수일 때 ϕ(pq) = (p − 1)(q − 1)&lt;/li&gt;
&lt;li&gt;페르마의 소정리
p가 소수이고 gcd(a, p) = 1이면 a^(p−1) ≡ 1 (mod p)&lt;/li&gt;
&lt;li&gt;오일러의 정리
gcd(a, n) = 1이면 a^ϕ(n) ≡ 1 (mod n)
따라서 n = pq에서 gcd(m, n) = 1이면 m^(k·ϕ(n) + 1) ≡ m (mod n) 성립&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;키-생성&#34;&gt;키 생성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서로 다른 큰 소수 p, q 선택&lt;/li&gt;
&lt;li&gt;n = p × q, ϕ(n) = (p − 1)(q − 1) 계산&lt;/li&gt;
&lt;li&gt;1 &amp;lt; e &amp;lt; ϕ(n)이고 gcd(e, ϕ(n)) = 1인 e 선택&lt;/li&gt;
&lt;li&gt;ed ≡ 1 (mod ϕ(n))을 만족하는 d 계산, 즉 d = e의 모듈러 역원&lt;/li&gt;
&lt;li&gt;공개키 (n, e), 개인키 (n, d)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;암호화와-복호화&#34;&gt;암호화와 복호화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;암호화 C = M^e mod n, 0 &amp;lt; M &amp;lt; n에서 M은 평문, C는 암호문&lt;/li&gt;
&lt;li&gt;복호화 M = C^d mod n&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;왜-복호화가-성립하는가&#34;&gt;왜 복호화가 성립하는가&lt;/h3&gt;
&lt;p&gt;C^d = (M^e)^d = M^(ed)이며 키 생성에서 ed = k·ϕ(n) + 1을 만족
gcd(M, n) = 1이면 오일러의 정리로 M^ϕ(n) ≡ 1 (mod n) 이므로 M^(k·ϕ(n) + 1) ≡ M (mod n) 성립
M이 n과 서로소가 아닌 특수한 경우에도 p, q 각각에 대한 합동을 보아 중국인의 나머지 정리로 같은 결론에 도달 가능이라는 점만 언급&lt;/p&gt;</description>
    </item>
    <item>
      <title>암호 시스템 기초: 대칭·비대칭 암호, 키와 트랩도어 함수</title>
      <link>https://blog.jsontapose.com/posts/crypto-basics-symmetric-asymmetric-trapdoor-functions-69a493/</link>
      <pubDate>Tue, 18 Nov 2025 13:11:23 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/crypto-basics-symmetric-asymmetric-trapdoor-functions-69a493/</guid>
      <description>&lt;p&gt;본 글은 정보보호 개론 맥락에서 암호 시스템의 기본 개념과 동작 방식을 정리한 내용임&lt;/p&gt;
&lt;h3 id=&#34;개념과-배경&#34;&gt;개념과 배경&lt;/h3&gt;
&lt;p&gt;암호학은 정보의 안전한 전달과 저장을 위한 방법론을 다루는 학문임
정보 보안의 목표는 CIA로 요약됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무결성 중간 위조·변조 불가&lt;/li&gt;
&lt;li&gt;기밀성 허용되지 않은 자는 내용 파악 불가&lt;/li&gt;
&lt;li&gt;가용성 적절한 시점에 허가된 사용자만 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현대 보안에서는 암호 알고리즘이 공개되어도 안전해야 한다는 전제를 둠 즉 안전성은 비밀 알고리즘이 아니라 키에 의존함
컴퓨터가 다루는 모든 정보는 이진수이므로 보호는 결국 비트열을 다른 형태로 변환하는 문제로 귀결됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>영지식 증명 ZKP의 개념과 동작 원리, 디지털 서명과의 차이</title>
      <link>https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</link>
      <pubDate>Mon, 29 Sep 2025 13:10:22 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/zkp-concepts-and-how-it-works-vs-digital-signatures-1338b0/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;영지식 증명은 어떤 명제가 참임을 설득하면서도 그 근거가 되는 비밀은 끝까지 숨기는 절차를 말함
블록체인과 프라이버시 보존 컴퓨팅에서 핵심 도구로 자리 잡았고 범용 계산의 유효성을 작은 증명으로 압축해 전달하는 현대 프로토콜의 기초로 쓰임
이 글은 기본 개념과 직관, 수학적 성질, 대화형과 비대화형의 차이, 디지털 서명과의 구분, 이산로그 기반 간단 Σ-프로토콜까지 한 번에 정리함&lt;/p&gt;
&lt;h2 id=&#34;목적과-맥락&#34;&gt;목적과 맥락&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;비밀을 공개하지 않고 유효성만 검증하려는 요구 증가&lt;/li&gt;
&lt;li&gt;퍼블릭 블록체인에서 데이터 비공개 유지와 정합성 보장 필요 확대&lt;/li&gt;
&lt;li&gt;오프체인 연산을 온체인에 작은 증명으로 제출해 확장성과 비용 개선 추구&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;핵심-개념과-정의&#34;&gt;핵심 개념과 정의&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Prover 비밀을 가진 참여자. 비밀을 공개하지 않고 명제의 참을 설득하려는 주체&lt;/li&gt;
&lt;li&gt;Verifier 검증자. Prover가 비밀을 가진 사실 또는 명제가 참이라는 사실만 확인하려는 주체&lt;/li&gt;
&lt;li&gt;Witness 또는 Secret 명제의 참을 뒷받침하는 비밀 값 또는 비밀 지식&lt;/li&gt;
&lt;li&gt;Statement 공개 가능한 명제 표현. 예 y = g^x mod p에서 x를 알고 있음을 증명&lt;/li&gt;
&lt;li&gt;Challenge 검증자가 제시하는 무작위 도전값. 조작 불가와 예측 불가가 전제&lt;/li&gt;
&lt;li&gt;Transcript 또는 View 대화형 상호작용의 기록. 시뮬레이터가 동일 분포로 재현 가능해야 영지식 성립&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;영지식-증명의-세-가지-성질&#34;&gt;영지식 증명의 세 가지 성질&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;완전성 Completeness 정직한 Prover가 비밀을 가지고 있으면 정직한 Verifier는 높은 확률로 설득됨&lt;/li&gt;
&lt;li&gt;건전성 Soundness 비밀이 없으면 Prover가 속일 확률이 매우 낮음. 도전 공간 확대나 반복으로 속임 확률을 지수적으로 낮춤&lt;/li&gt;
&lt;li&gt;영지식성 Zero-Knowledge Verifier는 명제가 참이라는 사실 외 추가 정보를 얻지 못함. 시뮬레이터가 실제와 구별 불가한 트랜스크립트를 비밀 없이 생성 가능해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;직관적-예시-알리바바-동굴&#34;&gt;직관적 예시 알리바바 동굴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;동굴의 두 갈래 A와 B 사이를 가로막는 문이 있고 비밀 주문을 알면 반대편으로 넘어올 수 있음&lt;/li&gt;
&lt;li&gt;검증자는 Prover가 들어간 뒤 무작위로 A 또는 B로 나오라고 요구함&lt;/li&gt;
&lt;li&gt;Prover가 주문을 모르면 자신이 들어간 쪽을 요구받을 때만 성공 가능. 1회 성공 확률 1/2&lt;/li&gt;
&lt;li&gt;k회 독립 반복하면 모두 속일 확률 2^-k로 급감&lt;/li&gt;
&lt;li&gt;검증자는 주문 내용은 모르지만 Prover가 주문을 안다는 사실만 높은 확률로 확신 가능함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;핵심 포인트&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
