<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nestjs on HandsLog</title>
    <link>https://blog.jsontapose.com/categories/nestjs/</link>
    <description>Recent content in Nestjs on HandsLog</description>
    <generator>Hugo -- 0.146.0</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 09 Dec 2025 13:13:40 +0000</lastBuildDate>
    <atom:link href="https://blog.jsontapose.com/categories/nestjs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NestJS forRoot는 싱글톤 보장 아님, global true로는 중복 호출 못 막음</title>
      <link>https://blog.jsontapose.com/posts/nestjs-forroot-not-singleton-global-true-duplicate-call-9aeb54/</link>
      <pubDate>Tue, 09 Dec 2025 13:13:40 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-forroot-not-singleton-global-true-duplicate-call-9aeb54/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;forRoot 패턴이 자동으로 싱글톤을 보장하지 않음
동일 모듈에서 forRoot를 여러 번 호출하면 호출 횟수만큼 프로바이더 인스턴스가 만들어짐
@nestjs/schedule의 ScheduleModule도 예외 아님&lt;/p&gt;
&lt;h3 id=&#34;핵심-개념&#34;&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dynamic module forRoot
&lt;ul&gt;
&lt;li&gt;forRoot는 DynamicModule을 반환하는 팩토리 패턴&lt;/li&gt;
&lt;li&gt;호출할 때마다 새로운 동적 모듈 토큰 생성, 별개의 모듈 인스턴스로 취급됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;global true의 의미
&lt;ul&gt;
&lt;li&gt;모듈을 전역 스코프로 노출하여 재임포트 없이 프로바이더 주입 가능하게 함&lt;/li&gt;
&lt;li&gt;전역 노출일 뿐, 중복 생성 방지 수단은 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단 스니펫&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;static&lt;/span&gt; forRoot&lt;span style=&#34;color:#eceff4&#34;&gt;(...)&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;global&lt;/span&gt;&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    module: &lt;span style=&#34;color:#81a1c1&#34;&gt;ScheduleModule&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    providers&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;ScheduleExplorer&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; SchedulerRegistry&lt;span style=&#34;color:#eceff4&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exports&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;[&lt;/span&gt;SchedulerRegistry&lt;span style=&#34;color:#eceff4&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;동작-원리&#34;&gt;동작 원리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ScheduleExplorer는 OnModuleInit 훅에서 애플리케이션 프로바이더를 스캔하고 @Cron 메서드를 등록함&lt;/li&gt;
&lt;li&gt;forRoot를 두 번 호출하면 ScheduleExplorer 인스턴스가 2개 생성됨&lt;/li&gt;
&lt;li&gt;각 인스턴스가 같은 @Cron 메서드를 각각 등록하므로 작업이 중복 등록됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개념 스니펫&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS forRoot()의 동작 원리와 싱글톤에 대한 오해</title>
      <link>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</link>
      <pubDate>Sun, 07 Dec 2025 13:07:35 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-forroot-and-singleton-myth-922927/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;NestJS을 다루다 보면 &lt;code&gt;ConfigModule.forRoot()&lt;/code&gt;, &lt;code&gt;TypeOrmModule.forRoot()&lt;/code&gt; 같은 코드를 보게 됨
보통 &amp;ldquo;이건 전역 설정이니까 한 번만 하면 끝이고 알아서 싱글톤 유지되겠지?&amp;ldquo;라고 생각하기 쉬움&lt;/p&gt;
&lt;p&gt;하지만 &lt;code&gt;forRoot()&lt;/code&gt;를 호출한다고 프레임워크가 알아서 물리적인 싱글톤 인스턴스를 강제하는 건 아님
특히 &lt;code&gt;ScheduleModule&lt;/code&gt;처럼 사이드 이펙트(이벤트 리스너, 타이머 등)를 유발하는 모듈을 잘못 다루면, 기능이 중복 실행되는 심각한 버그가 터질 수 있음&lt;/p&gt;
&lt;p&gt;이 글에서는 &lt;code&gt;forRoot()&lt;/code&gt;의 진짜 의미와 내부 동작, 그리고 &lt;code&gt;ScheduleModule&lt;/code&gt; 중복 실행 문제가 왜 생기는지 코드로 뜯어보겠음&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;forroot란-무엇인가&#34;&gt;forRoot()란 무엇인가&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;forRoot()&lt;/code&gt;는 NestJS의 &lt;strong&gt;동적 모듈&lt;/strong&gt;(Dynamic Module)을 생성하기 위해 관례적으로 쓰는 메서드 이름임&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Swagger 가이드 — ApiProperty와 PickType/OmitType/PartialType 사용법</title>
      <link>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</link>
      <pubDate>Thu, 30 Oct 2025 13:11:03 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-swagger-apiproperty-picktype-omittype-partialtype-200c9b/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;@nestjs/swagger는 NestJS와 Swagger(OpenAPI) 스펙을 연결해 API 문서를 자동 생성하는 모듈임
DTO(Data Transfer Object) 클래스에 메타데이터를 부여해 타입과 예시, 설명 등을 Swagger UI에 노출하는 흐름으로 작동함
핵심 도구는 @ApiProperty와 DTO 유틸리티 타입들(PickType, OmitType, PartialType)임&lt;/p&gt;
&lt;h3 id=&#34;apiproperty-개념과-사용&#34;&gt;ApiProperty 개념과 사용&lt;/h3&gt;
&lt;p&gt;@ApiProperty는 DTO 속성 단위로 문서화 메타데이터를 부여하는 데코레이터임
타입, 설명, 예시, 필수 여부 등을 정의해 Swagger UI에 명확한 스키마 제공
코드와 문서가 한 소스에서 유지되어 일관성 확보에 유리함&lt;/p&gt;
&lt;p&gt;간단 사용 예시&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;class&lt;/span&gt; CreateUserDto &lt;span style=&#34;color:#eceff4&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#81a1c1;font-weight:bold&#34;&gt;@ApiProperty&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;({&lt;/span&gt; description&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;사용자 이름&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;,&lt;/span&gt; example&lt;span style=&#34;color:#81a1c1&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a3be8c&#34;&gt;&amp;#34;John Doe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#eceff4&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name: &lt;span style=&#34;color:#81a1c1&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#eceff4&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이 속성 정의만으로 Swagger 스키마에 name 필드의 설명과 예시가 노출됨&lt;/p&gt;</description>
    </item>
    <item>
      <title>NestJS Guard로 요청 보호하기 — CanActivate, UseGuards, Bearer 인증 예시</title>
      <link>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</link>
      <pubDate>Fri, 17 Oct 2025 13:09:19 +0000</pubDate>
      <guid>https://blog.jsontapose.com/posts/nestjs-guard-canactivate-useguards-bearer-auth-427051/</guid>
      <description>&lt;h3 id=&#34;개요&#34;&gt;개요&lt;/h3&gt;
&lt;p&gt;가드 Guard를 이용해 NestJS 애플리케이션을 위험한 요청으로부터 차단하는 방법 정리
컨트롤러에 도달하기 전 단계에서 인증과 접근 제어 수행하는 패턴 중심으로 설명&lt;/p&gt;
&lt;h3 id=&#34;가드란&#34;&gt;가드란&lt;/h3&gt;
&lt;p&gt;NestJS에서 가드는 애플리케이션에 들어오는 요청을 컨트롤러로 보내기 전에 통과 여부를 결정하는 구성 요소
미들웨어와 유사한 역할이지만 라우트 핸들러 실행 여부를 명시적으로 결정하는 책임에 초점
요청 수명주기에서 미들웨어 다음, 컨트롤러 이전에 실행됨
canActivate가 true 또는 Promise&lt;!-- raw HTML omitted --&gt;을 반환하면 다음 단계로 진행, false면 기본적으로 403 Forbidden 응답 발생&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
